(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("clv-sipjs", [], factory);
	else if(typeof exports === 'object')
		exports["clv-sipjs"] = factory();
	else
		root["clv-sipjs"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/clv-sipjs.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-runtime/core-js/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/object/define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/object/define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/core-js/weak-map.js":
/*!********************************************************!*\
  !*** ./node_modules/babel-runtime/core-js/weak-map.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = { "default": __webpack_require__(/*! core-js/library/fn/weak-map */ "./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js"), __esModule: true };

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/classCallCheck.js":
/*!**************************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/classCallCheck.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/***/ }),

/***/ "./node_modules/babel-runtime/helpers/createClass.js":
/*!***********************************************************!*\
  !*** ./node_modules/babel-runtime/helpers/createClass.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _defineProperty = __webpack_require__(/*! ../core-js/object/define-property */ "./node_modules/babel-runtime/core-js/object/define-property.js");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/object/define-property.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es6.object.define-property */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js");
var $Object = __webpack_require__(/*! ../../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js":
/*!********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/fn/weak-map.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js");
__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js");
__webpack_require__(/*! ../modules/es6.weak-map */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js");
__webpack_require__(/*! ../modules/es7.weak-map.of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js");
__webpack_require__(/*! ../modules/es7.weak-map.from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js");
module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").WeakMap;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js");
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js");
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js");
var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-create.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var getWeak = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js").getWeak;
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js");
var $has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
var fails = __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");
var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-instance.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.12' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js");
var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js");
var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js");
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").document;
module.exports = document && document.documentElement;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array-iter.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-array.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_cof.js");
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-call.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js");
var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js");
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-create.js");
var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js");
var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js")('meta');
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var setDesc = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");
var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js");
var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_fails.js")(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-create.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_dom-create.js")('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(/*! ./_html */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_html.js").appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ie8-dom-define.js");
var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js");
var dP = Object.defineProperty;

exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dps.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js");
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_an-object.js");
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gops.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-gpo.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js");
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");
var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-includes.js")(false);
var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-pie.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_property-desc.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine-all.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_a-function.js");
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_ctx.js");
var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_for-of.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-to-string-tag.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f;
var has = __webpack_require__(/*! ./_has */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_has.js");
var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared-key.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('keys');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js":
/*!************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-absolute-index.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iobject.js");
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-length.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-integer.js");
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-object.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_defined.js");
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-primitive.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_shared.js")('wks');
var uid = __webpack_require__(/*! ./_uid */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_uid.js");
var Symbol = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js").Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/core.get-iterator-method.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_classof.js");
var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('iterator');
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
module.exports = __webpack_require__(/*! ./_core */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_add-to-unscopables.js");
var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-step.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_to-iobject.js");

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.define-property.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_export.js");
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_descriptors.js"), 'Object', { defineProperty: __webpack_require__(/*! ./_object-dp */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-dp.js").f });


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.object.to-string.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {



/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.weak-map.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_array-methods.js")(0);
var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_redefine.js");
var meta = __webpack_require__(/*! ./_meta */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_meta.js");
var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_object-assign.js");
var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection-weak.js");
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_is-object.js");
var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_validate-collection.js");
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.from.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(/*! ./_set-collection-from */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-from.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/es7.weak-map.of.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(/*! ./_set-collection-of */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_set-collection-of.js")('WeakMap');


/***/ }),

/***/ "./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/babel-runtime/node_modules/core-js/library/modules/web.dom.iterable.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./es6.array.iterator */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/es6.array.iterator.js");
var global = __webpack_require__(/*! ./_global */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_global.js");
var hide = __webpack_require__(/*! ./_hide */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_hide.js");
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_iterators.js");
var TO_STRING_TAG = __webpack_require__(/*! ./_wks */ "./node_modules/babel-runtime/node_modules/core-js/library/modules/_wks.js")('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),

/***/ "./node_modules/es6-event-emitter/dist/emitter.js":
/*!********************************************************!*\
  !*** ./node_modules/es6-event-emitter/dist/emitter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _classCallCheck2 = __webpack_require__(/*! babel-runtime/helpers/classCallCheck */ "./node_modules/babel-runtime/helpers/classCallCheck.js");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = __webpack_require__(/*! babel-runtime/helpers/createClass */ "./node_modules/babel-runtime/helpers/createClass.js");

var _createClass3 = _interopRequireDefault(_createClass2);

var _weakMap = __webpack_require__(/*! babel-runtime/core-js/weak-map */ "./node_modules/babel-runtime/core-js/weak-map.js");

var _weakMap2 = _interopRequireDefault(_weakMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _weakMap2.default();

var Emitter = function () {
	function Emitter() {
		(0, _classCallCheck3.default)(this, Emitter);

		emitter.set(this, {
			events: {}
		});

		this.eventLength = 0;
	}

	(0, _createClass3.default)(Emitter, [{
		key: 'on',
		value: function on(event, cb) {
			var once = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

			if (typeof cb === 'undefined') {
				throw new Error('You must provide a callback method.');
			}

			if (typeof cb !== 'function') {
				throw new TypeError('Listener must be a function');
			}

			this.events[event] = this.events[event] || [];
			this.events[event].push({
				cb: cb,
				once: once
			});

			this.eventLength++;

			return this;
		}
	}, {
		key: 'off',
		value: function off(event, cb) {
			if (typeof cb === 'undefined') {
				throw new Error('You must provide a callback method.');
			}

			if (typeof cb !== 'function') {
				throw new TypeError('Listener must be a function');
			}

			if (typeof this.events[event] === 'undefined') {
				throw new Error('Event not found - the event you provided is: ' + event);
			}

			var listeners = this.events[event];

			listeners.forEach(function (v, i) {
				if (v.cb === cb) {
					listeners.splice(i, 1);
				}
			});

			if (listeners.length === 0) {
				delete this.events[event];

				this.eventLength--;
			}

			return this;
		}
	}, {
		key: 'trigger',
		value: function trigger(event) {
			var _this = this;

			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			if (typeof event === 'undefined') {
				throw new Error('You must provide an event to trigger.');
			}

			var listeners = this.events[event];
			var onceListeners = [];

			if (typeof listeners !== 'undefined') {
				listeners.forEach(function (v, k) {
					v.cb.apply(_this, args);

					if (v.once) onceListeners.unshift(k);

					onceListeners.forEach(function (v, k) {
						listeners.splice(k, 1);
					});
				});
			}

			return this;
		}
	}, {
		key: 'once',
		value: function once(event, cb) {
			this.on(event, cb, true);
		}
	}, {
		key: 'destroy',
		value: function destroy() {
			emitter.delete(this);

			this.eventLength = 0;
		}
	}, {
		key: 'events',
		get: function get() {
			return emitter.get(this).events;
		}
	}]);
	return Emitter;
}();

exports.default = Emitter;

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/sip.js/lib/ClientContext.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/ClientContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var ClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(ClientContext, _super);
    function ClientContext(ua, method, target, options) {
        var _this = _super.call(this) || this;
        _this.data = {};
        ClientContext.initializer(_this, ua, method, target, options);
        return _this;
    }
    ClientContext.initializer = function (objToConstruct, ua, method, originalTarget, options) {
        objToConstruct.type = Enums_1.TypeStrings.ClientContext;
        // Validate arguments
        if (originalTarget === undefined) {
            throw new TypeError("Not enough arguments");
        }
        objToConstruct.ua = ua;
        objToConstruct.logger = ua.getLogger("sip.clientcontext");
        objToConstruct.method = method;
        var target = ua.normalizeTarget(originalTarget);
        if (!target) {
            throw new TypeError("Invalid target: " + originalTarget);
        }
        var fromURI = ua.userAgentCore.configuration.aor;
        if (options && options.params && options.params.fromUri) {
            fromURI =
                (typeof options.params.fromUri === "string") ?
                    core_1.Grammar.URIParse(options.params.fromUri) :
                    options.params.fromUri;
            if (!fromURI) {
                throw new TypeError("Invalid from URI: " + options.params.fromUri);
            }
        }
        var toURI = target;
        if (options && options.params && options.params.toUri) {
            toURI =
                (typeof options.params.toUri === "string") ?
                    core_1.Grammar.URIParse(options.params.toUri) :
                    options.params.toUri;
            if (!toURI) {
                throw new TypeError("Invalid to URI: " + options.params.toUri);
            }
        }
        /* Options
        * - extraHeaders
        * - params
        * - contentType
        * - body
        */
        options = Object.create(options || Object.prototype);
        options = options || {};
        var extraHeaders = (options.extraHeaders || []).slice();
        var params = options.params || {};
        var bodyObj;
        if (options.body) {
            bodyObj = {
                body: options.body,
                contentType: options.contentType ? options.contentType : "application/sdp"
            };
            objToConstruct.body = bodyObj;
        }
        var body;
        if (bodyObj) {
            body = Utils_1.Utils.fromBodyObj(bodyObj);
        }
        // Build the request
        objToConstruct.request = ua.userAgentCore.makeOutgoingRequestMessage(method, target, fromURI, toURI, params, extraHeaders, body);
        /* Set other properties from the request */
        if (objToConstruct.request.from) {
            objToConstruct.localIdentity = objToConstruct.request.from;
        }
        if (objToConstruct.request.to) {
            objToConstruct.remoteIdentity = objToConstruct.request.to;
        }
    };
    ClientContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.request(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    ClientContext.prototype.receiveResponse = function (response) {
        var statusCode = response.statusCode || 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                this.emit("progress", response, cause);
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                if (this.ua.applicants[this.toString()]) {
                    delete this.ua.applicants[this.toString()];
                }
                this.emit("accepted", response, cause);
                break;
            default:
                if (this.ua.applicants[this.toString()]) {
                    delete this.ua.applicants[this.toString()];
                }
                this.emit("rejected", response, cause);
                this.emit("failed", response, cause);
                break;
        }
    };
    ClientContext.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    ClientContext.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    return ClientContext;
}(events_1.EventEmitter));
exports.ClientContext = ClientContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Constants.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Constants.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var version_1 = __webpack_require__(/*! ./version */ "./node_modules/sip.js/lib/version.js");
var C;
(function (C) {
    C.version = version_1.LIBRARY_VERSION;
    C.USER_AGENT = "SIP.js/" + version_1.LIBRARY_VERSION;
    // SIP scheme
    C.SIP = "sip";
    C.SIPS = "sips";
    // End and Failure causes
    var causes;
    (function (causes) {
        // Generic error causes
        causes["CONNECTION_ERROR"] = "Connection Error";
        causes["INTERNAL_ERROR"] = "Internal Error";
        causes["REQUEST_TIMEOUT"] = "Request Timeout";
        causes["SIP_FAILURE_CODE"] = "SIP Failure Code";
        // SIP error causes
        causes["ADDRESS_INCOMPLETE"] = "Address Incomplete";
        causes["AUTHENTICATION_ERROR"] = "Authentication Error";
        causes["BUSY"] = "Busy";
        causes["DIALOG_ERROR"] = "Dialog Error";
        causes["INCOMPATIBLE_SDP"] = "Incompatible SDP";
        causes["NOT_FOUND"] = "Not Found";
        causes["REDIRECTED"] = "Redirected";
        causes["REJECTED"] = "Rejected";
        causes["UNAVAILABLE"] = "Unavailable";
        // Session error causes
        causes["BAD_MEDIA_DESCRIPTION"] = "Bad Media Description";
        causes["CANCELED"] = "Canceled";
        causes["EXPIRES"] = "Expires";
        causes["NO_ACK"] = "No ACK";
        causes["NO_ANSWER"] = "No Answer";
        causes["NO_PRACK"] = "No PRACK";
        causes["RTP_TIMEOUT"] = "RTP Timeout";
        causes["USER_DENIED_MEDIA_ACCESS"] = "User Denied Media Access";
        causes["WEBRTC_ERROR"] = "WebRTC Error";
        causes["WEBRTC_NOT_SUPPORTED"] = "WebRTC Not Supported";
    })(causes = C.causes || (C.causes = {}));
    var supported;
    (function (supported) {
        supported["REQUIRED"] = "required";
        supported["SUPPORTED"] = "supported";
        supported["UNSUPPORTED"] = "none";
    })(supported = C.supported || (C.supported = {}));
    C.SIP_ERROR_CAUSES = {
        ADDRESS_INCOMPLETE: [484],
        AUTHENTICATION_ERROR: [401, 407],
        BUSY: [486, 600],
        INCOMPATIBLE_SDP: [488, 606],
        NOT_FOUND: [404, 604],
        REDIRECTED: [300, 301, 302, 305, 380],
        REJECTED: [403, 603],
        UNAVAILABLE: [480, 410, 408, 430]
    };
    // SIP Methods
    C.ACK = "ACK";
    C.BYE = "BYE";
    C.CANCEL = "CANCEL";
    C.INFO = "INFO";
    C.INVITE = "INVITE";
    C.MESSAGE = "MESSAGE";
    C.NOTIFY = "NOTIFY";
    C.OPTIONS = "OPTIONS";
    C.REGISTER = "REGISTER";
    C.UPDATE = "UPDATE";
    C.SUBSCRIBE = "SUBSCRIBE";
    C.PUBLISH = "PUBLISH";
    C.REFER = "REFER";
    C.PRACK = "PRACK";
    /* SIP Response Reasons
     * DOC: http://www.iana.org/assignments/sip-parameters
     * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
     */
    C.REASON_PHRASE = {
        100: "Trying",
        180: "Ringing",
        181: "Call Is Being Forwarded",
        182: "Queued",
        183: "Session Progress",
        199: "Early Dialog Terminated",
        200: "OK",
        202: "Accepted",
        204: "No Notification",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Moved Temporarily",
        305: "Use Proxy",
        380: "Alternative Service",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        410: "Gone",
        412: "Conditional Request Failed",
        413: "Request Entity Too Large",
        414: "Request-URI Too Long",
        415: "Unsupported Media Type",
        416: "Unsupported URI Scheme",
        417: "Unknown Resource-Priority",
        420: "Bad Extension",
        421: "Extension Required",
        422: "Session Interval Too Small",
        423: "Interval Too Brief",
        428: "Use Identity Header",
        429: "Provide Referrer Identity",
        430: "Flow Failed",
        433: "Anonymity Disallowed",
        436: "Bad Identity-Info",
        437: "Unsupported Certificate",
        438: "Invalid Identity Header",
        439: "First Hop Lacks Outbound Support",
        440: "Max-Breadth Exceeded",
        469: "Bad Info Package",
        470: "Consent Needed",
        478: "Unresolvable Destination",
        480: "Temporarily Unavailable",
        481: "Call/Transaction Does Not Exist",
        482: "Loop Detected",
        483: "Too Many Hops",
        484: "Address Incomplete",
        485: "Ambiguous",
        486: "Busy Here",
        487: "Request Terminated",
        488: "Not Acceptable Here",
        489: "Bad Event",
        491: "Request Pending",
        493: "Undecipherable",
        494: "Security Agreement Required",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Server Time-out",
        505: "Version Not Supported",
        513: "Message Too Large",
        580: "Precondition Failure",
        600: "Busy Everywhere",
        603: "Decline",
        604: "Does Not Exist Anywhere",
        606: "Not Acceptable"
    };
    /* SIP Option Tags
     * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4
     */
    C.OPTION_TAGS = {
        "100rel": true,
        "199": true,
        "answermode": true,
        "early-session": true,
        "eventlist": true,
        "explicitsub": true,
        "from-change": true,
        "geolocation-http": true,
        "geolocation-sip": true,
        "gin": true,
        "gruu": true,
        "histinfo": true,
        "ice": true,
        "join": true,
        "multiple-refer": true,
        "norefersub": true,
        "nosub": true,
        "outbound": true,
        "path": true,
        "policy": true,
        "precondition": true,
        "pref": true,
        "privacy": true,
        "recipient-list-invite": true,
        "recipient-list-message": true,
        "recipient-list-subscribe": true,
        "replaces": true,
        "resource-priority": true,
        "sdp-anat": true,
        "sec-agree": true,
        "tdialog": true,
        "timer": true,
        "uui": true // RFC 7433
    };
    var dtmfType;
    (function (dtmfType) {
        dtmfType["INFO"] = "info";
        dtmfType["RTP"] = "rtp";
    })(dtmfType = C.dtmfType || (C.dtmfType = {}));
})(C = exports.C || (exports.C = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Enums.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/Enums.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// enums can't really be declared, so they are set here.
// pulled out of individual files to avoid circular dependencies
Object.defineProperty(exports, "__esModule", { value: true });
var DialogStatus;
(function (DialogStatus) {
    DialogStatus[DialogStatus["STATUS_EARLY"] = 1] = "STATUS_EARLY";
    DialogStatus[DialogStatus["STATUS_CONFIRMED"] = 2] = "STATUS_CONFIRMED";
})(DialogStatus = exports.DialogStatus || (exports.DialogStatus = {}));
var SessionStatus;
(function (SessionStatus) {
    // Session states
    SessionStatus[SessionStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
    SessionStatus[SessionStatus["STATUS_INVITE_SENT"] = 1] = "STATUS_INVITE_SENT";
    SessionStatus[SessionStatus["STATUS_1XX_RECEIVED"] = 2] = "STATUS_1XX_RECEIVED";
    SessionStatus[SessionStatus["STATUS_INVITE_RECEIVED"] = 3] = "STATUS_INVITE_RECEIVED";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ANSWER"] = 4] = "STATUS_WAITING_FOR_ANSWER";
    SessionStatus[SessionStatus["STATUS_ANSWERED"] = 5] = "STATUS_ANSWERED";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_PRACK"] = 6] = "STATUS_WAITING_FOR_PRACK";
    SessionStatus[SessionStatus["STATUS_WAITING_FOR_ACK"] = 7] = "STATUS_WAITING_FOR_ACK";
    SessionStatus[SessionStatus["STATUS_CANCELED"] = 8] = "STATUS_CANCELED";
    SessionStatus[SessionStatus["STATUS_TERMINATED"] = 9] = "STATUS_TERMINATED";
    SessionStatus[SessionStatus["STATUS_ANSWERED_WAITING_FOR_PRACK"] = 10] = "STATUS_ANSWERED_WAITING_FOR_PRACK";
    SessionStatus[SessionStatus["STATUS_EARLY_MEDIA"] = 11] = "STATUS_EARLY_MEDIA";
    SessionStatus[SessionStatus["STATUS_CONFIRMED"] = 12] = "STATUS_CONFIRMED";
})(SessionStatus = exports.SessionStatus || (exports.SessionStatus = {}));
var TypeStrings;
(function (TypeStrings) {
    TypeStrings[TypeStrings["ClientContext"] = 0] = "ClientContext";
    TypeStrings[TypeStrings["ConfigurationError"] = 1] = "ConfigurationError";
    TypeStrings[TypeStrings["Dialog"] = 2] = "Dialog";
    TypeStrings[TypeStrings["DigestAuthentication"] = 3] = "DigestAuthentication";
    TypeStrings[TypeStrings["DTMF"] = 4] = "DTMF";
    TypeStrings[TypeStrings["IncomingMessage"] = 5] = "IncomingMessage";
    TypeStrings[TypeStrings["IncomingRequest"] = 6] = "IncomingRequest";
    TypeStrings[TypeStrings["IncomingResponse"] = 7] = "IncomingResponse";
    TypeStrings[TypeStrings["InvalidStateError"] = 8] = "InvalidStateError";
    TypeStrings[TypeStrings["InviteClientContext"] = 9] = "InviteClientContext";
    TypeStrings[TypeStrings["InviteServerContext"] = 10] = "InviteServerContext";
    TypeStrings[TypeStrings["Logger"] = 11] = "Logger";
    TypeStrings[TypeStrings["LoggerFactory"] = 12] = "LoggerFactory";
    TypeStrings[TypeStrings["MethodParameterError"] = 13] = "MethodParameterError";
    TypeStrings[TypeStrings["NameAddrHeader"] = 14] = "NameAddrHeader";
    TypeStrings[TypeStrings["NotSupportedError"] = 15] = "NotSupportedError";
    TypeStrings[TypeStrings["OutgoingRequest"] = 16] = "OutgoingRequest";
    TypeStrings[TypeStrings["Parameters"] = 17] = "Parameters";
    TypeStrings[TypeStrings["PublishContext"] = 18] = "PublishContext";
    TypeStrings[TypeStrings["ReferClientContext"] = 19] = "ReferClientContext";
    TypeStrings[TypeStrings["ReferServerContext"] = 20] = "ReferServerContext";
    TypeStrings[TypeStrings["RegisterContext"] = 21] = "RegisterContext";
    TypeStrings[TypeStrings["RenegotiationError"] = 22] = "RenegotiationError";
    TypeStrings[TypeStrings["RequestSender"] = 23] = "RequestSender";
    TypeStrings[TypeStrings["ServerContext"] = 24] = "ServerContext";
    TypeStrings[TypeStrings["Session"] = 25] = "Session";
    TypeStrings[TypeStrings["SessionDescriptionHandler"] = 26] = "SessionDescriptionHandler";
    TypeStrings[TypeStrings["SessionDescriptionHandlerError"] = 27] = "SessionDescriptionHandlerError";
    TypeStrings[TypeStrings["SessionDescriptionHandlerObserver"] = 28] = "SessionDescriptionHandlerObserver";
    TypeStrings[TypeStrings["Subscription"] = 29] = "Subscription";
    TypeStrings[TypeStrings["Transport"] = 30] = "Transport";
    TypeStrings[TypeStrings["UA"] = 31] = "UA";
    TypeStrings[TypeStrings["URI"] = 32] = "URI";
})(TypeStrings = exports.TypeStrings || (exports.TypeStrings = {}));
// UA status codes
var UAStatus;
(function (UAStatus) {
    UAStatus[UAStatus["STATUS_INIT"] = 0] = "STATUS_INIT";
    UAStatus[UAStatus["STATUS_STARTING"] = 1] = "STATUS_STARTING";
    UAStatus[UAStatus["STATUS_READY"] = 2] = "STATUS_READY";
    UAStatus[UAStatus["STATUS_USER_CLOSED"] = 3] = "STATUS_USER_CLOSED";
    UAStatus[UAStatus["STATUS_NOT_READY"] = 4] = "STATUS_NOT_READY";
})(UAStatus = exports.UAStatus || (exports.UAStatus = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Exceptions.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/Exceptions.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
// tslint:disable:max-classes-per-file
var Exceptions;
(function (Exceptions) {
    /**
     * Indicates the session description handler has closed.
     * Occurs when getDescription() or setDescription() are called after close() has been called.
     * Occurs when close() is called while getDescription() or setDescription() are in progress.
     */
    var ClosedSessionDescriptionHandlerError = /** @class */ (function (_super) {
        tslib_1.__extends(ClosedSessionDescriptionHandlerError, _super);
        function ClosedSessionDescriptionHandlerError() {
            return _super.call(this, "The session description handler has closed.") || this;
        }
        return ClosedSessionDescriptionHandlerError;
    }(core_1.Exception));
    Exceptions.ClosedSessionDescriptionHandlerError = ClosedSessionDescriptionHandlerError;
    /**
     * Indicates the session terminated before the action completed.
     */
    var TerminatedSessionError = /** @class */ (function (_super) {
        tslib_1.__extends(TerminatedSessionError, _super);
        function TerminatedSessionError() {
            return _super.call(this, "The session has terminated.") || this;
        }
        return TerminatedSessionError;
    }(core_1.Exception));
    Exceptions.TerminatedSessionError = TerminatedSessionError;
    /**
     * Unsupported session description content type.
     */
    var UnsupportedSessionDescriptionContentTypeError = /** @class */ (function (_super) {
        tslib_1.__extends(UnsupportedSessionDescriptionContentTypeError, _super);
        function UnsupportedSessionDescriptionContentTypeError(message) {
            return _super.call(this, message ? message : "Unsupported session description content type.") || this;
        }
        return UnsupportedSessionDescriptionContentTypeError;
    }(core_1.Exception));
    Exceptions.UnsupportedSessionDescriptionContentTypeError = UnsupportedSessionDescriptionContentTypeError;
})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));
/**
 * DEPRECATED: The original implementation of exceptions in this library attempted to
 * deal with the lack of type checking in JavaScript by adding a "type" attribute
 * to objects and using that to discriminate. On top of that it layered allcoated
 * "code" numbers and constant "name" strings. All of that is unnecessary when using
 * TypeScript, inheriting from Error and properly setting up the prototype chain...
 */
var LegacyException = /** @class */ (function (_super) {
    tslib_1.__extends(LegacyException, _super);
    function LegacyException(code, name, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.name = name;
        _this.message = message;
        return _this;
    }
    return LegacyException;
}(core_1.Exception));
(function (Exceptions) {
    var ConfigurationError = /** @class */ (function (_super) {
        tslib_1.__extends(ConfigurationError, _super);
        function ConfigurationError(parameter, value) {
            var _this = _super.call(this, 1, "CONFIGURATION_ERROR", (!value) ? "Missing parameter: " + parameter :
                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
            _this.type = Enums_1.TypeStrings.ConfigurationError;
            _this.parameter = parameter;
            _this.value = value;
            return _this;
        }
        return ConfigurationError;
    }(LegacyException));
    Exceptions.ConfigurationError = ConfigurationError;
    var InvalidStateError = /** @class */ (function (_super) {
        tslib_1.__extends(InvalidStateError, _super);
        function InvalidStateError(status) {
            var _this = _super.call(this, 2, "INVALID_STATE_ERROR", "Invalid status: " + status) || this;
            _this.type = Enums_1.TypeStrings.InvalidStateError;
            _this.status = status;
            return _this;
        }
        return InvalidStateError;
    }(LegacyException));
    Exceptions.InvalidStateError = InvalidStateError;
    var NotSupportedError = /** @class */ (function (_super) {
        tslib_1.__extends(NotSupportedError, _super);
        function NotSupportedError(message) {
            var _this = _super.call(this, 3, "NOT_SUPPORTED_ERROR", message) || this;
            _this.type = Enums_1.TypeStrings.NotSupportedError;
            return _this;
        }
        return NotSupportedError;
    }(LegacyException));
    Exceptions.NotSupportedError = NotSupportedError;
    // 4 was GetDescriptionError, which was deprecated and now removed
    var RenegotiationError = /** @class */ (function (_super) {
        tslib_1.__extends(RenegotiationError, _super);
        function RenegotiationError(message) {
            var _this = _super.call(this, 5, "RENEGOTIATION_ERROR", message) || this;
            _this.type = Enums_1.TypeStrings.RenegotiationError;
            return _this;
        }
        return RenegotiationError;
    }(LegacyException));
    Exceptions.RenegotiationError = RenegotiationError;
    var MethodParameterError = /** @class */ (function (_super) {
        tslib_1.__extends(MethodParameterError, _super);
        function MethodParameterError(method, parameter, value) {
            var _this = _super.call(this, 6, "METHOD_PARAMETER_ERROR", (!value) ?
                "Missing parameter: " + parameter :
                "Invalid value " + JSON.stringify(value) + " for parameter '" + parameter + "'") || this;
            _this.type = Enums_1.TypeStrings.MethodParameterError;
            _this.method = method;
            _this.parameter = parameter;
            _this.value = value;
            return _this;
        }
        return MethodParameterError;
    }(LegacyException));
    Exceptions.MethodParameterError = MethodParameterError;
    // 7 was TransportError, which was replaced
    var SessionDescriptionHandlerError = /** @class */ (function (_super) {
        tslib_1.__extends(SessionDescriptionHandlerError, _super);
        function SessionDescriptionHandlerError(method, error, message) {
            var _this = _super.call(this, 8, "SESSION_DESCRIPTION_HANDLER_ERROR", message || "Error with Session Description Handler") || this;
            _this.type = Enums_1.TypeStrings.SessionDescriptionHandlerError;
            _this.method = method;
            _this.error = error;
            return _this;
        }
        return SessionDescriptionHandlerError;
    }(LegacyException));
    Exceptions.SessionDescriptionHandlerError = SessionDescriptionHandlerError;
})(Exceptions = exports.Exceptions || (exports.Exceptions = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/PublishContext.js":
/*!***************************************************!*\
  !*** ./node_modules/sip.js/lib/PublishContext.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * SIP Publish (SIP Extension for Event State Publication RFC3903)
 * @class Class creating a SIP PublishContext.
 */
var PublishContext = /** @class */ (function (_super) {
    tslib_1.__extends(PublishContext, _super);
    function PublishContext(ua, target, event, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.contentType = (options.contentType || "text/plain");
        if (typeof options.expires !== "number" || (options.expires % 1) !== 0) {
            options.expires = 3600;
        }
        else {
            options.expires = Number(options.expires);
        }
        if (typeof (options.unpublishOnClose) !== "boolean") {
            options.unpublishOnClose = true;
        }
        if (target === undefined || target === null || target === "") {
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
        }
        else {
            target = ua.normalizeTarget(target);
            if (target === undefined) {
                throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Target", target);
            }
        }
        _this = _super.call(this, ua, Constants_1.C.PUBLISH, target, options) || this;
        _this.type = Enums_1.TypeStrings.PublishContext;
        _this.options = options;
        _this.target = target;
        if (event === undefined || event === null || event === "") {
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Event", event);
        }
        else {
            _this.event = event;
        }
        _this.logger = ua.getLogger("sip.publish");
        _this.pubRequestExpires = _this.options.expires;
        return _this;
    }
    /**
     * Publish
     * @param {string} Event body to publish, optional
     */
    PublishContext.prototype.publish = function (body) {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        // is Inital or Modify request
        this.options.body = body;
        this.pubRequestBody = this.options.body;
        if (this.pubRequestExpires === 0) {
            // This is Initial request after unpublish
            this.pubRequestExpires = this.options.expires;
            this.pubRequestEtag = undefined;
        }
        if (!(this.ua.publishers[this.target.toString() + ":" + this.event])) {
            this.ua.publishers[this.target.toString() + ":" + this.event] = this;
        }
        this.sendPublishRequest();
    };
    /**
     * Unpublish
     */
    PublishContext.prototype.unpublish = function () {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        this.pubRequestBody = undefined;
        this.pubRequestExpires = 0;
        if (this.pubRequestEtag !== undefined) {
            this.sendPublishRequest();
        }
    };
    /**
     * Close
     */
    PublishContext.prototype.close = function () {
        // Send unpublish, if requested
        if (this.options.unpublishOnClose) {
            this.unpublish();
        }
        else {
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestExpires = 0;
            this.pubRequestEtag = undefined;
        }
        if (this.ua.publishers[this.target.toString() + ":" + this.event]) {
            delete this.ua.publishers[this.target.toString() + ":" + this.event];
        }
    };
    PublishContext.prototype.onRequestTimeout = function () {
        _super.prototype.onRequestTimeout.call(this);
        this.emit("unpublished", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    PublishContext.prototype.onTransportError = function () {
        _super.prototype.onTransportError.call(this);
        this.emit("unpublished", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    PublishContext.prototype.receiveResponse = function (response) {
        var _this = this;
        var statusCode = response.statusCode || 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                this.emit("progress", response, cause);
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                // Set SIP-Etag
                if (response.hasHeader("SIP-ETag")) {
                    this.pubRequestEtag = response.getHeader("SIP-ETag");
                }
                else {
                    this.logger.warn("SIP-ETag header missing in a 200-class response to PUBLISH");
                }
                // Update Expire
                if (response.hasHeader("Expires")) {
                    var expires = Number(response.getHeader("Expires"));
                    if (typeof expires === "number" && expires >= 0 && expires <= this.pubRequestExpires) {
                        this.pubRequestExpires = expires;
                    }
                    else {
                        this.logger.warn("Bad Expires header in a 200-class response to PUBLISH");
                    }
                }
                else {
                    this.logger.warn("Expires header missing in a 200-class response to PUBLISH");
                }
                if (this.pubRequestExpires !== 0) {
                    // Schedule refresh
                    this.publishRefreshTimer = setTimeout(function () { return _this.refreshRequest(); }, this.pubRequestExpires * 900);
                    this.emit("published", response, cause);
                }
                else {
                    this.emit("unpublished", response, cause);
                }
                break;
            case /^412$/.test(statusCode.toString()):
                // 412 code means no matching ETag - possibly the PUBLISH expired
                // Resubmit as new request, if the current request is not a "remove"
                if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {
                    this.logger.warn("412 response to PUBLISH, recovering");
                    this.pubRequestEtag = undefined;
                    this.emit("progress", response, cause);
                    this.publish(this.options.body);
                }
                else {
                    this.logger.warn("412 response to PUBLISH, recovery failed");
                    this.pubRequestExpires = 0;
                    this.emit("failed", response, cause);
                    this.emit("unpublished", response, cause);
                }
                break;
            case /^423$/.test(statusCode.toString()):
                // 423 code means we need to adjust the Expires interval up
                if (this.pubRequestExpires !== 0 && response.hasHeader("Min-Expires")) {
                    var minExpires = Number(response.getHeader("Min-Expires"));
                    if (typeof minExpires === "number" || minExpires > this.pubRequestExpires) {
                        this.logger.warn("423 code in response to PUBLISH, adjusting the Expires value and trying to recover");
                        this.pubRequestExpires = minExpires;
                        this.emit("progress", response, cause);
                        this.publish(this.options.body);
                    }
                    else {
                        this.logger.warn("Bad 423 response Min-Expires header received for PUBLISH");
                        this.pubRequestExpires = 0;
                        this.emit("failed", response, cause);
                        this.emit("unpublished", response, cause);
                    }
                }
                else {
                    this.logger.warn("423 response to PUBLISH, recovery failed");
                    this.pubRequestExpires = 0;
                    this.emit("failed", response, cause);
                    this.emit("unpublished", response, cause);
                }
                break;
            default:
                this.pubRequestExpires = 0;
                this.emit("failed", response, cause);
                this.emit("unpublished", response, cause);
                break;
        }
        // Do the cleanup
        if (this.pubRequestExpires === 0) {
            if (this.publishRefreshTimer) {
                clearTimeout(this.publishRefreshTimer);
                this.publishRefreshTimer = undefined;
            }
            this.pubRequestBody = undefined;
            this.pubRequestEtag = undefined;
        }
    };
    PublishContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.publish(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    PublishContext.prototype.refreshRequest = function () {
        // Clean up before the run
        if (this.publishRefreshTimer) {
            clearTimeout(this.publishRefreshTimer);
            this.publishRefreshTimer = undefined;
        }
        // This is Refresh request
        this.pubRequestBody = undefined;
        if (this.pubRequestEtag === undefined) {
            // Request not valid
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Body", undefined);
        }
        if (this.pubRequestExpires === 0) {
            // Request not valid
            throw new Exceptions_1.Exceptions.MethodParameterError("Publish", "Expire", this.pubRequestExpires);
        }
        this.sendPublishRequest();
    };
    PublishContext.prototype.sendPublishRequest = function () {
        var reqOptions = Object.create(this.options || Object.prototype);
        reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();
        reqOptions.extraHeaders.push("Event: " + this.event);
        reqOptions.extraHeaders.push("Expires: " + this.pubRequestExpires);
        if (this.pubRequestEtag !== undefined) {
            reqOptions.extraHeaders.push("SIP-If-Match: " + this.pubRequestEtag);
        }
        var ruri = this.target instanceof core_1.URI ? this.target : this.ua.normalizeTarget(this.target);
        if (!ruri) {
            throw new Error("ruri undefined.");
        }
        var params = this.options.params || {};
        var bodyObj;
        if (this.pubRequestBody !== undefined) {
            bodyObj = {
                body: this.pubRequestBody,
                contentType: this.options.contentType
            };
        }
        var body;
        if (bodyObj) {
            body = Utils_1.Utils.fromBodyObj(bodyObj);
        }
        this.request = this.ua.userAgentCore.makeOutgoingRequestMessage(Constants_1.C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.ua.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);
        this.send();
    };
    return PublishContext;
}(ClientContext_1.ClientContext));
exports.PublishContext = PublishContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/ReferContext.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/ReferContext.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
// tslint:disable-next-line:max-classes-per-file
var ReferClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(ReferClientContext, _super);
    function ReferClientContext(ua, applicant, target, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        if (ua === undefined || applicant === undefined || target === undefined) {
            throw new TypeError("Not enough arguments");
        }
        _this = _super.call(this, ua, Constants_1.C.REFER, applicant.remoteIdentity.uri.toString(), options) || this;
        _this.type = Enums_1.TypeStrings.ReferClientContext;
        _this.options = options;
        _this.extraHeaders = (_this.options.extraHeaders || []).slice();
        _this.applicant = applicant;
        _this.target = _this.initReferTo(target);
        if (_this.ua) {
            _this.extraHeaders.push("Referred-By: <" + _this.ua.configuration.uri + ">");
        }
        // TODO: Check that this is correct isc/icc
        _this.extraHeaders.push("Contact: " + applicant.contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        _this.extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        _this.extraHeaders.push("Refer-To: " + _this.target);
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    ReferClientContext.prototype.refer = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var extraHeaders = (this.extraHeaders || []).slice();
        if (options.extraHeaders) {
            extraHeaders.concat(options.extraHeaders);
        }
        this.applicant.sendRequest(Constants_1.C.REFER, {
            extraHeaders: this.extraHeaders,
            receiveResponse: function (response) {
                var statusCode = response && response.statusCode ? response.statusCode.toString() : "";
                if (/^1[0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestProgress", _this);
                }
                else if (/^2[0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestAccepted", _this);
                }
                else if (/^[4-6][0-9]{2}$/.test(statusCode)) {
                    _this.emit("referRequestRejected", _this);
                }
                if (options.receiveResponse) {
                    options.receiveResponse(response);
                }
            }
        });
        return this;
    };
    ReferClientContext.prototype.receiveNotify = function (request) {
        // If we can correctly handle this, then we need to send a 200 OK!
        var contentType = request.message.hasHeader("Content-Type") ?
            request.message.getHeader("Content-Type") : undefined;
        if (contentType && contentType.search(/^message\/sipfrag/) !== -1) {
            var messageBody = core_1.Grammar.parse(request.message.body, "sipfrag");
            if (messageBody === -1) {
                request.reject({
                    statusCode: 489,
                    reasonPhrase: "Bad Event"
                });
                return;
            }
            switch (true) {
                case (/^1[0-9]{2}$/.test(messageBody.status_code)):
                    this.emit("referProgress", this);
                    break;
                case (/^2[0-9]{2}$/.test(messageBody.status_code)):
                    this.emit("referAccepted", this);
                    if (!this.options.activeAfterTransfer && this.applicant.terminate) {
                        this.applicant.terminate();
                    }
                    break;
                default:
                    this.emit("referRejected", this);
                    break;
            }
            request.accept();
            this.emit("notify", request.message);
            return;
        }
        request.reject({
            statusCode: 489,
            reasonPhrase: "Bad Event"
        });
    };
    ReferClientContext.prototype.initReferTo = function (target) {
        var stringOrURI;
        if (typeof target === "string") {
            // REFER without Replaces (Blind Transfer)
            var targetString = core_1.Grammar.parse(target, "Refer_To");
            stringOrURI = targetString && targetString.uri ? targetString.uri : target;
            // Check target validity
            var targetUri = this.ua.normalizeTarget(target);
            if (!targetUri) {
                throw new TypeError("Invalid target: " + target);
            }
            stringOrURI = targetUri;
        }
        else {
            // REFER with Replaces (Attended Transfer)
            if (!target.session) {
                throw new Error("Session undefined.");
            }
            var displayName = target.remoteIdentity.friendlyName;
            var remoteTarget = target.session.remoteTarget.toString();
            var callId = target.session.callId;
            var remoteTag = target.session.remoteTag;
            var localTag = target.session.localTag;
            var replaces = encodeURIComponent(callId + ";to-tag=" + remoteTag + ";from-tag=" + localTag);
            stringOrURI = "\"" + displayName + "\" <" + remoteTarget + "?Replaces=" + replaces + ">";
        }
        return stringOrURI;
    };
    return ReferClientContext;
}(ClientContext_1.ClientContext));
exports.ReferClientContext = ReferClientContext;
// tslint:disable-next-line:max-classes-per-file
var ReferServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(ReferServerContext, _super);
    function ReferServerContext(ua, incomingRequest, session) {
        var _this = _super.call(this, ua, incomingRequest) || this;
        _this.session = session;
        _this.type = Enums_1.TypeStrings.ReferServerContext;
        _this.ua = ua;
        _this.status = Enums_1.SessionStatus.STATUS_INVITE_RECEIVED;
        _this.fromTag = _this.request.fromTag;
        _this.id = _this.request.callId + _this.fromTag;
        _this.contact = _this.ua.contact.toString();
        _this.logger = ua.getLogger("sip.referservercontext", _this.id);
        // Needed to send the NOTIFY's
        _this.cseq = Math.floor(Math.random() * 10000);
        _this.callId = _this.request.callId;
        _this.fromUri = _this.request.to.uri;
        _this.fromTag = _this.request.to.parameters.tag;
        _this.remoteTarget = _this.request.headers.Contact[0].parsed.uri;
        _this.toUri = _this.request.from.uri;
        _this.toTag = _this.request.fromTag;
        _this.routeSet = _this.request.getHeaders("record-route");
        // RFC 3515 2.4.1
        if (!_this.request.hasHeader("refer-to")) {
            _this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting refer.");
            _this.reject();
            return _this;
        }
        _this.referTo = _this.request.parseHeader("refer-to");
        // TODO: Must set expiration timer and send 202 if there is no response by then
        _this.referredSession = _this.ua.findSession(_this.request);
        if (_this.request.hasHeader("referred-by")) {
            _this.referredBy = _this.request.getHeader("referred-by");
        }
        if (_this.referTo.uri.hasHeader("replaces")) {
            _this.replaces = _this.referTo.uri.getHeader("replaces");
        }
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
        return _this;
    }
    ReferServerContext.prototype.progress = function () {
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.incomingRequest.trying();
    };
    ReferServerContext.prototype.reject = function (options) {
        if (options === void 0) { options = {}; }
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.logger.log("Rejecting refer");
        this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
        _super.prototype.reject.call(this, options);
        this.emit("referRequestRejected", this);
    };
    ReferServerContext.prototype.accept = function (options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        }
        else {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.incomingRequest.accept({
            statusCode: 202,
            reasonPhrase: "Accepted"
        });
        this.emit("referRequestAccepted", this);
        if (options.followRefer) {
            this.logger.log("Accepted refer, attempting to automatically follow it");
            var target = this.referTo.uri;
            if (!target.scheme || !target.scheme.match("^sips?$")) {
                this.logger.error("SIP.js can only automatically follow SIP refer target");
                this.reject();
                return;
            }
            var inviteOptions = options.inviteOptions || {};
            var extraHeaders = (inviteOptions.extraHeaders || []).slice();
            if (this.replaces) {
                // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
                extraHeaders.push("Replaces: " + decodeURIComponent(this.replaces));
            }
            if (this.referredBy) {
                extraHeaders.push("Referred-By: " + this.referredBy);
            }
            inviteOptions.extraHeaders = extraHeaders;
            target.clearHeaders();
            this.targetSession = this.ua.invite(target.toString(), inviteOptions, modifiers);
            this.emit("referInviteSent", this);
            if (this.targetSession) {
                this.targetSession.once("progress", function (response) {
                    var statusCode = response.statusCode || 100;
                    var reasonPhrase = response.reasonPhrase;
                    _this.sendNotify(("SIP/2.0 " + statusCode + " " + reasonPhrase).trim());
                    _this.emit("referProgress", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referProgress", _this);
                    }
                });
                this.targetSession.once("accepted", function () {
                    _this.logger.log("Successfully followed the refer");
                    _this.sendNotify("SIP/2.0 200 OK");
                    _this.emit("referAccepted", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referAccepted", _this);
                    }
                });
                var referFailed = function (response) {
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return; // No throw here because it is possible this gets called multiple times
                    }
                    _this.logger.log("Refer was not successful. Resuming session");
                    if (response && response.statusCode === 429) {
                        _this.logger.log("Alerting referrer that identity is required.");
                        _this.sendNotify("SIP/2.0 429 Provide Referrer Identity");
                        return;
                    }
                    _this.sendNotify("SIP/2.0 603 Declined");
                    // Must change the status after sending the final Notify or it will not send due to check
                    _this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
                    _this.emit("referRejected", _this);
                    if (_this.referredSession) {
                        _this.referredSession.emit("referRejected");
                    }
                };
                this.targetSession.once("rejected", referFailed);
                this.targetSession.once("failed", referFailed);
            }
        }
        else {
            this.logger.log("Accepted refer, but did not automatically follow it");
            this.sendNotify("SIP/2.0 200 OK");
            this.emit("referAccepted", this);
            if (this.referredSession) {
                this.referredSession.emit("referAccepted", this);
            }
        }
    };
    ReferServerContext.prototype.sendNotify = function (bodyStr) {
        // FIXME: Ported this. Clean it up. Session knows its state.
        if (this.status !== Enums_1.SessionStatus.STATUS_ANSWERED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (core_1.Grammar.parse(bodyStr, "sipfrag") === -1) {
            throw new Error("sipfrag body is required to send notify for refer");
        }
        var body = {
            contentDisposition: "render",
            contentType: "message/sipfrag",
            content: bodyStr
        };
        // NOTIFY requests sent in same dialog as in dialog REFER.
        if (this.session) {
            this.session.notify(undefined, {
                extraHeaders: [
                    "Event: refer",
                    "Subscription-State: terminated",
                ],
                body: body
            });
            return;
        }
        // The implicit subscription created by a REFER is the same as a
        // subscription created with a SUBSCRIBE request.  The agent issuing the
        // REFER can terminate this subscription prematurely by unsubscribing
        // using the mechanisms described in [2].  Terminating a subscription,
        // either by explicitly unsubscribing or rejecting NOTIFY, is not an
        // indication that the referenced request should be withdrawn or
        // abandoned.
        // https://tools.ietf.org/html/rfc3515#section-2.4.4
        // NOTIFY requests sent in new dialog for out of dialog REFER.
        // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.
        var request = this.ua.userAgentCore.makeOutgoingRequestMessage(Constants_1.C.NOTIFY, this.remoteTarget, this.fromUri, this.toUri, {
            cseq: this.cseq += 1,
            callId: this.callId,
            fromTag: this.fromTag,
            toTag: this.toTag,
            routeSet: this.routeSet
        }, [
            "Event: refer",
            "Subscription-State: terminated",
            "Content-Type: message/sipfrag"
        ], body);
        var transport = this.ua.transport;
        if (!transport) {
            throw new Error("Transport undefined.");
        }
        var user = {
            loggerFactory: this.ua.getLoggerFactory()
        };
        var nic = new core_1.NonInviteClientTransaction(request, transport, user);
    };
    ReferServerContext.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    return ReferServerContext;
}(ServerContext_1.ServerContext));
exports.ReferServerContext = ReferServerContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/RegisterContext.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/RegisterContext.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * Configuration load.
 * @private
 * returns {any}
 */
function loadConfig(configuration) {
    var settings = {
        expires: 600,
        extraContactHeaderParams: [],
        instanceId: undefined,
        params: {},
        regId: undefined,
        registrar: undefined,
    };
    var configCheck = getConfigurationCheck();
    // Check Mandatory parameters
    for (var parameter in configCheck.mandatory) {
        if (!configuration.hasOwnProperty(parameter)) {
            throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
        }
        else {
            var value = configuration[parameter];
            var checkedValue = configCheck.mandatory[parameter](value);
            if (checkedValue !== undefined) {
                settings[parameter] = checkedValue;
            }
            else {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
            }
        }
    }
    // Check Optional parameters
    for (var parameter in configCheck.optional) {
        if (configuration.hasOwnProperty(parameter)) {
            var value = configuration[parameter];
            // If the parameter value is an empty array, but shouldn't be, apply its default value.
            if (value instanceof Array && value.length === 0) {
                continue;
            }
            // If the parameter value is null, empty string, or undefined then apply its default value.
            // If it's a number with NaN value then also apply its default value.
            // NOTE: JS does not allow "value === NaN", the following does the work:
            if (value === null || value === "" || value === undefined ||
                (typeof (value) === "number" && isNaN(value))) {
                continue;
            }
            var checkedValue = configCheck.optional[parameter](value);
            if (checkedValue !== undefined) {
                settings[parameter] = checkedValue;
            }
            else {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
            }
        }
    }
    return settings;
}
function getConfigurationCheck() {
    return {
        mandatory: {},
        optional: {
            expires: function (expires) {
                if (Utils_1.Utils.isDecimal(expires)) {
                    var value = Number(expires);
                    if (value >= 0) {
                        return value;
                    }
                }
            },
            extraContactHeaderParams: function (extraContactHeaderParams) {
                if (extraContactHeaderParams instanceof Array) {
                    return extraContactHeaderParams.filter(function (contactHeaderParam) { return (typeof contactHeaderParam === "string"); });
                }
            },
            instanceId: function (instanceId) {
                if (typeof instanceId !== "string") {
                    return;
                }
                if ((/^uuid:/i.test(instanceId))) {
                    instanceId = instanceId.substr(5);
                }
                if (core_1.Grammar.parse(instanceId, "uuid") === -1) {
                    return;
                }
                else {
                    return instanceId;
                }
            },
            params: function (params) {
                if (typeof params === "object") {
                    return params;
                }
            },
            regId: function (regId) {
                if (Utils_1.Utils.isDecimal(regId)) {
                    var value = Number(regId);
                    if (value >= 0) {
                        return value;
                    }
                }
            },
            registrar: function (registrar) {
                if (typeof registrar !== "string") {
                    return;
                }
                if (!/^sip:/i.test(registrar)) {
                    registrar = Constants_1.C.SIP + ":" + registrar;
                }
                var parsed = core_1.Grammar.URIParse(registrar);
                if (!parsed) {
                    return;
                }
                else if (parsed.user) {
                    return;
                }
                else {
                    return parsed;
                }
            }
        }
    };
}
var RegisterContext = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterContext, _super);
    function RegisterContext(ua, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var settings = loadConfig(options);
        if (settings.regId && !settings.instanceId) {
            settings.instanceId = Utils_1.Utils.newUUID();
        }
        else if (!settings.regId && settings.instanceId) {
            settings.regId = 1;
        }
        settings.params.toUri = settings.params.toUri || ua.configuration.uri;
        settings.params.toDisplayName = settings.params.toDisplayName || ua.configuration.displayName;
        settings.params.callId = settings.params.callId || Utils_1.Utils.createRandomToken(22);
        settings.params.cseq = settings.params.cseq || Math.floor(Math.random() * 10000);
        /* If no 'registrarServer' is set use the 'uri' value without user portion. */
        if (!settings.registrar) {
            var registrarServer = {};
            if (typeof ua.configuration.uri === "object") {
                registrarServer = ua.configuration.uri.clone();
                registrarServer.user = undefined;
            }
            else {
                registrarServer = ua.configuration.uri;
            }
            settings.registrar = registrarServer;
        }
        _this = _super.call(this, ua, Constants_1.C.REGISTER, settings.registrar, settings) || this;
        _this.type = Enums_1.TypeStrings.RegisterContext;
        _this.options = settings;
        _this.logger = ua.getLogger("sip.registercontext");
        _this.logger.log("configuration parameters for RegisterContext after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                _this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
            }
        }
        // Registration expires
        _this.expires = settings.expires;
        // Contact header
        _this.contact = ua.contact.toString();
        // Set status
        _this.registered = false;
        ua.transport.on("disconnected", function () { return _this.onTransportDisconnected(); });
        return _this;
    }
    RegisterContext.prototype.register = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Handle Options
        this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options);
        var extraHeaders = (this.options.extraHeaders || []).slice();
        extraHeaders.push("Contact: " + this.generateContactHeader(this.expires));
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        // Save original extraHeaders to be used in .close
        this.closeHeaders = this.options.closeWithHeaders ?
            (this.options.extraHeaders || []).slice() : [];
        this.receiveResponse = function (response) {
            // Discard responses to older REGISTER/un-REGISTER requests.
            if (response.cseq !== _this.request.cseq) {
                return;
            }
            // Clear registration timer
            if (_this.registrationTimer !== undefined) {
                clearTimeout(_this.registrationTimer);
                _this.registrationTimer = undefined;
            }
            var statusCode = (response.statusCode || 0).toString();
            switch (true) {
                case /^1[0-9]{2}$/.test(statusCode):
                    _this.emit("progress", response);
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    _this.emit("accepted", response);
                    var expires = void 0;
                    if (response.hasHeader("expires")) {
                        expires = Number(response.getHeader("expires"));
                    }
                    if (_this.registrationExpiredTimer !== undefined) {
                        clearTimeout(_this.registrationExpiredTimer);
                        _this.registrationExpiredTimer = undefined;
                    }
                    // Search the Contact pointing to us and update the expires value accordingly.
                    var contacts = response.getHeaders("contact").length;
                    if (!contacts) {
                        _this.logger.warn("no Contact header in response to REGISTER, response ignored");
                        break;
                    }
                    var contact = void 0;
                    while (contacts--) {
                        contact = response.parseHeader("contact", contacts);
                        if (contact.uri.user === _this.ua.contact.uri.user) {
                            expires = contact.getParam("expires");
                            break;
                        }
                        else {
                            contact = undefined;
                        }
                    }
                    if (!contact) {
                        _this.logger.warn("no Contact header pointing to us, response ignored");
                        break;
                    }
                    if (expires === undefined) {
                        expires = _this.expires;
                    }
                    // Re-Register before the expiration interval has elapsed.
                    // For that, decrease the expires value. ie: 3 seconds
                    _this.registrationTimer = setTimeout(function () {
                        _this.registrationTimer = undefined;
                        _this.register(_this.options);
                    }, (expires * 1000) - 3000);
                    _this.registrationExpiredTimer = setTimeout(function () {
                        _this.logger.warn("registration expired");
                        if (_this.registered) {
                            _this.unregistered(undefined, Constants_1.C.causes.EXPIRES);
                        }
                    }, expires * 1000);
                    // Save gruu values
                    if (contact.hasParam("temp-gruu")) {
                        _this.ua.contact.tempGruu = core_1.Grammar.URIParse(contact.getParam("temp-gruu").replace(/"/g, ""));
                    }
                    if (contact.hasParam("pub-gruu")) {
                        _this.ua.contact.pubGruu = core_1.Grammar.URIParse(contact.getParam("pub-gruu").replace(/"/g, ""));
                    }
                    _this.registered = true;
                    _this.emit("registered", response || undefined);
                    break;
                // Interval too brief RFC3261 10.2.8
                case /^423$/.test(statusCode):
                    if (response.hasHeader("min-expires")) {
                        // Increase our registration interval to the suggested minimum
                        _this.expires = Number(response.getHeader("min-expires"));
                        // Attempt the registration again immediately
                        _this.register(_this.options);
                    }
                    else { // This response MUST contain a Min-Expires header field
                        _this.logger.warn("423 response received for REGISTER without Min-Expires");
                        _this.registrationFailure(response, Constants_1.C.causes.SIP_FAILURE_CODE);
                    }
                    break;
                default:
                    _this.registrationFailure(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
            }
        };
        this.onRequestTimeout = function () {
            _this.registrationFailure(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        };
        this.onTransportError = function () {
            _this.registrationFailure(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        };
        this.request.cseq++;
        this.request.setHeader("cseq", this.request.cseq + " REGISTER");
        this.request.extraHeaders = extraHeaders;
        this.send();
    };
    RegisterContext.prototype.close = function () {
        var options = {
            all: false,
            extraHeaders: this.closeHeaders
        };
        this.registeredBefore = this.registered;
        if (this.registered) {
            this.unregister(options);
        }
    };
    RegisterContext.prototype.unregister = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.registered && !options.all) {
            this.logger.warn("Already unregistered, but sending an unregister anyways.");
        }
        var extraHeaders = (options.extraHeaders || []).slice();
        this.registered = false;
        // Clear the registration timer.
        if (this.registrationTimer !== undefined) {
            clearTimeout(this.registrationTimer);
            this.registrationTimer = undefined;
        }
        if (options.all) {
            extraHeaders.push("Contact: *");
            extraHeaders.push("Expires: 0");
        }
        else {
            extraHeaders.push("Contact: " + this.generateContactHeader(0));
        }
        this.receiveResponse = function (response) {
            var statusCode = (response && response.statusCode) ? response.statusCode.toString() : "";
            switch (true) {
                case /^1[0-9]{2}$/.test(statusCode):
                    _this.emit("progress", response);
                    break;
                case /^2[0-9]{2}$/.test(statusCode):
                    _this.emit("accepted", response);
                    if (_this.registrationExpiredTimer !== undefined) {
                        clearTimeout(_this.registrationExpiredTimer);
                        _this.registrationExpiredTimer = undefined;
                    }
                    _this.unregistered(response);
                    break;
                default:
                    _this.unregistered(response, Utils_1.Utils.sipErrorCause(response.statusCode || 0));
            }
        };
        this.onRequestTimeout = function () {
            // Not actually unregistered...
            // this.unregistered(undefined, SIP.C.causes.REQUEST_TIMEOUT);
        };
        this.request.cseq++;
        this.request.setHeader("cseq", this.request.cseq + " REGISTER");
        this.request.extraHeaders = extraHeaders;
        this.send();
    };
    RegisterContext.prototype.unregistered = function (response, cause) {
        this.registered = false;
        this.emit("unregistered", response || undefined, cause || undefined);
    };
    RegisterContext.prototype.send = function () {
        var _this = this;
        this.ua.userAgentCore.register(this.request, {
            onAccept: function (response) { return _this.receiveResponse(response.message); },
            onProgress: function (response) { return _this.receiveResponse(response.message); },
            onRedirect: function (response) { return _this.receiveResponse(response.message); },
            onReject: function (response) { return _this.receiveResponse(response.message); },
            onTrying: function (response) { return _this.receiveResponse(response.message); }
        });
        return this;
    };
    RegisterContext.prototype.registrationFailure = function (response, cause) {
        this.emit("failed", response || undefined, cause || undefined);
    };
    RegisterContext.prototype.onTransportDisconnected = function () {
        this.registeredBefore = this.registered;
        if (this.registrationTimer !== undefined) {
            clearTimeout(this.registrationTimer);
            this.registrationTimer = undefined;
        }
        if (this.registrationExpiredTimer !== undefined) {
            clearTimeout(this.registrationExpiredTimer);
            this.registrationExpiredTimer = undefined;
        }
        if (this.registered) {
            this.unregistered(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        }
    };
    /**
     * Helper Function to generate Contact Header
     * @private
     * returns {String}
     */
    RegisterContext.prototype.generateContactHeader = function (expires) {
        if (expires === void 0) { expires = 0; }
        var contact = this.contact;
        if (this.options.regId && this.options.instanceId) {
            contact += ";reg-id=" + this.options.regId;
            contact += ';+sip.instance="<urn:uuid:' + this.options.instanceId + '>"';
        }
        if (this.options.extraContactHeaderParams) {
            this.options.extraContactHeaderParams.forEach(function (header) {
                contact += ";" + header;
            });
        }
        contact += ";expires=" + expires;
        return contact;
    };
    return RegisterContext;
}(ClientContext_1.ClientContext));
exports.RegisterContext = RegisterContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/ServerContext.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/ServerContext.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var ServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(ServerContext, _super);
    function ServerContext(ua, incomingRequest) {
        var _this = _super.call(this) || this;
        _this.incomingRequest = incomingRequest;
        _this.data = {};
        ServerContext.initializer(_this, ua, incomingRequest);
        return _this;
    }
    // hack to get around our multiple inheritance issues
    ServerContext.initializer = function (objectToConstruct, ua, incomingRequest) {
        var request = incomingRequest.message;
        objectToConstruct.type = Enums_1.TypeStrings.ServerContext;
        objectToConstruct.ua = ua;
        objectToConstruct.logger = ua.getLogger("sip.servercontext");
        objectToConstruct.request = request;
        if (request.body) {
            objectToConstruct.body = request.body;
        }
        if (request.hasHeader("Content-Type")) {
            objectToConstruct.contentType = request.getHeader("Content-Type");
        }
        objectToConstruct.method = request.method;
        objectToConstruct.localIdentity = request.to;
        objectToConstruct.remoteIdentity = request.from;
        var hasAssertedIdentity = request.hasHeader("P-Asserted-Identity");
        if (hasAssertedIdentity) {
            var assertedIdentity = request.getHeader("P-Asserted-Identity");
            if (assertedIdentity) {
                objectToConstruct.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(assertedIdentity);
            }
        }
    };
    ServerContext.prototype.progress = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 180;
        options.minCode = 100;
        options.maxCode = 199;
        options.events = ["progress"];
        return this.reply(options);
    };
    ServerContext.prototype.accept = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 200;
        options.minCode = 200;
        options.maxCode = 299;
        options.events = ["accepted"];
        return this.reply(options);
    };
    ServerContext.prototype.reject = function (options) {
        if (options === void 0) { options = {}; }
        options.statusCode = options.statusCode || 480;
        options.minCode = 300;
        options.maxCode = 699;
        options.events = ["rejected", "failed"];
        return this.reply(options);
    };
    ServerContext.prototype.reply = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 100;
        var minCode = options.minCode || 100;
        var maxCode = options.maxCode || 699;
        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
        var extraHeaders = options.extraHeaders || [];
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        var events = options.events || [];
        if (statusCode < minCode || statusCode > maxCode) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var responseOptions = {
            statusCode: statusCode,
            reasonPhrase: reasonPhrase,
            extraHeaders: extraHeaders,
            body: body
        };
        var response;
        var statusCodeString = statusCode.toString();
        switch (true) {
            case /^100$/.test(statusCodeString):
                response = this.incomingRequest.trying(responseOptions).message;
                break;
            case /^1[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.progress(responseOptions).message;
                break;
            case /^2[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.accept(responseOptions).message;
                break;
            case /^3[0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.redirect([], responseOptions).message;
                break;
            case /^[4-6][0-9]{2}$/.test(statusCodeString):
                response = this.incomingRequest.reject(responseOptions).message;
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
        events.forEach(function (event) {
            _this.emit(event, response, reasonPhrase);
        });
        return this;
    };
    ServerContext.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
    };
    ServerContext.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
    };
    return ServerContext;
}(events_1.EventEmitter));
exports.ServerContext = ServerContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/Session.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
var DTMF_1 = __webpack_require__(/*! ./Session/DTMF */ "./node_modules/sip.js/lib/Session/DTMF.js");
var DTMFValidator_1 = __webpack_require__(/*! ./Session/DTMFValidator */ "./node_modules/sip.js/lib/Session/DTMFValidator.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/*
 * @param {function returning SIP.sessionDescriptionHandler} [sessionDescriptionHandlerFactory]
 *        (See the documentation for the sessionDescriptionHandlerFactory argument of the UA constructor.)
 */
var Session = /** @class */ (function (_super) {
    tslib_1.__extends(Session, _super);
    function Session(sessionDescriptionHandlerFactory) {
        var _this = _super.call(this) || this;
        _this.data = {};
        _this.type = Enums_1.TypeStrings.Session;
        if (!sessionDescriptionHandlerFactory) {
            throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("A session description handler is required for the session to function");
        }
        _this.status = Session.C.STATUS_NULL;
        _this.pendingReinvite = false;
        _this.sessionDescriptionHandlerFactory = sessionDescriptionHandlerFactory;
        _this.hasOffer = false;
        _this.hasAnswer = false;
        // Session Timers
        _this.timers = {
            ackTimer: undefined,
            expiresTimer: undefined,
            invite2xxTimer: undefined,
            userNoAnswerTimer: undefined,
            rel1xxTimer: undefined,
            prackTimer: undefined
        };
        // Session info
        _this.startTime = undefined;
        _this.endTime = undefined;
        _this.tones = undefined;
        // Hold state
        _this.localHold = false;
        _this.earlySdp = undefined;
        _this.rel100 = Constants_1.C.supported.UNSUPPORTED;
        return _this;
    }
    Session.prototype.dtmf = function (tones, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED && this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        // Check tones' validity
        DTMFValidator_1.DTMFValidator.validate(tones);
        var sendDTMF = function () {
            if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED || !_this.tones || _this.tones.length === 0) {
                // Stop sending DTMF
                _this.tones = undefined;
                return;
            }
            var dtmf = _this.tones.shift();
            var timeout;
            if (dtmf.tone === ",") {
                timeout = 2000;
            }
            else {
                dtmf.on("failed", function () { _this.tones = undefined; });
                dtmf.send(options);
                timeout = dtmf.duration + dtmf.interToneGap;
            }
            // Set timeout for the next tone
            setTimeout(sendDTMF, timeout);
        };
        tones = tones.toString();
        var dtmfType = this.ua.configuration.dtmfType;
        if (this.sessionDescriptionHandler && dtmfType === Constants_1.C.dtmfType.RTP) {
            var sent = this.sessionDescriptionHandler.sendDtmf(tones, options);
            if (!sent) {
                this.logger.warn("Attempt to use dtmfType 'RTP' has failed, falling back to INFO packet method");
                dtmfType = Constants_1.C.dtmfType.INFO;
            }
        }
        if (dtmfType === Constants_1.C.dtmfType.INFO) {
            var dtmfs = [];
            var tonesArray = tones.split("");
            while (tonesArray.length > 0) {
                dtmfs.push(new DTMF_1.DTMF(this, tonesArray.shift(), options));
            }
            if (Array.isArray(this.tones) && this.tones.length) {
                // Tones are already queued, just add to the queue
                this.tones = this.tones.concat(dtmfs);
                return this;
            }
            this.tones = dtmfs;
            sendDTMF();
        }
        return this;
    };
    Session.prototype.bye = function (options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.logger.error("Error: Attempted to send BYE in a terminated session.");
            return this;
        }
        this.logger.log("terminating Session");
        var statusCode = options.statusCode;
        if (statusCode && (statusCode < 200 || statusCode >= 700)) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        options.receiveResponse = function () { };
        return this.sendRequest(Constants_1.C.BYE, options).terminated();
    };
    Session.prototype.refer = function (target, options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.referContext = new ReferContext_1.ReferClientContext(this.ua, this, target, options);
        this.emit("referRequested", this.referContext);
        this.referContext.refer(options);
        return this.referContext;
    };
    /**
     * Sends in dialog request.
     * @param method Request method.
     * @param options Options bucket.
     */
    Session.prototype.sendRequest = function (method, options) {
        if (options === void 0) { options = {}; }
        if (!this.session) {
            throw new Error("Session undefined.");
        }
        // Convert any "body" option to a Body.
        if (options.body) {
            options.body = Utils_1.Utils.fromBodyObj(options.body);
        }
        // Convert any "receiveResponse" callback option passed to an OutgoingRequestDelegate.
        var delegate;
        var callback = options.receiveResponse;
        if (callback) {
            delegate = {
                onAccept: function (response) { return callback(response.message); },
                onProgress: function (response) { return callback(response.message); },
                onRedirect: function (response) { return callback(response.message); },
                onReject: function (response) { return callback(response.message); },
                onTrying: function (response) { return callback(response.message); }
            };
        }
        var request;
        var requestOptions = options;
        switch (method) {
            case Constants_1.C.BYE:
                request = this.session.bye(delegate, requestOptions);
                break;
            case Constants_1.C.INVITE:
                request = this.session.invite(delegate, requestOptions);
                break;
            case Constants_1.C.MESSAGE:
                request = this.session.message(delegate, requestOptions);
                break;
            case Constants_1.C.REFER:
                request = this.session.refer(delegate, requestOptions);
                break;
            default:
                throw new Error("Unexpected " + method + ". Method not implemented by user agent core.");
        }
        // Ported - Emit the request event
        this.emit(method.toLowerCase(), request.message);
        return this;
    };
    Session.prototype.close = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.logger.log("closing INVITE session " + this.id);
        // 1st Step. Terminate media.
        if (this.sessionDescriptionHandler) {
            this.sessionDescriptionHandler.close();
        }
        // 2nd Step. Terminate signaling.
        // Clear session timers
        for (var timer in this.timers) {
            if (this.timers[timer]) {
                clearTimeout(this.timers[timer]);
            }
        }
        this.status = Enums_1.SessionStatus.STATUS_TERMINATED;
        if (this.ua.transport) {
            this.ua.transport.removeListener("transportError", this.errorListener);
        }
        delete this.ua.sessions[this.id];
        return this;
    };
    Session.prototype.hold = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (this.localHold) {
            this.logger.log("Session is already on hold, cannot put it on hold again");
            return;
        }
        options.modifiers = modifiers;
        if (this.sessionDescriptionHandler) {
            options.modifiers.push(this.sessionDescriptionHandler.holdModifier);
        }
        this.localHold = true;
        this.sendReinvite(options);
    };
    Session.prototype.unhold = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (this.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK && this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (!this.localHold) {
            this.logger.log("Session is not on hold, cannot unhold it");
            return;
        }
        options.modifiers = modifiers;
        this.localHold = false;
        this.sendReinvite(options);
    };
    Session.prototype.reinvite = function (options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        options.modifiers = modifiers;
        return this.sendReinvite(options);
    };
    Session.prototype.terminate = function (options) {
        // here for types and to be overridden
        return this;
    };
    Session.prototype.onTransportError = function () {
        if (this.status !== Enums_1.SessionStatus.STATUS_CONFIRMED && this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(undefined, Constants_1.C.causes.CONNECTION_ERROR);
        }
    };
    Session.prototype.onRequestTimeout = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.terminated(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        }
        else if (this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
            this.terminated(undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        }
    };
    Session.prototype.onDialogError = function (response) {
        if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.terminated(response, Constants_1.C.causes.DIALOG_ERROR);
        }
        else if (this.status !== Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.failed(response, Constants_1.C.causes.DIALOG_ERROR);
            this.terminated(response, Constants_1.C.causes.DIALOG_ERROR);
        }
    };
    Session.prototype.on = function (name, callback) {
        return _super.prototype.on.call(this, name, callback);
    };
    Session.prototype.onAck = function (incomingRequest) {
        var _this = this;
        var confirmSession = function () {
            clearTimeout(_this.timers.ackTimer);
            clearTimeout(_this.timers.invite2xxTimer);
            _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
            var contentDisp = incomingRequest.message.getHeader("Content-Disposition");
            if (contentDisp && contentDisp.type === "render") {
                _this.renderbody = incomingRequest.message.body;
                _this.rendertype = incomingRequest.message.getHeader("Content-Type");
            }
            _this.emit("confirmed", incomingRequest.message);
        };
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            if (this.sessionDescriptionHandler &&
                this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
                this.hasAnswer = true;
                this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).catch(function (e) {
                    _this.logger.warn(e);
                    _this.terminate({
                        statusCode: "488",
                        reasonPhrase: "Bad Media Description"
                    });
                    _this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    _this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    throw e;
                }).then(function () { return confirmSession(); });
            }
            else {
                confirmSession();
            }
        }
    };
    Session.prototype.receiveRequest = function (incomingRequest) {
        switch (incomingRequest.message.method) { // TODO: This needs a default case
            case Constants_1.C.BYE:
                incomingRequest.accept();
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.emit("bye", incomingRequest.message);
                    this.terminated(incomingRequest.message, Constants_1.C.BYE);
                }
                break;
            case Constants_1.C.INVITE:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.logger.log("re-INVITE received");
                    this.receiveReinvite(incomingRequest);
                }
                break;
            case Constants_1.C.INFO:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED || this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
                    if (this.onInfo) {
                        return this.onInfo(incomingRequest.message);
                    }
                    var contentType = incomingRequest.message.getHeader("content-type");
                    if (contentType) {
                        if (contentType.match(/^application\/dtmf-relay/i)) {
                            if (incomingRequest.message.body) {
                                var body = incomingRequest.message.body.split("\r\n", 2);
                                if (body.length === 2) {
                                    var tone = void 0;
                                    var duration = void 0;
                                    var regTone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/;
                                    if (regTone.test(body[0])) {
                                        tone = body[0].replace(regTone, "$2");
                                    }
                                    var regDuration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;
                                    if (regDuration.test(body[1])) {
                                        duration = parseInt(body[1].replace(regDuration, "$2"), 10);
                                    }
                                    if (tone && duration) {
                                        new DTMF_1.DTMF(this, tone, { duration: duration }).init_incoming(incomingRequest);
                                    }
                                }
                            }
                        }
                        else {
                            incomingRequest.reject({
                                statusCode: 415,
                                extraHeaders: ["Accept: application/dtmf-relay"]
                            });
                        }
                    }
                }
                break;
            case Constants_1.C.REFER:
                if (this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
                    this.logger.log("REFER received");
                    this.referContext = new ReferContext_1.ReferServerContext(this.ua, incomingRequest, this.session);
                    if (this.listeners("referRequested").length) {
                        this.emit("referRequested", this.referContext);
                    }
                    else {
                        this.logger.log("No referRequested listeners, automatically accepting and following the refer");
                        var options = { followRefer: true };
                        if (this.passedOptions) {
                            options.inviteOptions = this.passedOptions;
                        }
                        this.referContext.accept(options, this.modifiers);
                    }
                }
                break;
            case Constants_1.C.NOTIFY:
                if (this.referContext &&
                    this.referContext.type === Enums_1.TypeStrings.ReferClientContext &&
                    incomingRequest.message.hasHeader("event") &&
                    /^refer(;.*)?$/.test(incomingRequest.message.getHeader("event"))) {
                    this.referContext.receiveNotify(incomingRequest);
                    return;
                }
                incomingRequest.accept();
                this.emit("notify", incomingRequest.message);
                break;
            case Constants_1.C.MESSAGE:
                incomingRequest.accept();
                this.emit("message", incomingRequest.message);
                break;
        }
    };
    // In dialog INVITE Reception
    Session.prototype.receiveReinvite = function (incomingRequest) {
        // TODO: Should probably check state of the session
        var _this = this;
        this.emit("reinvite", this, incomingRequest.message);
        if (incomingRequest.message.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity =
                core_1.Grammar.nameAddrHeaderParse(incomingRequest.message.getHeader("P-Asserted-Identity"));
        }
        var promise;
        if (!this.sessionDescriptionHandler) {
            this.logger.warn("No SessionDescriptionHandler to reinvite");
            return;
        }
        if (incomingRequest.message.getHeader("Content-Length") === "0" &&
            !incomingRequest.message.getHeader("Content-Type")) { // Invite w/o SDP
            promise = this.sessionDescriptionHandler.getDescription(this.sessionDescriptionHandlerOptions, this.modifiers);
        }
        else if (this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
            // Invite w/ SDP
            promise = this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(this.sessionDescriptionHandler.getDescription.bind(this.sessionDescriptionHandler, this.sessionDescriptionHandlerOptions, this.modifiers));
        }
        else { // Bad Packet (should never get hit)
            incomingRequest.reject({ statusCode: 415 });
            this.emit("reinviteFailed", this);
            return;
        }
        promise.catch(function (e) {
            var statusCode;
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                statusCode = 500;
            }
            else if (e.type === Enums_1.TypeStrings.RenegotiationError) {
                _this.emit("renegotiationError", e);
                _this.logger.warn(e.toString());
                statusCode = 488;
            }
            else {
                _this.logger.error(e);
                statusCode = 488;
            }
            incomingRequest.reject({ statusCode: statusCode });
            _this.emit("reinviteFailed", _this);
            // TODO: This could be better
            throw e;
        }).then(function (description) {
            var extraHeaders = ["Contact: " + _this.contact];
            incomingRequest.accept({
                statusCode: 200,
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(description)
            });
            _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK;
            _this.emit("reinviteAccepted", _this);
        });
    };
    Session.prototype.sendReinvite = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.pendingReinvite) {
            this.logger.warn("Reinvite in progress. Please wait until complete, then try again.");
            return;
        }
        if (!this.sessionDescriptionHandler) {
            this.logger.warn("No SessionDescriptionHandler, can't reinvite..");
            return;
        }
        this.pendingReinvite = true;
        options.modifiers = options.modifiers || [];
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Contact: " + this.contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function (description) {
            if (!_this.session) {
                throw new Error("Session undefined.");
            }
            var delegate = {
                onAccept: function (response) {
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        _this.logger.error("Received reinvite response, but in STATUS_TERMINATED");
                        // TODO: Do we need to send a SIP response?
                        return;
                    }
                    if (!_this.pendingReinvite) {
                        _this.logger.error("Received reinvite response, but have no pending reinvite");
                        // TODO: Do we need to send a SIP response?
                        return;
                    }
                    // FIXME: Why is this set here?
                    _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    // 17.1.1.1 - For each final response that is received at the client transaction,
                    // the client transaction sends an ACK,
                    _this.emit("ack", response.ack());
                    _this.pendingReinvite = false;
                    // TODO: All of these timers should move into the Transaction layer
                    clearTimeout(_this.timers.invite2xxTimer);
                    if (!_this.sessionDescriptionHandler ||
                        !_this.sessionDescriptionHandler.hasDescription(response.message.getHeader("Content-Type") || "")) {
                        _this.logger.error("2XX response received to re-invite but did not have a description");
                        _this.emit("reinviteFailed", _this);
                        _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("2XX response received to re-invite but did not have a description"));
                        return;
                    }
                    _this.sessionDescriptionHandler
                        .setDescription(response.message.body, _this.sessionDescriptionHandlerOptions, _this.modifiers)
                        .catch(function (e) {
                        _this.logger.error("Could not set the description in 2XX response");
                        _this.logger.error(e);
                        _this.emit("reinviteFailed", _this);
                        _this.emit("renegotiationError", e);
                        _this.sendRequest(Constants_1.C.BYE, {
                            extraHeaders: ["Reason: " + Utils_1.Utils.getReasonHeaderValue(488, "Not Acceptable Here")]
                        });
                        _this.terminated(undefined, Constants_1.C.causes.INCOMPATIBLE_SDP);
                        throw e;
                    })
                        .then(function () {
                        _this.emit("reinviteAccepted", _this);
                    });
                },
                onProgress: function (response) {
                    return;
                },
                onRedirect: function (response) {
                    // FIXME: Does ACK need to be sent?
                    _this.pendingReinvite = false;
                    _this.logger.log("Received a non 1XX or 2XX response to a re-invite");
                    _this.emit("reinviteFailed", _this);
                    _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("Invalid response to a re-invite"));
                },
                onReject: function (response) {
                    // FIXME: Does ACK need to be sent?
                    _this.pendingReinvite = false;
                    _this.logger.log("Received a non 1XX or 2XX response to a re-invite");
                    _this.emit("reinviteFailed", _this);
                    _this.emit("renegotiationError", new Exceptions_1.Exceptions.RenegotiationError("Invalid response to a re-invite"));
                },
                onTrying: function (response) {
                    return;
                }
            };
            var requestOptions = {
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(description)
            };
            _this.session.invite(delegate, requestOptions);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.RenegotiationError) {
                _this.pendingReinvite = false;
                _this.emit("renegotiationError", e);
                _this.logger.warn("Renegotiation Error");
                _this.logger.warn(e.toString());
                throw e;
            }
            _this.logger.error("sessionDescriptionHandler error");
            _this.logger.error(e);
            throw e;
        });
    };
    Session.prototype.failed = function (response, cause) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.emit("failed", response, cause);
        return this;
    };
    Session.prototype.rejected = function (response, cause) {
        this.emit("rejected", response, cause);
        return this;
    };
    Session.prototype.canceled = function () {
        if (this.sessionDescriptionHandler) {
            this.sessionDescriptionHandler.close();
        }
        this.emit("cancel");
        return this;
    };
    Session.prototype.accepted = function (response, cause) {
        if (!(response instanceof String)) {
            cause = Utils_1.Utils.getReasonPhrase((response && response.statusCode) || 0, cause);
        }
        this.startTime = new Date();
        if (this.replacee) {
            this.replacee.emit("replaced", this);
            this.replacee.terminate();
        }
        this.emit("accepted", response, cause);
        return this;
    };
    Session.prototype.terminated = function (message, cause) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        this.endTime = new Date();
        this.close();
        this.emit("terminated", message, cause);
        return this;
    };
    Session.prototype.connecting = function (request) {
        this.emit("connecting", { request: request });
        return this;
    };
    Session.C = Enums_1.SessionStatus;
    return Session;
}(events_1.EventEmitter));
exports.Session = Session;
// tslint:disable-next-line:max-classes-per-file
var InviteServerContext = /** @class */ (function (_super) {
    tslib_1.__extends(InviteServerContext, _super);
    function InviteServerContext(ua, incomingInviteRequest) {
        var _this = this;
        if (!ua.configuration.sessionDescriptionHandlerFactory) {
            ua.logger.warn("Can't build ISC without SDH Factory");
            throw new Error("ISC Constructor Failed");
        }
        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
        _this._canceled = false;
        _this.rseq = Math.floor(Math.random() * 10000);
        _this.incomingRequest = incomingInviteRequest;
        var request = incomingInviteRequest.message;
        ServerContext_1.ServerContext.initializer(_this, ua, incomingInviteRequest);
        _this.type = Enums_1.TypeStrings.InviteServerContext;
        var contentDisp = request.parseHeader("Content-Disposition");
        if (contentDisp && contentDisp.type === "render") {
            _this.renderbody = request.body;
            _this.rendertype = request.getHeader("Content-Type");
        }
        _this.status = Enums_1.SessionStatus.STATUS_INVITE_RECEIVED;
        _this.fromTag = request.fromTag;
        _this.id = request.callId + _this.fromTag;
        _this.request = request;
        _this.contact = _this.ua.contact.toString();
        _this.logger = ua.getLogger("sip.inviteservercontext", _this.id);
        // Save the session into the ua sessions collection.
        _this.ua.sessions[_this.id] = _this;
        // Set 100rel if necessary
        var set100rel = function (header, relSetting) {
            if (request.hasHeader(header) && request.getHeader(header).toLowerCase().indexOf("100rel") >= 0) {
                _this.rel100 = relSetting;
            }
        };
        set100rel("require", Constants_1.C.supported.REQUIRED);
        set100rel("supported", Constants_1.C.supported.SUPPORTED);
        // Set the toTag on the incoming request to the toTag which
        // will be used in the response to the incoming request!!!
        // FIXME: HACK: This is a hack to port an existing behavior.
        // The behavior being ported appears to be a hack itself,
        // so this is a hack to port a hack. At least one test spec
        // relies on it (which is yet another hack).
        _this.request.toTag = incomingInviteRequest.toTag;
        _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
        // Set userNoAnswerTimer
        _this.timers.userNoAnswerTimer = setTimeout(function () {
            incomingInviteRequest.reject({ statusCode: 408 });
            _this.failed(request, Constants_1.C.causes.NO_ANSWER);
            _this.terminated(request, Constants_1.C.causes.NO_ANSWER);
        }, _this.ua.configuration.noAnswerTimeout || 60);
        /* Set expiresTimer
        * RFC3261 13.3.1
        */
        // Get the Expires header value if exists
        if (request.hasHeader("expires")) {
            var expires = Number(request.getHeader("expires") || 0) * 1000;
            _this.timers.expiresTimer = setTimeout(function () {
                if (_this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
                    incomingInviteRequest.reject({ statusCode: 487 });
                    _this.failed(request, Constants_1.C.causes.EXPIRES);
                    _this.terminated(request, Constants_1.C.causes.EXPIRES);
                }
            }, expires);
        }
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    Object.defineProperty(InviteServerContext.prototype, "autoSendAnInitialProvisionalResponse", {
        /**
         * If true, a first provisional response after the 100 Trying
         * will be sent automatically. This is false it the UAC required
         * reliable provisional responses (100rel in Require header),
         * otherwise it is true. The provisional is sent by calling
         * `progress()` without any options.
         *
         * FIXME: TODO: It seems reasonable that the ISC user should
         * be able to optionally disable this behavior. As the provisional
         * is sent prior to the "invite" event being emitted, it's a known
         * issue that the ISC user cannot register listeners or do any other
         * setup prior to the call to `progress()`. As an example why this is
         * an issue, setting `ua.configuration.rel100` to REQUIRED will result
         * in an attempt by `progress()` to send a 183 with SDP produced by
         * calling `getDescription()` on a session description handler, but
         * the ISC user cannot perform any potentially required session description
         * handler initialization (thus preventing the utilization of setting
         * `ua.configuration.rel100` to REQUIRED). That begs the question of
         * why this behavior is disabled when the UAC requires 100rel but not
         * when the UAS requires 100rel? But ignoring that, it's just one example
         * of a class of cases where the ISC user needs to do something prior
         * to the first call to `progress()` and is unable to do so.
         */
        get: function () {
            return this.rel100 === Constants_1.C.supported.REQUIRED ? false : true;
        },
        enumerable: true,
        configurable: true
    });
    // type hack for servercontext interface
    InviteServerContext.prototype.reply = function (options) {
        if (options === void 0) { options = {}; }
        return this;
    };
    // typing note: this was the only function using its super in ServerContext
    // so the bottom half of this function is copied and paired down from that
    InviteServerContext.prototype.reject = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        this.logger.log("rejecting RTCSession");
        var statusCode = options.statusCode || 480;
        var reasonPhrase = Utils_1.Utils.getReasonPhrase(statusCode, options.reasonPhrase);
        var extraHeaders = options.extraHeaders || [];
        if (statusCode < 300 || statusCode > 699) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        // FIXME: Need to redirect to someplae
        var response = statusCode < 400 ?
            this.incomingRequest.redirect([], { statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }) :
            this.incomingRequest.reject({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
        (["rejected", "failed"]).forEach(function (event) {
            _this.emit(event, response.message, reasonPhrase);
        });
        return this.terminated();
    };
    /**
     * Accept the incoming INVITE request to start a Session.
     * Replies to the INVITE request with a 200 Ok response.
     * @param options Options bucket.
     */
    InviteServerContext.prototype.accept = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // FIXME: Need guard against calling more than once.
        this._accept(options)
            .then(function (_a) {
            var message = _a.message, session = _a.session;
            session.delegate = {
                onAck: function (ackRequest) { return _this.onAck(ackRequest); },
                onAckTimeout: function () { return _this.onAckTimeout(); },
                onBye: function (byeRequest) { return _this.receiveRequest(byeRequest); },
                onInfo: function (infoRequest) { return _this.receiveRequest(infoRequest); },
                onInvite: function (inviteRequest) { return _this.receiveRequest(inviteRequest); },
                onMessage: function (messageRequest) { return _this.receiveRequest(messageRequest); },
                onNotify: function (notifyRequest) { return _this.receiveRequest(notifyRequest); },
                onPrack: function (prackRequest) { return _this.receiveRequest(prackRequest); },
                onRefer: function (referRequest) { return _this.receiveRequest(referRequest); },
            };
            _this.session = session;
            _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK;
            _this.accepted(message, Utils_1.Utils.getReasonPhrase(200));
        })
            .catch(function (error) {
            _this.onContextError(error);
            // FIXME: Assuming error due to async race on CANCEL and eating error.
            if (!_this._canceled) {
                throw error;
            }
        });
        return this;
    };
    /**
     * Report progress to the the caller.
     * Replies to the INVITE request with a 1xx provisional response.
     * @param options Options bucket.
     */
    InviteServerContext.prototype.progress = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Ported
        var statusCode = options.statusCode || 180;
        if (statusCode < 100 || statusCode > 199) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        // Ported
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            this.logger.warn("Unexpected call for progress while terminated, ignoring");
            return this;
        }
        // Added
        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED) {
            this.logger.warn("Unexpected call for progress while answered, ignoring");
            return this;
        }
        // Added
        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
            this.logger.warn("Unexpected call for progress while answered (waiting for prack), ignoring");
            return this;
        }
        // After the first reliable provisional response for a request has been
        // acknowledged, the UAS MAY send additional reliable provisional
        // responses.  The UAS MUST NOT send a second reliable provisional
        // response until the first is acknowledged.  After the first, it is
        // RECOMMENDED that the UAS not send an additional reliable provisional
        // response until the previous is acknowledged.  The first reliable
        // provisional response receives special treatment because it conveys
        // the initial sequence number.  If additional reliable provisional
        // responses were sent before the first was acknowledged, the UAS could
        // not be certain these were received in order.
        // https://tools.ietf.org/html/rfc3262#section-3
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
            this.logger.warn("Unexpected call for progress while waiting for prack, ignoring");
            return this;
        }
        // Ported
        if (options.statusCode === 100) {
            try {
                this.incomingRequest.trying();
            }
            catch (error) {
                this.onContextError(error);
                // FIXME: Assuming error due to async race on CANCEL and eating error.
                if (!this._canceled) {
                    throw error;
                }
            }
            return this;
        }
        // Standard provisional response.
        if (!(this.rel100 === Constants_1.C.supported.REQUIRED) &&
            !(this.rel100 === Constants_1.C.supported.SUPPORTED && options.rel100) &&
            !(this.rel100 === Constants_1.C.supported.SUPPORTED && this.ua.configuration.rel100 === Constants_1.C.supported.REQUIRED)) {
            this._progress(options)
                .catch(function (error) {
                _this.onContextError(error);
                // FIXME: Assuming error due to async race on CANCEL and eating error.
                if (!_this._canceled) {
                    throw error;
                }
            });
            return this;
        }
        // Reliable provisional response.
        this._reliableProgressWaitForPrack(options)
            .catch(function (error) {
            _this.onContextError(error);
            // FIXME: Assuming error due to async race on CANCEL and eating error.
            if (!_this._canceled) {
                throw error;
            }
        });
        return this;
    };
    /**
     * Reject an unaccepted incoming INVITE request or send BYE if established session.
     * @param options Options bucket. FIXME: This options bucket needs to be typed.
     */
    InviteServerContext.prototype.terminate = function (options) {
        // The caller's UA MAY send a BYE for either confirmed or early dialogs,
        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
        // BYE on a confirmed dialog until it has received an ACK for its 2xx
        // response or until the server transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        var _this = this;
        if (options === void 0) { options = {}; }
        // We don't yet have a dialog, so reject request.
        if (!this.session) {
            this.reject(options);
            return this;
        }
        switch (this.session.sessionState) {
            case core_1.SessionState.Initial:
                this.reject(options);
                return this;
            case core_1.SessionState.Early:
                this.reject(options);
                return this;
            case core_1.SessionState.AckWait:
                this.session.delegate = {
                    // When ACK shows up, say BYE.
                    onAck: function () {
                        _this.sendRequest(Constants_1.C.BYE, options);
                    },
                    // Or the server transaction times out before the ACK arrives.
                    onAckTimeout: function () {
                        _this.sendRequest(Constants_1.C.BYE, options);
                    }
                };
                // Ported
                this.emit("bye", this.request);
                this.terminated();
                return this;
            case core_1.SessionState.Confirmed:
                this.bye(options);
                return this;
            case core_1.SessionState.Terminated:
                return this;
            default:
                return this;
        }
    };
    InviteServerContext.prototype.onCancel = function (message) {
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER ||
            this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK ||
            this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK ||
            this.status === Enums_1.SessionStatus.STATUS_EARLY_MEDIA ||
            this.status === Enums_1.SessionStatus.STATUS_ANSWERED) {
            this.status = Enums_1.SessionStatus.STATUS_CANCELED;
            this.incomingRequest.reject({ statusCode: 487 });
            this.canceled();
            this.rejected(message, Constants_1.C.causes.CANCELED);
            this.failed(message, Constants_1.C.causes.CANCELED);
            this.terminated(message, Constants_1.C.causes.CANCELED);
        }
    };
    InviteServerContext.prototype.receiveRequest = function (incomingRequest) {
        var _this = this;
        switch (incomingRequest.message.method) {
            case Constants_1.C.PRACK:
                if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK ||
                    this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                    if (!this.hasAnswer) {
                        this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
                        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
                        if (this.sessionDescriptionHandler.hasDescription(incomingRequest.message.getHeader("Content-Type") || "")) {
                            this.hasAnswer = true;
                            this.sessionDescriptionHandler.setDescription(incomingRequest.message.body, this.sessionDescriptionHandlerOptions, this.modifiers).then(function () {
                                clearTimeout(_this.timers.rel1xxTimer);
                                clearTimeout(_this.timers.prackTimer);
                                incomingRequest.accept();
                                if (_this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                                    _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                                    _this.accept();
                                }
                                _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                            }, function (e) {
                                _this.logger.warn(e);
                                _this.terminate({
                                    statusCode: "488",
                                    reasonPhrase: "Bad Media Description"
                                });
                                _this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                                _this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                            });
                        }
                        else {
                            this.terminate({
                                statusCode: "488",
                                reasonPhrase: "Bad Media Description"
                            });
                            this.failed(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                            this.terminated(incomingRequest.message, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                        }
                    }
                    else {
                        clearTimeout(this.timers.rel1xxTimer);
                        clearTimeout(this.timers.prackTimer);
                        incomingRequest.accept();
                        if (this.status === Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK) {
                            this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                            this.accept();
                        }
                        this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                    }
                }
                else if (this.status === Enums_1.SessionStatus.STATUS_EARLY_MEDIA) {
                    incomingRequest.accept();
                }
                break;
            default:
                _super.prototype.receiveRequest.call(this, incomingRequest);
                break;
        }
    };
    // Internal Function to setup the handler consistently
    InviteServerContext.prototype.setupSessionDescriptionHandler = function () {
        if (this.sessionDescriptionHandler) {
            return this.sessionDescriptionHandler;
        }
        return this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions);
    };
    InviteServerContext.prototype.generateResponseOfferAnswer = function (options) {
        if (!this.session) {
            var body = core_1.getBody(this.incomingRequest.message);
            if (!body || body.contentDisposition !== "session") {
                return this.getOffer(options);
            }
            else {
                return this.setOfferAndGetAnswer(body, options);
            }
        }
        else {
            switch (this.session.signalingState) {
                case core_1.SignalingState.Initial:
                    return this.getOffer(options);
                case core_1.SignalingState.Stable:
                    return Promise.resolve(undefined);
                case core_1.SignalingState.HaveLocalOffer:
                    // o  Once the UAS has sent or received an answer to the initial
                    // offer, it MUST NOT generate subsequent offers in any responses
                    // to the initial INVITE.  This means that a UAS based on this
                    // specification alone can never generate subsequent offers until
                    // completion of the initial transaction.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    return Promise.resolve(undefined);
                case core_1.SignalingState.HaveRemoteOffer:
                    if (!this.session.offer) {
                        throw new Error("Session offer undefined");
                    }
                    return this.setOfferAndGetAnswer(this.session.offer, options);
                case core_1.SignalingState.Closed:
                    throw new Error("Invalid signaling state " + this.session.signalingState + ".");
                default:
                    throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            }
        }
    };
    InviteServerContext.prototype.handlePrackOfferAnswer = function (request, options) {
        if (!this.session) {
            throw new Error("Session undefined.");
        }
        // If the PRACK doesn't have an offer/answer, nothing to be done.
        var body = core_1.getBody(request.message);
        if (!body || body.contentDisposition !== "session") {
            return Promise.resolve(undefined);
        }
        // If the UAC receives a reliable provisional response with an offer
        // (this would occur if the UAC sent an INVITE without an offer, in
        // which case the first reliable provisional response will contain the
        // offer), it MUST generate an answer in the PRACK.  If the UAC receives
        // a reliable provisional response with an answer, it MAY generate an
        // additional offer in the PRACK.  If the UAS receives a PRACK with an
        // offer, it MUST place the answer in the 2xx to the PRACK.
        // https://tools.ietf.org/html/rfc3262#section-5
        switch (this.session.signalingState) {
            case core_1.SignalingState.Initial:
                // State should never be reached as first reliable provisional response must have answer/offer.
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            case core_1.SignalingState.Stable:
                // Receved answer.
                return this.setAnswer(body, options).then(function () { return undefined; });
            case core_1.SignalingState.HaveLocalOffer:
                // State should never be reached as local offer would be answered by this PRACK
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            case core_1.SignalingState.HaveRemoteOffer:
                // Receved offer, generate answer.
                return this.setOfferAndGetAnswer(body, options);
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + this.session.signalingState + ".");
        }
    };
    /**
     * Called when session canceled.
     */
    InviteServerContext.prototype.canceled = function () {
        this._canceled = true;
        return _super.prototype.canceled.call(this);
    };
    /**
     * Called when session terminated.
     * Using it here just for the PRACK timeout.
     */
    InviteServerContext.prototype.terminated = function (message, cause) {
        this.prackNeverArrived();
        return _super.prototype.terminated.call(this, message, cause);
    };
    /**
     * A version of `accept` which resolves a session when the 200 Ok response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `accept()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._accept = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // FIXME: Ported - callback for in dialog INFO requests.
        // Turns out accept() can be called more than once if we are waiting
        // for a PRACK in which case "options" get completely tossed away.
        // So this is broken in that case (and potentially other uses of options).
        // Tempted to just try to fix it now, but leaving it broken for the moment.
        this.onInfo = options.onInfo;
        // The UAS MAY send a final response to the initial request before
        // having received PRACKs for all unacknowledged reliable provisional
        // responses, unless the final response is 2xx and any of the
        // unacknowledged reliable provisional responses contained a session
        // description.  In that case, it MUST NOT send a final response until
        // those provisional responses are acknowledged.  If the UAS does send a
        // final response when reliable responses are still unacknowledged, it
        // SHOULD NOT continue to retransmit the unacknowledged reliable
        // provisional responses, but it MUST be prepared to process PRACK
        // requests for those outstanding responses.  A UAS MUST NOT send new
        // reliable provisional responses (as opposed to retransmissions of
        // unacknowledged ones) after sending a final response to a request.
        // https://tools.ietf.org/html/rfc3262#section-3
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED_WAITING_FOR_PRACK;
            return this.waitForArrivalOfPrack()
                .then(function () {
                _this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
                clearTimeout(_this.timers.userNoAnswerTimer); // Ported
            })
                .then(function () { return _this.generateResponseOfferAnswer(options); })
                .then(function (body) { return _this.incomingRequest.accept({ statusCode: 200, body: body }); });
        }
        // Ported
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER) {
            this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        }
        else {
            return Promise.reject(new Exceptions_1.Exceptions.InvalidStateError(this.status));
        }
        this.status = Enums_1.SessionStatus.STATUS_ANSWERED;
        clearTimeout(this.timers.userNoAnswerTimer); // Ported
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.accept({ statusCode: 200, body: body }); });
    };
    /**
     * A version of `progress` which resolves when the provisional response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._progress = function (options) {
        if (options === void 0) { options = {}; }
        // Ported
        var statusCode = options.statusCode || 180;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        var body = options.body ? core_1.fromBodyLegacy(options.body) : undefined;
        // The 183 (Session Progress) response is used to convey information
        // about the progress of the call that is not otherwise classified.  The
        // Reason-Phrase, header fields, or message body MAY be used to convey
        // more details about the call progress.
        // https://tools.ietf.org/html/rfc3261#section-21.1.5
        // It is the de facto industry standard to utilize 183 with SDP to provide "early media".
        // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.
        if (statusCode === 183 && !body) {
            return this._progressWithSDP(options);
        }
        try {
            var progressResponse = this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
            this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            this.session = progressResponse.session;
            return Promise.resolve(progressResponse);
        }
        catch (error) {
            return Promise.reject(error);
        }
    };
    /**
     * A version of `progress` which resolves when the provisional response with sdp is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._progressWithSDP = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        // Get an offer/answer and send a reply.
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }); })
            .then(function (progressResponse) {
            _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            _this.session = progressResponse.session;
            return progressResponse;
        });
    };
    /**
     * A version of `progress` which resolves when the reliable provisional response is sent.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._reliableProgress = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Require: 100rel");
        extraHeaders.push("RSeq: " + Math.floor(Math.random() * 10000));
        // Get an offer/answer and send a reply.
        return this.generateResponseOfferAnswer(options)
            .then(function (body) { return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body }); })
            .then(function (progressResponse) {
            _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
            _this.session = progressResponse.session;
            return progressResponse;
        });
    };
    /**
     * A version of `progress` which resolves when the reliable provisional response is acknowledged.
     * @param options Options bucket.
     * @throws {ClosedSessionDescriptionHandlerError} The session description handler closed before method completed.
     * @throws {TransactionStateError} The transaction state does not allow for `progress()` to be called.
     *                                 Note that the transaction state can change while this call is in progress.
     */
    InviteServerContext.prototype._reliableProgressWaitForPrack = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var statusCode = options.statusCode || 183;
        var reasonPhrase = options.reasonPhrase;
        var extraHeaders = (options.extraHeaders || []).slice();
        extraHeaders.push("Require: 100rel");
        extraHeaders.push("RSeq: " + this.rseq++);
        var body;
        // Ported - set status.
        this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK;
        return new Promise(function (resolve, reject) {
            var waitingForPrack = true;
            return _this.generateResponseOfferAnswer(options)
                .then(function (offerAnswer) {
                body = offerAnswer;
                return _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
            })
                .then(function (progressResponse) {
                _this.emit("progress", progressResponse.message, reasonPhrase); // Ported
                _this.session = progressResponse.session;
                var prackRequest;
                var prackResponse;
                progressResponse.session.delegate = {
                    onPrack: function (request) {
                        prackRequest = request;
                        clearTimeout(prackWaitTimeoutTimer);
                        clearTimeout(rel1xxRetransmissionTimer);
                        if (!waitingForPrack) {
                            return;
                        }
                        waitingForPrack = false;
                        _this.handlePrackOfferAnswer(prackRequest, options)
                            .then(function (prackResponseBody) {
                            try {
                                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });
                                // Ported - set status.
                                if (_this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_PRACK) {
                                    _this.status = Enums_1.SessionStatus.STATUS_WAITING_FOR_ANSWER;
                                }
                                _this.prackArrived();
                                resolve({ prackRequest: prackRequest, prackResponse: prackResponse, progressResponse: progressResponse });
                            }
                            catch (error) {
                                reject(error);
                            }
                        });
                    }
                };
                // https://tools.ietf.org/html/rfc3262#section-3
                var prackWaitTimeout = function () {
                    if (!waitingForPrack) {
                        return;
                    }
                    waitingForPrack = false;
                    _this.logger.warn("No PRACK received, rejecting INVITE.");
                    clearTimeout(rel1xxRetransmissionTimer);
                    try {
                        _this.incomingRequest.reject({ statusCode: 504 });
                        _this.terminated(undefined, Constants_1.C.causes.NO_PRACK);
                        reject(new Exceptions_1.Exceptions.TerminatedSessionError());
                    }
                    catch (error) {
                        reject(error);
                    }
                };
                var prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, core_1.Timers.T1 * 64);
                // https://tools.ietf.org/html/rfc3262#section-3
                var rel1xxRetransmission = function () {
                    try {
                        _this.incomingRequest.progress({ statusCode: statusCode, reasonPhrase: reasonPhrase, extraHeaders: extraHeaders, body: body });
                    }
                    catch (error) {
                        waitingForPrack = false;
                        reject(error);
                        return;
                    }
                    rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);
                };
                var timeout = core_1.Timers.T1;
                var rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);
            });
        });
    };
    /**
     * Callback for when ACK for a 2xx response is never received.
     * @param session Session the ACK never arrived for
     */
    InviteServerContext.prototype.onAckTimeout = function () {
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            this.logger.log("no ACK received for an extended period of time, terminating the call");
            if (!this.session) {
                throw new Error("Session undefined.");
            }
            this.session.bye();
            this.terminated(undefined, Constants_1.C.causes.NO_ACK);
        }
    };
    /**
     * FIXME: TODO: The current library interface presents async methods without a
     * proper async error handling mechanism. Arguably a promise based interface
     * would be an improvement over the pattern of returning `this`. The approach has
     * been generally along the lines of log a error and terminate.
     */
    InviteServerContext.prototype.onContextError = function (error) {
        var statusCode = 480;
        if (error instanceof core_1.Exception) { // There might be interest in catching these Exceptions.
            if (error instanceof Exceptions_1.Exceptions.SessionDescriptionHandlerError) {
                this.logger.error(error.message);
                if (error.error) {
                    this.logger.error(error.error);
                }
            }
            else if (error instanceof Exceptions_1.Exceptions.TerminatedSessionError) {
                // PRACK never arrived, so we timed out waiting for it.
                this.logger.warn("Incoming session terminated while waiting for PRACK.");
            }
            else if (error instanceof Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError) {
                statusCode = 415;
            }
            else if (error instanceof core_1.Exception) {
                this.logger.error(error.message);
            }
        }
        else if (error instanceof Error) { // Other Errors hould go uncaught.
            this.logger.error(error.message);
        }
        else {
            // We don't actually know what a session description handler implementation might throw
            // our way, so as a last resort, just assume we are getting an "any" and log it.
            this.logger.error("An error occurred in the session description handler.");
            this.logger.error(error);
        }
        try {
            this.incomingRequest.reject({ statusCode: statusCode }); // "Temporarily Unavailable"
            this.failed(this.incomingRequest.message, error.message);
            this.terminated(this.incomingRequest.message, error.message);
        }
        catch (error) {
            return;
        }
    };
    InviteServerContext.prototype.prackArrived = function () {
        if (this.waitingForPrackResolve) {
            this.waitingForPrackResolve();
        }
        this.waitingForPrackPromise = undefined;
        this.waitingForPrackResolve = undefined;
        this.waitingForPrackReject = undefined;
    };
    InviteServerContext.prototype.prackNeverArrived = function () {
        if (this.waitingForPrackReject) {
            this.waitingForPrackReject(new Exceptions_1.Exceptions.TerminatedSessionError());
        }
        this.waitingForPrackPromise = undefined;
        this.waitingForPrackResolve = undefined;
        this.waitingForPrackReject = undefined;
    };
    /**
     * @throws {Exceptions.TerminatedSessionError} The session terminated before being accepted (i.e. cancel arrived).
     */
    InviteServerContext.prototype.waitForArrivalOfPrack = function () {
        var _this = this;
        if (this.waitingForPrackPromise) {
            throw new Error("Already waiting for PRACK");
        }
        this.waitingForPrackPromise = new Promise(function (resolve, reject) {
            _this.waitingForPrackResolve = resolve;
            _this.waitingForPrackReject = reject;
        });
        return this.waitingForPrackPromise;
    };
    InviteServerContext.prototype.getOffer = function (options) {
        this.hasOffer = true;
        var sdh = this.getSessionDescriptionHandler();
        return sdh
            .getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function (bodyObj) { return Utils_1.Utils.fromBodyObj(bodyObj); });
    };
    InviteServerContext.prototype.setAnswer = function (answer, options) {
        this.hasAnswer = true;
        var sdh = this.getSessionDescriptionHandler();
        if (!sdh.hasDescription(answer.contentType)) {
            return Promise.reject(new Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError());
        }
        return sdh
            .setDescription(answer.content, options.sessionDescriptionHandlerOptions, options.modifiers);
    };
    InviteServerContext.prototype.setOfferAndGetAnswer = function (offer, options) {
        this.hasOffer = true;
        this.hasAnswer = true;
        var sdh = this.getSessionDescriptionHandler();
        if (!sdh.hasDescription(offer.contentType)) {
            return Promise.reject(new Exceptions_1.Exceptions.UnsupportedSessionDescriptionContentTypeError());
        }
        return sdh
            .setDescription(offer.content, options.sessionDescriptionHandlerOptions, options.modifiers)
            .then(function () { return sdh.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers); })
            .then(function (bodyObj) { return Utils_1.Utils.fromBodyObj(bodyObj); });
    };
    InviteServerContext.prototype.getSessionDescriptionHandler = function () {
        // Create our session description handler if not already done so...
        var sdh = this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();
        // FIXME: Ported - this can get emitted multiple times even when only created once... don't we care?
        this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
        // Return.
        return sdh;
    };
    return InviteServerContext;
}(Session));
exports.InviteServerContext = InviteServerContext;
// tslint:disable-next-line:max-classes-per-file
var InviteClientContext = /** @class */ (function (_super) {
    tslib_1.__extends(InviteClientContext, _super);
    function InviteClientContext(ua, target, options, modifiers) {
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        var _this = this;
        if (!ua.configuration.sessionDescriptionHandlerFactory) {
            ua.logger.warn("Can't build ISC without SDH Factory");
            throw new Error("ICC Constructor Failed");
        }
        options.params = options.params || {};
        var anonymous = options.anonymous || false;
        var fromTag = Utils_1.Utils.newTag();
        options.params.fromTag = fromTag;
        /* Do not add ;ob in initial forming dialog requests if the registration over
        *  the current connection got a GRUU URI.
        */
        var contact = ua.contact.toString({
            anonymous: anonymous,
            outbound: anonymous ? !ua.contact.tempGruu : !ua.contact.pubGruu
        });
        var extraHeaders = (options.extraHeaders || []).slice();
        if (anonymous && ua.configuration.uri) {
            options.params.fromDisplayName = "Anonymous";
            options.params.fromUri = "sip:anonymous@anonymous.invalid";
            extraHeaders.push("P-Preferred-Identity: " + ua.configuration.uri.toString());
            extraHeaders.push("Privacy: id");
        }
        extraHeaders.push("Contact: " + contact);
        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        if (ua.configuration.rel100 === Constants_1.C.supported.REQUIRED) {
            extraHeaders.push("Require: 100rel");
        }
        if (ua.configuration.replaces === Constants_1.C.supported.REQUIRED) {
            extraHeaders.push("Require: replaces");
        }
        options.extraHeaders = extraHeaders;
        _this = _super.call(this, ua.configuration.sessionDescriptionHandlerFactory) || this;
        ClientContext_1.ClientContext.initializer(_this, ua, Constants_1.C.INVITE, target, options);
        _this.earlyMediaSessionDescriptionHandlers = new Map();
        _this.type = Enums_1.TypeStrings.InviteClientContext;
        _this.passedOptions = options; // Save for later to use with refer
        _this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions || {};
        _this.modifiers = modifiers;
        _this.inviteWithoutSdp = options.inviteWithoutSdp || false;
        // Set anonymous property
        _this.anonymous = options.anonymous || false;
        // Custom data to be sent either in INVITE or in ACK
        _this.renderbody = options.renderbody || undefined;
        _this.rendertype = options.rendertype || "text/plain";
        // Session parameter initialization
        _this.fromTag = fromTag;
        _this.contact = contact;
        // Check Session Status
        if (_this.status !== Enums_1.SessionStatus.STATUS_NULL) {
            throw new Exceptions_1.Exceptions.InvalidStateError(_this.status);
        }
        // OutgoingSession specific parameters
        _this.isCanceled = false;
        _this.received100 = false;
        _this.method = Constants_1.C.INVITE;
        _this.logger = ua.getLogger("sip.inviteclientcontext");
        ua.applicants[_this.toString()] = _this;
        _this.id = _this.request.callId + _this.fromTag;
        _this.onInfo = options.onInfo;
        _this.errorListener = _this.onTransportError.bind(_this);
        if (ua.transport) {
            ua.transport.on("transportError", _this.errorListener);
        }
        return _this;
    }
    InviteClientContext.prototype.receiveResponse = function (response) {
        throw new Error("Unimplemented.");
    };
    // hack for getting around ClientContext interface
    InviteClientContext.prototype.send = function () {
        this.sendInvite();
        return this;
    };
    InviteClientContext.prototype.invite = function () {
        var _this = this;
        // Save the session into the ua sessions collection.
        // Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway
        this.ua.sessions[this.id] = this;
        // This should allow the function to return so that listeners can be set up for these events
        Promise.resolve().then(function () {
            // FIXME: There is a race condition where cancel (or terminate) can be called synchronously after invite.
            if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                return;
            }
            if (_this.inviteWithoutSdp) {
                // just send an invite with no sdp...
                if (_this.renderbody && _this.rendertype) {
                    _this.request.body = {
                        body: _this.renderbody,
                        contentType: _this.rendertype
                    };
                }
                _this.status = Enums_1.SessionStatus.STATUS_INVITE_SENT;
                _this.send();
            }
            else {
                // Initialize Media Session
                _this.sessionDescriptionHandler = _this.sessionDescriptionHandlerFactory(_this, _this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
                _this.emit("SessionDescriptionHandler-created", _this.sessionDescriptionHandler);
                _this.sessionDescriptionHandler.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers)
                    .then(function (description) {
                    // FIXME: There is a race condition where cancel (or terminate) can be called (a)synchronously after invite.
                    if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.hasOffer = true;
                    _this.request.body = description;
                    _this.status = Enums_1.SessionStatus.STATUS_INVITE_SENT;
                    _this.send();
                }, function (err) {
                    if (err.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                        _this.logger.log(err.message);
                        if (err.error) {
                            _this.logger.log(err.error);
                        }
                    }
                    if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.failed(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                    _this.terminated(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                });
            }
        });
        return this;
    };
    InviteClientContext.prototype.cancel = function (options) {
        if (options === void 0) { options = {}; }
        // Check Session Status
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED || this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.status);
        }
        if (this.isCanceled) {
            throw new Exceptions_1.Exceptions.InvalidStateError(Enums_1.SessionStatus.STATUS_CANCELED);
        }
        this.isCanceled = true;
        this.logger.log("Canceling session");
        var cancelReason = Utils_1.Utils.getCancelReason(options.statusCode, options.reasonPhrase);
        options.extraHeaders = (options.extraHeaders || []).slice();
        if (this.outgoingInviteRequest) {
            this.logger.warn("Canceling session before it was created");
            this.outgoingInviteRequest.cancel(cancelReason, options);
        }
        return this.canceled();
    };
    InviteClientContext.prototype.terminate = function (options) {
        if (this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
            return this;
        }
        if (this.status === Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK || this.status === Enums_1.SessionStatus.STATUS_CONFIRMED) {
            this.bye(options);
        }
        else {
            this.cancel(options);
        }
        return this;
    };
    /**
     * 13.2.1 Creating the Initial INVITE
     *
     * Since the initial INVITE represents a request outside of a dialog,
     * its construction follows the procedures of Section 8.1.1.  Additional
     * processing is required for the specific case of INVITE.
     *
     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.
     * It indicates what methods can be invoked within a dialog, on the UA
     * sending the INVITE, for the duration of the dialog.  For example, a
     * UA capable of receiving INFO requests within a dialog [34] SHOULD
     * include an Allow header field listing the INFO method.
     *
     * A Supported header field (Section 20.37) SHOULD be present in the
     * INVITE.  It enumerates all the extensions understood by the UAC.
     *
     * An Accept (Section 20.1) header field MAY be present in the INVITE.
     * It indicates which Content-Types are acceptable to the UA, in both
     * the response received by it, and in any subsequent requests sent to
     * it within dialogs established by the INVITE.  The Accept header field
     * is especially useful for indicating support of various session
     * description formats.
     *
     * The UAC MAY add an Expires header field (Section 20.19) to limit the
     * validity of the invitation.  If the time indicated in the Expires
     * header field is reached and no final answer for the INVITE has been
     * received, the UAC core SHOULD generate a CANCEL request for the
     * INVITE, as per Section 9.
     *
     * A UAC MAY also find it useful to add, among others, Subject (Section
     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)
     * header fields.  They all contain information related to the INVITE.
     *
     * The UAC MAY choose to add a message body to the INVITE.  Section
     * 8.1.1.10 deals with how to construct the header fields -- Content-
     * Type among others -- needed to describe the message body.
     *
     * https://tools.ietf.org/html/rfc3261#section-13.2.1
     */
    InviteClientContext.prototype.sendInvite = function () {
        //    There are special rules for message bodies that contain a session
        //    description - their corresponding Content-Disposition is "session".
        //    SIP uses an offer/answer model where one UA sends a session
        //    description, called the offer, which contains a proposed description
        //    of the session.  The offer indicates the desired communications means
        //    (audio, video, games), parameters of those means (such as codec
        //    types) and addresses for receiving media from the answerer.  The
        //    other UA responds with another session description, called the
        //    answer, which indicates which communications means are accepted, the
        //    parameters that apply to those means, and addresses for receiving
        //    media from the offerer. An offer/answer exchange is within the
        //    context of a dialog, so that if a SIP INVITE results in multiple
        //    dialogs, each is a separate offer/answer exchange.  The offer/answer
        //    model defines restrictions on when offers and answers can be made
        //    (for example, you cannot make a new offer while one is in progress).
        //    This results in restrictions on where the offers and answers can
        //    appear in SIP messages.  In this specification, offers and answers
        //    can only appear in INVITE requests and responses, and ACK.  The usage
        //    of offers and answers is further restricted.  For the initial INVITE
        //    transaction, the rules are:
        //
        //       o  The initial offer MUST be in either an INVITE or, if not there,
        //          in the first reliable non-failure message from the UAS back to
        //          the UAC.  In this specification, that is the final 2xx
        //          response.
        //
        //       o  If the initial offer is in an INVITE, the answer MUST be in a
        //          reliable non-failure message from UAS back to UAC which is
        //          correlated to that INVITE.  For this specification, that is
        //          only the final 2xx response to that INVITE.  That same exact
        //          answer MAY also be placed in any provisional responses sent
        //          prior to the answer.  The UAC MUST treat the first session
        //          description it receives as the answer, and MUST ignore any
        //          session descriptions in subsequent responses to the initial
        //          INVITE.
        //
        //       o  If the initial offer is in the first reliable non-failure
        //          message from the UAS back to UAC, the answer MUST be in the
        //          acknowledgement for that message (in this specification, ACK
        //          for a 2xx response).
        //
        //       o  After having sent or received an answer to the first offer, the
        //          UAC MAY generate subsequent offers in requests based on rules
        //          specified for that method, but only if it has received answers
        //          to any previous offers, and has not sent any offers to which it
        //          hasn't gotten an answer.
        //
        //       o  Once the UAS has sent or received an answer to the initial
        //          offer, it MUST NOT generate subsequent offers in any responses
        //          to the initial INVITE.  This means that a UAS based on this
        //          specification alone can never generate subsequent offers until
        //          completion of the initial transaction.
        //
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        var _this = this;
        // 5 The Offer/Answer Model and PRACK
        //
        //    RFC 3261 describes guidelines for the sets of messages in which
        //    offers and answers [3] can appear.  Based on those guidelines, this
        //    extension provides additional opportunities for offer/answer
        //    exchanges.
        //    If the INVITE contained an offer, the UAS MAY generate an answer in a
        //    reliable provisional response (assuming these are supported by the
        //    UAC).  That results in the establishment of the session before
        //    completion of the call.  Similarly, if a reliable provisional
        //    response is the first reliable message sent back to the UAC, and the
        //    INVITE did not contain an offer, one MUST appear in that reliable
        //    provisional response.
        //    If the UAC receives a reliable provisional response with an offer
        //    (this would occur if the UAC sent an INVITE without an offer, in
        //    which case the first reliable provisional response will contain the
        //    offer), it MUST generate an answer in the PRACK.  If the UAC receives
        //    a reliable provisional response with an answer, it MAY generate an
        //    additional offer in the PRACK.  If the UAS receives a PRACK with an
        //    offer, it MUST place the answer in the 2xx to the PRACK.
        //    Once an answer has been sent or received, the UA SHOULD establish the
        //    session based on the parameters of the offer and answer, even if the
        //    original INVITE itself has not been responded to.
        //    If the UAS had placed a session description in any reliable
        //    provisional response that is unacknowledged when the INVITE is
        //    accepted, the UAS MUST delay sending the 2xx until the provisional
        //    response is acknowledged.  Otherwise, the reliability of the 1xx
        //    cannot be guaranteed, and reliability is needed for proper operation
        //    of the offer/answer exchange.
        //    All user agents that support this extension MUST support all
        //    offer/answer exchanges that are possible based on the rules in
        //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK
        //    as requests, and 2xx and reliable 1xx as non-failure reliable
        //    responses.
        //
        // https://tools.ietf.org/html/rfc3262#section-5
        ////
        // The Offer/Answer Model Implementation
        //
        // The offer/answer model is straight forward, but one MUST READ the specifications...
        //
        // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // 5 The Offer/Answer Model and PRACK
        // https://tools.ietf.org/html/rfc3262#section-5
        //
        // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model
        // https://tools.ietf.org/html/rfc6337
        //
        // *** IMPORTANT IMPLEMENTATION CHOICES ***
        //
        // TLDR...
        //
        //  1) Only one offer/answer exchange permitted during initial INVITE.
        //  2) No "early media" if the initial offer is in an INVITE.
        //
        //
        // 1) Initial Offer/Answer Restriction.
        //
        // Our implementation replaces the following bullet point...
        //
        // o  After having sent or received an answer to the first offer, the
        //    UAC MAY generate subsequent offers in requests based on rules
        //    specified for that method, but only if it has received answers
        //    to any previous offers, and has not sent any offers to which it
        //    hasn't gotten an answer.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // ...with...
        //
        // o  After having sent or received an answer to the first offer, the
        //    UAC MUST NOT generate subsequent offers in requests based on rules
        //    specified for that method.
        //
        // ...which in combination with this bullet point...
        //
        // o  Once the UAS has sent or received an answer to the initial
        //    offer, it MUST NOT generate subsequent offers in any responses
        //    to the initial INVITE.  This means that a UAS based on this
        //    specification alone can never generate subsequent offers until
        //    completion of the initial transaction.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // ...ensures that EXACTLY ONE offer/answer exchange will occur
        // during an initial out of dialog INVITE request made by our UAC.
        //
        //
        // 2) Early Media Restriction.
        //
        // While our implementation adheres to the following bullet point...
        //
        // o  If the initial offer is in an INVITE, the answer MUST be in a
        //    reliable non-failure message from UAS back to UAC which is
        //    correlated to that INVITE.  For this specification, that is
        //    only the final 2xx response to that INVITE.  That same exact
        //    answer MAY also be placed in any provisional responses sent
        //    prior to the answer.  The UAC MUST treat the first session
        //    description it receives as the answer, and MUST ignore any
        //    session descriptions in subsequent responses to the initial
        //    INVITE.
        // https://tools.ietf.org/html/rfc3261#section-13.2.1
        //
        // We have made the following implementation decision with regard to early media...
        //
        // o  If the initial offer is in the INVITE, the answer from the
        //    UAS back to the UAC will establish a media session only
        //    only after the final 2xx response to that INVITE is received.
        //
        // The reason for this decision is rooted in a restriction currently
        // inherent in WebRTC. Specifically, while a SIP INVITE request with an
        // initial offer may fork resulting in more than one provisional answer,
        // there is currently no easy/good way to to "fork" an offer generated
        // by a peer connection. In particular, a WebRTC offer currently may only
        // be matched with one answer and we have no good way to know which
        // "provisional answer" is going to be the "final answer". So we have
        // decided to punt and not create any "early media" sessions in this case.
        //
        // The upshot is that if you want "early media", you must not put the
        // initial offer in the INVITE. Instead, force the UAS to provide the
        // initial offer by sending an INVITE without an offer. In the WebRTC
        // case this allows us to create a unique peer connection with a unique
        // answer for every provisional offer with "early media" on all of them.
        ////
        ////
        // ROADMAP: The Offer/Answer Model Implementation
        //
        // The "no early media if offer in INVITE" implementation is not a
        // welcome one. The masses want it. The want it and they want it
        // to work for WebRTC (so they want to have their cake and eat too).
        //
        // So while we currently cannot make the offer in INVITE+forking+webrtc
        // case work, we decided to do the following...
        //
        // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...
        // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...
        // 3) ask SDH Factory if it supports "earlyRemoteAnswer"
        //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)
        //   b) if false, defer getting a SDH until 2xx response is received
        //
        // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)
        // early media if initial offer is in the INVITE). We will, however, provide an "inviteWillNotFork"
        // option which if set to "true" will have our supplied WebRTC SDH behave in the 3a manner.
        // That will result in
        //  - early media working with initial offer in the INVITE, and...
        //  - if the INVITE forks, the session terminating with an ERROR that reads like
        //    "You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too."
        //  - furthermore, we accept that users will report that error to us as "bug" regardless
        //
        // So, SDH Factory is going to end up with a new interface along the lines of...
        //
        // interface SessionDescriptionHandlerFactory {
        //   makeLocalOffer(): Promise<ContentTypeAndBody>;
        //   makeSessionDescriptionHandler(
        //     initialOffer: ContentTypeAndBody, offerType: "local" | "remote"
        //   ): Promise<SessionDescriptionHandler>;
        //   supportsEarlyRemoteAnswer: boolean;
        //   supportsContentType(contentType: string): boolean;
        //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>
        //   setDescription(description: ContentTypeAndBody): Promise<void>
        // }
        //
        // We should be able to get rid of all the hasOffer/hasAnswer tracking code and otherwise code
        // it up to the same interaction with the SDH Factory and SDH regardless of signaling scenario.
        ////
        // Send the INVITE request.
        this.outgoingInviteRequest = this.ua.userAgentCore.invite(this.request, {
            onAccept: function (inviteResponse) { return _this.onAccept(inviteResponse); },
            onProgress: function (inviteResponse) { return _this.onProgress(inviteResponse); },
            onRedirect: function (inviteResponse) { return _this.onRedirect(inviteResponse); },
            onReject: function (inviteResponse) { return _this.onReject(inviteResponse); },
            onTrying: function (inviteResponse) { return _this.onTrying(inviteResponse); }
        });
    };
    InviteClientContext.prototype.ackAndBye = function (inviteResponse, session, statusCode, reasonPhrase) {
        if (!this.ua.userAgentCore) {
            throw new Error("Method requires user agent core.");
        }
        var extraHeaders = [];
        if (statusCode) {
            extraHeaders.push("Reason: " + Utils_1.Utils.getReasonHeaderValue(statusCode, reasonPhrase));
        }
        var outgoingAckRequest = inviteResponse.ack();
        this.emit("ack", outgoingAckRequest.message);
        var outgoingByeRequest = session.bye(undefined, { extraHeaders: extraHeaders });
        this.emit("bye", outgoingByeRequest.message);
    };
    InviteClientContext.prototype.disposeEarlyMedia = function () {
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        this.earlyMediaSessionDescriptionHandlers.forEach(function (sessionDescriptionHandler) {
            sessionDescriptionHandler.close();
        });
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 2xx response.
     */
    InviteClientContext.prototype.onAccept = function (inviteResponse) {
        var _this = this;
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        var response = inviteResponse.message;
        var session = inviteResponse.session;
        // Our transaction layer is "non-standard" in that it will only
        // pass us a 2xx response once per branch, so there is no need to
        // worry about dealing with 2xx retransmissions. However, we can
        // and do still get 2xx responses for multiple branches (when an
        // INVITE is forked) which may create multiple confirmed dialogs.
        // Herein we are acking and sending a bye to any confirmed dialogs
        // which arrive beyond the first one. This is the desired behavior
        // for most applications (but certainly not all).
        // If we already received a confirmed dialog, ack & bye this session.
        if (this.session) {
            this.ackAndBye(inviteResponse, session);
            return;
        }
        // If the user requested cancellation, ack & bye this session.
        if (this.isCanceled) {
            this.ackAndBye(inviteResponse, session);
            this.emit("bye", this.request); // FIXME: Ported this odd second "bye" emit
            return;
        }
        // Ported behavior.
        if (response.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
        }
        // We have a confirmed dialog.
        this.session = session;
        this.session.delegate = {
            onAck: function (ackRequest) { return _this.onAck(ackRequest); },
            onBye: function (byeRequest) { return _this.receiveRequest(byeRequest); },
            onInfo: function (infoRequest) { return _this.receiveRequest(infoRequest); },
            onInvite: function (inviteRequest) { return _this.receiveRequest(inviteRequest); },
            onMessage: function (messageRequest) { return _this.receiveRequest(messageRequest); },
            onNotify: function (notifyRequest) { return _this.receiveRequest(notifyRequest); },
            onPrack: function (prackRequest) { return _this.receiveRequest(prackRequest); },
            onRefer: function (referRequest) { return _this.receiveRequest(referRequest); },
        };
        switch (session.signalingState) {
            case core_1.SignalingState.Initial:
                // INVITE without Offer, so MUST have Offer at this point, so invalid state.
                this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                break;
            case core_1.SignalingState.HaveLocalOffer:
                // INVITE with Offer, so MUST have Answer at this point, so invalid state.
                this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                break;
            case core_1.SignalingState.HaveRemoteOffer:
                // INVITE without Offer, received offer in 2xx, so MUST send Answer in ACK.
                var sdh_1 = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
                this.sessionDescriptionHandler = sdh_1;
                this.emit("SessionDescriptionHandler-created", this.sessionDescriptionHandler);
                if (!sdh_1.hasDescription(response.getHeader("Content-Type") || "")) {
                    this.ackAndBye(inviteResponse, session, 400, "Missing session description");
                    this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    break;
                }
                this.hasOffer = true;
                sdh_1
                    .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)
                    .then(function () { return sdh_1.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); })
                    .then(function (description) {
                    if (_this.isCanceled || _this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        return;
                    }
                    _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    _this.hasAnswer = true;
                    var body = {
                        contentDisposition: "session", contentType: description.contentType, content: description.body
                    };
                    var ackRequest = inviteResponse.ack({ body: body });
                    _this.emit("ack", ackRequest.message);
                    _this.accepted(response);
                })
                    .catch(function (e) {
                    if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                        _this.logger.warn("invalid description");
                        _this.logger.warn(e.toString());
                        // TODO: This message is inconsistent
                        _this.ackAndBye(inviteResponse, session, 488, "Invalid session description");
                        _this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                    }
                    else {
                        throw e;
                    }
                });
                break;
            case core_1.SignalingState.Stable:
                // This session has completed an initial offer/answer exchange...
                var options_1;
                if (this.renderbody && this.rendertype) {
                    options_1 = { body: { contentDisposition: "render", contentType: this.rendertype, content: this.renderbody } };
                }
                // If INVITE with Offer and we have been waiting till now to apply the answer.
                if (this.hasOffer && !this.hasAnswer) {
                    if (!this.sessionDescriptionHandler) {
                        throw new Error("Session description handler undefined.");
                    }
                    var answer = session.answer;
                    if (!answer) {
                        throw new Error("Answer is undefined.");
                    }
                    this.sessionDescriptionHandler
                        .setDescription(answer.content, this.sessionDescriptionHandlerOptions, this.modifiers)
                        .then(function () {
                        _this.hasAnswer = true;
                        _this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                        var ackRequest = inviteResponse.ack(options_1);
                        _this.emit("ack", ackRequest.message);
                        _this.accepted(response);
                    })
                        .catch(function (error) {
                        _this.logger.error(error);
                        _this.ackAndBye(inviteResponse, session, 488, "Not Acceptable Here");
                        _this.failed(response, Constants_1.C.causes.BAD_MEDIA_DESCRIPTION);
                        // FIME: DON'T EAT UNHANDLED ERRORS!
                    });
                }
                else {
                    // Otherwise INVITE with or without Offer and we have already completed the initial exchange.
                    this.sessionDescriptionHandler = this.earlyMediaSessionDescriptionHandlers.get(session.id);
                    if (!this.sessionDescriptionHandler) {
                        throw new Error("Session description handler undefined.");
                    }
                    this.earlyMediaSessionDescriptionHandlers.delete(session.id);
                    this.hasOffer = true;
                    this.hasAnswer = true;
                    this.status = Enums_1.SessionStatus.STATUS_CONFIRMED;
                    var ackRequest = inviteResponse.ack();
                    this.emit("ack", ackRequest.message);
                    this.accepted(response);
                }
                break;
            case core_1.SignalingState.Closed:
                // Dialog has terminated.
                break;
            default:
                throw new Error("Unknown session signaling state.");
        }
        this.disposeEarlyMedia();
    };
    /**
     * Handle provisional response to initial INVITE.
     * @param inviteResponse 1xx response.
     */
    InviteClientContext.prototype.onProgress = function (inviteResponse) {
        var _this = this;
        // Ported - User requested cancellation.
        if (this.isCanceled) {
            return;
        }
        if (!this.outgoingInviteRequest) {
            throw new Error("Outgoing INVITE request undefined.");
        }
        if (!this.earlyMediaSessionDescriptionHandlers) {
            throw new Error("Early media session description handlers undefined.");
        }
        var response = inviteResponse.message;
        var session = inviteResponse.session;
        // Ported - Set status.
        this.status = Enums_1.SessionStatus.STATUS_1XX_RECEIVED;
        // Ported - Set assertedIdentity.
        if (response.hasHeader("P-Asserted-Identity")) {
            this.assertedIdentity = core_1.Grammar.nameAddrHeaderParse(response.getHeader("P-Asserted-Identity"));
        }
        // The provisional response MUST establish a dialog if one is not yet created.
        // https://tools.ietf.org/html/rfc3262#section-4
        if (!session) {
            // A response with a to tag MUST create a session (should never get here).
            throw new Error("Session undefined.");
        }
        // If a provisional response is received for an initial request, and
        // that response contains a Require header field containing the option
        // tag 100rel, the response is to be sent reliably.  If the response is
        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
        // ignored, and the procedures below MUST NOT be used.
        // https://tools.ietf.org/html/rfc3262#section-4
        var requireHeader = response.getHeader("require");
        var rseqHeader = response.getHeader("rseq");
        var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
        var responseReliable = !!rseq;
        var extraHeaders = [];
        if (responseReliable) {
            extraHeaders.push("RAck: " + response.getHeader("rseq") + " " + response.getHeader("cseq"));
        }
        // INVITE without Offer and session still has no offer (and no answer).
        if (session.signalingState === core_1.SignalingState.Initial) {
            // Similarly, if a reliable provisional
            // response is the first reliable message sent back to the UAC, and the
            // INVITE did not contain an offer, one MUST appear in that reliable
            // provisional response.
            // https://tools.ietf.org/html/rfc3262#section-5
            if (responseReliable) {
                this.logger.warn("First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.");
                // FIXME: Known popular UA's currently end up here...
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            this.emit("progress", response);
            return;
        }
        // INVITE with Offer and session only has that initial local offer.
        if (session.signalingState === core_1.SignalingState.HaveLocalOffer) {
            if (responseReliable) {
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            this.emit("progress", response);
            return;
        }
        // INVITE without Offer and received initial offer in provisional response
        if (session.signalingState === core_1.SignalingState.HaveRemoteOffer) {
            // The initial offer MUST be in either an INVITE or, if not there,
            // in the first reliable non-failure message from the UAS back to
            // the UAC.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            // According to Section 13.2.1 of [RFC3261], 'The first reliable
            // non-failure message' must have an offer if there is no offer in the
            // INVITE request.  This means that the User Agent (UA) that receives
            // the INVITE request without an offer must include an offer in the
            // first reliable response with 100rel extension.  If no reliable
            // provisional response has been sent, the User Agent Server (UAS) must
            // include an offer when sending 2xx response.
            // https://tools.ietf.org/html/rfc6337#section-2.2
            if (!responseReliable) {
                this.logger.warn("Non-reliable provisional response MUST NOT contain an initial offer, discarding response.");
                return;
            }
            // If the initial offer is in the first reliable non-failure
            // message from the UAS back to UAC, the answer MUST be in the
            // acknowledgement for that message
            var sdh_2 = this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions || {});
            this.emit("SessionDescriptionHandler-created", sdh_2);
            this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh_2);
            sdh_2
                .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)
                .then(function () { return sdh_2.getDescription(_this.sessionDescriptionHandlerOptions, _this.modifiers); })
                .then(function (description) {
                var body = {
                    contentDisposition: "session", contentType: description.contentType, content: description.body
                };
                inviteResponse.prack({ extraHeaders: extraHeaders, body: body });
                _this.status = Enums_1.SessionStatus.STATUS_EARLY_MEDIA;
                _this.emit("progress", response);
            })
                .catch(function (error) {
                if (_this.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                    return;
                }
                _this.failed(undefined, Constants_1.C.causes.WEBRTC_ERROR);
                _this.terminated(undefined, Constants_1.C.causes.WEBRTC_ERROR);
            });
            return;
        }
        // This session has completed an initial offer/answer exchange, so...
        // - INVITE with SDP and this provisional response MAY be reliable
        // - INVITE without SDP and this provisional response MAY be reliable
        if (session.signalingState === core_1.SignalingState.Stable) {
            if (responseReliable) {
                inviteResponse.prack({ extraHeaders: extraHeaders });
            }
            // Note: As documented, no early media if offer was in INVITE, so nothing to be done.
            // FIXME: TODO: Add a flag/hack to allow early media in this case. There are people
            //              in non-forking environments (think straight to FreeSWITCH) who want
            //              early media on a 183. Not sure how to actually make it work, basically
            //              something like...
            if (false) {}
            this.emit("progress", response);
            return;
        }
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 3xx response.
     */
    InviteClientContext.prototype.onRedirect = function (inviteResponse) {
        this.disposeEarlyMedia();
        var response = inviteResponse.message;
        var statusCode = response.statusCode;
        var cause = Utils_1.Utils.sipErrorCause(statusCode || 0);
        this.rejected(response, cause);
        this.failed(response, cause);
        this.terminated(response, cause);
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 4xx, 5xx, or 6xx response.
     */
    InviteClientContext.prototype.onReject = function (inviteResponse) {
        this.disposeEarlyMedia();
        var response = inviteResponse.message;
        var statusCode = response.statusCode;
        var cause = Utils_1.Utils.sipErrorCause(statusCode || 0);
        this.rejected(response, cause);
        this.failed(response, cause);
        this.terminated(response, cause);
    };
    /**
     * Handle final response to initial INVITE.
     * @param inviteResponse 100 response.
     */
    InviteClientContext.prototype.onTrying = function (inviteResponse) {
        this.received100 = true;
        this.emit("progress", inviteResponse.message);
    };
    return InviteClientContext;
}(Session));
exports.InviteClientContext = InviteClientContext;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session/DTMF.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/Session/DTMF.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ../Constants */ "./node_modules/sip.js/lib/Constants.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var DTMFValidator_1 = __webpack_require__(/*! ./DTMFValidator */ "./node_modules/sip.js/lib/Session/DTMFValidator.js");
/**
 * @class DTMF
 * @param {SIP.Session} session
 */
var DTMF = /** @class */ (function (_super) {
    tslib_1.__extends(DTMF, _super);
    function DTMF(session, tone, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.C = {
            MIN_DURATION: 70,
            MAX_DURATION: 6000,
            DEFAULT_DURATION: 100,
            MIN_INTER_TONE_GAP: 50,
            DEFAULT_INTER_TONE_GAP: 500
        };
        _this.type = Enums_1.TypeStrings.DTMF;
        if (tone === undefined) {
            throw new TypeError("Not enough arguments");
        }
        _this.logger = session.ua.getLogger("sip.invitecontext.dtmf", session.id);
        _this.owner = session;
        var moreThanOneTone = false;
        // If tone is invalid, it will automatically generate an exception.
        // Otherwise, it will return the tone in the correct format.
        _this.tone = DTMFValidator_1.DTMFValidator.validate(tone, moreThanOneTone);
        var duration = options.duration;
        var interToneGap = options.interToneGap;
        // Check duration
        if (duration && !Utils_1.Utils.isDecimal(duration)) {
            throw new TypeError("Invalid tone duration: " + duration);
        }
        else if (!duration) {
            duration = _this.C.DEFAULT_DURATION;
        }
        else if (duration < _this.C.MIN_DURATION) {
            _this.logger.warn("'duration' value is lower than the minimum allowed, setting it to " +
                _this.C.MIN_DURATION + " milliseconds");
            duration = _this.C.MIN_DURATION;
        }
        else if (duration > _this.C.MAX_DURATION) {
            _this.logger.warn("'duration' value is greater than the maximum allowed, setting it to " +
                _this.C.MAX_DURATION + " milliseconds");
            duration = _this.C.MAX_DURATION;
        }
        else {
            duration = Math.abs(duration);
        }
        _this.duration = duration;
        // Check interToneGap
        if (interToneGap && !Utils_1.Utils.isDecimal(interToneGap)) {
            throw new TypeError("Invalid interToneGap: " + interToneGap);
        }
        else if (!interToneGap) {
            interToneGap = _this.C.DEFAULT_INTER_TONE_GAP;
        }
        else if (interToneGap < _this.C.MIN_INTER_TONE_GAP) {
            _this.logger.warn("'interToneGap' value is lower than the minimum allowed, setting it to " +
                _this.C.MIN_INTER_TONE_GAP + " milliseconds");
            interToneGap = _this.C.MIN_INTER_TONE_GAP;
        }
        else {
            interToneGap = Math.abs(interToneGap);
        }
        _this.interToneGap = interToneGap;
        return _this;
    }
    DTMF.prototype.send = function (options) {
        if (options === void 0) { options = {}; }
        // Check RTCSession Status
        if (this.owner.status !== Enums_1.SessionStatus.STATUS_CONFIRMED &&
            this.owner.status !== Enums_1.SessionStatus.STATUS_WAITING_FOR_ACK) {
            throw new Exceptions_1.Exceptions.InvalidStateError(this.owner.status);
        }
        // Get DTMF options
        var extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
        var body = {
            contentType: "application/dtmf-relay",
            body: "Signal= " + this.tone + "\r\nDuration= " + this.duration
        };
        if (this.owner.session) {
            var request = this.owner.session.info(undefined, {
                extraHeaders: extraHeaders,
                body: Utils_1.Utils.fromBodyObj(body)
            });
            this.owner.emit("dtmf", request.message, this);
            return;
        }
    };
    DTMF.prototype.init_incoming = function (request) {
        request.accept();
        if (!this.tone || !this.duration) {
            this.logger.warn("invalid INFO DTMF received, discarded");
        }
        else {
            this.owner.emit("dtmf", request.message, this);
        }
    };
    DTMF.prototype.receiveResponse = function (response) {
        var statusCode = response && response.statusCode ? response.statusCode : 0;
        switch (true) {
            case /^1[0-9]{2}$/.test(statusCode.toString()):
                // Ignore provisional responses.
                break;
            case /^2[0-9]{2}$/.test(statusCode.toString()):
                this.emit("succeeded", {
                    originator: "remote",
                    response: response
                });
                break;
            default:
                var cause = Utils_1.Utils.sipErrorCause(statusCode);
                this.emit("failed", response, cause);
                break;
        }
    };
    DTMF.prototype.onRequestTimeout = function () {
        this.emit("failed", undefined, Constants_1.C.causes.REQUEST_TIMEOUT);
        this.owner.onRequestTimeout();
    };
    DTMF.prototype.onTransportError = function () {
        this.emit("failed", undefined, Constants_1.C.causes.CONNECTION_ERROR);
        this.owner.onTransportError();
    };
    DTMF.prototype.onDialogError = function (response) {
        this.emit("failed", response, Constants_1.C.causes.DIALOG_ERROR);
        this.owner.onDialogError(response);
    };
    return DTMF;
}(events_1.EventEmitter));
exports.DTMF = DTMF;


/***/ }),

/***/ "./node_modules/sip.js/lib/Session/DTMFValidator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/Session/DTMFValidator.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DTMFValidator = /** @class */ (function () {
    function DTMFValidator() {
    }
    DTMFValidator.validate = function (tone, moreThanOneTone) {
        if (moreThanOneTone === void 0) { moreThanOneTone = true; }
        // Check tone type
        if (typeof tone === "string") {
            tone = tone.toUpperCase();
        }
        else if (typeof tone === "number") {
            tone = tone.toString();
        }
        else {
            DTMFValidator.generateInvalidToneError(tone);
        }
        var regex = moreThanOneTone ? /^[0-9A-D#*,]+$/i : /^[0-9A-D#*]$/i;
        // Check tone value
        if (!tone.match(regex)) {
            DTMFValidator.generateInvalidToneError(tone);
        }
        return tone;
    };
    DTMFValidator.generateInvalidToneError = function (tone) {
        var toneForMsg = (!!tone && typeof tone !== "boolean" ? tone.toString().toLowerCase() : tone);
        throw new TypeError("Invalid tone(s): " + toneForMsg);
    };
    return DTMFValidator;
}());
exports.DTMFValidator = DTMFValidator;


/***/ }),

/***/ "./node_modules/sip.js/lib/Subscription.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/Subscription.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var allowed_methods_1 = __webpack_require__(/*! ./core/user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
/**
 * While this class is named `Subscription`, it is closer to
 * an implementation of a "subscriber" as defined in RFC 6665
 * "SIP-Specific Event Notifications".
 * https://tools.ietf.org/html/rfc6665
 * @class Class creating a SIP Subscriber.
 */
var Subscription = /** @class */ (function (_super) {
    tslib_1.__extends(Subscription, _super);
    /**
     * Constructor.
     * @param ua User agent.
     * @param target Subscription target.
     * @param event Subscription event.
     * @param options Options bucket.
     */
    function Subscription(ua, target, event, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.data = {};
        _this.method = Constants_1.C.SUBSCRIBE;
        _this.body = undefined;
        // ClientContext interface
        _this.type = Enums_1.TypeStrings.Subscription;
        _this.ua = ua;
        _this.logger = ua.getLogger("sip.subscription");
        if (options.body) {
            _this.body = {
                body: options.body,
                contentType: options.contentType ? options.contentType : "application/sdp"
            };
        }
        // Target URI
        var uri = ua.normalizeTarget(target);
        if (!uri) {
            throw new TypeError("Invalid target: " + target);
        }
        _this.uri = uri;
        // Subscription event
        _this.event = event;
        // Subscription expires
        if (options.expires === undefined) {
            _this.expires = 3600;
        }
        else if (typeof options.expires !== "number") { // pre-typescript type guard
            ua.logger.warn("Option \"expires\" must be a number. Using default of 3600.");
            _this.expires = 3600;
        }
        else {
            _this.expires = options.expires;
        }
        // Subscription extra headers
        _this.extraHeaders = (options.extraHeaders || []).slice();
        // Subscription context.
        _this.context = _this.initContext();
        _this.disposed = false;
        // ClientContext interface
        _this.request = _this.context.message;
        if (!_this.request.from) {
            throw new Error("From undefined.");
        }
        if (!_this.request.to) {
            throw new Error("From undefined.");
        }
        _this.localIdentity = _this.request.from;
        _this.remoteIdentity = _this.request.to;
        // Add to UA's collection
        _this.id = _this.request.callId + _this.request.from.parameters.tag + _this.event;
        _this.ua.subscriptions[_this.id] = _this;
        return _this;
    }
    /**
     * Destructor.
     */
    Subscription.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        if (this.retryAfterTimer) {
            clearTimeout(this.retryAfterTimer);
            this.retryAfterTimer = undefined;
        }
        this.context.dispose();
        this.disposed = true;
        // Remove from UA's collection
        delete this.ua.subscriptions[this.id];
    };
    Subscription.prototype.on = function (name, callback) {
        return _super.prototype.on.call(this, name, callback);
    };
    Subscription.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return _super.prototype.emit.apply(this, tslib_1.__spreadArrays([event], args));
    };
    /**
     * Gracefully terminate.
     */
    Subscription.prototype.close = function () {
        if (this.disposed) {
            return;
        }
        this.dispose();
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                this.onTerminated();
                break;
            case core_1.SubscriptionState.NotifyWait:
                this.onTerminated();
                break;
            case core_1.SubscriptionState.Pending:
                this.unsubscribe();
                break;
            case core_1.SubscriptionState.Active:
                this.unsubscribe();
                break;
            case core_1.SubscriptionState.Terminated:
                this.onTerminated();
                break;
            default:
                break;
        }
    };
    /**
     * Send a re-SUBSCRIBE request if there is an "active" subscription.
     */
    Subscription.prototype.refresh = function () {
        var _this = this;
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                break;
            case core_1.SubscriptionState.Active:
                if (this.subscription) {
                    var request = this.subscription.refresh();
                    request.delegate = {
                        onAccept: (function (response) { return _this.onAccepted(response); }),
                        onRedirect: (function (response) { return _this.onFailed(response); }),
                        onReject: (function (response) { return _this.onFailed(response); }),
                    };
                }
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
    };
    /**
     * Send an initial SUBSCRIBE request if no subscription.
     * Send a re-SUBSCRIBE request if there is an "active" subscription.
     */
    Subscription.prototype.subscribe = function () {
        var _this = this;
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                this.context.subscribe().then(function (result) {
                    if (result.success) {
                        if (result.success.subscription) {
                            _this.subscription = result.success.subscription;
                            _this.subscription.delegate = {
                                onNotify: function (request) { return _this.onNotify(request); },
                                onRefresh: function (request) { return _this.onRefresh(request); },
                                onTerminated: function () { return _this.close(); }
                            };
                        }
                        _this.onNotify(result.success.request);
                    }
                    else if (result.failure) {
                        _this.onFailed(result.failure.response);
                    }
                });
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                break;
            case core_1.SubscriptionState.Active:
                this.refresh();
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
        return this;
    };
    /**
     * Send a re-SUBSCRIBE request if there is a "pending" or "active" subscription.
     */
    Subscription.prototype.unsubscribe = function () {
        this.dispose();
        switch (this.context.state) {
            case core_1.SubscriptionState.Initial:
                break;
            case core_1.SubscriptionState.NotifyWait:
                break;
            case core_1.SubscriptionState.Pending:
                if (this.subscription) {
                    this.subscription.unsubscribe();
                    // responses intentionally ignored
                }
                break;
            case core_1.SubscriptionState.Active:
                if (this.subscription) {
                    this.subscription.unsubscribe();
                    // responses intentionally ignored
                }
                break;
            case core_1.SubscriptionState.Terminated:
                break;
            default:
                break;
        }
        this.onTerminated();
    };
    Subscription.prototype.onAccepted = function (response) {
        var statusCode = response.message.statusCode ? response.message.statusCode : 0;
        var cause = Utils_1.Utils.getReasonPhrase(statusCode);
        this.emit("accepted", response.message, cause);
    };
    Subscription.prototype.onFailed = function (response) {
        this.close();
        if (response) {
            var statusCode = response.message.statusCode ? response.message.statusCode : 0;
            var cause = Utils_1.Utils.getReasonPhrase(statusCode);
            this.emit("failed", response.message, cause);
            this.emit("rejected", response.message, cause);
        }
    };
    Subscription.prototype.onNotify = function (request) {
        var _this = this;
        request.accept(); // Send 200 response.
        this.emit("notify", { request: request.message });
        // If we've set state to done, no further processing should take place
        // and we are only interested in cleaning up after the appropriate NOTIFY.
        if (this.disposed) {
            return;
        }
        //  If the "Subscription-State" value is "terminated", the subscriber
        //  MUST consider the subscription terminated.  The "expires" parameter
        //  has no semantics for "terminated" -- notifiers SHOULD NOT include an
        //  "expires" parameter on a "Subscription-State" header field with a
        //  value of "terminated", and subscribers MUST ignore any such
        //  parameter, if present.  If a reason code is present, the client
        //  should behave as described below.  If no reason code or an unknown
        //  reason code is present, the client MAY attempt to re-subscribe at any
        //  time (unless a "retry-after" parameter is present, in which case the
        //  client SHOULD NOT attempt re-subscription until after the number of
        //  seconds specified by the "retry-after" parameter).  The reason codes
        //  defined by this document are:
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = request.message.parseHeader("Subscription-State");
        if (subscriptionState && subscriptionState.state) {
            switch (subscriptionState.state) {
                case "terminated":
                    if (subscriptionState.reason) {
                        this.logger.log("Terminated subscription with reason " + subscriptionState.reason);
                        switch (subscriptionState.reason) {
                            case "deactivated":
                            case "timeout":
                                this.initContext();
                                this.subscribe();
                                return;
                            case "probation":
                            case "giveup":
                                this.initContext();
                                if (subscriptionState.params && subscriptionState.params["retry-after"]) {
                                    this.retryAfterTimer = setTimeout(function () { return _this.subscribe(); }, subscriptionState.params["retry-after"]);
                                }
                                else {
                                    this.subscribe();
                                }
                                return;
                            case "rejected":
                            case "noresource":
                            case "invariant":
                                break;
                        }
                    }
                    this.close();
                    break;
                default:
                    break;
            }
        }
    };
    Subscription.prototype.onRefresh = function (request) {
        var _this = this;
        request.delegate = {
            onAccept: function (response) { return _this.onAccepted(response); }
        };
    };
    Subscription.prototype.onTerminated = function () {
        this.emit("terminated");
    };
    Subscription.prototype.initContext = function () {
        var _this = this;
        var options = {
            extraHeaders: this.extraHeaders,
            body: this.body ? Utils_1.Utils.fromBodyObj(this.body) : undefined
        };
        this.context = new SubscribeClientContext(this.ua.userAgentCore, this.uri, this.event, this.expires, options);
        this.context.delegate = {
            onAccept: (function (response) { return _this.onAccepted(response); })
        };
        return this.context;
    };
    return Subscription;
}(events_1.EventEmitter));
exports.Subscription = Subscription;
// tslint:disable-next-line:max-classes-per-file
var SubscribeClientContext = /** @class */ (function () {
    function SubscribeClientContext(core, target, event, expires, options, delegate) {
        this.core = core;
        this.target = target;
        this.event = event;
        this.expires = expires;
        this.subscribed = false;
        this.logger = core.loggerFactory.getLogger("sip.subscription");
        this.delegate = delegate;
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var extraHeaders = (options && options.extraHeaders || []).slice();
        extraHeaders.push(allowHeader);
        extraHeaders.push("Event: " + this.event);
        extraHeaders.push("Expires: " + this.expires);
        extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        var body = options && options.body;
        this.message = core.makeOutgoingRequestMessage(Constants_1.C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);
    }
    /** Destructor. */
    SubscribeClientContext.prototype.dispose = function () {
        if (this.subscription) {
            this.subscription.dispose();
        }
        if (this.request) {
            this.request.waitNotifyStop();
            this.request.dispose();
        }
    };
    Object.defineProperty(SubscribeClientContext.prototype, "state", {
        /** Subscription state. */
        get: function () {
            if (this.subscription) {
                return this.subscription.subscriptionState;
            }
            else if (this.subscribed) {
                return core_1.SubscriptionState.NotifyWait;
            }
            else {
                return core_1.SubscriptionState.Initial;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Establish subscription.
     * @param options Options bucket.
     */
    SubscribeClientContext.prototype.subscribe = function () {
        var _this = this;
        if (this.subscribed) {
            return Promise.reject(new Error("Not in initial state. Did you call subscribe more than once?"));
        }
        this.subscribed = true;
        return new Promise(function (resolve, reject) {
            if (!_this.message) {
                throw new Error("Message undefined.");
            }
            _this.request = _this.core.subscribe(_this.message, {
                // This SUBSCRIBE request will be confirmed with a final response.
                // 200-class responses indicate that the subscription has been accepted
                // and that a NOTIFY request will be sent immediately.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onAccept: function (response) {
                    if (_this.delegate && _this.delegate.onAccept) {
                        _this.delegate.onAccept(response);
                    }
                },
                // Due to the potential for out-of-order messages, packet loss, and
                // forking, the subscriber MUST be prepared to receive NOTIFY requests
                // before the SUBSCRIBE transaction has completed.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                onNotify: function (requestWithSubscription) {
                    _this.subscription = requestWithSubscription.subscription;
                    if (_this.subscription) {
                        _this.subscription.autoRefresh = true;
                    }
                    resolve({ success: requestWithSubscription });
                },
                // If this Timer N expires prior to the receipt of a NOTIFY request,
                // the subscriber considers the subscription failed, and cleans up
                // any state associated with the subscription attempt.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4
                onNotifyTimeout: function () {
                    resolve({ failure: {} });
                },
                // This SUBSCRIBE request will be confirmed with a final response.
                // Non-200-class final responses indicate that no subscription or new
                // dialog usage has been created, and no subsequent NOTIFY request will
                // be sent.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onRedirect: function (response) {
                    resolve({ failure: { response: response } });
                },
                // This SUBSCRIBE request will be confirmed with a final response.
                // Non-200-class final responses indicate that no subscription or new
                // dialog usage has been created, and no subsequent NOTIFY request will
                // be sent.
                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
                onReject: function (response) {
                    resolve({ failure: { response: response } });
                }
            });
        });
    };
    return SubscribeClientContext;
}());


/***/ }),

/***/ "./node_modules/sip.js/lib/Transport.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Transport.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/**
 * Legacy Transport.
 * @remarks
 * Abstract transport layer base class.
 * @public
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    /**
     * Constructor
     * @param logger - Logger.
     * @param options - Options bucket. Deprecated.
     */
    function Transport(logger, options) {
        var _this = _super.call(this) || this;
        _this.logger = logger;
        return _this;
    }
    Object.defineProperty(Transport.prototype, "protocol", {
        /**
         * The protocol.
         *
         * @remarks
         * Formatted as defined for the Via header sent-protocol transport.
         * https://tools.ietf.org/html/rfc3261#section-20.42
         */
        get: function () {
            return this.server && this.server.scheme ? this.server.scheme : "WSS";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the promise designated by the child layer then emits a connected event.
     * Automatically emits an event upon resolution, unless overrideEvent is set. If you
     * override the event in this fashion, you should emit it in your implementation of connectPromise
     * @param options - Options bucket.
     */
    Transport.prototype.connect = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return this.connectPromise(options).then(function (data) {
            if (!data.overrideEvent) {
                _this.emit("connected");
            }
        });
    };
    /**
     * Sends a message then emits a 'messageSent' event. Automatically emits an
     * event upon resolution, unless data.overrideEvent is set. If you override
     * the event in this fashion, you should emit it in your implementation of sendPromise
     * Rejects with an Error if message fails to send.
     * @param message - Message.
     * @param options - Options bucket.
     */
    Transport.prototype.send = function (message, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        // Error handling is independent of whether the message was a request or
        // response.
        //
        // If the transport user asks for a message to be sent over an
        // unreliable transport, and the result is an ICMP error, the behavior
        // depends on the type of ICMP error.  Host, network, port or protocol
        // unreachable errors, or parameter problem errors SHOULD cause the
        // transport layer to inform the transport user of a failure in sending.
        // Source quench and TTL exceeded ICMP errors SHOULD be ignored.
        //
        // If the transport user asks for a request to be sent over a reliable
        // transport, and the result is a connection failure, the transport
        // layer SHOULD inform the transport user of a failure in sending.
        // https://tools.ietf.org/html/rfc3261#section-18.4
        return this.sendPromise(message).then(function (result) {
            if (!result.overrideEvent) {
                _this.emit("messageSent", result.msg);
            }
        });
    };
    /**
     * Returns the promise designated by the child layer then emits a
     * disconnected event. Automatically emits an event upon resolution,
     * unless overrideEvent is set. If you override the event in this fashion,
     * you should emit it in your implementation of disconnectPromise
     * @param options - Options bucket
     */
    Transport.prototype.disconnect = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return this.disconnectPromise(options).then(function (data) {
            if (!data.overrideEvent) {
                _this.emit("disconnected");
            }
        });
    };
    Transport.prototype.afterConnected = function (callback) {
        if (this.isConnected()) {
            callback();
        }
        else {
            this.once("connected", callback);
        }
    };
    /**
     * Returns a promise which resolves once the UA is connected. DEPRECATION WARNING: just use afterConnected()
     */
    Transport.prototype.waitForConnected = function () {
        var _this = this;
        // tslint:disable-next-line:no-console
        console.warn("DEPRECATION WARNING Transport.waitForConnected(): use afterConnected() instead");
        return new Promise(function (resolve) {
            _this.afterConnected(resolve);
        });
    };
    return Transport;
}(events_1.EventEmitter));
exports.Transport = Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/UA.js":
/*!***************************************!*\
  !*** ./node_modules/sip.js/lib/UA.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var PublishContext_1 = __webpack_require__(/*! ./PublishContext */ "./node_modules/sip.js/lib/PublishContext.js");
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
var RegisterContext_1 = __webpack_require__(/*! ./RegisterContext */ "./node_modules/sip.js/lib/RegisterContext.js");
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
var Session_1 = __webpack_require__(/*! ./Session */ "./node_modules/sip.js/lib/Session.js");
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/sip.js/lib/Subscription.js");
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
var SessionDescriptionHandler_1 = __webpack_require__(/*! ./Web/SessionDescriptionHandler */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js");
var Transport_1 = __webpack_require__(/*! ./Web/Transport */ "./node_modules/sip.js/lib/Web/Transport.js");
/**
 * @class Class creating a SIP User Agent.
 * @param {function returning SIP.sessionDescriptionHandler} [configuration.sessionDescriptionHandlerFactory]
 *  A function will be invoked by each of the UA's Sessions to build the sessionDescriptionHandler for that Session.
 *  If no (or a falsy) value is provided, each Session will use a default (WebRTC) sessionDescriptionHandler.
 */
var UA = /** @class */ (function (_super) {
    tslib_1.__extends(UA, _super);
    function UA(configuration) {
        var _this = _super.call(this) || this;
        /** Unload listener. */
        _this.unloadListener = (function () { _this.stop(); });
        _this.type = Enums_1.TypeStrings.UA;
        _this.log = new core_1.LoggerFactory();
        _this.logger = _this.getLogger("sip.ua");
        _this.configuration = {};
        // User actions outside any session/dialog (MESSAGE)
        _this.applicants = {};
        _this.data = {};
        _this.sessions = {};
        _this.subscriptions = {};
        _this.publishers = {};
        _this.status = Enums_1.UAStatus.STATUS_INIT;
        /**
         * Load configuration
         *
         * @throws {SIP.Exceptions.ConfigurationError}
         * @throws {TypeError}
         */
        if (configuration === undefined) {
            configuration = {};
        }
        else if (typeof configuration === "string" || configuration instanceof String) {
            configuration = {
                uri: configuration
            };
        }
        // Apply log configuration if present
        if (configuration.log) {
            _this.log.builtinEnabled = configuration.log.builtinEnabled;
            if (configuration.log.hasOwnProperty("connector")) {
                _this.log.connector = configuration.log.connector;
            }
            if (configuration.log.hasOwnProperty("level")) {
                var level = configuration.log.level;
                var normalized = void 0;
                if (typeof level === "string") {
                    switch (level) {
                        case "error":
                            normalized = core_1.Levels.error;
                            break;
                        case "warn":
                            normalized = core_1.Levels.warn;
                            break;
                        case "log":
                            normalized = core_1.Levels.log;
                            break;
                        case "debug":
                            normalized = core_1.Levels.debug;
                            break;
                        default:
                            break;
                    }
                }
                else {
                    switch (level) {
                        case 0:
                            normalized = core_1.Levels.error;
                            break;
                        case 1:
                            normalized = core_1.Levels.warn;
                            break;
                        case 2:
                            normalized = core_1.Levels.log;
                            break;
                        case 3:
                            normalized = core_1.Levels.debug;
                            break;
                        default:
                            break;
                    }
                }
                // avoid setting level when invalid, use default level instead
                if (normalized === undefined) {
                    _this.logger.error("Invalid \"level\" parameter value: " + JSON.stringify(level));
                }
                else {
                    _this.log.level = normalized;
                }
            }
        }
        var deprecatedMessage = "The UA class has been deprecated and will no longer be available starting with SIP.js release 0.16.0. " +
            "The UA has been replaced by the UserAgent class. Please update accordingly.";
        _this.logger.warn(deprecatedMessage);
        try {
            _this.loadConfig(configuration);
        }
        catch (e) {
            _this.status = Enums_1.UAStatus.STATUS_NOT_READY;
            _this.error = UA.C.CONFIGURATION_ERROR;
            throw e;
        }
        if (!_this.configuration.transportConstructor) {
            throw new core_1.TransportError("Transport constructor not set");
        }
        _this.transport = new _this.configuration.transportConstructor(_this.getLogger("sip.transport"), _this.configuration.transportOptions);
        var userAgentCoreConfiguration = makeUserAgentCoreConfigurationFromUA(_this);
        // The Replaces header contains information used to match an existing
        // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE
        // with a Replaces header, the User Agent (UA) attempts to match this
        // information with a confirmed or early dialog.
        // https://tools.ietf.org/html/rfc3891#section-3
        var handleInviteWithReplacesHeader = function (context, request) {
            if (_this.configuration.replaces !== Constants_1.C.supported.UNSUPPORTED) {
                var replaces = request.parseHeader("replaces");
                if (replaces) {
                    var targetSession = _this.sessions[replaces.call_id + replaces.replaces_from_tag] ||
                        _this.sessions[replaces.call_id + replaces.replaces_to_tag] ||
                        undefined;
                    if (!targetSession) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 481 });
                        return;
                    }
                    if (targetSession.status === Enums_1.SessionStatus.STATUS_TERMINATED) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 603 });
                        return;
                    }
                    var targetDialogId = replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag;
                    var targetDialog = _this.userAgentCore.dialogs.get(targetDialogId);
                    if (!targetDialog) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 481 });
                        return;
                    }
                    if (!targetDialog.early && replaces.early_only) {
                        _this.userAgentCore.replyStateless(request, { statusCode: 486 });
                        return;
                    }
                    context.replacee = targetSession;
                }
            }
        };
        var userAgentCoreDelegate = {
            onInvite: function (incomingInviteRequest) {
                // FIXME: Ported - 100 Trying send should be configurable.
                // Only required if TU will not respond in 200ms.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                incomingInviteRequest.trying();
                incomingInviteRequest.delegate = {
                    onCancel: function (cancel) {
                        context.onCancel(cancel);
                    },
                    onTransportError: function (error) {
                        context.onTransportError();
                    }
                };
                var context = new Session_1.InviteServerContext(_this, incomingInviteRequest);
                // Ported - handling of out of dialog INVITE with Replaces.
                handleInviteWithReplacesHeader(context, incomingInviteRequest.message);
                // Ported - make the first call to progress automatically.
                if (context.autoSendAnInitialProvisionalResponse) {
                    context.progress();
                }
                _this.emit("invite", context);
            },
            onMessage: function (incomingMessageRequest) {
                // Ported - handling of out of dialog MESSAGE.
                var serverContext = new ServerContext_1.ServerContext(_this, incomingMessageRequest);
                serverContext.body = incomingMessageRequest.message.body;
                serverContext.contentType = incomingMessageRequest.message.getHeader("Content-Type") || "text/plain";
                incomingMessageRequest.accept();
                _this.emit("message", serverContext); // TODO: Review. Why is a "ServerContext" emitted? What use it is?
            },
            onNotify: function (incomingNotifyRequest) {
                // DEPRECATED: Out of dialog NOTIFY is an obsolete usage.
                // Ported - handling of out of dialog NOTIFY.
                if (_this.configuration.allowLegacyNotifications && _this.listeners("notify").length > 0) {
                    incomingNotifyRequest.accept();
                    _this.emit("notify", { request: incomingNotifyRequest.message });
                }
                else {
                    incomingNotifyRequest.reject({ statusCode: 481 });
                }
            },
            onRefer: function (incomingReferRequest) {
                // Ported - handling of out of dialog REFER.
                _this.logger.log("Received an out of dialog refer");
                if (!_this.configuration.allowOutOfDialogRefers) {
                    incomingReferRequest.reject({ statusCode: 405 });
                }
                _this.logger.log("Allow out of dialog refers is enabled on the UA");
                var referContext = new ReferContext_1.ReferServerContext(_this, incomingReferRequest);
                if (_this.listeners("outOfDialogReferRequested").length) {
                    _this.emit("outOfDialogReferRequested", referContext);
                }
                else {
                    _this.logger.log("No outOfDialogReferRequest listeners, automatically accepting and following the out of dialog refer");
                    referContext.accept({ followRefer: true });
                }
            },
            onSubscribe: function (incomingSubscribeRequest) {
                _this.emit("subscribe", incomingSubscribeRequest);
            },
        };
        _this.userAgentCore = new core_1.UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);
        // Initialize registerContext
        _this.registerContext = new RegisterContext_1.RegisterContext(_this, configuration.registerOptions);
        _this.registerContext.on("failed", _this.emit.bind(_this, "registrationFailed"));
        _this.registerContext.on("registered", _this.emit.bind(_this, "registered"));
        _this.registerContext.on("unregistered", _this.emit.bind(_this, "unregistered"));
        if (_this.configuration.autostart) {
            _this.start();
        }
        return _this;
    }
    // =================
    //  High Level API
    // =================
    UA.prototype.register = function (options) {
        if (options === void 0) { options = {}; }
        if (options.register) {
            this.configuration.register = true;
        }
        this.registerContext.register(options);
        return this;
    };
    /**
     * Unregister.
     *
     * @param {Boolean} [all] unregister all user bindings.
     *
     */
    UA.prototype.unregister = function (options) {
        var _this = this;
        this.configuration.register = false;
        this.transport.afterConnected(function () {
            _this.registerContext.unregister(options);
        });
        return this;
    };
    UA.prototype.isRegistered = function () {
        return this.registerContext.registered;
    };
    /**
     * Make an outgoing call.
     *
     * @param {String} target
     * @param {Object} views
     * @param {Object} [options.media] gets passed to SIP.sessionDescriptionHandler.getDescription as mediaHint
     *
     * @throws {TypeError}
     *
     */
    UA.prototype.invite = function (target, options, modifiers) {
        var _this = this;
        var context = new Session_1.InviteClientContext(this, target, options, modifiers);
        // Delay sending actual invite until the next 'tick' if we are already
        // connected, so that API consumers can register to events fired by the
        // the session.
        this.transport.afterConnected(function () {
            context.invite();
            _this.emit("inviteSent", context);
        });
        return context;
    };
    UA.prototype.subscribe = function (target, event, options) {
        var sub = new Subscription_1.Subscription(this, target, event, options);
        this.transport.afterConnected(function () { return sub.subscribe(); });
        return sub;
    };
    /**
     * Send PUBLISH Event State Publication (RFC3903)
     *
     * @param {String} target
     * @param {String} event
     * @param {String} body
     * @param {Object} [options]
     *
     * @throws {SIP.Exceptions.MethodParameterError}
     */
    UA.prototype.publish = function (target, event, body, options) {
        var pub = new PublishContext_1.PublishContext(this, target, event, options);
        this.transport.afterConnected(function () {
            pub.publish(body);
        });
        return pub;
    };
    /**
     * Send a message.
     *
     * @param {String} target
     * @param {String} body
     * @param {Object} [options]
     *
     * @throws {TypeError}
     */
    UA.prototype.message = function (target, body, options) {
        if (options === void 0) { options = {}; }
        if (body === undefined) {
            throw new TypeError("Not enough arguments");
        }
        // There is no Message module, so it is okay that the UA handles defaults here.
        options.contentType = options.contentType || "text/plain";
        options.body = body;
        return this.request(Constants_1.C.MESSAGE, target, options);
    };
    UA.prototype.request = function (method, target, options) {
        var req = new ClientContext_1.ClientContext(this, method, target, options);
        this.transport.afterConnected(function () { return req.send(); });
        return req;
    };
    /**
     * Gracefully close.
     */
    UA.prototype.stop = function () {
        this.logger.log("user requested closure...");
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            this.logger.warn("UA already closed");
            return this;
        }
        // Close registerContext
        this.logger.log("closing registerContext");
        this.registerContext.close();
        // Run terminate on every Session
        for (var session in this.sessions) {
            if (this.sessions[session]) {
                this.logger.log("closing session " + session);
                this.sessions[session].terminate();
            }
        }
        // Run unsubscribe on every Subscription
        for (var subscription in this.subscriptions) {
            if (this.subscriptions[subscription]) {
                this.logger.log("unsubscribe " + subscription);
                this.subscriptions[subscription].unsubscribe();
            }
        }
        // Run close on every Publisher
        for (var publisher in this.publishers) {
            if (this.publishers[publisher]) {
                this.logger.log("unpublish " + publisher);
                this.publishers[publisher].close();
            }
        }
        // Run close on every applicant
        for (var applicant in this.applicants) {
            if (this.applicants[applicant]) {
                this.applicants[applicant].close();
            }
        }
        this.status = Enums_1.UAStatus.STATUS_USER_CLOSED;
        // Disconnect the transport and reset user agent core
        this.transport.disconnect();
        this.userAgentCore.reset();
        if (this.configuration.autostop) {
            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
            var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
            if (typeof window !== "undefined" &&
                typeof window.removeEventListener === "function" &&
                !googleChromePackagedApp) {
                window.removeEventListener("unload", this.unloadListener);
            }
        }
        return this;
    };
    /**
     * Connect to the WS server if status = STATUS_INIT.
     * Resume UA after being closed.
     *
     */
    UA.prototype.start = function () {
        this.logger.log("user requested startup...");
        if (this.status === Enums_1.UAStatus.STATUS_INIT) {
            this.status = Enums_1.UAStatus.STATUS_STARTING;
            this.setTransportListeners();
            this.emit("transportCreated", this.transport);
            this.transport.connect();
        }
        else if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            this.logger.log("resuming");
            this.status = Enums_1.UAStatus.STATUS_READY;
            this.transport.connect();
        }
        else if (this.status === Enums_1.UAStatus.STATUS_STARTING) {
            this.logger.log("UA is in STARTING status, not opening new connection");
        }
        else if (this.status === Enums_1.UAStatus.STATUS_READY) {
            this.logger.log("UA is in READY status, not resuming");
        }
        else {
            this.logger.error("Connection is down. Auto-Recovery system is trying to connect");
        }
        if (this.configuration.autostop) {
            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps
            var googleChromePackagedApp = typeof chrome !== "undefined" && chrome.app && chrome.app.runtime ? true : false;
            if (typeof window !== "undefined" &&
                typeof window.addEventListener === "function" &&
                !googleChromePackagedApp) {
                window.addEventListener("unload", this.unloadListener);
            }
        }
        return this;
    };
    /**
     * Normalize a string into a valid SIP request URI
     *
     * @param {String} target
     *
     * @returns {SIP.URI|undefined}
     */
    UA.prototype.normalizeTarget = function (target) {
        return Utils_1.Utils.normalizeTarget(target, this.configuration.hostportParams);
    };
    UA.prototype.getLogger = function (category, label) {
        return this.log.getLogger(category, label);
    };
    UA.prototype.getLoggerFactory = function () {
        return this.log;
    };
    UA.prototype.getSupportedResponseOptions = function () {
        var optionTags = [];
        if (this.contact.pubGruu || this.contact.tempGruu) {
            optionTags.push("gruu");
        }
        if (this.configuration.rel100 === Constants_1.C.supported.SUPPORTED) {
            optionTags.push("100rel");
        }
        if (this.configuration.replaces === Constants_1.C.supported.SUPPORTED) {
            optionTags.push("replaces");
        }
        optionTags.push("outbound");
        optionTags = optionTags.concat(this.configuration.extraSupported || []);
        var allowUnregistered = this.configuration.hackAllowUnregisteredOptionTags || false;
        var optionTagSet = {};
        optionTags = optionTags.filter(function (optionTag) {
            var registered = Constants_1.C.OPTION_TAGS[optionTag];
            var unique = !optionTagSet[optionTag];
            optionTagSet[optionTag] = true;
            return (registered || allowUnregistered) && unique;
        });
        return optionTags;
    };
    /**
     * Get the session to which the request belongs to, if any.
     * @param {SIP.IncomingRequest} request.
     * @returns {SIP.OutgoingSession|SIP.IncomingSession|undefined}
     */
    UA.prototype.findSession = function (request) {
        return this.sessions[request.callId + request.fromTag] ||
            this.sessions[request.callId + request.toTag] ||
            undefined;
    };
    UA.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    // ==============================
    // Event Handlers
    // ==============================
    UA.prototype.onTransportError = function () {
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED) {
            return;
        }
        if (!this.error || this.error !== UA.C.NETWORK_ERROR) {
            this.status = Enums_1.UAStatus.STATUS_NOT_READY;
            this.error = UA.C.NETWORK_ERROR;
        }
    };
    /**
     * Helper function. Sets transport listeners
     */
    UA.prototype.setTransportListeners = function () {
        var _this = this;
        this.transport.on("connected", function () { return _this.onTransportConnected(); });
        this.transport.on("message", function (message) { return _this.onTransportReceiveMsg(message); });
        this.transport.on("transportError", function () { return _this.onTransportError(); });
    };
    /**
     * Transport connection event.
     * @event
     * @param {SIP.Transport} transport.
     */
    UA.prototype.onTransportConnected = function () {
        var _this = this;
        if (this.configuration.register) {
            // In an effor to maintain behavior from when we "initialized" an
            // authentication factory, this is in a Promise.then
            Promise.resolve().then(function () { return _this.registerContext.register(); });
        }
    };
    /**
     * Handle SIP message received from the transport.
     * @param messageString The message.
     */
    UA.prototype.onTransportReceiveMsg = function (messageString) {
        var _this = this;
        var message = core_1.Parser.parseMessage(messageString, this.getLogger("sip.parser"));
        if (!message) {
            this.logger.warn("UA failed to parse incoming SIP message - discarding.");
            return;
        }
        if (this.status === Enums_1.UAStatus.STATUS_USER_CLOSED && message instanceof core_1.IncomingRequestMessage) {
            this.logger.warn("UA received message when status = USER_CLOSED - aborting");
            return;
        }
        // A valid SIP request formulated by a UAC MUST, at a minimum, contain
        // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,
        // and Via; all of these header fields are mandatory in all SIP
        // requests.
        // https://tools.ietf.org/html/rfc3261#section-8.1.1
        var hasMinimumHeaders = function () {
            var mandatoryHeaders = ["from", "to", "call_id", "cseq", "via"];
            for (var _i = 0, mandatoryHeaders_1 = mandatoryHeaders; _i < mandatoryHeaders_1.length; _i++) {
                var header = mandatoryHeaders_1[_i];
                if (!message.hasHeader(header)) {
                    _this.logger.warn("Missing mandatory header field : " + header + ".");
                    return false;
                }
            }
            return true;
        };
        // Request Checks
        if (message instanceof core_1.IncomingRequestMessage) {
            // This is port of SanityCheck.minimumHeaders().
            if (!hasMinimumHeaders()) {
                this.logger.warn("Request missing mandatory header field. Dropping.");
                return;
            }
            // FIXME: This is non-standard and should be a configruable behavior (desirable regardless).
            // Custom SIP.js check to reject request from ourself (this instance of SIP.js).
            // This is port of SanityCheck.rfc3261_16_3_4().
            if (!message.toTag && message.callId.substr(0, 5) === this.configuration.sipjsId) {
                this.userAgentCore.replyStateless(message, { statusCode: 482 });
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to reject requests if body length wrong.
            // This is port of SanityCheck.rfc3261_18_3_request().
            var len = Utils_1.Utils.str_utf8_length(message.body);
            var contentLength = message.getHeader("content-length");
            if (contentLength && len < Number(contentLength)) {
                this.userAgentCore.replyStateless(message, { statusCode: 400 });
                return;
            }
        }
        // Reponse Checks
        if (message instanceof core_1.IncomingResponseMessage) {
            // This is port of SanityCheck.minimumHeaders().
            if (!hasMinimumHeaders()) {
                this.logger.warn("Response missing mandatory header field. Dropping.");
                return;
            }
            // Custom SIP.js check to drop responses if multiple Via headers.
            // This is port of SanityCheck.rfc3261_8_1_3_3().
            if (message.getHeaders("via").length > 1) {
                this.logger.warn("More than one Via header field present in the response. Dropping.");
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to drop responses if bad Via header.
            // This is port of SanityCheck.rfc3261_18_1_2().
            if (message.via.host !== this.configuration.viaHost || message.via.port !== undefined) {
                this.logger.warn("Via sent-by in the response does not match UA Via host value. Dropping.");
                return;
            }
            // FIXME: This should be Transport check before we get here (Section 18).
            // Custom SIP.js check to reject requests if body length wrong.
            // This is port of SanityCheck.rfc3261_18_3_response().
            var len = Utils_1.Utils.str_utf8_length(message.body);
            var contentLength = message.getHeader("content-length");
            if (contentLength && len < Number(contentLength)) {
                this.logger.warn("Message body length is lower than the value in Content-Length header field. Dropping.");
                return;
            }
        }
        // Handle Request
        if (message instanceof core_1.IncomingRequestMessage) {
            this.userAgentCore.receiveIncomingRequestFromTransport(message);
            return;
        }
        // Handle Response
        if (message instanceof core_1.IncomingResponseMessage) {
            this.userAgentCore.receiveIncomingResponseFromTransport(message);
            return;
        }
        throw new Error("Invalid message type.");
    };
    // =================
    // Utils
    // =================
    UA.prototype.checkAuthenticationFactory = function (authenticationFactory) {
        if (!(authenticationFactory instanceof Function)) {
            return;
        }
        if (!authenticationFactory.initialize) {
            authenticationFactory.initialize = function () {
                return Promise.resolve();
            };
        }
        return authenticationFactory;
    };
    /**
     * Configuration load.
     * returns {void}
     */
    UA.prototype.loadConfig = function (configuration) {
        var _this = this;
        // Settings and default values
        var settings = {
            /* Host address
             * Value to be set in Via sent_by and host part of Contact FQDN
             */
            viaHost: Utils_1.Utils.createRandomToken(12) + ".invalid",
            uri: new core_1.URI("sip", "anonymous." + Utils_1.Utils.createRandomToken(6), "anonymous.invalid", undefined, undefined),
            // Custom Configuration Settings
            custom: {},
            // Display name
            displayName: "",
            // Password
            password: undefined,
            register: true,
            // Registration parameters
            registerOptions: {},
            // Transport related parameters
            transportConstructor: Transport_1.Transport,
            transportOptions: {},
            usePreloadedRoute: false,
            // string to be inserted into User-Agent request header
            userAgentString: Constants_1.C.USER_AGENT,
            // Session parameters
            noAnswerTimeout: 60,
            // Hacks
            hackViaTcp: false,
            hackIpInContact: false,
            hackWssInTransport: false,
            hackAllowUnregisteredOptionTags: false,
            // Session Description Handler Options
            sessionDescriptionHandlerFactoryOptions: {
                constraints: {},
                peerConnectionOptions: {}
            },
            extraSupported: [],
            contactName: Utils_1.Utils.createRandomToken(8),
            contactTransport: "ws",
            forceRport: false,
            // autostarting
            autostart: true,
            autostop: true,
            // Reliable Provisional Responses
            rel100: Constants_1.C.supported.UNSUPPORTED,
            // DTMF type: 'info' or 'rtp' (RFC 4733)
            // RTP Payload Spec: https://tools.ietf.org/html/rfc4733
            // WebRTC Audio Spec: https://tools.ietf.org/html/rfc7874
            dtmfType: Constants_1.C.dtmfType.INFO,
            // Replaces header (RFC 3891)
            // http://tools.ietf.org/html/rfc3891
            replaces: Constants_1.C.supported.UNSUPPORTED,
            sessionDescriptionHandlerFactory: SessionDescriptionHandler_1.SessionDescriptionHandler.defaultFactory,
            authenticationFactory: this.checkAuthenticationFactory(function (ua) {
                return new core_1.DigestAuthentication(ua.getLoggerFactory(), _this.configuration.authorizationUser, _this.configuration.password);
            }),
            allowLegacyNotifications: false,
            allowOutOfDialogRefers: false,
            experimentalFeatures: false
        };
        var configCheck = this.getConfigurationCheck();
        // Check Mandatory parameters
        for (var parameter in configCheck.mandatory) {
            if (!configuration.hasOwnProperty(parameter)) {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
            }
            else {
                var value = configuration[parameter];
                var checkedValue = configCheck.mandatory[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Check Optional parameters
        for (var parameter in configCheck.optional) {
            if (configuration.hasOwnProperty(parameter)) {
                var value = configuration[parameter];
                // If the parameter value is an empty array, but shouldn't be, apply its default value.
                // If the parameter value is null, empty string, or undefined then apply its default value.
                // If it's a number with NaN value then also apply its default value.
                // NOTE: JS does not allow "value === NaN", the following does the work:
                if ((value instanceof Array && value.length === 0) ||
                    (value === null || value === "" || value === undefined) ||
                    (typeof (value) === "number" && isNaN(value))) {
                    continue;
                }
                var checkedValue = configCheck.optional[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Post Configuration Process
        // Allow passing 0 number as displayName.
        if (settings.displayName === 0) {
            settings.displayName = "0";
        }
        // sipjsId instance parameter. Static random tag of length 5
        settings.sipjsId = Utils_1.Utils.createRandomToken(5);
        // String containing settings.uri without scheme and user.
        var hostportParams = settings.uri.clone();
        hostportParams.user = undefined;
        settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, "");
        /* Check whether authorizationUser is explicitly defined.
         * Take 'settings.uri.user' value if not.
         */
        if (!settings.authorizationUser) {
            settings.authorizationUser = settings.uri.user;
        }
        // User noAnswerTimeout
        settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;
        // Via Host
        if (settings.hackIpInContact) {
            if (typeof settings.hackIpInContact === "boolean") {
                var from = 1;
                var to = 254;
                var octet = Math.floor(Math.random() * (to - from + 1) + from);
                // random Test-Net IP (http://tools.ietf.org/html/rfc5735)
                settings.viaHost = "192.0.2." + octet;
            }
            else if (typeof settings.hackIpInContact === "string") {
                settings.viaHost = settings.hackIpInContact;
            }
        }
        // Contact transport parameter
        if (settings.hackWssInTransport) {
            settings.contactTransport = "wss";
        }
        this.contact = {
            pubGruu: undefined,
            tempGruu: undefined,
            uri: new core_1.URI("sip", settings.contactName, settings.viaHost, undefined, { transport: settings.contactTransport }),
            toString: function (options) {
                if (options === void 0) { options = {}; }
                var anonymous = options.anonymous || false;
                var outbound = options.outbound || false;
                var contact = "<";
                if (anonymous) {
                    contact += (_this.contact.tempGruu ||
                        ("sip:anonymous@anonymous.invalid;transport=" + settings.contactTransport)).toString();
                }
                else {
                    contact += (_this.contact.pubGruu || _this.contact.uri).toString();
                }
                if (outbound) {
                    contact += ";ob";
                }
                contact += ">";
                return contact;
            }
        };
        var skeleton = {};
        // Fill the value of the configuration_skeleton
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                skeleton[parameter] = settings[parameter];
            }
        }
        Object.assign(this.configuration, skeleton);
        this.logger.log("configuration parameters after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                switch (parameter) {
                    case "uri":
                    case "sessionDescriptionHandlerFactory":
                        this.logger.log("· " + parameter + ": " + settings[parameter]);
                        break;
                    case "password":
                        this.logger.log("· " + parameter + ": " + "NOT SHOWN");
                        break;
                    case "transportConstructor":
                        this.logger.log("· " + parameter + ": " + settings[parameter].name);
                        break;
                    default:
                        this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
                }
            }
        }
        return;
    };
    /**
     * Configuration checker.
     * @return {Boolean}
     */
    UA.prototype.getConfigurationCheck = function () {
        return {
            mandatory: {},
            optional: {
                uri: function (uri) {
                    if (!(/^sip:/i).test(uri)) {
                        uri = Constants_1.C.SIP + ":" + uri;
                    }
                    var parsed = core_1.Grammar.URIParse(uri);
                    if (!parsed || !parsed.user) {
                        return;
                    }
                    else {
                        return parsed;
                    }
                },
                transportConstructor: function (transportConstructor) {
                    if (transportConstructor instanceof Function) {
                        return transportConstructor;
                    }
                },
                transportOptions: function (transportOptions) {
                    if (typeof transportOptions === "object") {
                        return transportOptions;
                    }
                },
                authorizationUser: function (authorizationUser) {
                    if (core_1.Grammar.parse('"' + authorizationUser + '"', "quoted_string") === -1) {
                        return;
                    }
                    else {
                        return authorizationUser;
                    }
                },
                displayName: function (displayName) {
                    if (core_1.Grammar.parse('"' + displayName + '"', "displayName") === -1) {
                        return;
                    }
                    else {
                        return displayName;
                    }
                },
                dtmfType: function (dtmfType) {
                    switch (dtmfType) {
                        case Constants_1.C.dtmfType.RTP:
                            return Constants_1.C.dtmfType.RTP;
                        case Constants_1.C.dtmfType.INFO:
                        // Fall through
                        default:
                            return Constants_1.C.dtmfType.INFO;
                    }
                },
                hackViaTcp: function (hackViaTcp) {
                    if (typeof hackViaTcp === "boolean") {
                        return hackViaTcp;
                    }
                },
                hackIpInContact: function (hackIpInContact) {
                    if (typeof hackIpInContact === "boolean") {
                        return hackIpInContact;
                    }
                    else if (typeof hackIpInContact === "string" && core_1.Grammar.parse(hackIpInContact, "host") !== -1) {
                        return hackIpInContact;
                    }
                },
                hackWssInTransport: function (hackWssInTransport) {
                    if (typeof hackWssInTransport === "boolean") {
                        return hackWssInTransport;
                    }
                },
                hackAllowUnregisteredOptionTags: function (hackAllowUnregisteredOptionTags) {
                    if (typeof hackAllowUnregisteredOptionTags === "boolean") {
                        return hackAllowUnregisteredOptionTags;
                    }
                },
                contactTransport: function (contactTransport) {
                    if (typeof contactTransport === "string") {
                        return contactTransport;
                    }
                },
                extraSupported: function (optionTags) {
                    if (!(optionTags instanceof Array)) {
                        return;
                    }
                    for (var _i = 0, optionTags_1 = optionTags; _i < optionTags_1.length; _i++) {
                        var tag = optionTags_1[_i];
                        if (typeof tag !== "string") {
                            return;
                        }
                    }
                    return optionTags;
                },
                forceRport: function (forceRport) {
                    if (typeof forceRport === "boolean") {
                        return forceRport;
                    }
                },
                noAnswerTimeout: function (noAnswerTimeout) {
                    if (Utils_1.Utils.isDecimal(noAnswerTimeout)) {
                        var value = Number(noAnswerTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                password: function (password) {
                    return String(password);
                },
                rel100: function (rel100) {
                    if (rel100 === Constants_1.C.supported.REQUIRED) {
                        return Constants_1.C.supported.REQUIRED;
                    }
                    else if (rel100 === Constants_1.C.supported.SUPPORTED) {
                        return Constants_1.C.supported.SUPPORTED;
                    }
                    else {
                        return Constants_1.C.supported.UNSUPPORTED;
                    }
                },
                replaces: function (replaces) {
                    if (replaces === Constants_1.C.supported.REQUIRED) {
                        return Constants_1.C.supported.REQUIRED;
                    }
                    else if (replaces === Constants_1.C.supported.SUPPORTED) {
                        return Constants_1.C.supported.SUPPORTED;
                    }
                    else {
                        return Constants_1.C.supported.UNSUPPORTED;
                    }
                },
                register: function (register) {
                    if (typeof register === "boolean") {
                        return register;
                    }
                },
                registerOptions: function (registerOptions) {
                    if (typeof registerOptions === "object") {
                        return registerOptions;
                    }
                },
                usePreloadedRoute: function (usePreloadedRoute) {
                    if (typeof usePreloadedRoute === "boolean") {
                        return usePreloadedRoute;
                    }
                },
                userAgentString: function (userAgentString) {
                    if (typeof userAgentString === "string") {
                        return userAgentString;
                    }
                },
                autostart: function (autostart) {
                    if (typeof autostart === "boolean") {
                        return autostart;
                    }
                },
                autostop: function (autostop) {
                    if (typeof autostop === "boolean") {
                        return autostop;
                    }
                },
                sessionDescriptionHandlerFactory: function (sessionDescriptionHandlerFactory) {
                    if (sessionDescriptionHandlerFactory instanceof Function) {
                        return sessionDescriptionHandlerFactory;
                    }
                },
                sessionDescriptionHandlerFactoryOptions: function (options) {
                    if (typeof options === "object") {
                        return options;
                    }
                },
                authenticationFactory: this.checkAuthenticationFactory,
                allowLegacyNotifications: function (allowLegacyNotifications) {
                    if (typeof allowLegacyNotifications === "boolean") {
                        return allowLegacyNotifications;
                    }
                },
                custom: function (custom) {
                    if (typeof custom === "object") {
                        return custom;
                    }
                },
                contactName: function (contactName) {
                    if (typeof contactName === "string") {
                        return contactName;
                    }
                },
                experimentalFeatures: function (experimentalFeatures) {
                    if (typeof experimentalFeatures === "boolean") {
                        return experimentalFeatures;
                    }
                },
            }
        };
    };
    UA.C = {
        // UA status codes
        STATUS_INIT: 0,
        STATUS_STARTING: 1,
        STATUS_READY: 2,
        STATUS_USER_CLOSED: 3,
        STATUS_NOT_READY: 4,
        // UA error codes
        CONFIGURATION_ERROR: 1,
        NETWORK_ERROR: 2,
        ALLOWED_METHODS: [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ],
        ACCEPTED_BODY_TYPES: [
            "application/sdp",
            "application/dtmf-relay"
        ],
        MAX_FORWARDS: 70,
        TAG_LENGTH: 10
    };
    return UA;
}(events_1.EventEmitter));
exports.UA = UA;
(function (UA) {
    var DtmfType;
    (function (DtmfType) {
        DtmfType["RTP"] = "rtp";
        DtmfType["INFO"] = "info";
    })(DtmfType = UA.DtmfType || (UA.DtmfType = {}));
})(UA = exports.UA || (exports.UA = {}));
exports.UA = UA;
/**
 * Factory function to generate configuration give a UA.
 * @param ua UA
 */
function makeUserAgentCoreConfigurationFromUA(ua) {
    // FIXME: Configuration URI is a bad mix of types currently. It also needs to exist.
    if (!(ua.configuration.uri instanceof core_1.URI)) {
        throw new Error("Configuration URI not instance of URI.");
    }
    var aor = ua.configuration.uri;
    var contact = ua.contact;
    var displayName = ua.configuration.displayName ? ua.configuration.displayName : "";
    var hackViaTcp = ua.configuration.hackViaTcp ? true : false;
    var routeSet = ua.configuration.usePreloadedRoute && ua.transport.server && ua.transport.server.sipUri ?
        [ua.transport.server.sipUri] :
        [];
    var sipjsId = ua.configuration.sipjsId || Utils_1.Utils.createRandomToken(5);
    var supportedOptionTags = [];
    supportedOptionTags.push("outbound"); // TODO: is this really supported?
    if (ua.configuration.rel100 === Constants_1.C.supported.SUPPORTED) {
        supportedOptionTags.push("100rel");
    }
    if (ua.configuration.replaces === Constants_1.C.supported.SUPPORTED) {
        supportedOptionTags.push("replaces");
    }
    if (ua.configuration.extraSupported) {
        supportedOptionTags.push.apply(supportedOptionTags, ua.configuration.extraSupported);
    }
    if (!ua.configuration.hackAllowUnregisteredOptionTags) {
        supportedOptionTags = supportedOptionTags.filter(function (optionTag) { return Constants_1.C.OPTION_TAGS[optionTag]; });
    }
    supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values
    var supportedOptionTagsResponse = ua.getSupportedResponseOptions();
    var userAgentHeaderFieldValue = ua.configuration.userAgentString || "sipjs";
    if (!(ua.configuration.viaHost)) {
        throw new Error("Configuration via host undefined");
    }
    var viaForceRport = ua.configuration.forceRport ? true : false;
    var viaHost = ua.configuration.viaHost;
    var configuration = {
        aor: aor,
        contact: contact,
        displayName: displayName,
        hackViaTcp: hackViaTcp,
        loggerFactory: ua.getLoggerFactory(),
        routeSet: routeSet,
        sipjsId: sipjsId,
        supportedOptionTags: supportedOptionTags,
        supportedOptionTagsResponse: supportedOptionTagsResponse,
        userAgentHeaderFieldValue: userAgentHeaderFieldValue,
        viaForceRport: viaForceRport,
        viaHost: viaHost,
        authenticationFactory: function () {
            if (ua.configuration.authenticationFactory) {
                return ua.configuration.authenticationFactory(ua);
            }
            return undefined;
        },
        transportAccessor: function () { return ua.transport; }
    };
    return configuration;
}
exports.makeUserAgentCoreConfigurationFromUA = makeUserAgentCoreConfigurationFromUA;


/***/ }),

/***/ "./node_modules/sip.js/lib/Utils.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/Utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
var grammar_1 = __webpack_require__(/*! ./core/messages/grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var uri_1 = __webpack_require__(/*! ./core/messages/uri */ "./node_modules/sip.js/lib/core/messages/uri.js");
var Utils;
(function (Utils) {
    function defer() {
        var deferred = {};
        deferred.promise = new Promise(function (resolve, reject) {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
        return deferred;
    }
    Utils.defer = defer;
    function reducePromises(arr, val) {
        return arr.reduce(function (acc, fn) {
            acc = acc.then(fn);
            return acc;
        }, Promise.resolve(val));
    }
    Utils.reducePromises = reducePromises;
    function str_utf8_length(str) {
        return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
    }
    Utils.str_utf8_length = str_utf8_length;
    function generateFakeSDP(body) {
        if (!body) {
            return;
        }
        var start = body.indexOf("o=");
        var end = body.indexOf("\r\n", start);
        return "v=0\r\n" + body.slice(start, end) + "\r\ns=-\r\nt=0 0\r\nc=IN IP4 0.0.0.0";
    }
    Utils.generateFakeSDP = generateFakeSDP;
    function isDecimal(num) {
        var numAsNum = parseInt(num, 10);
        return !isNaN(numAsNum) && (parseFloat(num) === numAsNum);
    }
    Utils.isDecimal = isDecimal;
    function createRandomToken(size, base) {
        if (base === void 0) { base = 32; }
        var token = "";
        for (var i = 0; i < size; i++) {
            var r = Math.floor(Math.random() * base);
            token += r.toString(base);
        }
        return token;
    }
    Utils.createRandomToken = createRandomToken;
    function newTag() {
        // used to use the constant in UA
        return Utils.createRandomToken(10);
    }
    Utils.newTag = newTag;
    // http://stackoverflow.com/users/109538/broofa
    function newUUID() {
        var UUID = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            var r = Math.floor(Math.random() * 16);
            var v = c === "x" ? r : (r % 4 + 8);
            return v.toString(16);
        });
        return UUID;
    }
    Utils.newUUID = newUUID;
    /*
     * Normalize SIP URI.
     * NOTE: It does not allow a SIP URI without username.
     * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
     * Detects the domain part (if given) and properly hex-escapes the user portion.
     * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
     * @private
     * @param {String} target
     * @param {String} [domain]
     */
    function normalizeTarget(target, domain) {
        // If no target is given then raise an error.
        if (!target) {
            return;
            // If a SIP.URI instance is given then return it.
        }
        else if (target instanceof uri_1.URI) {
            return target;
            // If a string is given split it by '@':
            // - Last fragment is the desired domain.
            // - Otherwise append the given domain argument.
        }
        else if (typeof target === "string") {
            var targetArray = target.split("@");
            var targetUser = void 0;
            var targetDomain = void 0;
            switch (targetArray.length) {
                case 1:
                    if (!domain) {
                        return;
                    }
                    targetUser = target;
                    targetDomain = domain;
                    break;
                case 2:
                    targetUser = targetArray[0];
                    targetDomain = targetArray[1];
                    break;
                default:
                    targetUser = targetArray.slice(0, targetArray.length - 1).join("@");
                    targetDomain = targetArray[targetArray.length - 1];
            }
            // Remove the URI scheme (if present).
            targetUser = targetUser.replace(/^(sips?|tel):/i, "");
            // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
            if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(targetUser)) {
                targetUser = targetUser.replace(/[\-\.\(\)]/g, "");
            }
            // Build the complete SIP URI.
            target = Constants_1.C.SIP + ":" + Utils.escapeUser(targetUser) + "@" + targetDomain;
            // Finally parse the resulting URI.
            return grammar_1.Grammar.URIParse(target);
        }
        else {
            return;
        }
    }
    Utils.normalizeTarget = normalizeTarget;
    /*
     * Hex-escape a SIP URI user.
     * @private
     * @param {String} user
     */
    function escapeUser(user) {
        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
        return encodeURIComponent(decodeURIComponent(user))
            .replace(/%3A/ig, ":")
            .replace(/%2B/ig, "+")
            .replace(/%3F/ig, "?")
            .replace(/%2F/ig, "/");
    }
    Utils.escapeUser = escapeUser;
    function headerize(str) {
        var exceptions = {
            "Call-Id": "Call-ID",
            "Cseq": "CSeq",
            "Min-Se": "Min-SE",
            "Rack": "RAck",
            "Rseq": "RSeq",
            "Www-Authenticate": "WWW-Authenticate",
        };
        var name = str.toLowerCase().replace(/_/g, "-").split("-");
        var parts = name.length;
        var hname = "";
        for (var part = 0; part < parts; part++) {
            if (part !== 0) {
                hname += "-";
            }
            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
        }
        if (exceptions[hname]) {
            hname = exceptions[hname];
        }
        return hname;
    }
    Utils.headerize = headerize;
    function sipErrorCause(statusCode) {
        for (var cause in Constants_1.C.SIP_ERROR_CAUSES) {
            if (Constants_1.C.SIP_ERROR_CAUSES[cause].indexOf(statusCode) !== -1) {
                return Constants_1.C.causes[cause];
            }
        }
        return Constants_1.C.causes.SIP_FAILURE_CODE;
    }
    Utils.sipErrorCause = sipErrorCause;
    function getReasonPhrase(code, specific) {
        return specific || Constants_1.C.REASON_PHRASE[code] || "";
    }
    Utils.getReasonPhrase = getReasonPhrase;
    function getReasonHeaderValue(code, reason) {
        reason = Utils.getReasonPhrase(code, reason);
        return "SIP;cause=" + code + ';text="' + reason + '"';
    }
    Utils.getReasonHeaderValue = getReasonHeaderValue;
    function getCancelReason(code, reason) {
        if (code && code < 200 || code > 699) {
            throw new TypeError("Invalid statusCode: " + code);
        }
        else if (code) {
            return Utils.getReasonHeaderValue(code, reason);
        }
    }
    Utils.getCancelReason = getCancelReason;
    function buildStatusLine(code, reason) {
        // Validate code and reason values
        if (!code || (code < 100 || code > 699)) {
            throw new TypeError("Invalid statusCode: " + code);
        }
        else if (reason && typeof reason !== "string" && !(reason instanceof String)) {
            throw new TypeError("Invalid reason: " + reason);
        }
        reason = Utils.getReasonPhrase(code, reason);
        return "SIP/2.0 " + code + " " + reason + "\r\n";
    }
    Utils.buildStatusLine = buildStatusLine;
    /**
     * Create a Body given a BodyObj.
     * @param bodyObj Body Object
     */
    function fromBodyObj(bodyObj) {
        var content = bodyObj.body;
        var contentType = bodyObj.contentType;
        var contentDisposition = contentTypeToContentDisposition(contentType);
        var body = { contentDisposition: contentDisposition, contentType: contentType, content: content };
        return body;
    }
    Utils.fromBodyObj = fromBodyObj;
    /**
     * Create a BodyObj given a Body.
     * @param bodyObj Body Object
     */
    function toBodyObj(body) {
        var bodyObj = {
            body: body.content,
            contentType: body.contentType
        };
        return bodyObj;
    }
    Utils.toBodyObj = toBodyObj;
    // If the Content-Disposition header field is missing, bodies of
    // Content-Type application/sdp imply the disposition "session", while
    // other content types imply "render".
    // https://tools.ietf.org/html/rfc3261#section-13.2.1
    function contentTypeToContentDisposition(contentType) {
        if (contentType === "application/sdp") {
            return "session";
        }
        else {
            return "render";
        }
    }
})(Utils = exports.Utils || (exports.Utils = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Modifiers.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Modifiers.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var stripPayload = function (sdp, payload) {
    var mediaDescs = [];
    var lines = sdp.split(/\r\n/);
    var currentMediaDesc;
    for (var i = 0; i < lines.length;) {
        var line = lines[i];
        if (/^m=(?:audio|video)/.test(line)) {
            currentMediaDesc = {
                index: i,
                stripped: []
            };
            mediaDescs.push(currentMediaDesc);
        }
        else if (currentMediaDesc) {
            var rtpmap = /^a=rtpmap:(\d+) ([^/]+)\//.exec(line);
            if (rtpmap && payload === rtpmap[2]) {
                lines.splice(i, 1);
                currentMediaDesc.stripped.push(rtpmap[1]);
                continue; // Don't increment 'i'
            }
        }
        i++;
    }
    for (var _i = 0, mediaDescs_1 = mediaDescs; _i < mediaDescs_1.length; _i++) {
        var mediaDesc = mediaDescs_1[_i];
        var mline = lines[mediaDesc.index].split(" ");
        // Ignore the first 3 parameters of the mline. The codec information is after that
        for (var j = 3; j < mline.length;) {
            if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {
                mline.splice(j, 1);
                continue;
            }
            j++;
        }
        lines[mediaDesc.index] = mline.join(" ");
    }
    return lines.join("\r\n");
};
var stripMediaDescription = function (sdp, description) {
    var descriptionRegExp = new RegExp("m=" + description + ".*$", "gm");
    var groupRegExp = new RegExp("^a=group:.*$", "gm");
    if (descriptionRegExp.test(sdp)) {
        var midLineToRemove_1;
        sdp = sdp.split(/^m=/gm).filter(function (section) {
            if (section.substr(0, description.length) === description) {
                midLineToRemove_1 = section.match(/^a=mid:.*$/gm);
                if (midLineToRemove_1) {
                    var step = midLineToRemove_1[0].match(/:.+$/g);
                    if (step) {
                        midLineToRemove_1 = step[0].substr(1);
                    }
                }
                return false;
            }
            return true;
        }).join("m=");
        var groupLine = sdp.match(groupRegExp);
        if (groupLine && groupLine.length === 1) {
            var groupLinePortion = groupLine[0];
            var groupRegExpReplace = new RegExp("\ *" + midLineToRemove_1 + "[^\ ]*", "g");
            groupLinePortion = groupLinePortion.replace(groupRegExpReplace, "");
            sdp = sdp.split(groupRegExp).join(groupLinePortion);
        }
    }
    return sdp;
};
function stripTcpCandidates(description) {
    description.sdp = (description.sdp || "").replace(/^a=candidate:\d+ \d+ tcp .*?\r\n/img, "");
    return Promise.resolve(description);
}
exports.stripTcpCandidates = stripTcpCandidates;
function stripTelephoneEvent(description) {
    description.sdp = stripPayload(description.sdp || "", "telephone-event");
    return Promise.resolve(description);
}
exports.stripTelephoneEvent = stripTelephoneEvent;
function cleanJitsiSdpImageattr(description) {
    description.sdp = (description.sdp || "").replace(/^(a=imageattr:.*?)(x|y)=\[0-/gm, "$1$2=[1:");
    return Promise.resolve(description);
}
exports.cleanJitsiSdpImageattr = cleanJitsiSdpImageattr;
function stripG722(description) {
    description.sdp = stripPayload(description.sdp || "", "G722");
    return Promise.resolve(description);
}
exports.stripG722 = stripG722;
function stripRtpPayload(payload) {
    return function (description) {
        description.sdp = stripPayload(description.sdp || "", payload);
        return Promise.resolve(description);
    };
}
exports.stripRtpPayload = stripRtpPayload;
function stripVideo(description) {
    description.sdp = stripMediaDescription(description.sdp || "", "video");
    return Promise.resolve(description);
}
exports.stripVideo = stripVideo;
function addMidLines(description) {
    var sdp = description.sdp || "";
    if (sdp.search(/^a=mid.*$/gm) === -1) {
        var mlines_1 = sdp.match(/^m=.*$/gm);
        var sdpArray_1 = sdp.split(/^m=.*$/gm);
        if (mlines_1) {
            mlines_1.forEach(function (elem, idx) {
                mlines_1[idx] = elem + "\na=mid:" + idx;
            });
        }
        sdpArray_1.forEach(function (elem, idx) {
            if (mlines_1 && mlines_1[idx]) {
                sdpArray_1[idx] = elem + mlines_1[idx];
            }
        });
        sdp = sdpArray_1.join("");
        description.sdp = sdp;
    }
    return Promise.resolve(description);
}
exports.addMidLines = addMidLines;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js":
/*!******************************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var session_1 = __webpack_require__(/*! ../api/session */ "./node_modules/sip.js/lib/api/session.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
var SessionDescriptionHandlerObserver_1 = __webpack_require__(/*! ./SessionDescriptionHandlerObserver */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js");
/* SessionDescriptionHandler
 * @class PeerConnection helper Class.
 * @param {SIP.Session} session
 * @param {Object} [options]
 */
var SessionDescriptionHandler = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDescriptionHandler, _super);
    function SessionDescriptionHandler(logger, observer, options) {
        var _this = _super.call(this) || this;
        _this.type = Enums_1.TypeStrings.SessionDescriptionHandler;
        // TODO: Validate the options
        _this.options = options || {};
        _this.logger = logger;
        _this.observer = observer;
        _this.dtmfSender = undefined;
        _this.shouldAcquireMedia = true;
        _this.CONTENT_TYPE = "application/sdp";
        _this.C = {
            DIRECTION: {
                NULL: null,
                SENDRECV: "sendrecv",
                SENDONLY: "sendonly",
                RECVONLY: "recvonly",
                INACTIVE: "inactive"
            }
        };
        _this.logger.log("SessionDescriptionHandlerOptions: " + JSON.stringify(_this.options));
        _this.direction = _this.C.DIRECTION.NULL;
        _this.modifiers = _this.options.modifiers || [];
        if (!Array.isArray(_this.modifiers)) {
            _this.modifiers = [_this.modifiers];
        }
        _this.iceGatheringTimeout = false;
        _this.initPeerConnection(_this.options.peerConnectionOptions);
        _this.constraints = _this.checkAndDefaultConstraints(_this.options.constraints);
        return _this;
    }
    /**
     * @param {SIP.Session} session
     * @param {Object} [options]
     */
    SessionDescriptionHandler.defaultFactory = function (session, options) {
        var logger = (session instanceof session_1.Session) ?
            session.userAgent.getLogger("sip.sessionDescriptionHandler", session.id) :
            session.ua.getLogger("sip.invitecontext.sessionDescriptionHandler", session.id);
        var observer = new SessionDescriptionHandlerObserver_1.SessionDescriptionHandlerObserver(session, options);
        return new SessionDescriptionHandler(logger, observer, options);
    };
    // Functions the sesssion can use
    /**
     * Destructor
     */
    SessionDescriptionHandler.prototype.close = function () {
        this.logger.log("closing PeerConnection");
        // have to check signalingState since this.close() gets called multiple times
        if (this.peerConnection && this.peerConnection.signalingState !== "closed") {
            if (this.peerConnection.getSenders) {
                this.peerConnection.getSenders().forEach(function (sender) {
                    if (sender.track) {
                        sender.track.stop();
                    }
                });
            }
            else {
                this.logger.warn("Using getLocalStreams which is deprecated");
                this.peerConnection.getLocalStreams().forEach(function (stream) {
                    stream.getTracks().forEach(function (track) {
                        track.stop();
                    });
                });
            }
            if (this.peerConnection.getReceivers) {
                this.peerConnection.getReceivers().forEach(function (receiver) {
                    if (receiver.track) {
                        receiver.track.stop();
                    }
                });
            }
            else {
                this.logger.warn("Using getRemoteStreams which is deprecated");
                this.peerConnection.getRemoteStreams().forEach(function (stream) {
                    stream.getTracks().forEach(function (track) {
                        track.stop();
                    });
                });
            }
            this.resetIceGatheringComplete();
            this.peerConnection.close();
        }
    };
    /**
     * Gets the local description from the underlying media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
     *   connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves with the local description to be used for the session
     */
    SessionDescriptionHandler.prototype.getDescription = function (options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (options.peerConnectionOptions) {
            this.initPeerConnection(options.peerConnectionOptions);
        }
        // Merge passed constraints with saved constraints and save
        var newConstraints = Object.assign({}, this.constraints, options.constraints);
        newConstraints = this.checkAndDefaultConstraints(newConstraints);
        if (JSON.stringify(newConstraints) !== JSON.stringify(this.constraints)) {
            this.constraints = newConstraints;
            this.shouldAcquireMedia = true;
        }
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers = modifiers.concat(this.modifiers);
        return Promise.resolve().then(function () {
            if (_this.shouldAcquireMedia) {
                return _this.acquire(_this.constraints).then(function () {
                    _this.shouldAcquireMedia = false;
                });
            }
        }).then(function () { return _this.createOfferOrAnswer(options.RTCOfferOptions, modifiers); })
            .then(function (description) {
            if (description.sdp === undefined) {
                throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("getDescription", undefined, "SDP undefined");
            }
            _this.emit("getDescription", description);
            return {
                body: description.sdp,
                contentType: _this.CONTENT_TYPE
            };
        });
    };
    /**
     * Check if the Session Description Handler can handle the Content-Type described by a SIP Message
     * @param {String} contentType The content type that is in the SIP Message
     * @returns {boolean}
     */
    SessionDescriptionHandler.prototype.hasDescription = function (contentType) {
        return contentType === this.CONTENT_TYPE;
    };
    /**
     * The modifier that should be used when the session would like to place the call on hold
     * @param {String} [sdp] The description that will be modified
     * @returns {Promise} Promise that resolves with modified SDP
     */
    SessionDescriptionHandler.prototype.holdModifier = function (description) {
        if (!description.sdp) {
            return Promise.resolve(description);
        }
        if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(description.sdp)) {
            description.sdp = description.sdp.replace(/(m=[^\r]*\r\n)/g, "$1a=sendonly\r\n");
        }
        else {
            description.sdp = description.sdp.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n");
            description.sdp = description.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n");
        }
        return Promise.resolve(description);
    };
    /**
     * Set the remote description to the underlying media implementation
     * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation
     * @param {Object} [options] Options object to be used by getDescription
     * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints
     *   https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints
     * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer
     *   connection with the new options
     * @param {Array} [modifiers] Array with one time use description modifiers
     * @returns {Promise} Promise that resolves once the description is set
     */
    SessionDescriptionHandler.prototype.setDescription = function (sessionDescription, options, modifiers) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (modifiers === void 0) { modifiers = []; }
        if (options.peerConnectionOptions) {
            this.initPeerConnection(options.peerConnectionOptions);
        }
        if (!Array.isArray(modifiers)) {
            modifiers = [modifiers];
        }
        modifiers = modifiers.concat(this.modifiers);
        var description = {
            type: this.hasOffer("local") ? "answer" : "offer",
            sdp: sessionDescription
        };
        return Promise.resolve().then(function () {
            // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)
            if (_this.shouldAcquireMedia && _this.options.alwaysAcquireMediaFirst) {
                return _this.acquire(_this.constraints).then(function () {
                    _this.shouldAcquireMedia = false;
                });
            }
        }).then(function () { return Utils_1.Utils.reducePromises(modifiers, description); })
            .catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e, "The modifiers did not resolve successfully");
            _this.logger.error(error.message);
            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
            throw error;
        }).then(function (modifiedDescription) {
            _this.emit("setDescription", modifiedDescription);
            return _this.peerConnection.setRemoteDescription(modifiedDescription);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            // Check the original SDP for video, and ensure that we have want to do audio fallback
            if ((/^m=video.+$/gm).test(sessionDescription) && !options.disableAudioFallback) {
                // Do not try to audio fallback again
                options.disableAudioFallback = true;
                // Remove video first, then do the other modifiers
                return _this.setDescription(sessionDescription, options, [Modifiers.stripVideo].concat(modifiers));
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("setDescription", e);
            if (error.error) {
                _this.logger.error(error.error);
            }
            _this.emit("peerConnection-setRemoteDescriptionFailed", error);
            throw error;
        }).then(function () {
            if (_this.peerConnection.getReceivers) {
                _this.emit("setRemoteDescription", _this.peerConnection.getReceivers());
            }
            else {
                _this.emit("setRemoteDescription", _this.peerConnection.getRemoteStreams());
            }
            _this.emit("confirmed", _this);
        });
    };
    /**
     * Send DTMF via RTP (RFC 4733)
     * @param {String} tones A string containing DTMF digits
     * @param {Object} [options] Options object to be used by sendDtmf
     * @returns {boolean} true if DTMF send is successful, false otherwise
     */
    SessionDescriptionHandler.prototype.sendDtmf = function (tones, options) {
        if (options === void 0) { options = {}; }
        if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {
            var senders = this.peerConnection.getSenders();
            if (senders.length > 0) {
                this.dtmfSender = senders[0].dtmf;
            }
        }
        if (!this.dtmfSender && this.hasBrowserTrackSupport()) {
            var streams = this.peerConnection.getLocalStreams();
            if (streams.length > 0) {
                var audioTracks = streams[0].getAudioTracks();
                if (audioTracks.length > 0) {
                    this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);
                }
            }
        }
        if (!this.dtmfSender) {
            return false;
        }
        try {
            this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);
        }
        catch (e) {
            if (e.type === "InvalidStateError" || e.type === "InvalidCharacterError") {
                this.logger.error(e);
                return false;
            }
            else {
                throw e;
            }
        }
        this.logger.log("DTMF sent via RTP: " + tones.toString());
        return true;
    };
    /**
     * Get the direction of the session description
     * @returns {String} direction of the description
     */
    SessionDescriptionHandler.prototype.getDirection = function () {
        return this.direction;
    };
    SessionDescriptionHandler.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    SessionDescriptionHandler.prototype.getMediaStream = function (constraints) {
        return navigator.mediaDevices.getUserMedia(constraints);
    };
    // Internal functions
    SessionDescriptionHandler.prototype.createOfferOrAnswer = function (RTCOfferOptions, modifiers) {
        var _this = this;
        if (RTCOfferOptions === void 0) { RTCOfferOptions = {}; }
        if (modifiers === void 0) { modifiers = []; }
        var methodName = this.hasOffer("remote") ? "createAnswer" : "createOffer";
        var pc = this.peerConnection;
        this.logger.log(methodName);
        var method = this.hasOffer("remote") ? pc.createAnswer : pc.createOffer;
        return method.apply(pc, RTCOfferOptions).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-" + methodName + "Failed");
            _this.emit("peerConnection-" + methodName + "Failed", error);
            throw error;
        }).then(function (sdp) {
            return Utils_1.Utils.reducePromises(modifiers, _this.createRTCSessionDescriptionInit(sdp));
        }).then(function (sdp) {
            _this.resetIceGatheringComplete();
            _this.logger.log("Setting local sdp.");
            _this.logger.log("sdp is " + sdp.sdp || false);
            return pc.setLocalDescription(sdp);
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e, "peerConnection-SetLocalDescriptionFailed");
            _this.emit("peerConnection-SetLocalDescriptionFailed", error);
            throw error;
        }).then(function () { return _this.waitForIceGatheringComplete(); })
            .then(function () {
            if (!_this.peerConnection.localDescription) {
                throw new Exceptions_1.Exceptions.SessionDescriptionHandlerError("Missing local description");
            }
            var localDescription = _this.createRTCSessionDescriptionInit(_this.peerConnection.localDescription);
            return Utils_1.Utils.reducePromises(modifiers, localDescription);
        }).then(function (localDescription) {
            _this.setDirection(localDescription.sdp || "");
            return localDescription;
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("createOfferOrAnswer", e);
            _this.logger.error(error.toString());
            throw error;
        });
    };
    // Creates an RTCSessionDescriptionInit from an RTCSessionDescription
    SessionDescriptionHandler.prototype.createRTCSessionDescriptionInit = function (RTCSessionDescription) {
        return {
            type: RTCSessionDescription.type,
            sdp: RTCSessionDescription.sdp
        };
    };
    SessionDescriptionHandler.prototype.addDefaultIceCheckingTimeout = function (peerConnectionOptions) {
        if (peerConnectionOptions.iceCheckingTimeout === undefined) {
            peerConnectionOptions.iceCheckingTimeout = 5000;
        }
        return peerConnectionOptions;
    };
    SessionDescriptionHandler.prototype.addDefaultIceServers = function (rtcConfiguration) {
        if (!rtcConfiguration.iceServers) {
            rtcConfiguration.iceServers = [{ urls: "stun:stun.l.google.com:19302" }];
        }
        return rtcConfiguration;
    };
    SessionDescriptionHandler.prototype.checkAndDefaultConstraints = function (constraints) {
        var defaultConstraints = { audio: true, video: !this.options.alwaysAcquireMediaFirst };
        constraints = constraints || defaultConstraints;
        // Empty object check
        if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {
            return defaultConstraints;
        }
        return constraints;
    };
    SessionDescriptionHandler.prototype.hasBrowserTrackSupport = function () {
        return Boolean(this.peerConnection.addTrack);
    };
    SessionDescriptionHandler.prototype.hasBrowserGetSenderSupport = function () {
        return Boolean(this.peerConnection.getSenders);
    };
    SessionDescriptionHandler.prototype.initPeerConnection = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        options = this.addDefaultIceCheckingTimeout(options);
        options.rtcConfiguration = options.rtcConfiguration || {};
        options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);
        this.logger.log("initPeerConnection");
        if (this.peerConnection) {
            this.logger.log("Already have a peer connection for this session. Tearing down.");
            this.resetIceGatheringComplete();
            this.peerConnection.close();
        }
        this.peerConnection = new RTCPeerConnection(options.rtcConfiguration);
        this.logger.log("New peer connection created");
        if ("ontrack" in this.peerConnection) {
            this.peerConnection.addEventListener("track", function (e) {
                _this.logger.log("track added");
                _this.observer.trackAdded();
                _this.emit("addTrack", e);
            });
        }
        else {
            this.logger.warn("Using onaddstream which is deprecated");
            this.peerConnection.onaddstream = function (e) {
                _this.logger.log("stream added");
                _this.emit("addStream", e);
            };
        }
        this.peerConnection.onicecandidate = function (e) {
            _this.emit("iceCandidate", e);
            if (e.candidate) {
                _this.logger.log("ICE candidate received: " +
                    (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));
            }
            else if (e.candidate === null) {
                // indicates the end of candidate gathering
                _this.logger.log("ICE candidate gathering complete");
                _this.triggerIceGatheringComplete();
            }
        };
        this.peerConnection.onicegatheringstatechange = function () {
            _this.logger.log("RTCIceGatheringState changed: " + _this.peerConnection.iceGatheringState);
            switch (_this.peerConnection.iceGatheringState) {
                case "gathering":
                    _this.emit("iceGathering", _this);
                    if (!_this.iceGatheringTimer && options.iceCheckingTimeout) {
                        _this.iceGatheringTimeout = false;
                        _this.iceGatheringTimer = setTimeout(function () {
                            _this.logger.log("RTCIceChecking Timeout Triggered after " + options.iceCheckingTimeout + " milliseconds");
                            _this.iceGatheringTimeout = true;
                            _this.triggerIceGatheringComplete();
                        }, options.iceCheckingTimeout);
                    }
                    break;
                case "complete":
                    _this.triggerIceGatheringComplete();
                    break;
            }
        };
        this.peerConnection.oniceconnectionstatechange = function () {
            var stateEvent;
            switch (_this.peerConnection.iceConnectionState) {
                case "new":
                    stateEvent = "iceConnection";
                    break;
                case "checking":
                    stateEvent = "iceConnectionChecking";
                    break;
                case "connected":
                    stateEvent = "iceConnectionConnected";
                    break;
                case "completed":
                    stateEvent = "iceConnectionCompleted";
                    break;
                case "failed":
                    stateEvent = "iceConnectionFailed";
                    break;
                case "disconnected":
                    stateEvent = "iceConnectionDisconnected";
                    break;
                case "closed":
                    stateEvent = "iceConnectionClosed";
                    break;
                default:
                    _this.logger.warn("Unknown iceConnection state: " + _this.peerConnection.iceConnectionState);
                    return;
            }
            _this.logger.log("ICE Connection State changed to " + stateEvent);
            _this.emit(stateEvent, _this);
        };
    };
    SessionDescriptionHandler.prototype.acquire = function (constraints) {
        var _this = this;
        // Default audio & video to true
        constraints = this.checkAndDefaultConstraints(constraints);
        return new Promise(function (resolve, reject) {
            /*
             * Make the call asynchronous, so that ICCs have a chance
             * to define callbacks to `userMediaRequest`
             */
            _this.logger.log("acquiring local media");
            _this.emit("userMediaRequest", constraints);
            if (constraints.audio || constraints.video) {
                _this.getMediaStream(constraints).then(function (streams) {
                    _this.observer.trackAdded();
                    _this.emit("userMedia", streams);
                    resolve(streams);
                }).catch(function (e) {
                    _this.emit("userMediaFailed", e);
                    reject(e);
                });
            }
            else {
                // Local streams were explicitly excluded.
                resolve([]);
            }
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "unable to acquire streams");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        }).then(function (streams) {
            _this.logger.log("acquired local media streams");
            // Remove old tracks
            if (_this.peerConnection.removeTrack) {
                _this.peerConnection.getSenders().forEach(function (sender) {
                    _this.peerConnection.removeTrack(sender);
                });
            }
            return streams;
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error removing streams");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        }).then(function (streams) {
            var streamsArr = [].concat(streams);
            streamsArr.forEach(function (stream) {
                if (_this.peerConnection.addTrack) {
                    stream.getTracks().forEach(function (track) {
                        _this.peerConnection.addTrack(track, stream);
                    });
                }
                else {
                    // Chrome 59 does not support addTrack
                    _this.peerConnection.addStream(stream);
                }
            });
            return Promise.resolve();
        }).catch(function (e) {
            if (e.type === Enums_1.TypeStrings.SessionDescriptionHandlerError) {
                throw e;
            }
            var error = new Exceptions_1.Exceptions.SessionDescriptionHandlerError("acquire", e, "error adding stream");
            _this.logger.error(error.message);
            if (error.error) {
                _this.logger.error(error.error);
            }
            throw error;
        });
    };
    SessionDescriptionHandler.prototype.hasOffer = function (where) {
        var offerState = "have-" + where + "-offer";
        return this.peerConnection.signalingState === offerState;
    };
    // ICE gathering state handling
    SessionDescriptionHandler.prototype.isIceGatheringComplete = function () {
        return this.peerConnection.iceGatheringState === "complete" || this.iceGatheringTimeout;
    };
    SessionDescriptionHandler.prototype.resetIceGatheringComplete = function () {
        this.iceGatheringTimeout = false;
        this.logger.log("resetIceGatheringComplete");
        if (this.iceGatheringTimer) {
            clearTimeout(this.iceGatheringTimer);
            this.iceGatheringTimer = undefined;
        }
        if (this.iceGatheringDeferred) {
            this.iceGatheringDeferred.reject();
            this.iceGatheringDeferred = undefined;
        }
    };
    SessionDescriptionHandler.prototype.setDirection = function (sdp) {
        var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);
        if (match === null) {
            this.direction = this.C.DIRECTION.NULL;
            this.observer.directionChanged();
            return;
        }
        var direction = match[1];
        switch (direction) {
            case this.C.DIRECTION.SENDRECV:
            case this.C.DIRECTION.SENDONLY:
            case this.C.DIRECTION.RECVONLY:
            case this.C.DIRECTION.INACTIVE:
                this.direction = direction;
                break;
            default:
                this.direction = this.C.DIRECTION.NULL;
                break;
        }
        this.observer.directionChanged();
    };
    SessionDescriptionHandler.prototype.triggerIceGatheringComplete = function () {
        if (this.isIceGatheringComplete()) {
            this.emit("iceGatheringComplete", this);
            if (this.iceGatheringTimer) {
                clearTimeout(this.iceGatheringTimer);
                this.iceGatheringTimer = undefined;
            }
            if (this.iceGatheringDeferred) {
                this.iceGatheringDeferred.resolve();
                this.iceGatheringDeferred = undefined;
            }
        }
    };
    SessionDescriptionHandler.prototype.waitForIceGatheringComplete = function () {
        this.logger.log("waitForIceGatheringComplete");
        if (this.isIceGatheringComplete()) {
            this.logger.log("ICE is already complete. Return resolved.");
            return Promise.resolve();
        }
        else if (!this.iceGatheringDeferred) {
            this.iceGatheringDeferred = Utils_1.Utils.defer();
        }
        this.logger.log("ICE is not complete. Returning promise");
        return this.iceGatheringDeferred ? this.iceGatheringDeferred.promise : Promise.resolve();
    };
    return SessionDescriptionHandler;
}(events_1.EventEmitter));
exports.SessionDescriptionHandler = SessionDescriptionHandler;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/SessionDescriptionHandlerObserver.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var session_1 = __webpack_require__(/*! ../api/session */ "./node_modules/sip.js/lib/api/session.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
/* SessionDescriptionHandlerObserver
 * @class SessionDescriptionHandler Observer Class.
 * @param {SIP.Session} session
 * @param {Object} [options]
 */
var SessionDescriptionHandlerObserver = /** @class */ (function () {
    function SessionDescriptionHandlerObserver(session, options) {
        this.type = Enums_1.TypeStrings.SessionDescriptionHandlerObserver;
        this.session = session;
        this.options = options;
    }
    SessionDescriptionHandlerObserver.prototype.trackAdded = function () {
        if (this.session instanceof session_1.Session) {
            return;
        }
        this.session.emit("trackAdded");
    };
    SessionDescriptionHandlerObserver.prototype.directionChanged = function () {
        if (this.session instanceof session_1.Session) {
            return;
        }
        this.session.emit("directionChanged");
    };
    return SessionDescriptionHandlerObserver;
}());
exports.SessionDescriptionHandlerObserver = SessionDescriptionHandlerObserver;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Simple.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Simple.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var UA_1 = __webpack_require__(/*! ../UA */ "./node_modules/sip.js/lib/UA.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
/* Simple
 * @class Simple
 */
var SimpleStatus;
(function (SimpleStatus) {
    SimpleStatus[SimpleStatus["STATUS_NULL"] = 0] = "STATUS_NULL";
    SimpleStatus[SimpleStatus["STATUS_NEW"] = 1] = "STATUS_NEW";
    SimpleStatus[SimpleStatus["STATUS_CONNECTING"] = 2] = "STATUS_CONNECTING";
    SimpleStatus[SimpleStatus["STATUS_CONNECTED"] = 3] = "STATUS_CONNECTED";
    SimpleStatus[SimpleStatus["STATUS_COMPLETED"] = 4] = "STATUS_COMPLETED";
})(SimpleStatus = exports.SimpleStatus || (exports.SimpleStatus = {}));
var Simple = /** @class */ (function (_super) {
    tslib_1.__extends(Simple, _super);
    function Simple(options) {
        var _this = _super.call(this) || this;
        /*
        *  {
        *    media: {
        *      remote: {
        *        audio: <DOM element>,
        *        video: <DOM element>
        *      },
        *      local: {
        *        video: <DOM element>
        *      }
        *    },
        *    ua: {
        *       <UA Configuration Options>
        *    }
        *  }
        */
        if (options.media.remote.video) {
            _this.video = true;
        }
        else {
            _this.video = false;
        }
        if (options.media.remote.audio) {
            _this.audio = true;
        }
        else {
            _this.audio = false;
        }
        if (!_this.audio && !_this.video) {
            // Need to do at least audio or video
            // Error
            throw new Error("At least one remote audio or video element is required for Simple.");
        }
        _this.options = options;
        // https://stackoverflow.com/questions/7944460/detect-safari-browser
        var browserUa = navigator.userAgent.toLowerCase();
        var isSafari = false;
        var isFirefox = false;
        if (browserUa.indexOf("safari") > -1 && browserUa.indexOf("chrome") < 0) {
            isSafari = true;
        }
        else if (browserUa.indexOf("firefox") > -1 && browserUa.indexOf("chrome") < 0) {
            isFirefox = true;
        }
        var sessionDescriptionHandlerFactoryOptions = {};
        if (isSafari) {
            sessionDescriptionHandlerFactoryOptions.modifiers = [Modifiers.stripG722];
        }
        if (isFirefox) {
            sessionDescriptionHandlerFactoryOptions.alwaysAcquireMediaFirst = true;
        }
        if (!_this.options.ua.uri) {
            _this.anonymous = true;
        }
        else {
            _this.anonymous = false;
        }
        _this.ua = new UA_1.UA({
            // User Configurable Options
            uri: _this.options.ua.uri,
            authorizationUser: _this.options.ua.authorizationUser,
            password: _this.options.ua.password,
            displayName: _this.options.ua.displayName,
            // Undocumented "Advanced" Options
            userAgentString: _this.options.ua.userAgentString,
            // Fixed Options
            register: true,
            sessionDescriptionHandlerFactoryOptions: sessionDescriptionHandlerFactoryOptions,
            transportOptions: {
                traceSip: _this.options.ua.traceSip,
                wsServers: _this.options.ua.wsServers
            }
        });
        _this.state = SimpleStatus.STATUS_NULL;
        _this.logger = _this.ua.getLogger("sip.simple");
        _this.ua.on("registered", function () {
            _this.emit("registered", _this.ua);
        });
        _this.ua.on("unregistered", function () {
            _this.emit("unregistered", _this.ua);
        });
        _this.ua.on("registrationFailed", function () {
            _this.emit("unregistered", _this.ua);
        });
        _this.ua.on("invite", function (session) {
            // If there is already an active session reject the incoming session
            if (_this.state !== SimpleStatus.STATUS_NULL && _this.state !== SimpleStatus.STATUS_COMPLETED) {
                _this.logger.warn("Rejecting incoming call. Simple only supports 1 call at a time");
                session.reject();
                return;
            }
            _this.session = session;
            _this.setupSession();
            _this.emit("ringing", _this.session);
        });
        _this.ua.on("message", function (message) {
            _this.emit("message", message);
        });
        return _this;
    }
    Simple.prototype.call = function (destination) {
        if (!this.ua || !this.checkRegistration()) {
            this.logger.warn("A registered UA is required for calling");
            return;
        }
        if (this.state !== SimpleStatus.STATUS_NULL && this.state !== SimpleStatus.STATUS_COMPLETED) {
            this.logger.warn("Cannot make more than a single call with Simple");
            return;
        }
        // Safari hack, because you cannot call .play() from a non user action
        if (this.options.media.remote.audio) {
            this.options.media.remote.audio.autoplay = true;
        }
        if (this.options.media.remote.video) {
            this.options.media.remote.video.autoplay = true;
        }
        if (this.options.media.local && this.options.media.local.video) {
            this.options.media.local.video.autoplay = true;
            this.options.media.local.video.volume = 0;
        }
        this.session = this.ua.invite(destination, {
            sessionDescriptionHandlerOptions: {
                constraints: {
                    audio: this.audio,
                    video: this.video
                }
            }
        });
        this.setupSession();
        return this.session;
    };
    Simple.prototype.answer = function () {
        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
            this.logger.warn("No call to answer");
            return;
        }
        // Safari hack, because you cannot call .play() from a non user action
        if (this.options.media.remote.audio) {
            this.options.media.remote.audio.autoplay = true;
        }
        if (this.options.media.remote.video) {
            this.options.media.remote.video.autoplay = true;
        }
        return this.session.accept({
            sessionDescriptionHandlerOptions: {
                constraints: {
                    audio: this.audio,
                    video: this.video
                }
            }
        });
        // emit call is active
    };
    Simple.prototype.reject = function () {
        if (this.state !== SimpleStatus.STATUS_NEW && this.state !== SimpleStatus.STATUS_CONNECTING) {
            this.logger.warn("Call is already answered");
            return;
        }
        return this.session.reject();
    };
    Simple.prototype.hangup = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED &&
            this.state !== SimpleStatus.STATUS_CONNECTING &&
            this.state !== SimpleStatus.STATUS_NEW) {
            this.logger.warn("No active call to hang up on");
            return;
        }
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            return this.session.cancel();
        }
        else if (this.session) {
            return this.session.bye();
        }
    };
    Simple.prototype.hold = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || this.session.localHold) {
            this.logger.warn("Cannot put call on hold");
            return;
        }
        this.mute();
        this.logger.log("Placing session on hold");
        return this.session.hold();
    };
    Simple.prototype.unhold = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session || !this.session.localHold) {
            this.logger.warn("Cannot unhold a call that is not on hold");
            return;
        }
        this.unmute();
        this.logger.log("Placing call off hold");
        return this.session.unhold();
    };
    Simple.prototype.mute = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            this.logger.warn("An acitve call is required to mute audio");
            return;
        }
        this.logger.log("Muting Audio");
        this.toggleMute(true);
        this.emit("mute", this);
    };
    Simple.prototype.unmute = function () {
        if (this.state !== SimpleStatus.STATUS_CONNECTED) {
            this.logger.warn("An active call is required to unmute audio");
            return;
        }
        this.logger.log("Unmuting Audio");
        this.toggleMute(false);
        this.emit("unmute", this);
    };
    Simple.prototype.sendDTMF = function (tone) {
        if (this.state !== SimpleStatus.STATUS_CONNECTED || !this.session) {
            this.logger.warn("An active call is required to send a DTMF tone");
            return;
        }
        this.logger.log("Sending DTMF tone: " + tone);
        this.session.dtmf(tone);
    };
    Simple.prototype.message = function (destination, message) {
        if (!this.ua || !this.checkRegistration()) {
            this.logger.warn("A registered UA is required to send a message");
            return;
        }
        if (!destination || !message) {
            this.logger.warn("A destination and message are required to send a message");
            return;
        }
        this.ua.message(destination, message);
    };
    // Private Helpers
    Simple.prototype.checkRegistration = function () {
        return (this.anonymous || (this.ua && this.ua.isRegistered()));
    };
    Simple.prototype.setupRemoteMedia = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session to set remote media on");
            return;
        }
        // If there is a video track, it will attach the video and audio to the same element
        var pc = this.session.sessionDescriptionHandler.peerConnection;
        var remoteStream;
        if (pc.getReceivers) {
            remoteStream = new MediaStream();
            pc.getReceivers().forEach(function (receiver) {
                var track = receiver.track;
                if (track) {
                    remoteStream.addTrack(track);
                }
            });
        }
        else {
            remoteStream = pc.getRemoteStreams()[0];
        }
        if (this.video) {
            this.options.media.remote.video.srcObject = remoteStream;
            this.options.media.remote.video.play().catch(function () {
                _this.logger.log("play was rejected");
            });
        }
        else if (this.audio) {
            this.options.media.remote.audio.srcObject = remoteStream;
            this.options.media.remote.audio.play().catch(function () {
                _this.logger.log("play was rejected");
            });
        }
    };
    Simple.prototype.setupLocalMedia = function () {
        if (!this.session) {
            this.logger.warn("No session to set local media on");
            return;
        }
        if (this.video && this.options.media.local && this.options.media.local.video) {
            var pc = this.session.sessionDescriptionHandler.peerConnection;
            var localStream_1;
            if (pc.getSenders) {
                localStream_1 = new MediaStream();
                pc.getSenders().forEach(function (sender) {
                    var track = sender.track;
                    if (track && track.kind === "video") {
                        localStream_1.addTrack(track);
                    }
                });
            }
            else {
                localStream_1 = pc.getLocalStreams()[0];
            }
            this.options.media.local.video.srcObject = localStream_1;
            this.options.media.local.video.volume = 0;
            this.options.media.local.video.play();
        }
    };
    Simple.prototype.cleanupMedia = function () {
        if (this.video) {
            this.options.media.remote.video.srcObject = null;
            this.options.media.remote.video.pause();
            if (this.options.media.local && this.options.media.local.video) {
                this.options.media.local.video.srcObject = null;
                this.options.media.local.video.pause();
            }
        }
        if (this.audio) {
            this.options.media.remote.audio.srcObject = null;
            this.options.media.remote.audio.pause();
        }
    };
    Simple.prototype.setupSession = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session to set up");
            return;
        }
        this.state = SimpleStatus.STATUS_NEW;
        this.emit("new", this.session);
        this.session.on("progress", function () { return _this.onProgress(); });
        this.session.on("accepted", function () { return _this.onAccepted(); });
        this.session.on("rejected", function () { return _this.onEnded(); });
        this.session.on("failed", function () { return _this.onFailed(); });
        this.session.on("terminated", function () { return _this.onEnded(); });
    };
    Simple.prototype.destroyMedia = function () {
        if (this.session && this.session.sessionDescriptionHandler) {
            this.session.sessionDescriptionHandler.close();
        }
    };
    Simple.prototype.toggleMute = function (mute) {
        if (!this.session) {
            this.logger.warn("No session to toggle mute");
            return;
        }
        var pc = this.session.sessionDescriptionHandler.peerConnection;
        if (pc.getSenders) {
            pc.getSenders().forEach(function (sender) {
                if (sender.track) {
                    sender.track.enabled = !mute;
                }
            });
        }
        else {
            pc.getLocalStreams().forEach(function (stream) {
                stream.getAudioTracks().forEach(function (track) {
                    track.enabled = !mute;
                });
                stream.getVideoTracks().forEach(function (track) {
                    track.enabled = !mute;
                });
            });
        }
    };
    Simple.prototype.onAccepted = function () {
        var _this = this;
        if (!this.session) {
            this.logger.warn("No session for accepting");
            return;
        }
        this.state = SimpleStatus.STATUS_CONNECTED;
        this.emit("connected", this.session);
        this.setupLocalMedia();
        this.setupRemoteMedia();
        if (this.session.sessionDescriptionHandler) {
            this.session.sessionDescriptionHandler.on("addTrack", function () {
                _this.logger.log("A track has been added, triggering new remoteMedia setup");
                _this.setupRemoteMedia();
            });
            this.session.sessionDescriptionHandler.on("addStream", function () {
                _this.logger.log("A stream has been added, trigger new remoteMedia setup");
                _this.setupRemoteMedia();
            });
        }
        this.session.on("dtmf", function (request, dtmf) {
            _this.emit("dtmf", dtmf.tone);
        });
        this.session.on("bye", function () { return _this.onEnded(); });
    };
    Simple.prototype.onProgress = function () {
        this.state = SimpleStatus.STATUS_CONNECTING;
        this.emit("connecting", this.session);
    };
    Simple.prototype.onFailed = function () {
        this.onEnded();
    };
    Simple.prototype.onEnded = function () {
        this.state = SimpleStatus.STATUS_COMPLETED;
        this.emit("ended", this.session);
        this.cleanupMedia();
    };
    Simple.C = SimpleStatus;
    return Simple;
}(events_1.EventEmitter));
exports.Simple = Simple;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/Transport.js":
/*!**************************************************!*\
  !*** ./node_modules/sip.js/lib/Web/Transport.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
var Enums_1 = __webpack_require__(/*! ../Enums */ "./node_modules/sip.js/lib/Enums.js");
var Exceptions_1 = __webpack_require__(/*! ../Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
var Transport_1 = __webpack_require__(/*! ../Transport */ "./node_modules/sip.js/lib/Transport.js");
var Utils_1 = __webpack_require__(/*! ../Utils */ "./node_modules/sip.js/lib/Utils.js");
var TransportStatus;
(function (TransportStatus) {
    TransportStatus[TransportStatus["STATUS_CONNECTING"] = 0] = "STATUS_CONNECTING";
    TransportStatus[TransportStatus["STATUS_OPEN"] = 1] = "STATUS_OPEN";
    TransportStatus[TransportStatus["STATUS_CLOSING"] = 2] = "STATUS_CLOSING";
    TransportStatus[TransportStatus["STATUS_CLOSED"] = 3] = "STATUS_CLOSED";
})(TransportStatus = exports.TransportStatus || (exports.TransportStatus = {}));
/**
 * Compute an amount of time in seconds to wait before sending another
 * keep-alive.
 * @returns {Number}
 */
var computeKeepAliveTimeout = function (upperBound) {
    var lowerBound = upperBound * 0.8;
    return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);
};
/**
 * @class Transport
 * @param {Object} options
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(logger, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, logger) || this;
        _this.type = Enums_1.TypeStrings.Transport;
        _this.reconnectionAttempts = 0;
        _this.status = TransportStatus.STATUS_CONNECTING;
        _this.configuration = _this.loadConfig(options);
        _this.server = _this.configuration.wsServers[0];
        return _this;
    }
    /**
     * @returns {Boolean}
     */
    Transport.prototype.isConnected = function () {
        return this.status === TransportStatus.STATUS_OPEN;
    };
    /**
     * Send a message.
     * @param message - Outgoing message.
     * @param options - Options bucket.
     */
    Transport.prototype.sendPromise = function (message, options) {
        if (options === void 0) { options = {}; }
        if (this.ws === undefined) {
            this.onError("unable to send message - WebSocket undefined");
            return Promise.reject(new Error("WebSocket undefined."));
        }
        // FIXME: This check is likely not necessary as WebSocket.send() will
        // throw INVALID_STATE_ERR if the connection is not currently open
        // which could happen regardless of what we thing the state is.
        if (!this.statusAssert(TransportStatus.STATUS_OPEN, options.force)) {
            this.onError("unable to send message - WebSocket not open");
            return Promise.reject(new Error("WebSocket not open."));
        }
        if (this.configuration.traceSip === true) {
            this.logger.log("sending WebSocket message:\n\n" + message + "\n");
        }
        // WebSocket.send() can throw.
        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
        try {
            this.ws.send(message);
        }
        catch (error) {
            if (error instanceof error) {
                Promise.reject(error);
            }
            return Promise.reject(new Error("Failed to send message."));
        }
        return Promise.resolve({ msg: message });
    };
    /**
     * Disconnect socket.
     */
    Transport.prototype.disconnectPromise = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.disconnectionPromise) { // Already disconnecting. Just return this.
            return this.disconnectionPromise;
        }
        options.code = options.code || 1000;
        if (!this.statusTransition(TransportStatus.STATUS_CLOSING, options.force)) {
            if (this.status === TransportStatus.STATUS_CLOSED) { // Websocket is already closed
                return Promise.resolve({ overrideEvent: true });
            }
            else if (this.connectionPromise) { // Websocket is connecting, cannot move to disconneting yet
                return this.connectionPromise.then(function () { return Promise.reject("The websocket did not disconnect"); })
                    .catch(function () { return Promise.resolve({ overrideEvent: true }); });
            }
            else {
                // Cannot move to disconnecting, but not in connecting state.
                return Promise.reject("The websocket did not disconnect");
            }
        }
        this.emit("disconnecting");
        this.disconnectionPromise = new Promise(function (resolve, reject) {
            _this.disconnectDeferredResolve = resolve;
            if (_this.reconnectTimer) {
                clearTimeout(_this.reconnectTimer);
                _this.reconnectTimer = undefined;
            }
            if (_this.ws) {
                _this.stopSendingKeepAlives();
                _this.logger.log("closing WebSocket " + _this.server.wsUri);
                _this.ws.close(options.code, options.reason);
            }
            else {
                reject("Attempted to disconnect but the websocket doesn't exist");
            }
        });
        return this.disconnectionPromise;
    };
    /**
     * Connect socket.
     */
    Transport.prototype.connectPromise = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.status === TransportStatus.STATUS_CLOSING && !options.force) {
            return Promise.reject("WebSocket " + this.server.wsUri + " is closing");
        }
        if (this.connectionPromise) {
            return this.connectionPromise;
        }
        this.server = this.server || this.getNextWsServer(options.force);
        this.connectionPromise = new Promise(function (resolve, reject) {
            if ((_this.status === TransportStatus.STATUS_OPEN || _this.status === TransportStatus.STATUS_CLOSING)
                && !options.force) {
                _this.logger.warn("WebSocket " + _this.server.wsUri + " is already connected");
                reject("Failed status check - attempted to open a connection but already open/closing");
                return;
            }
            _this.connectDeferredResolve = resolve;
            _this.connectDeferredReject = reject;
            _this.status = TransportStatus.STATUS_CONNECTING;
            _this.emit("connecting");
            _this.logger.log("connecting to WebSocket " + _this.server.wsUri);
            _this.disposeWs();
            try {
                _this.ws = new WebSocket(_this.server.wsUri, "sip");
                _this.ws.binaryType = "arraybuffer"; // set data type of received binary messages
            }
            catch (e) {
                _this.ws = undefined;
                _this.statusTransition(TransportStatus.STATUS_CLOSED, true);
                _this.onError("error connecting to WebSocket " + _this.server.wsUri + ":" + e);
                reject("Failed to create a websocket");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                return;
            }
            if (!_this.ws) {
                reject("Unexpected instance websocket not set");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                return;
            }
            _this.connectionTimeout = setTimeout(function () {
                _this.statusTransition(TransportStatus.STATUS_CLOSED);
                _this.logger.warn("took too long to connect - exceeded time set in configuration.connectionTimeout: " +
                    _this.configuration.connectionTimeout + "s");
                _this.emit("disconnected", { code: 1000 });
                _this.connectionPromise = undefined;
                reject("Connection timeout");
                _this.connectDeferredResolve = undefined;
                _this.connectDeferredReject = undefined;
                var ws = _this.ws;
                _this.disposeWs();
                if (ws) {
                    ws.close(1000);
                }
            }, _this.configuration.connectionTimeout * 1000);
            _this.boundOnOpen = _this.onOpen.bind(_this);
            _this.boundOnMessage = _this.onMessage.bind(_this);
            _this.boundOnClose = _this.onClose.bind(_this);
            _this.boundOnError = _this.onWebsocketError.bind(_this);
            _this.ws.addEventListener("open", _this.boundOnOpen);
            _this.ws.addEventListener("message", _this.boundOnMessage);
            _this.ws.addEventListener("close", _this.boundOnClose);
            _this.ws.addEventListener("error", _this.boundOnError);
        });
        return this.connectionPromise;
    };
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onMessage = function (e) {
        var data = e.data;
        var finishedData;
        // CRLF Keep Alive response from server. Clear our keep alive timeout.
        if (/^(\r\n)+$/.test(data)) {
            this.clearKeepAliveTimeout();
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket message with CRLF Keep Alive response");
            }
            return;
        }
        else if (!data) {
            this.logger.warn("received empty message, message discarded");
            return;
        }
        else if (typeof data !== "string") { // WebSocket binary message.
            try {
                // the UInt8Data was here prior to types, and doesn't check
                finishedData = String.fromCharCode.apply(null, new Uint8Array(data));
            }
            catch (err) {
                this.logger.warn("received WebSocket binary message failed to be converted into string, message discarded");
                return;
            }
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket binary message:\n\n" + data + "\n");
            }
        }
        else { // WebSocket text message.
            if (this.configuration.traceSip === true) {
                this.logger.log("received WebSocket text message:\n\n" + data + "\n");
            }
            finishedData = data;
        }
        this.emit("message", finishedData);
    };
    // Transport Event Handlers
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onOpen = function () {
        if (this.status === TransportStatus.STATUS_CLOSED) { // Indicated that the transport thinks the ws is dead already
            var ws = this.ws;
            this.disposeWs();
            if (ws) {
                ws.close(1000);
            }
            return;
        }
        this.statusTransition(TransportStatus.STATUS_OPEN, true);
        this.emit("connected");
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
            this.connectionTimeout = undefined;
        }
        this.logger.log("WebSocket " + this.server.wsUri + " connected");
        // Clear reconnectTimer since we are not disconnected
        if (this.reconnectTimer !== undefined) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = undefined;
        }
        // Reset reconnectionAttempts
        this.reconnectionAttempts = 0;
        // Reset disconnection promise so we can disconnect from a fresh state
        this.disconnectionPromise = undefined;
        this.disconnectDeferredResolve = undefined;
        // Start sending keep-alives
        this.startSendingKeepAlives();
        if (this.connectDeferredResolve) {
            this.connectDeferredResolve({ overrideEvent: true });
            this.connectDeferredResolve = undefined;
            this.connectDeferredReject = undefined;
        }
        else {
            this.logger.warn("Unexpected websocket.onOpen with no connectDeferredResolve");
        }
    };
    /**
     * @event
     * @param {event} e
     */
    Transport.prototype.onClose = function (e) {
        this.logger.log("WebSocket disconnected (code: " + e.code + (e.reason ? "| reason: " + e.reason : "") + ")");
        if (this.status !== TransportStatus.STATUS_CLOSING) {
            this.logger.warn("WebSocket closed without SIP.js requesting it");
            this.emit("transportError");
        }
        this.stopSendingKeepAlives();
        // Clean up connection variables so we can connect again from a fresh state
        if (this.connectionTimeout) {
            clearTimeout(this.connectionTimeout);
        }
        if (this.connectDeferredReject) {
            this.connectDeferredReject("Websocket Closed");
        }
        this.connectionTimeout = undefined;
        this.connectionPromise = undefined;
        this.connectDeferredResolve = undefined;
        this.connectDeferredReject = undefined;
        // Check whether the user requested to close.
        if (this.disconnectDeferredResolve) {
            this.disconnectDeferredResolve({ overrideEvent: true });
            this.statusTransition(TransportStatus.STATUS_CLOSED);
            this.disconnectDeferredResolve = undefined;
            return;
        }
        this.statusTransition(TransportStatus.STATUS_CLOSED, true);
        this.emit("disconnected", { code: e.code, reason: e.reason });
        this.disposeWs();
        this.reconnect();
    };
    /**
     * Removes event listeners and clears the instance ws
     */
    Transport.prototype.disposeWs = function () {
        if (this.ws) {
            this.ws.removeEventListener("open", this.boundOnOpen);
            this.ws.removeEventListener("message", this.boundOnMessage);
            this.ws.removeEventListener("close", this.boundOnClose);
            this.ws.removeEventListener("error", this.boundOnError);
            this.ws = undefined;
        }
    };
    /**
     * @event
     * @param {string} e
     */
    Transport.prototype.onError = function (e) {
        this.logger.warn("Transport error: " + e);
        this.emit("transportError");
    };
    /**
     * @event
     * @private
     */
    Transport.prototype.onWebsocketError = function () {
        this.onError("The Websocket had an error");
    };
    /**
     * Reconnection attempt logic.
     */
    Transport.prototype.reconnect = function () {
        var _this = this;
        if (this.reconnectionAttempts > 0) {
            this.logger.log("Reconnection attempt " + this.reconnectionAttempts + " failed");
        }
        if (this.noAvailableServers()) {
            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
            this.logger.warn("no available ws servers left - going to closed state");
            this.statusTransition(TransportStatus.STATUS_CLOSED, true);
            this.emit("closed");
            this.resetServerErrorStatus();
            return;
        }
        if (this.isConnected()) {
            this.logger.warn("attempted to reconnect while connected - forcing disconnect");
            this.disconnect({ force: true });
        }
        this.reconnectionAttempts += 1;
        if (this.reconnectionAttempts > this.configuration.maxReconnectionAttempts) {
            this.logger.warn("maximum reconnection attempts for WebSocket " + this.server.wsUri);
            this.logger.log("transport " + this.server.wsUri + " failed | connection state set to 'error'");
            this.server.isError = true;
            this.emit("transportError");
            if (!this.noAvailableServers()) {
                this.server = this.getNextWsServer();
            }
            // When there are no available servers, the reconnect function ends on the next recursive call
            // after checking for no available servers again.
            this.reconnectionAttempts = 0;
            this.reconnect();
        }
        else {
            this.logger.log("trying to reconnect to WebSocket " +
                this.server.wsUri + " (reconnection attempt " + this.reconnectionAttempts + ")");
            this.reconnectTimer = setTimeout(function () {
                _this.connect();
                _this.reconnectTimer = undefined;
            }, (this.reconnectionAttempts === 1) ? 0 : this.configuration.reconnectionTimeout * 1000);
        }
    };
    /**
     * Resets the error state of all servers in the configuration
     */
    Transport.prototype.resetServerErrorStatus = function () {
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var websocket = _a[_i];
            websocket.isError = false;
        }
    };
    /**
     * Retrieve the next server to which connect.
     * @param {Boolean} force allows bypass of server error status checking
     * @returns {Object} WsServer
     */
    Transport.prototype.getNextWsServer = function (force) {
        if (force === void 0) { force = false; }
        if (this.noAvailableServers()) {
            this.logger.warn("attempted to get next ws server but there are no available ws servers left");
            throw new Error("Attempted to get next ws server, but there are no available ws servers left.");
        }
        // Order servers by weight
        var candidates = [];
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var wsServer = _a[_i];
            if (wsServer.isError && !force) {
                continue;
            }
            else if (candidates.length === 0) {
                candidates.push(wsServer);
            }
            else if (wsServer.weight > candidates[0].weight) {
                candidates = [wsServer];
            }
            else if (wsServer.weight === candidates[0].weight) {
                candidates.push(wsServer);
            }
        }
        var idx = Math.floor(Math.random() * candidates.length);
        return candidates[idx];
    };
    /**
     * Checks all configuration servers, returns true if all of them have isError: true and false otherwise
     * @returns {Boolean}
     */
    Transport.prototype.noAvailableServers = function () {
        for (var _i = 0, _a = this.configuration.wsServers; _i < _a.length; _i++) {
            var server = _a[_i];
            if (!server.isError) {
                return false;
            }
        }
        return true;
    };
    // ==============================
    // KeepAlive Stuff
    // ==============================
    /**
     * Send a keep-alive (a double-CRLF sequence).
     * @returns {Boolean}
     */
    Transport.prototype.sendKeepAlive = function () {
        var _this = this;
        if (this.keepAliveDebounceTimeout) {
            // We already have an outstanding keep alive, do not send another.
            return;
        }
        this.keepAliveDebounceTimeout = setTimeout(function () {
            _this.emit("keepAliveDebounceTimeout");
            _this.clearKeepAliveTimeout();
        }, this.configuration.keepAliveDebounce * 1000);
        return this.send("\r\n\r\n");
    };
    Transport.prototype.clearKeepAliveTimeout = function () {
        if (this.keepAliveDebounceTimeout) {
            clearTimeout(this.keepAliveDebounceTimeout);
        }
        this.keepAliveDebounceTimeout = undefined;
    };
    /**
     * Start sending keep-alives.
     */
    Transport.prototype.startSendingKeepAlives = function () {
        var _this = this;
        if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {
            this.keepAliveInterval = setInterval(function () {
                _this.sendKeepAlive();
                _this.startSendingKeepAlives();
            }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));
        }
    };
    /**
     * Stop sending keep-alives.
     */
    Transport.prototype.stopSendingKeepAlives = function () {
        if (this.keepAliveInterval) {
            clearInterval(this.keepAliveInterval);
        }
        if (this.keepAliveDebounceTimeout) {
            clearTimeout(this.keepAliveDebounceTimeout);
        }
        this.keepAliveInterval = undefined;
        this.keepAliveDebounceTimeout = undefined;
    };
    // ==============================
    // Status Stuff
    // ==============================
    /**
     * Checks given status against instance current status. Returns true if they match
     * @param {Number} status
     * @param {Boolean} [force]
     * @returns {Boolean}
     */
    Transport.prototype.statusAssert = function (status, force) {
        if (status === this.status) {
            return true;
        }
        else {
            if (force) {
                this.logger.warn("Attempted to assert " +
                    Object.keys(TransportStatus)[this.status] + " as " +
                    Object.keys(TransportStatus)[status] + "- continuing with option: 'force'");
                return true;
            }
            else {
                this.logger.warn("Tried to assert " +
                    Object.keys(TransportStatus)[status] + " but is currently " +
                    Object.keys(TransportStatus)[this.status]);
                return false;
            }
        }
    };
    /**
     * Transitions the status. Checks for legal transition via assertion beforehand
     * @param {Number} status
     * @param {Boolean} [force]
     * @returns {Boolean}
     */
    Transport.prototype.statusTransition = function (status, force) {
        if (force === void 0) { force = false; }
        this.logger.log("Attempting to transition status from " +
            Object.keys(TransportStatus)[this.status] + " to " +
            Object.keys(TransportStatus)[status]);
        if ((status === TransportStatus.STATUS_CONNECTING && this.statusAssert(TransportStatus.STATUS_CLOSED, force)) ||
            (status === TransportStatus.STATUS_OPEN && this.statusAssert(TransportStatus.STATUS_CONNECTING, force)) ||
            (status === TransportStatus.STATUS_CLOSING && this.statusAssert(TransportStatus.STATUS_OPEN, force)) ||
            (status === TransportStatus.STATUS_CLOSED)) {
            this.status = status;
            return true;
        }
        else {
            this.logger.warn("Status transition failed - result: no-op - reason:" +
                " either gave an nonexistent status or attempted illegal transition");
            return false;
        }
    };
    // ==============================
    // Configuration Handling
    // ==============================
    /**
     * Configuration load.
     * returns {Configuration}
     */
    Transport.prototype.loadConfig = function (configuration) {
        var settings = {
            wsServers: [{
                    scheme: "WSS",
                    sipUri: "<sip:edge.sip.onsip.com;transport=ws;lr>",
                    weight: 0,
                    wsUri: "wss://edge.sip.onsip.com",
                    isError: false
                }],
            connectionTimeout: 5,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
            keepAliveInterval: 0,
            keepAliveDebounce: 10,
            // Logging
            traceSip: false
        };
        var configCheck = this.getConfigurationCheck();
        // Check Mandatory parameters
        for (var parameter in configCheck.mandatory) {
            if (!configuration.hasOwnProperty(parameter)) {
                throw new Exceptions_1.Exceptions.ConfigurationError(parameter);
            }
            else {
                var value = configuration[parameter];
                var checkedValue = configCheck.mandatory[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        // Check Optional parameters
        for (var parameter in configCheck.optional) {
            if (configuration.hasOwnProperty(parameter)) {
                var value = configuration[parameter];
                // If the parameter value is an empty array, but shouldn't be, apply its default value.
                // If the parameter value is null, empty string, or undefined then apply its default value.
                // If it's a number with NaN value then also apply its default value.
                // NOTE: JS does not allow "value === NaN", the following does the work:
                if ((value instanceof Array && value.length === 0) ||
                    (value === null || value === "" || value === undefined) ||
                    (typeof (value) === "number" && isNaN(value))) {
                    continue;
                }
                var checkedValue = configCheck.optional[parameter](value);
                if (checkedValue !== undefined) {
                    settings[parameter] = checkedValue;
                }
                else {
                    throw new Exceptions_1.Exceptions.ConfigurationError(parameter, value);
                }
            }
        }
        var skeleton = {}; // Fill the value of the configuration_skeleton
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                skeleton[parameter] = {
                    value: settings[parameter],
                };
            }
        }
        var returnConfiguration = Object.defineProperties({}, skeleton);
        this.logger.log("configuration parameters after validation:");
        for (var parameter in settings) {
            if (settings.hasOwnProperty(parameter)) {
                this.logger.log("· " + parameter + ": " + JSON.stringify(settings[parameter]));
            }
        }
        return returnConfiguration;
    };
    /**
     * Configuration checker.
     * @return {Boolean}
     */
    Transport.prototype.getConfigurationCheck = function () {
        return {
            mandatory: {},
            optional: {
                // Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid
                wsServers: function (wsServers) {
                    /* Allow defining wsServers parameter as:
                     *  String: "host"
                     *  Array of Strings: ["host1", "host2"]
                     *  Array of Objects: [{wsUri:"host1", weight:1}, {wsUri:"host2", weight:0}]
                     *  Array of Objects and Strings: [{wsUri:"host1"}, "host2"]
                     */
                    if (typeof wsServers === "string") {
                        wsServers = [{ wsUri: wsServers }];
                    }
                    else if (wsServers instanceof Array) {
                        for (var idx = 0; idx < wsServers.length; idx++) {
                            if (typeof wsServers[idx] === "string") {
                                wsServers[idx] = { wsUri: wsServers[idx] };
                            }
                        }
                    }
                    else {
                        return;
                    }
                    if (wsServers.length === 0) {
                        return false;
                    }
                    for (var _i = 0, wsServers_1 = wsServers; _i < wsServers_1.length; _i++) {
                        var wsServer = wsServers_1[_i];
                        if (!wsServer.wsUri) {
                            return;
                        }
                        if (wsServer.weight && !Number(wsServer.weight)) {
                            return;
                        }
                        var url = core_1.Grammar.parse(wsServer.wsUri, "absoluteURI");
                        if (url === -1) {
                            return;
                        }
                        else if (["wss", "ws", "udp"].indexOf(url.scheme) < 0) {
                            return;
                        }
                        else {
                            wsServer.sipUri = "<sip:" + url.host +
                                (url.port ? ":" + url.port : "") + ";transport=" + url.scheme.replace(/^wss$/i, "ws") + ";lr>";
                            if (!wsServer.weight) {
                                wsServer.weight = 0;
                            }
                            wsServer.isError = false;
                            wsServer.scheme = url.scheme.toUpperCase();
                        }
                    }
                    return wsServers;
                },
                keepAliveInterval: function (keepAliveInterval) {
                    if (Utils_1.Utils.isDecimal(keepAliveInterval)) {
                        var value = Number(keepAliveInterval);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                keepAliveDebounce: function (keepAliveDebounce) {
                    if (Utils_1.Utils.isDecimal(keepAliveDebounce)) {
                        var value = Number(keepAliveDebounce);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                traceSip: function (traceSip) {
                    if (typeof traceSip === "boolean") {
                        return traceSip;
                    }
                },
                connectionTimeout: function (connectionTimeout) {
                    if (Utils_1.Utils.isDecimal(connectionTimeout)) {
                        var value = Number(connectionTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                },
                maxReconnectionAttempts: function (maxReconnectionAttempts) {
                    if (Utils_1.Utils.isDecimal(maxReconnectionAttempts)) {
                        var value = Number(maxReconnectionAttempts);
                        if (value >= 0) {
                            return value;
                        }
                    }
                },
                reconnectionTimeout: function (reconnectionTimeout) {
                    if (Utils_1.Utils.isDecimal(reconnectionTimeout)) {
                        var value = Number(reconnectionTimeout);
                        if (value > 0) {
                            return value;
                        }
                    }
                }
            }
        };
    };
    Transport.C = TransportStatus;
    return Transport;
}(Transport_1.Transport));
exports.Transport = Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/Web/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sip.js/lib/Web/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var Modifiers = tslib_1.__importStar(__webpack_require__(/*! ./Modifiers */ "./node_modules/sip.js/lib/Web/Modifiers.js"));
exports.Modifiers = Modifiers;
var Simple_1 = __webpack_require__(/*! ./Simple */ "./node_modules/sip.js/lib/Web/Simple.js");
exports.Simple = Simple_1.Simple;
var SessionDescriptionHandler_1 = __webpack_require__(/*! ./SessionDescriptionHandler */ "./node_modules/sip.js/lib/Web/SessionDescriptionHandler.js");
exports.SessionDescriptionHandler = SessionDescriptionHandler_1.SessionDescriptionHandler;
var Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/sip.js/lib/Web/Transport.js");
exports.Transport = Transport_1.Transport;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/bye.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/api/bye.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A request to end a {@link Session} (incoming BYE).
 * @public
 */
var Bye = /** @class */ (function () {
    /** @internal */
    function Bye(incomingByeRequest) {
        this.incomingByeRequest = incomingByeRequest;
    }
    Object.defineProperty(Bye.prototype, "request", {
        /** Incoming BYE request message. */
        get: function () {
            return this.incomingByeRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Bye.prototype.accept = function (options) {
        this.incomingByeRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Bye.prototype.reject = function (options) {
        this.incomingByeRequest.reject(options);
        return Promise.resolve();
    };
    return Bye;
}());
exports.Bye = Bye;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/emitter.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/emitter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Creates an {@link Emitter}.
 * @param eventEmitter - An event emitter.
 * @param eventName - Event name.
 * @internal
 */
function _makeEmitter(eventEmitter, eventName) {
    if (eventName === void 0) { eventName = "event"; }
    return {
        addListener: function (listener, options) {
            if (options === void 0) { options = {}; }
            if (options.once) {
                eventEmitter.once(eventName, listener);
            }
            else {
                eventEmitter.addListener(eventName, listener);
            }
        },
        removeListener: function (listener) {
            eventEmitter.removeListener(eventName, listener);
        },
        on: function (listener) {
            eventEmitter.on(eventName, listener);
        },
        off: function (listener) {
            eventEmitter.removeListener(eventName, listener);
        },
        once: function (listener) {
            eventEmitter.once(eventName, listener);
        }
    };
}
exports._makeEmitter = _makeEmitter;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an unsupported content type prevented execution.
 * @public
 */
var ContentTypeUnsupportedError = /** @class */ (function (_super) {
    tslib_1.__extends(ContentTypeUnsupportedError, _super);
    function ContentTypeUnsupportedError(message) {
        return _super.call(this, message ? message : "Unsupported content type.") || this;
    }
    return ContentTypeUnsupportedError;
}(core_1.Exception));
exports.ContentTypeUnsupportedError = ContentTypeUnsupportedError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./content-type-unsupported */ "./node_modules/sip.js/lib/api/exceptions/content-type-unsupported.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./request-pending */ "./node_modules/sip.js/lib/api/exceptions/request-pending.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-description-handler */ "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-terminated */ "./node_modules/sip.js/lib/api/exceptions/session-terminated.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./state-transition */ "./node_modules/sip.js/lib/api/exceptions/state-transition.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/request-pending.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/request-pending.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an outstanding prior request prevented execution.
 * @public
 */
var RequestPendingError = /** @class */ (function (_super) {
    tslib_1.__extends(RequestPendingError, _super);
    /** @internal */
    function RequestPendingError(message) {
        return _super.call(this, message ? message : "Request pending.") || this;
    }
    return RequestPendingError;
}(core_1.Exception));
exports.RequestPendingError = RequestPendingError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/session-description-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/session-description-handler.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating a session description handler error occured.
 * @public
 */
var SessionDescriptionHandlerError = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDescriptionHandlerError, _super);
    function SessionDescriptionHandlerError(message) {
        return _super.call(this, message ? message : "Unspecified session description handler error.") || this;
    }
    return SessionDescriptionHandlerError;
}(core_1.Exception));
exports.SessionDescriptionHandlerError = SessionDescriptionHandlerError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/session-terminated.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/session-terminated.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating the session terminated before the action completed.
 * @public
 */
var SessionTerminatedError = /** @class */ (function (_super) {
    tslib_1.__extends(SessionTerminatedError, _super);
    function SessionTerminatedError() {
        return _super.call(this, "The session has terminated.") || this;
    }
    return SessionTerminatedError;
}(core_1.Exception));
exports.SessionTerminatedError = SessionTerminatedError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/exceptions/state-transition.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/api/exceptions/state-transition.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ../../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * An exception indicating an invalid state transition error occured.
 * @public
 */
var StateTransitionError = /** @class */ (function (_super) {
    tslib_1.__extends(StateTransitionError, _super);
    function StateTransitionError(message) {
        return _super.call(this, message ? message : "An error occurred during state transition.") || this;
    }
    return StateTransitionError;
}(core_1.Exception));
exports.StateTransitionError = StateTransitionError;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/info.js":
/*!*********************************************!*\
  !*** ./node_modules/sip.js/lib/api/info.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An exchange of information (incoming INFO).
 * @public
 */
var Info = /** @class */ (function () {
    /** @internal */
    function Info(incomingInfoRequest) {
        this.incomingInfoRequest = incomingInfoRequest;
    }
    Object.defineProperty(Info.prototype, "request", {
        /** Incoming MESSAGE request message. */
        get: function () {
            return this.incomingInfoRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Info.prototype.accept = function (options) {
        this.incomingInfoRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Info.prototype.reject = function (options) {
        this.incomingInfoRequest.reject(options);
        return Promise.resolve();
    };
    return Info;
}());
exports.Info = Info;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/message.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/message.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A received message (incoming MESSAGE).
 * @public
 */
var Message = /** @class */ (function () {
    /** @internal */
    function Message(incomingMessageRequest) {
        this.incomingMessageRequest = incomingMessageRequest;
    }
    Object.defineProperty(Message.prototype, "request", {
        /** Incoming MESSAGE request message. */
        get: function () {
            return this.incomingMessageRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Message.prototype.accept = function (options) {
        this.incomingMessageRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Message.prototype.reject = function (options) {
        this.incomingMessageRequest.reject(options);
        return Promise.resolve();
    };
    return Message;
}());
exports.Message = Message;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/notification.js":
/*!*****************************************************!*\
  !*** ./node_modules/sip.js/lib/api/notification.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A notification of an event (incoming NOTIFY).
 * @public
 */
var Notification = /** @class */ (function () {
    /** @internal */
    function Notification(incomingNotifyRequest) {
        this.incomingNotifyRequest = incomingNotifyRequest;
    }
    Object.defineProperty(Notification.prototype, "request", {
        /** Incoming NOTIFY request message. */
        get: function () {
            return this.incomingNotifyRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Notification.prototype.accept = function (options) {
        this.incomingNotifyRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Notification.prototype.reject = function (options) {
        this.incomingNotifyRequest.reject(options);
        return Promise.resolve();
    };
    return Notification;
}());
exports.Notification = Notification;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/referral.js":
/*!*************************************************!*\
  !*** ./node_modules/sip.js/lib/api/referral.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
/**
 * A request to establish a {@link Session} elsewhere (incoming REFER).
 * @public
 */
var Referral = /** @class */ (function () {
    /** @internal */
    function Referral(incomingReferRequest, session) {
        this.incomingReferRequest = incomingReferRequest;
        this.session = session;
    }
    Object.defineProperty(Referral.prototype, "referTo", {
        get: function () {
            var referTo = this.incomingReferRequest.message.parseHeader("refer-to");
            if (!(referTo instanceof core_1.NameAddrHeader)) {
                throw new Error("Failed to parse Refer-To header.");
            }
            return referTo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "referredBy", {
        get: function () {
            return this.incomingReferRequest.message.getHeader("referred-by");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "replaces", {
        get: function () {
            return this.referTo.uri.getHeader("replaces");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Referral.prototype, "request", {
        /** Incoming REFER request message. */
        get: function () {
            return this.incomingReferRequest.message;
        },
        enumerable: true,
        configurable: true
    });
    /** Accept the request. */
    Referral.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 202 }; }
        this.incomingReferRequest.accept(options);
        return Promise.resolve();
    };
    /** Reject the request. */
    Referral.prototype.reject = function (options) {
        this.incomingReferRequest.reject(options);
        return Promise.resolve();
    };
    /**
     * Creates an inviter which may be used to send an out of dialog INVITE request.
     *
     * @remarks
     * This a helper method to create an Inviter which will execute the referral
     * of the `Session` which was referred. The appropriate headers are set and
     * the referred `Session` is linked to the new `Session`. Note that only a
     * single instance of the `Inviter` will be created and returned (if called
     * more than once a reference to the same `Inviter` will be returned every time).
     *
     * @param options - Options bucket.
     * @param modifiers - Session description handler modifiers.
     */
    Referral.prototype.makeInviter = function (options) {
        if (this.inviter) {
            return this.inviter;
        }
        var targetURI = this.referTo.uri.clone();
        targetURI.clearHeaders();
        options = options || {};
        var extraHeaders = (options.extraHeaders || []).slice();
        var replaces = this.replaces;
        if (replaces) {
            // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary
            extraHeaders.push("Replaces: " + decodeURIComponent(replaces));
        }
        var referredBy = this.referredBy;
        if (referredBy) {
            extraHeaders.push("Referred-By: " + referredBy);
        }
        options.extraHeaders = extraHeaders;
        this.inviter = this.session.userAgent._makeInviter(targetURI, options);
        this.inviter._referred = this.session;
        this.session._referral = this.inviter;
        return this.inviter;
    };
    return Referral;
}());
exports.Referral = Referral;


/***/ }),

/***/ "./node_modules/sip.js/lib/api/session-state.js":
/*!******************************************************!*\
  !*** ./node_modules/sip.js/lib/api/session-state.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * {@link Session} state.
 *
 * @remarks
 * The {@link Session} behaves in a deterministic manner according to the following
 * Finite State Machine (FSM).
 * ```txt
 *                   ___________________________________________________________
 *                  |  ____________________________________________             |
 *                  | |            ____________________________    |            |
 * Session          | |           |                            v   v            v
 * Constructed -> Initial -> Establishing -> Established -> Terminating -> Terminated
 *                                |               |___________________________^   ^
 *                                |_______________________________________________|
 * ```
 * @public
 */
var SessionState;
(function (SessionState) {
    /**
     * If `Inviter`, INVITE not sent yet.
     * If `Invitation`, received INVITE (but no final response sent yet).
     */
    SessionState["Initial"] = "Initial";
    /**
     * If `Inviter`, sent INVITE and waiting for a final response.
     * If `Invitation`, received INVITE and attempting to send 200 final response (but has not sent it yet).
     */
    SessionState["Establishing"] = "Establishing";
    /**
     * If `Inviter`, sent INVITE and received 200 final response and sent ACK.
     * If `Invitation`, received INVITE and sent 200 final response.
     */
    SessionState["Established"] = "Established";
    /**
     * If `Inviter`, sent INVITE, sent CANCEL and now waiting for 487 final response to ACK (or 200 to ACK & BYE).
     * If `Invitation`, received INVITE, sent 200 final response and now waiting on ACK and upon receipt will attempt BYE
     * (as the protocol specification requires, before sending a BYE we must receive the ACK - so we are waiting).
     */
    SessionState["Terminating"] = "Terminating";
    /**
     * If `Inviter`, sent INVITE and received non-200 final response (or sent/received BYE after receiving 200).
     * If `Invitation`, received INVITE and sent non-200 final response (or sent/received BYE after sending 200).
     */
    SessionState["Terminated"] = "Terminated";
})(SessionState = exports.SessionState || (exports.SessionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/api/session.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/api/session.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var core_1 = __webpack_require__(/*! ../core */ "./node_modules/sip.js/lib/core/index.js");
var utils_1 = __webpack_require__(/*! ../core/messages/utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
var allowed_methods_1 = __webpack_require__(/*! ../core/user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var bye_1 = __webpack_require__(/*! ./bye */ "./node_modules/sip.js/lib/api/bye.js");
var emitter_1 = __webpack_require__(/*! ./emitter */ "./node_modules/sip.js/lib/api/emitter.js");
var exceptions_1 = __webpack_require__(/*! ./exceptions */ "./node_modules/sip.js/lib/api/exceptions/index.js");
var info_1 = __webpack_require__(/*! ./info */ "./node_modules/sip.js/lib/api/info.js");
var message_1 = __webpack_require__(/*! ./message */ "./node_modules/sip.js/lib/api/message.js");
var notification_1 = __webpack_require__(/*! ./notification */ "./node_modules/sip.js/lib/api/notification.js");
var referral_1 = __webpack_require__(/*! ./referral */ "./node_modules/sip.js/lib/api/referral.js");
var session_state_1 = __webpack_require__(/*! ./session-state */ "./node_modules/sip.js/lib/api/session-state.js");
/**
 * A session provides real time communication between one or more participants.
 *
 * @remarks
 * The transport behaves in a deterministic manner according to the
 * the state defined in {@link SessionState}.
 * @public
 */
var Session = /** @class */ (function () {
    /**
     * Constructor.
     * @param userAgent - User agent. See {@link UserAgent} for details.
     * @internal
     */
    function Session(userAgent, options) {
        if (options === void 0) { options = {}; }
        /** True if there is a re-INVITE request outstanding. */
        this.pendingReinvite = false;
        /** Session state. */
        this._state = session_state_1.SessionState.Initial;
        /** Session state emitter. */
        this._stateEventEmitter = new events_1.EventEmitter();
        this.delegate = options.delegate;
        this._userAgent = userAgent;
    }
    /**
     * Destructor.
     */
    Session.prototype.dispose = function () {
        var _this = this;
        this.logger.log("Session " + this.id + " in state " + this._state + " is being disposed");
        // Remove from the user agent's session collection
        delete this.userAgent._sessions[this.id];
        // Dispose of dialog media
        if (this._sessionDescriptionHandler) {
            this._sessionDescriptionHandler.close();
            // TODO: The SDH needs to remain defined as it will be called after it is closed in cases
            // where an answer/offer arrives while the session is being torn down. There are a variety
            // of circumstances where this can happen - sending a BYE during a re-INVITE for example.
            // The code is currently written such that it lazily makes a new SDH when it needs one
            // and one is not yet defined. Thus if we undefined it here, it will currently make a
            // new one which is out of sync and then never gets cleaned up.
            //
            // The downside of leaving it defined are that calls this closed SDH will continue to be
            // made (think setDescription) and those should/will fail. These failures are handled, but
            // it would be nice to have it all coded up in a way where having an undefined SDH where
            // one is expected throws an error.
            //
            // this._sessionDescriptionHandler = undefined;
        }
        switch (this.state) {
            case session_state_1.SessionState.Initial:
                break; // the Inviter/Invitation sub class dispose method handles this case
            case session_state_1.SessionState.Establishing:
                break; // the Inviter/Invitation sub class dispose method handles this case
            case session_state_1.SessionState.Established:
                return new Promise(function (resolve, reject) {
                    _this._bye({
                        onAccept: function () { return resolve(); },
                        onRedirect: function () { return resolve(); },
                        onReject: function () { return resolve(); }
                    });
                });
            case session_state_1.SessionState.Terminating:
                break; // nothing to be done
            case session_state_1.SessionState.Terminated:
                break; // nothing to be done
            default:
                throw new Error("Unknown state.");
        }
        return Promise.resolve();
    };
    Object.defineProperty(Session.prototype, "assertedIdentity", {
        /**
         * The asserted identity of the remote user.
         */
        get: function () {
            return this._assertedIdentity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "dialog", {
        /**
         * The confirmed session dialog.
         */
        get: function () {
            return this._dialog;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "id", {
        /**
         * A unique identifier for this session.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "replacee", {
        /**
         * The session being replace by this one.
         */
        get: function () {
            return this._replacee;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionDescriptionHandler", {
        /**
         * Session description handler.
         * @remarks
         * If `this` is an instance of `Invitation`,
         * `sessionDescriptionHandler` will be defined when the session state changes to "established".
         * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,
         * `sessionDescriptionHandler` will be defined when the session state changes to "establishing".
         * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,
         * `sessionDescriptionHandler` will be defined when the session state changes to "established".
         * Otherwise `undefined`.
         */
        get: function () {
            return this._sessionDescriptionHandler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "sessionDescriptionHandlerFactory", {
        /**
         * Session description handler factory.
         */
        get: function () {
            return this.userAgent.configuration.sessionDescriptionHandlerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "state", {
        /**
         * Session state.
         */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "stateChange", {
        /**
         * Session state change emitter.
         */
        get: function () {
            return emitter_1._makeEmitter(this._stateEventEmitter);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Session.prototype, "userAgent", {
        /**
         * The user agent.
         */
        get: function () {
            return this._userAgent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * End the {@link Session}. Sends a BYE.
     * @param options - Options bucket. See {@link SessionByeOptions} for details.
     */
    Session.prototype.bye = function (options) {
        if (options === void 0) { options = {}; }
        var message = "Session.bye() may only be called if established session.";
        switch (this.state) {
            case session_state_1.SessionState.Initial:
                if (typeof this.cancel === "function") {
                    message += " However Inviter.invite() has not yet been called.";
                    message += " Perhaps you should have called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " However Invitation.accept() has not yet been called.";
                    message += " Perhaps you should have called Invitation.reject()?";
                }
                break;
            case session_state_1.SessionState.Establishing:
                if (typeof this.cancel === "function") {
                    message += " However a dialog does not yet exist.";
                    message += " Perhaps you should have called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " However Invitation.accept() has not yet been called (or not yet resolved).";
                    message += " Perhaps you should have called Invitation.reject()?";
                }
                break;
            case session_state_1.SessionState.Established:
                var requestDelegate = options.requestDelegate;
                var requestOptions = this.copyRequestOptions(options.requestOptions);
                return this._bye(requestDelegate, requestOptions);
            case session_state_1.SessionState.Terminating:
                message += " However this session is already terminating.";
                if (typeof this.cancel === "function") {
                    message += " Perhaps you have already called Inviter.cancel()?";
                }
                else if (typeof this.reject === "function") {
                    message += " Perhaps you have already called Session.bye()?";
                }
                break;
            case session_state_1.SessionState.Terminated:
                message += " However this session is already terminated.";
                break;
            default:
                throw new Error("Unknown state");
        }
        this.logger.error(message);
        return Promise.reject(new Error("Invalid session state " + this.state));
    };
    /**
     * Share {@link Info} with peer. Sends an INFO.
     * @param options - Options bucket. See {@link SessionInfoOptions} for details.
     */
    Session.prototype.info = function (options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.info() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._info(requestDelegate, requestOptions);
    };
    /**
     * Renegotiate the session. Sends a re-INVITE.
     * @param options - Options bucket. See {@link SessionInviteOptions} for details.
     */
    Session.prototype.invite = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.logger.log("Session.invite");
        if (this.state !== session_state_1.SessionState.Established) {
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        if (this.pendingReinvite) {
            return Promise.reject(new exceptions_1.RequestPendingError("Reinvite in progress. Please wait until complete, then try again."));
        }
        this.pendingReinvite = true;
        var delegate = {
            onAccept: function (response) {
                // A re-INVITE transaction has an offer/answer [RFC3264] exchange
                // associated with it.  The UAC (User Agent Client) generating a given
                // re-INVITE can act as the offerer or as the answerer.  A UAC willing
                // to act as the offerer includes an offer in the re-INVITE.  The UAS
                // (User Agent Server) then provides an answer in a response to the
                // re-INVITE.  A UAC willing to act as answerer does not include an
                // offer in the re-INVITE.  The UAS then provides an offer in a response
                // to the re-INVITE becoming, thus, the offerer.
                // https://tools.ietf.org/html/rfc6141#section-1
                var body = core_1.getBody(response.message);
                if (!body) {
                    // No way to recover, so terminate session and mark as failed.
                    _this.logger.error("Received 2xx response to re-INVITE without a session description");
                    _this.ackAndBye(response, 400, "Missing session description");
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                    _this.pendingReinvite = false;
                    return;
                }
                if (options.withoutSdp) {
                    // INVITE without SDP - set remote offer and send an answer in the ACK
                    // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                    //        This behavior was ported from legacy code and the issue punted down the road.
                    var answerOptions = {
                        sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
                        sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
                    };
                    _this.setOfferAndGetAnswer(body, answerOptions)
                        .then(function (answerBody) {
                        response.ack({ body: answerBody });
                    })
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to handle offer in 2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        if (_this.state === session_state_1.SessionState.Terminated) {
                            // A BYE should not be sent if already terminated.
                            // For example, a BYE may be sent/received while re-INVITE is outstanding.
                            response.ack();
                        }
                        else {
                            _this.ackAndBye(response, 488, "Bad Media Description");
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                    })
                        .then(function () {
                        _this.pendingReinvite = false;
                        if (options.requestDelegate && options.requestDelegate.onAccept) {
                            options.requestDelegate.onAccept(response);
                        }
                    });
                }
                else {
                    // INVITE with SDP - set remote answer and send an ACK
                    // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
                    //        This behavior was ported from legacy code and the issue punted down the road.
                    var answerOptions = {
                        sessionDescriptionHandlerOptions: _this._sessionDescriptionHandlerOptions,
                        sessionDescriptionHandlerModifiers: _this._sessionDescriptionHandlerModifiers
                    };
                    _this.setAnswer(body, answerOptions)
                        .then(function () {
                        response.ack();
                    })
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to handle answer in 2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        // A BYE should only be sent if session is not already terminated.
                        // For example, a BYE may be sent/received while re-INVITE is outstanding.
                        // The ACK needs to be sent regardless as it was not handled by the transaction.
                        if (_this.state !== session_state_1.SessionState.Terminated) {
                            _this.ackAndBye(response, 488, "Bad Media Description");
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                        else {
                            response.ack();
                        }
                    })
                        .then(function () {
                        _this.pendingReinvite = false;
                        if (options.requestDelegate && options.requestDelegate.onAccept) {
                            options.requestDelegate.onAccept(response);
                        }
                    });
                }
            },
            onProgress: function (response) {
                return;
            },
            onRedirect: function (response) {
                return;
            },
            onReject: function (response) {
                _this.logger.warn("Received a non-2xx response to re-INVITE");
                _this.pendingReinvite = false;
                if (options.withoutSdp) {
                    if (options.requestDelegate && options.requestDelegate.onReject) {
                        options.requestDelegate.onReject(response);
                    }
                }
                else {
                    _this.rollbackOffer()
                        .catch(function (error) {
                        // No way to recover, so terminate session and mark as failed.
                        _this.logger.error("Failed to rollback offer on non-2xx response to re-INVITE");
                        _this.logger.error(error.message);
                        // A BYE should only be sent if session is not already terminated.
                        // For example, a BYE may be sent/received while re-INVITE is outstanding.
                        // Note that the ACK was already sent by the transaction, so just need to send BYE.
                        if (_this.state !== session_state_1.SessionState.Terminated) {
                            if (!_this.dialog) {
                                throw new Error("Dialog undefined.");
                            }
                            var extraHeaders = [];
                            extraHeaders.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                            _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                        }
                    })
                        .then(function () {
                        if (options.requestDelegate && options.requestDelegate.onReject) {
                            options.requestDelegate.onReject(response);
                        }
                    });
                }
            },
            onTrying: function (response) {
                return;
            }
        };
        var requestOptions = options.requestOptions || {};
        requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();
        requestOptions.extraHeaders.push("Allow: " + allowed_methods_1.AllowedMethods.toString());
        requestOptions.extraHeaders.push("Contact: " + this._contact);
        // Just send an INVITE with no sdp...
        if (options.withoutSdp) {
            if (!this.dialog) {
                this.pendingReinvite = false;
                throw new Error("Dialog undefined.");
            }
            return Promise.resolve(this.dialog.invite(delegate, requestOptions));
        }
        // Get an offer and send it in an INVITE
        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
        //        This behavior was ported from legacy code and the issue punted down the road.
        var offerOptions = {
            sessionDescriptionHandlerOptions: options.sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: options.sessionDescriptionHandlerModifiers
        };
        return this.getOffer(offerOptions)
            .then(function (offerBody) {
            if (!_this.dialog) {
                _this.pendingReinvite = false;
                throw new Error("Dialog undefined.");
            }
            requestOptions.body = offerBody;
            return _this.dialog.invite(delegate, requestOptions);
        })
            .catch(function (error) {
            _this.logger.error(error.message);
            _this.logger.error("Failed to send re-INVITE");
            _this.pendingReinvite = false;
            throw error;
        });
    };
    /**
     * Deliver a {@link Message}. Sends a MESSAGE.
     * @param options - Options bucket. See {@link SessionMessageOptions} for details.
     */
    Session.prototype.message = function (options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.message() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        return this._message(requestDelegate, requestOptions);
    };
    /**
     * Proffer a {@link Referral}. Send a REFER.
     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.
     * @param options - Options bucket. See {@link SessionReferOptions} for details.
     */
    Session.prototype.refer = function (referTo, options) {
        if (options === void 0) { options = {}; }
        // guard session state
        if (this.state !== session_state_1.SessionState.Established) {
            var message = "Session.refer() may only be called if established session.";
            this.logger.error(message);
            return Promise.reject(new Error("Invalid session state " + this.state));
        }
        var requestDelegate = options.requestDelegate;
        var requestOptions = this.copyRequestOptions(options.requestOptions);
        requestOptions.extraHeaders = requestOptions.extraHeaders ?
            requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) :
            this.referExtraHeaders(this.referToString(referTo));
        return this._refer(options.onNotify, requestDelegate, requestOptions);
    };
    /**
     * Send BYE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._bye = function (delegate, options) {
        var _this = this;
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        var dialog = this.dialog;
        // The caller's UA MAY send a BYE for either confirmed or early dialogs,
        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT
        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a
        // BYE on a confirmed dialog until it has received an ACK for its 2xx
        // response or until the server transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        switch (dialog.sessionState) {
            case core_1.SessionState.Initial:
                throw new Error("Invalid dialog state " + dialog.sessionState);
            case core_1.SessionState.Early: // Implementation choice - not sending BYE for early dialogs.
                throw new Error("Invalid dialog state " + dialog.sessionState);
            case core_1.SessionState.AckWait: { // This state only occurs if we are the callee.
                this.stateTransition(session_state_1.SessionState.Terminating); // We're terminating
                return new Promise(function (resolve, reject) {
                    dialog.delegate = {
                        // When ACK shows up, say BYE.
                        onAck: function () {
                            var request = dialog.bye(delegate, options);
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                            resolve(request);
                        },
                        // Or the server transaction times out before the ACK arrives.
                        onAckTimeout: function () {
                            var request = dialog.bye(delegate, options);
                            _this.stateTransition(session_state_1.SessionState.Terminated);
                            resolve(request);
                        }
                    };
                });
            }
            case core_1.SessionState.Confirmed: {
                var request = dialog.bye(delegate, options);
                this.stateTransition(session_state_1.SessionState.Terminated);
                return Promise.resolve(request);
            }
            case core_1.SessionState.Terminated:
                throw new Error("Invalid dialog state " + dialog.sessionState);
            default:
                throw new Error("Unrecognized state.");
        }
    };
    /**
     * Send INFO.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._info = function (delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        return Promise.resolve(this.dialog.info(delegate, options));
    };
    /**
     * Send MESSAGE.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._message = function (delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        return Promise.resolve(this.dialog.message(delegate, options));
    };
    /**
     * Send REFER.
     * @param onNotify - Notification callback.
     * @param delegate - Request delegate.
     * @param options - Request options bucket.
     * @internal
     */
    Session.prototype._refer = function (onNotify, delegate, options) {
        // Using core session dialog
        if (!this.dialog) {
            return Promise.reject(new Error("Session dialog undefined."));
        }
        // If set, deliver any in-dialog NOTIFY requests here...
        this.onNotify = onNotify;
        return Promise.resolve(this.dialog.refer(delegate, options));
    };
    /**
     * Send ACK and then BYE. There are unrecoverable errors which can occur
     * while handling dialog forming and in-dialog INVITE responses and when
     * they occur we ACK the response and send a BYE.
     * Note that the BYE is sent in the dialog associated with the response
     * which is not necessarily `this.dialog`. And, accordingly, the
     * session state is not transitioned to terminated and session is not closed.
     * @param inviteResponse - The response causing the error.
     * @param statusCode - Status code for he reason phrase.
     * @param reasonPhrase - Reason phrase for the BYE.
     * @internal
     */
    Session.prototype.ackAndBye = function (response, statusCode, reasonPhrase) {
        response.ack();
        var extraHeaders = [];
        if (statusCode) {
            extraHeaders.push("Reason: " + this.getReasonHeaderValue(statusCode, reasonPhrase));
        }
        // Using the dialog session associate with the response (which might not be this.dialog)
        response.session.bye(undefined, { extraHeaders: extraHeaders });
    };
    /**
     * Handle in dialog ACK request.
     * @internal
     */
    Session.prototype.onAckRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onAckRequest");
        if (this.state !== session_state_1.SessionState.Established && this.state !== session_state_1.SessionState.Terminating) {
            this.logger.error("ACK received while in state " + this.state + ", dropping request");
            return;
        }
        var dialog = this.dialog;
        if (!dialog) {
            throw new Error("Dialog undefined.");
        }
        switch (dialog.signalingState) {
            case core_1.SignalingState.Initial: {
                // State should never be reached as first reliable response must have answer/offer.
                // So we must have never has sent an offer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.Stable: {
                // State we should be in.
                // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.
                var body = core_1.getBody(request.message);
                // If the ACK doesn't have an answer, nothing to be done.
                if (!body) {
                    return;
                }
                if (body.contentDisposition === "render") {
                    this._renderbody = body.content;
                    this._rendertype = body.contentType;
                    return;
                }
                if (body.contentDisposition !== "session") {
                    return;
                }
                // Received answer in ACK.
                var options = {
                    sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
                    sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
                };
                this.setAnswer(body, options)
                    .catch(function (error) {
                    _this.logger.error(error.message);
                    var extraHeaders = ["Reason: " + _this.getReasonHeaderValue(488, "Bad Media Description")];
                    dialog.bye(undefined, { extraHeaders: extraHeaders });
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                });
                return;
            }
            case core_1.SignalingState.HaveLocalOffer: {
                // State should never be reached as local offer would be answered by this ACK.
                // So we must have received an ACK without an answer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.HaveRemoteOffer: {
                // State should never be reached as remote offer would be answered in first reliable response.
                // So we must have never has sent an answer.
                this.logger.error("Invalid signaling state " + dialog.signalingState + ".");
                var extraHeaders = ["Reason: " + this.getReasonHeaderValue(488, "Bad Media Description")];
                dialog.bye(undefined, { extraHeaders: extraHeaders });
                this.stateTransition(session_state_1.SessionState.Terminated);
                return;
            }
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + dialog.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + dialog.signalingState + ".");
        }
    };
    /**
     * Handle in dialog BYE request.
     * @internal
     */
    Session.prototype.onByeRequest = function (request) {
        this.logger.log("Session.onByeRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("BYE received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onBye) {
            var bye = new bye_1.Bye(request);
            this.delegate.onBye(bye);
        }
        else {
            request.accept();
        }
        this.stateTransition(session_state_1.SessionState.Terminated);
    };
    /**
     * Handle in dialog INFO request.
     * @internal
     */
    Session.prototype.onInfoRequest = function (request) {
        this.logger.log("Session.onInfoRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("INFO received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onInfo) {
            var info = new info_1.Info(request);
            this.delegate.onInfo(info);
        }
        else {
            // FIXME: TODO: We should reject request...
            //
            // If a UA receives an INFO request associated with an Info Package that
            // the UA has not indicated willingness to receive, the UA MUST send a
            // 469 (Bad Info Package) response (see Section 11.6), which contains a
            // Recv-Info header field with Info Packages for which the UA is willing
            // to receive INFO requests.
            // https://tools.ietf.org/html/rfc6086#section-4.2.2
            request.accept();
        }
    };
    /**
     * Handle in dialog INVITE request.
     * @internal
     */
    Session.prototype.onInviteRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onInviteRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("INVITE received while in state " + this.state + ", dropping request");
            return;
        }
        // TODO: would be nice to have core track and set the Contact header,
        // but currently the session which is setting it is holding onto it.
        var extraHeaders = ["Contact: " + this._contact];
        // Handle P-Asserted-Identity
        if (request.message.hasHeader("P-Asserted-Identity")) {
            var header = request.message.getHeader("P-Asserted-Identity");
            if (!header) {
                throw new Error("Header undefined.");
            }
            this._assertedIdentity = core_1.Grammar.nameAddrHeaderParse(header);
        }
        // FIXME: SDH options & SDH modifiers options are applied somewhat ambiguously
        //        This behavior was ported from legacy code and the issue punted down the road.
        var options = {
            sessionDescriptionHandlerOptions: this._sessionDescriptionHandlerOptions,
            sessionDescriptionHandlerModifiers: this._sessionDescriptionHandlerModifiers
        };
        this.generateResponseOfferAnswerInDialog(options)
            .then(function (body) {
            var outgoingResponse = request.accept({ statusCode: 200, extraHeaders: extraHeaders, body: body });
            if (_this.delegate && _this.delegate.onInvite) {
                _this.delegate.onInvite(request.message, outgoingResponse.message, 200);
            }
        })
            .catch(function (error) {
            _this.logger.error(error.message);
            _this.logger.error("Failed to handle to re-INVITE request");
            if (!_this.dialog) {
                throw new Error("Dialog undefined.");
            }
            _this.logger.error(_this.dialog.signalingState);
            // If we don't have a local/remote offer...
            if (_this.dialog.signalingState === core_1.SignalingState.Stable) {
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
                return;
            }
            // Otherwise rollback
            _this.rollbackOffer()
                .then(function () {
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
            })
                .catch(function (errorRollback) {
                // No way to recover, so terminate session and mark as failed.
                _this.logger.error(errorRollback.message);
                _this.logger.error("Failed to rollback offer on re-INVITE request");
                var outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here
                // A BYE should only be sent if session is not already terminated.
                // For example, a BYE may be sent/received while re-INVITE is outstanding.
                // Note that the ACK was already sent by the transaction, so just need to send BYE.
                if (_this.state !== session_state_1.SessionState.Terminated) {
                    if (!_this.dialog) {
                        throw new Error("Dialog undefined.");
                    }
                    var extraHeadersBye = [];
                    extraHeadersBye.push("Reason: " + _this.getReasonHeaderValue(500, "Internal Server Error"));
                    _this.dialog.bye(undefined, { extraHeaders: extraHeaders });
                    _this.stateTransition(session_state_1.SessionState.Terminated);
                }
                if (_this.delegate && _this.delegate.onInvite) {
                    _this.delegate.onInvite(request.message, outgoingResponse.message, 488);
                }
            });
        });
    };
    /**
     * Handle in dialog MESSAGE request.
     * @internal
     */
    Session.prototype.onMessageRequest = function (request) {
        this.logger.log("Session.onMessageRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("MESSAGE received while in state " + this.state + ", dropping request");
            return;
        }
        if (this.delegate && this.delegate.onMessage) {
            var message = new message_1.Message(request);
            this.delegate.onMessage(message);
        }
        else {
            request.accept();
        }
    };
    /**
     * Handle in dialog NOTIFY request.
     * @internal
     */
    Session.prototype.onNotifyRequest = function (request) {
        this.logger.log("Session.onNotifyRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("NOTIFY received while in state " + this.state + ", dropping request");
            return;
        }
        // If this a NOTIFY associated with the progress of a REFER,
        // look to delegate handling to the associated callback.
        if (this.onNotify) {
            var notification = new notification_1.Notification(request);
            this.onNotify(notification);
            return;
        }
        // Otherwise accept the NOTIFY.
        if (this.delegate && this.delegate.onNotify) {
            var notification = new notification_1.Notification(request);
            this.delegate.onNotify(notification);
        }
        else {
            request.accept();
        }
    };
    /**
     * Handle in dialog PRACK request.
     * @internal
     */
    Session.prototype.onPrackRequest = function (request) {
        this.logger.log("Session.onPrackRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("PRACK received while in state " + this.state + ", dropping request");
            return;
        }
        throw new Error("Unimplemented.");
    };
    /**
     * Handle in dialog REFER request.
     * @internal
     */
    Session.prototype.onReferRequest = function (request) {
        var _this = this;
        this.logger.log("Session.onReferRequest");
        if (this.state !== session_state_1.SessionState.Established) {
            this.logger.error("REFER received while in state " + this.state + ", dropping request");
            return;
        }
        // REFER is a SIP request and is constructed as defined in [1].  A REFER
        // request MUST contain exactly one Refer-To header field value.
        // https://tools.ietf.org/html/rfc3515#section-2.4.1
        if (!request.message.hasHeader("refer-to")) {
            this.logger.warn("Invalid REFER packet. A refer-to header is required. Rejecting.");
            request.reject();
            return;
        }
        var referral = new referral_1.Referral(request, this);
        if (this.delegate && this.delegate.onRefer) {
            this.delegate.onRefer(referral);
        }
        else {
            this.logger.log("No delegate available to handle REFER, automatically accepting and following.");
            referral
                .accept()
                .then(function () { return referral
                .makeInviter(_this._referralInviterOptions)
                .invite(); })
                .catch(function (error) {
                // FIXME: logging and eating error...
                _this.logger.error(error.message);
            });
        }
    };
    /**
     * Generate an offer or answer for a response to an INVITE request.
     * If a remote offer was provided in the request, set the remote
     * description and get a local answer. If a remote offer was not
     * provided, generates a local offer.
     * @internal
     */
    Session.prototype.generateResponseOfferAnswer = function (request, options) {
        if (this.dialog) {
            return this.generateResponseOfferAnswerInDialog(options);
        }
        var body = core_1.getBody(request.message);
        if (!body || body.contentDisposition !== "session") {
            return this.getOffer(options);
        }
        else {
            return this.setOfferAndGetAnswer(body, options);
        }
    };
    /**
     * Generate an offer or answer for a response to an INVITE request
     * when a dialog (early or otherwise) has already been established.
     * This method may NOT be called if a dialog has yet to be established.
     * @internal
     */
    Session.prototype.generateResponseOfferAnswerInDialog = function (options) {
        if (!this.dialog) {
            throw new Error("Dialog undefined.");
        }
        switch (this.dialog.signalingState) {
            case core_1.SignalingState.Initial:
                return this.getOffer(options);
            case core_1.SignalingState.HaveLocalOffer:
                // o  Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                return Promise.resolve(undefined);
            case core_1.SignalingState.HaveRemoteOffer:
                if (!this.dialog.offer) {
                    throw new Error("Session offer undefined in signaling state " + this.dialog.signalingState + ".");
                }
                return this.setOfferAndGetAnswer(this.dialog.offer, options);
            case core_1.SignalingState.Stable:
                // o  Once the UAS has sent or received an answer to the initial
                // offer, it MUST NOT generate subsequent offers in any responses
                // to the initial INVITE.  This means that a UAS based on this
                // specification alone can never generate subsequent offers until
                // completion of the initial transaction.
                // https://tools.ietf.org/html/rfc3261#section-13.2.1
                if (this.state !== session_state_1.SessionState.Established) {
                    return Promise.resolve(undefined);
                }
                // In dialog INVITE without offer, get an offer for the response.
                return this.getOffer(options);
            case core_1.SignalingState.Closed:
                throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
            default:
                throw new Error("Invalid signaling state " + this.dialog.signalingState + ".");
        }
    };
    /**
     * Get local offer.
     * @internal
     */
    Session.prototype.getOffer = function (options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            return sdh.getDescription(sdhOptions, sdhModifiers)
                .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                .catch(function (error) {
                _this.logger.error("Session.getOffer: SDH getDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.getOffer: SDH getDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Rollback local/remote offer.
     * @internal
     */
    Session.prototype.rollbackOffer = function () {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        if (!sdh.rollbackDescription) {
            return Promise.resolve();
        }
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            return sdh.rollbackDescription()
                .catch(function (error) {
                _this.logger.error("Session.rollbackOffer: SDH rollbackDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.rollbackOffer: SDH rollbackDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Set remote answer.
     * @internal
     */
    Session.prototype.setAnswer = function (answer, options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            if (!sdh.hasDescription(answer.contentType)) {
                return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
            }
        }
        catch (error) {
            this.logger.error("Session.setAnswer: SDH hasDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
        try {
            return sdh.setDescription(answer.content, sdhOptions, sdhModifiers)
                .catch(function (error) {
                _this.logger.error("Session.setAnswer: SDH setDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.setAnswer: SDH setDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * Set remote offer and get local answer.
     * @internal
     */
    Session.prototype.setOfferAndGetAnswer = function (offer, options) {
        var _this = this;
        var sdh = this.setupSessionDescriptionHandler();
        var sdhOptions = options.sessionDescriptionHandlerOptions;
        var sdhModifiers = options.sessionDescriptionHandlerModifiers;
        // This is intentionally written very defensively. Don't trust SDH to behave.
        try {
            if (!sdh.hasDescription(offer.contentType)) {
                return Promise.reject(new exceptions_1.ContentTypeUnsupportedError());
            }
        }
        catch (error) {
            this.logger.error("Session.setOfferAndGetAnswer: SDH hasDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
        try {
            return sdh.setDescription(offer.content, sdhOptions, sdhModifiers)
                .then(function () { return sdh.getDescription(sdhOptions, sdhModifiers); })
                .then(function (bodyAndContentType) { return core_1.fromBodyLegacy(bodyAndContentType); })
                .catch(function (error) {
                _this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...");
                var e = error instanceof Error ? error : new Error(error);
                _this.logger.error(e.message);
                throw e;
            });
        }
        catch (error) { // don't trust SDH to throw an Error
            this.logger.error("Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...");
            var e = error instanceof Error ? error : new Error(error);
            this.logger.error(e.message);
            return Promise.reject(e);
        }
    };
    /**
     * SDH for confirmed dialog.
     * @internal
     */
    Session.prototype.setSessionDescriptionHandler = function (sdh) {
        if (this._sessionDescriptionHandler) {
            throw new Error("Session description handler defined.");
        }
        this._sessionDescriptionHandler = sdh;
    };
    /**
     * SDH for confirmed dialog.
     * @internal
     */
    Session.prototype.setupSessionDescriptionHandler = function () {
        if (this._sessionDescriptionHandler) {
            return this._sessionDescriptionHandler;
        }
        this._sessionDescriptionHandler =
            this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);
        return this._sessionDescriptionHandler;
    };
    /**
     * Transition session state.
     * @internal
     */
    Session.prototype.stateTransition = function (newState) {
        var _this = this;
        var invalidTransition = function () {
            throw new Error("Invalid state transition from " + _this._state + " to " + newState);
        };
        // Validate transition
        switch (this._state) {
            case session_state_1.SessionState.Initial:
                if (newState !== session_state_1.SessionState.Establishing &&
                    newState !== session_state_1.SessionState.Established &&
                    newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Establishing:
                if (newState !== session_state_1.SessionState.Established &&
                    newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Established:
                if (newState !== session_state_1.SessionState.Terminating &&
                    newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Terminating:
                if (newState !== session_state_1.SessionState.Terminated) {
                    invalidTransition();
                }
                break;
            case session_state_1.SessionState.Terminated:
                invalidTransition();
                break;
            default:
                throw new Error("Unrecognized state.");
        }
        // Transition
        this._state = newState;
        this.logger.log("Session " + this.id + " transitioned to state " + this._state);
        this._stateEventEmitter.emit("event", this._state);
        // Dispose
        if (newState === session_state_1.SessionState.Terminated) {
            this.dispose();
        }
    };
    Session.prototype.copyRequestOptions = function (requestOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        var extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;
        var body = requestOptions.body ?
            {
                contentDisposition: requestOptions.body.contentDisposition || "render",
                contentType: requestOptions.body.contentType || "text/plain",
                content: requestOptions.body.content || ""
            } : undefined;
        return {
            extraHeaders: extraHeaders,
            body: body
        };
    };
    Session.prototype.getReasonHeaderValue = function (code, reason) {
        var cause = code;
        var text = utils_1.getReasonPhrase(code);
        if (!text && reason) {
            text = reason;
        }
        return "SIP;cause=" + cause + ';text="' + text + '"';
    };
    Session.prototype.referExtraHeaders = function (referTo) {
        var extraHeaders = [];
        extraHeaders.push("Referred-By: <" + this.userAgent.configuration.uri + ">");
        extraHeaders.push("Contact: " + this._contact);
        extraHeaders.push("Allow: " + [
            "ACK",
            "CANCEL",
            "INVITE",
            "MESSAGE",
            "BYE",
            "OPTIONS",
            "INFO",
            "NOTIFY",
            "REFER"
        ].toString());
        extraHeaders.push("Refer-To: " + referTo);
        return extraHeaders;
    };
    Session.prototype.referToString = function (target) {
        var referTo;
        if (target instanceof core_1.URI) {
            // REFER without Replaces (Blind Transfer)
            referTo = target.toString();
        }
        else {
            // REFER with Replaces (Attended Transfer)
            if (!target.dialog) {
                throw new Error("Dialog undefined.");
            }
            var displayName = target.remoteIdentity.friendlyName;
            var remoteTarget = target.dialog.remoteTarget.toString();
            var callId = target.dialog.callId;
            var remoteTag = target.dialog.remoteTag;
            var localTag = target.dialog.localTag;
            var replaces = encodeURIComponent(callId + ";to-tag=" + remoteTag + ";from-tag=" + localTag);
            referTo = "\"" + displayName + "\" <" + remoteTarget + "?Replaces=" + replaces + ">";
        }
        return referTo;
    };
    return Session;
}());
exports.Session = Session;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/dialog.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/dialog.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
/**
 * Dialog.
 * @remarks
 * A key concept for a user agent is that of a dialog.  A dialog
 * represents a peer-to-peer SIP relationship between two user agents
 * that persists for some time.  The dialog facilitates sequencing of
 * messages between the user agents and proper routing of requests
 * between both of them.  The dialog represents a context in which to
 * interpret SIP messages.
 * https://tools.ietf.org/html/rfc3261#section-12
 * @public
 */
var Dialog = /** @class */ (function () {
    /**
     * Dialog constructor.
     * @param core - User agent core.
     * @param dialogState - Initial dialog state.
     */
    function Dialog(core, dialogState) {
        this.core = core;
        this.dialogState = dialogState;
        this.core.dialogs.set(this.id, this);
    }
    /**
     * When a UAC receives a response that establishes a dialog, it
     * constructs the state of the dialog.  This state MUST be maintained
     * for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.2
     * @param outgoingRequestMessage - Outgoing request message for dialog.
     * @param incomingResponseMessage - Incoming response message creating dialog.
     */
    Dialog.initialDialogStateForUserAgentClient = function (outgoingRequestMessage, incomingResponseMessage) {
        // If the request was sent over TLS, and the Request-URI contained a
        // SIPS URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the response, taken in reverse order and preserving
        // all URI parameters.  If no Record-Route header field is present in
        // the response, the route set MUST be set to the empty set.  This route
        // set, even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the response.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var routeSet = incomingResponseMessage.getHeaders("record-route").reverse();
        var contact = incomingResponseMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The local sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The remote sequence
        // number MUST be empty (it is established when the remote UA sends a
        // request within the dialog).  The call identifier component of the
        // dialog ID MUST be set to the value of the Call-ID in the request.
        // The local tag component of the dialog ID MUST be set to the tag in
        // the From field in the request, and the remote tag component of the
        // dialog ID MUST be set to the tag in the To field of the response.  A
        // UAC MUST be prepared to receive a response without a tag in the To
        // field, in which case the tag is considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate To tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var localSequenceNumber = outgoingRequestMessage.cseq;
        var remoteSequenceNumber = undefined;
        var callId = outgoingRequestMessage.callId;
        var localTag = outgoingRequestMessage.fromTag;
        var remoteTag = incomingResponseMessage.toTag;
        if (!callId) { // TODO: Review to make sure this will never happen
            throw new Error("Call id undefined.");
        }
        if (!localTag) { // TODO: Review to make sure this will never happen
            throw new Error("From tag undefined.");
        }
        if (!remoteTag) { // TODO: Review to make sure this will never happen
            throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
        }
        // The remote URI MUST be set to the URI in the To field, and the local
        // URI MUST be set to the URI in the From field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        if (!outgoingRequestMessage.from) { // TODO: Review to make sure this will never happen
            throw new Error("From undefined.");
        }
        if (!outgoingRequestMessage.to) { // TODO: Review to make sure this will never happen
            throw new Error("To undefined.");
        }
        var localURI = outgoingRequestMessage.from.uri;
        var remoteURI = outgoingRequestMessage.to.uri;
        // A dialog can also be in the "early" state, which occurs when it is
        // created with a provisional response, and then transition to the
        // "confirmed" state when a 2xx final response arrives.
        // https://tools.ietf.org/html/rfc3261#section-12
        if (!incomingResponseMessage.statusCode) {
            throw new Error("Incoming response status code undefined.");
        }
        var early = incomingResponseMessage.statusCode < 200 ? true : false;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    /**
     * The UAS then constructs the state of the dialog.  This state MUST be
     * maintained for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.1
     * @param incomingRequestMessage - Incoming request message creating dialog.
     * @param toTag - Tag in the To field in the response to the incoming request.
     */
    Dialog.initialDialogStateForUserAgentServer = function (incomingRequestMessage, toTag, early) {
        if (early === void 0) { early = false; }
        // If the request arrived over TLS, and the Request-URI contained a SIPS
        // URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the request, taken in order and preserving all URI
        // parameters.  If no Record-Route header field is present in the
        // request, the route set MUST be set to the empty set.  This route set,
        // even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the request.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var routeSet = incomingRequestMessage.getHeaders("record-route");
        var contact = incomingRequestMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The remote sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The local sequence
        // number MUST be empty.  The call identifier component of the dialog ID
        // MUST be set to the value of the Call-ID in the request.  The local
        // tag component of the dialog ID MUST be set to the tag in the To field
        // in the response to the request (which always includes a tag), and the
        // remote tag component of the dialog ID MUST be set to the tag from the
        // From field in the request.  A UAS MUST be prepared to receive a
        // request without a tag in the From field, in which case the tag is
        // considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate From tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var remoteSequenceNumber = incomingRequestMessage.cseq;
        var localSequenceNumber = undefined;
        var callId = incomingRequestMessage.callId;
        var localTag = toTag;
        var remoteTag = incomingRequestMessage.fromTag;
        // The remote URI MUST be set to the URI in the From field, and the
        // local URI MUST be set to the URI in the To field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var remoteURI = incomingRequestMessage.from.uri;
        var localURI = incomingRequestMessage.to.uri;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    /** Destructor. */
    Dialog.prototype.dispose = function () {
        this.core.dialogs.delete(this.id);
    };
    Object.defineProperty(Dialog.prototype, "id", {
        /**
         * A dialog is identified at each UA with a dialog ID, which consists of
         * a Call-ID value, a local tag and a remote tag.  The dialog ID at each
         * UA involved in the dialog is not the same.  Specifically, the local
         * tag at one UA is identical to the remote tag at the peer UA.  The
         * tags are opaque tokens that facilitate the generation of unique
         * dialog IDs.
         * https://tools.ietf.org/html/rfc3261#section-12
         */
        get: function () {
            return this.dialogState.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "early", {
        /**
         * A dialog can also be in the "early" state, which occurs when it is
         * created with a provisional response, and then it transition to the
         * "confirmed" state when a 2xx final response received or is sent.
         *
         * Note: RFC 3261 is concise on when a dialog is "confirmed", but it
         * can be a point of confusion if an INVITE dialog is "confirmed" after
         * a 2xx is sent or after receiving the ACK for the 2xx response.
         * With careful reading it can be inferred a dialog is always is
         * "confirmed" when the 2xx is sent (regardless of type of dialog).
         * However a INVITE dialog does have additional considerations
         * when it is confirmed but an ACK has not yet been received (in
         * particular with regard to a callee sending BYE requests).
         */
        get: function () {
            return this.dialogState.early;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "callId", {
        /** Call identifier component of the dialog id. */
        get: function () {
            return this.dialogState.callId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localTag", {
        /** Local tag component of the dialog id. */
        get: function () {
            return this.dialogState.localTag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteTag", {
        /** Remote tag component of the dialog id. */
        get: function () {
            return this.dialogState.remoteTag;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localSequenceNumber", {
        /** Local sequence number (used to order requests from the UA to its peer). */
        get: function () {
            return this.dialogState.localSequenceNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteSequenceNumber", {
        /** Remote sequence number (used to order requests from its peer to the UA). */
        get: function () {
            return this.dialogState.remoteSequenceNumber;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "localURI", {
        /** Local URI. */
        get: function () {
            return this.dialogState.localURI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteURI", {
        /** Remote URI. */
        get: function () {
            return this.dialogState.remoteURI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "remoteTarget", {
        /** Remote target. */
        get: function () {
            return this.dialogState.remoteTarget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "routeSet", {
        /**
         * Route set, which is an ordered list of URIs. The route set is the
         * list of servers that need to be traversed to send a request to the peer.
         */
        get: function () {
            return this.dialogState.routeSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "secure", {
        /**
         * If the request was sent over TLS, and the Request-URI contained
         * a SIPS URI, the "secure" flag is set to true. *NOT IMPLEMENTED*
         */
        get: function () {
            return this.dialogState.secure;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Dialog.prototype, "userAgentCore", {
        /** The user agent core servicing this dialog. */
        get: function () {
            return this.core;
        },
        enumerable: true,
        configurable: true
    });
    /** Confirm the dialog. Only matters if dialog is currently early. */
    Dialog.prototype.confirm = function () {
        this.dialogState.early = false;
    };
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     *
     *    Note that some requests, such as INVITEs, affect several pieces of
     *    state.
     *
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */
    Dialog.prototype.receiveRequest = function (message) {
        // ACK guard.
        // By convention, the handling of ACKs is the responsibility
        // the particular dialog implementation. For example, see SessionDialog.
        // Furthermore, ACKs have same sequence number as the associated INVITE.
        if (message.method === messages_1.C.ACK) {
            return;
        }
        // If the remote sequence number was not empty, but the sequence number
        // of the request is lower than the remote sequence number, the request
        // is out of order and MUST be rejected with a 500 (Server Internal
        // Error) response.  If the remote sequence number was not empty, and
        // the sequence number of the request is greater than the remote
        // sequence number, the request is in order.  It is possible for the
        // CSeq sequence number to be higher than the remote sequence number by
        // more than one.  This is not an error condition, and a UAS SHOULD be
        // prepared to receive and process requests with CSeq values more than
        // one higher than the previous received request.  The UAS MUST then set
        // the remote sequence number to the value of the sequence number in the
        // CSeq header field value in the request.
        //
        //    If a proxy challenges a request generated by the UAC, the UAC has
        //    to resubmit the request with credentials.  The resubmitted request
        //    will have a new CSeq number.  The UAS will never see the first
        //    request, and thus, it will notice a gap in the CSeq number space.
        //    Such a gap does not represent any error condition.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (this.remoteSequenceNumber) {
            if (message.cseq <= this.remoteSequenceNumber) {
                throw new Error("Out of sequence in dialog request. Did you forget to call sequenceGuard()?");
            }
            this.dialogState.remoteSequenceNumber = message.cseq;
        }
        // If the remote sequence number is empty, it MUST be set to the value
        // of the sequence number in the CSeq header field value in the request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.remoteSequenceNumber) {
            this.dialogState.remoteSequenceNumber = message.cseq;
        }
        // When a UAS receives a target refresh request, it MUST replace the
        // dialog's remote target URI with the URI from the Contact header field
        // in that request, if present.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        // Note: "target refresh request" processing delegated to sub-class.
    };
    /**
     * If the dialog identifier in the 2xx response matches the dialog
     * identifier of an existing dialog, the dialog MUST be transitioned to
     * the "confirmed" state, and the route set for the dialog MUST be
     * recomputed based on the 2xx response using the procedures of Section
     * 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
     * constructed using the procedures of Section 12.1.2.
     *
     * Note that the only piece of state that is recomputed is the route
     * set.  Other pieces of state such as the highest sequence numbers
     * (remote and local) sent within the dialog are not recomputed.  The
     * route set only is recomputed for backwards compatibility.  RFC
     * 2543 did not mandate mirroring of the Record-Route header field in
     * a 1xx, only 2xx.  However, we cannot update the entire state of
     * the dialog, since mid-dialog requests may have been sent within
     * the early dialog, modifying the sequence numbers, for example.
     *
     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     */
    Dialog.prototype.recomputeRouteSet = function (message) {
        this.dialogState.routeSet = message.getHeaders("record-route").reverse();
    };
    /**
     * A request within a dialog is constructed by using many of the
     * components of the state stored as part of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1
     * @param method - Outgoing request method.
     */
    Dialog.prototype.createOutgoingRequestMessage = function (method, options) {
        // The URI in the To field of the request MUST be set to the remote URI
        // from the dialog state.  The tag in the To header field of the request
        // MUST be set to the remote tag of the dialog ID.  The From URI of the
        // request MUST be set to the local URI from the dialog state.  The tag
        // in the From header field of the request MUST be set to the local tag
        // of the dialog ID.  If the value of the remote or local tags is null,
        // the tag parameter MUST be omitted from the To or From header fields,
        // respectively.
        //
        //    Usage of the URI from the To and From fields in the original
        //    request within subsequent requests is done for backwards
        //    compatibility with RFC 2543, which used the URI for dialog
        //    identification.  In this specification, only the tags are used for
        //    dialog identification.  It is expected that mandatory reflection
        //    of the original To and From URI in mid-dialog requests will be
        //    deprecated in a subsequent revision of this specification.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        var toUri = this.remoteURI;
        var toTag = this.remoteTag;
        var fromUri = this.localURI;
        var fromTag = this.localTag;
        // The Call-ID of the request MUST be set to the Call-ID of the dialog.
        // Requests within a dialog MUST contain strictly monotonically
        // increasing and contiguous CSeq sequence numbers (increasing-by-one)
        // in each direction (excepting ACK and CANCEL of course, whose numbers
        // equal the requests being acknowledged or cancelled).  Therefore, if
        // the local sequence number is not empty, the value of the local
        // sequence number MUST be incremented by one, and this value MUST be
        // placed into the CSeq header field.  If the local sequence number is
        // empty, an initial value MUST be chosen using the guidelines of
        // Section 8.1.1.5.  The method field in the CSeq header field value
        // MUST match the method of the request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        var callId = this.callId;
        var cseq;
        if (options && options.cseq) {
            cseq = options.cseq;
        }
        else if (!this.dialogState.localSequenceNumber) {
            cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5
        }
        else {
            cseq = this.dialogState.localSequenceNumber += 1;
        }
        // The UAC uses the remote target and route set to build the Request-URI
        // and Route header field of the request.
        //
        // If the route set is empty, the UAC MUST place the remote target URI
        // into the Request-URI.  The UAC MUST NOT add a Route header field to
        // the request.
        //
        // If the route set is not empty, and the first URI in the route set
        // contains the lr parameter (see Section 19.1.1), the UAC MUST place
        // the remote target URI into the Request-URI and MUST include a Route
        // header field containing the route set values in order, including all
        // parameters.
        //
        // If the route set is not empty, and its first URI does not contain the
        // lr parameter, the UAC MUST place the first URI from the route set
        // into the Request-URI, stripping any parameters that are not allowed
        // in a Request-URI.  The UAC MUST add a Route header field containing
        // the remainder of the route set values in order, including all
        // parameters.  The UAC MUST then place the remote target URI into the
        // Route header field as the last value.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        // The lr parameter, when present, indicates that the element
        // responsible for this resource implements the routing mechanisms
        // specified in this document.  This parameter will be used in the
        // URIs proxies place into Record-Route header field values, and
        // may appear in the URIs in a pre-existing route set.
        //
        // This parameter is used to achieve backwards compatibility with
        // systems implementing the strict-routing mechanisms of RFC 2543
        // and the rfc2543bis drafts up to bis-05.  An element preparing
        // to send a request based on a URI not containing this parameter
        // can assume the receiving element implements strict-routing and
        // reformat the message to preserve the information in the
        // Request-URI.
        // https://tools.ietf.org/html/rfc3261#section-19.1.1
        // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
        var ruri = this.remoteTarget;
        var routeSet = this.routeSet;
        var extraHeaders = options && options.extraHeaders;
        var body = options && options.body;
        // The relative order of header fields with different field names is not
        // significant.  However, it is RECOMMENDED that header fields which are
        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
        // Max-Forwards, and Proxy-Authorization, for example) appear towards
        // the top of the message to facilitate rapid parsing.
        // https://tools.ietf.org/html/rfc3261#section-7.3.1
        var message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {
            callId: callId,
            cseq: cseq,
            fromTag: fromTag,
            toTag: toTag,
            routeSet: routeSet
        }, extraHeaders, body);
        return message;
    };
    /**
     * Increment the local sequence number by one.
     * It feels like this should be protected, but the current authentication handling currently
     * needs this to keep the dialog in sync when "auto re-sends" request messages.
     * @internal
     */
    Dialog.prototype.incrementLocalSequenceNumber = function () {
        if (!this.dialogState.localSequenceNumber) {
            throw new Error("Local sequence number undefined.");
        }
        this.dialogState.localSequenceNumber += 1;
    };
    /**
     * If the remote sequence number was not empty, but the sequence number
     * of the request is lower than the remote sequence number, the request
     * is out of order and MUST be rejected with a 500 (Server Internal
     * Error) response.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param request - Incoming request to guard.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.
     */
    Dialog.prototype.sequenceGuard = function (message) {
        // ACK guard.
        // By convention, handling of unexpected ACKs is responsibility
        // the particular dialog implementation. For example, see SessionDialog.
        // Furthermore, we cannot reply to an "out of sequence" ACK.
        if (message.method === messages_1.C.ACK) {
            return true;
        }
        // Note: We are rejecting on "less than or equal to" the remote
        // sequence number (excepting ACK whose numbers equal the requests
        // being acknowledged or cancelled), which is the correct thing to
        // do in our case. The only time a request with the same sequence number
        // will show up here if is a) it is a very late retransmission of a
        // request we already handled or b) it is a different request with the
        // same sequence number which would be violation of the standard.
        // Request retransmissions are absorbed by the transaction layer,
        // so any request with a duplicate sequence number getting here
        // would have to be a retransmission after the transaction terminated
        // or a broken request (with unique via branch value).
        // Requests within a dialog MUST contain strictly monotonically
        // increasing and contiguous CSeq sequence numbers (increasing-by-one)
        // in each direction (excepting ACK and CANCEL of course, whose numbers
        // equal the requests being acknowledged or cancelled).  Therefore, if
        // the local sequence number is not empty, the value of the local
        // sequence number MUST be incremented by one, and this value MUST be
        // placed into the CSeq header field.
        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1
        if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {
            this.core.replyStateless(message, { statusCode: 500 });
            return false;
        }
        return true;
    };
    return Dialog;
}());
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session-dialog */ "./node_modules/sip.js/lib/core/dialogs/session-dialog.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscription-dialog */ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/session-dialog.js":
/*!****************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/session-dialog.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var bye_user_agent_client_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js");
var bye_user_agent_server_1 = __webpack_require__(/*! ../user-agents/bye-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js");
var info_user_agent_client_1 = __webpack_require__(/*! ../user-agents/info-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js");
var info_user_agent_server_1 = __webpack_require__(/*! ../user-agents/info-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js");
var message_user_agent_client_1 = __webpack_require__(/*! ../user-agents/message-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js");
var message_user_agent_server_1 = __webpack_require__(/*! ../user-agents/message-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js");
var notify_user_agent_client_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js");
var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js");
var prack_user_agent_client_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js");
var prack_user_agent_server_1 = __webpack_require__(/*! ../user-agents/prack-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js");
var re_invite_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js");
var re_invite_user_agent_server_1 = __webpack_require__(/*! ../user-agents/re-invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js");
var refer_user_agent_client_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js");
var refer_user_agent_server_1 = __webpack_require__(/*! ../user-agents/refer-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js");
var dialog_1 = __webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js");
/**
 * Session Dialog.
 * @public
 */
var SessionDialog = /** @class */ (function (_super) {
    tslib_1.__extends(SessionDialog, _super);
    function SessionDialog(initialTransaction, core, state, delegate) {
        var _this = _super.call(this, core, state) || this;
        _this.initialTransaction = initialTransaction;
        /** The state of the offer/answer exchange. */
        _this._signalingState = session_1.SignalingState.Initial;
        /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */
        _this.ackWait = false;
        _this.delegate = delegate;
        if (initialTransaction instanceof transactions_1.InviteServerTransaction) {
            // If we're created by an invite server transaction, we're
            // going to be waiting for an ACK if are to be confirmed.
            _this.ackWait = true;
        }
        // If we're confirmed upon creation start the retransmitting whatever
        // the 2xx final response was that confirmed us into existence.
        if (!_this.early) {
            _this.start2xxRetransmissionTimer();
        }
        _this.signalingStateTransition(initialTransaction.request);
        _this.logger = core.loggerFactory.getLogger("sip.invite-dialog");
        _this.logger.log("INVITE dialog " + _this.id + " constructed");
        return _this;
    }
    SessionDialog.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._signalingState = session_1.SignalingState.Closed;
        this._offer = undefined;
        this._answer = undefined;
        if (this.invite2xxTimer) {
            clearTimeout(this.invite2xxTimer);
            this.invite2xxTimer = undefined;
        }
        // The UAS MUST still respond to any pending requests received for that
        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
        // be generated to those pending requests.
        // https://tools.ietf.org/html/rfc3261#section-15.1.2
        // TODO:
        // this.userAgentServers.forEach((uas) => uas.reply(487));
        this.logger.log("INVITE dialog " + this.id + " destroyed");
    };
    Object.defineProperty(SessionDialog.prototype, "sessionState", {
        // FIXME: Need real state machine
        get: function () {
            if (this.early) {
                return session_1.SessionState.Early;
            }
            else if (this.ackWait) {
                return session_1.SessionState.AckWait;
            }
            else if (this._signalingState === session_1.SignalingState.Closed) {
                return session_1.SessionState.Terminated;
            }
            else {
                return session_1.SessionState.Confirmed;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "signalingState", {
        /** The state of the offer/answer exchange. */
        get: function () {
            return this._signalingState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "offer", {
        /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */
        get: function () {
            return this._offer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SessionDialog.prototype, "answer", {
        /** The current answer. Undefined unless signaling state Stable. */
        get: function () {
            return this._answer;
        },
        enumerable: true,
        configurable: true
    });
    /** Confirm the dialog. Only matters if dialog is currently early. */
    SessionDialog.prototype.confirm = function () {
        // When we're confirmed start the retransmitting whatever
        // the 2xx final response that may have confirmed us.
        if (this.early) {
            this.start2xxRetransmissionTimer();
        }
        _super.prototype.confirm.call(this);
    };
    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */
    SessionDialog.prototype.reConfirm = function () {
        // When we're confirmed start the retransmitting whatever
        // the 2xx final response that may have confirmed us.
        if (this.reinviteUserAgentServer) {
            this.startReInvite2xxRetransmissionTimer();
        }
    };
    /**
     * The UAC core MUST generate an ACK request for each 2xx received from
     * the transaction layer.  The header fields of the ACK are constructed
     * in the same way as for any request sent within a dialog (see Section
     * 12) with the exception of the CSeq and the header fields related to
     * authentication.  The sequence number of the CSeq header field MUST be
     * the same as the INVITE being acknowledged, but the CSeq method MUST
     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
     * the 2xx contains an offer (based on the rules above), the ACK MUST
     * carry an answer in its body.  If the offer in the 2xx response is not
     * acceptable, the UAC core MUST generate a valid answer in the ACK and
     * then send a BYE immediately.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4
     * @param options - ACK options bucket.
     */
    SessionDialog.prototype.ack = function (options) {
        if (options === void 0) { options = {}; }
        this.logger.log("INVITE dialog " + this.id + " sending ACK request");
        var transaction;
        if (this.reinviteUserAgentClient) {
            // We're sending ACK for a re-INVITE
            if (!(this.reinviteUserAgentClient.transaction instanceof transactions_1.InviteClientTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            transaction = this.reinviteUserAgentClient.transaction;
            this.reinviteUserAgentClient = undefined;
        }
        else {
            // We're sending ACK for the initial INVITE
            if (!(this.initialTransaction instanceof transactions_1.InviteClientTransaction)) {
                throw new Error("Initial transaction not instance of InviteClientTransaction.");
            }
            transaction = this.initialTransaction;
        }
        options.cseq = transaction.request.cseq; // ACK cseq is INVITE cseq
        var message = this.createOutgoingRequestMessage(messages_1.C.ACK, options);
        transaction.ackResponse(message); // See InviteClientTransaction for details.
        this.signalingStateTransition(message);
        return { message: message };
    };
    /**
     * Terminating a Session
     *
     * This section describes the procedures for terminating a session
     * established by SIP.  The state of the session and the state of the
     * dialog are very closely related.  When a session is initiated with an
     * INVITE, each 1xx or 2xx response from a distinct UAS creates a
     * dialog, and if that response completes the offer/answer exchange, it
     * also creates a session.  As a result, each session is "associated"
     * with a single dialog - the one which resulted in its creation.  If an
     * initial INVITE generates a non-2xx final response, that terminates
     * all sessions (if any) and all dialogs (if any) that were created
     * through responses to the request.  By virtue of completing the
     * transaction, a non-2xx final response also prevents further sessions
     * from being created as a result of the INVITE.  The BYE request is
     * used to terminate a specific session or attempted session.  In this
     * case, the specific session is the one with the peer UA on the other
     * side of the dialog.  When a BYE is received on a dialog, any session
     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a
     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either
     * confirmed or early dialogs, and the callee's UA MAY send a BYE on
     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.
     *
     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog
     * until it has received an ACK for its 2xx response or until the server
     * transaction times out.  If no SIP extensions have defined other
     * application layer states associated with the dialog, the BYE also
     * terminates the dialog.
     *
     * https://tools.ietf.org/html/rfc3261#section-15
     * FIXME: Make these proper Exceptions...
     * @param options - BYE options bucket.
     * @returns
     * Throws `Error` if callee's UA attempts a BYE on an early dialog.
     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog
     *                while it's waiting on the ACK for its 2xx response.
     */
    SessionDialog.prototype.bye = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending BYE request");
        // The caller's UA MAY send a BYE for either
        // confirmed or early dialogs, and the callee's UA MAY send a BYE on
        // confirmed dialogs, but MUST NOT send a BYE on early dialogs.
        //
        // However, the callee's UA MUST NOT send a BYE on a confirmed dialog
        // until it has received an ACK for its 2xx response or until the server
        // transaction times out.
        // https://tools.ietf.org/html/rfc3261#section-15
        if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
            if (this.early) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("UAS MUST NOT send a BYE on early dialogs.");
            }
            if (this.ackWait && this.initialTransaction.state !== transactions_1.TransactionState.Terminated) {
                // FIXME: TODO: This should throw a proper exception.
                throw new Error("UAS MUST NOT send a BYE on a confirmed dialog " +
                    "until it has received an ACK for its 2xx response " +
                    "or until the server transaction times out.");
            }
        }
        // A BYE request is constructed as would any other request within a
        // dialog, as described in Section 12.
        //
        // Once the BYE is constructed, the UAC core creates a new non-INVITE
        // client transaction, and passes it the BYE request.  The UAC MUST
        // consider the session terminated (and therefore stop sending or
        // listening for media) as soon as the BYE request is passed to the
        // client transaction.  If the response for the BYE is a 481
        // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no
        // response at all is received for the BYE (that is, a timeout is
        // returned by the client transaction), the UAC MUST consider the
        // session and the dialog terminated.
        // https://tools.ietf.org/html/rfc3261#section-15.1.1
        return new bye_user_agent_client_1.ByeUserAgentClient(this, delegate, options);
    };
    /**
     * An INFO request can be associated with an Info Package (see
     * Section 5), or associated with a legacy INFO usage (see Section 2).
     *
     * The construction of the INFO request is the same as any other
     * non-target refresh request within an existing invite dialog usage as
     * described in Section 12.2 of RFC 3261.
     * https://tools.ietf.org/html/rfc6086#section-4.2.1
     * @param options - Options bucket.
     */
    SessionDialog.prototype.info = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending INFO request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        return new info_user_agent_client_1.InfoUserAgentClient(this, delegate, options);
    };
    /**
     * Modifying an Existing Session
     *
     * A successful INVITE request (see Section 13) establishes both a
     * dialog between two user agents and a session using the offer-answer
     * model.  Section 12 explains how to modify an existing dialog using a
     * target refresh request (for example, changing the remote target URI
     * of the dialog).  This section describes how to modify the actual
     * session.  This modification can involve changing addresses or ports,
     * adding a media stream, deleting a media stream, and so on.  This is
     * accomplished by sending a new INVITE request within the same dialog
     * that established the session.  An INVITE request sent within an
     * existing dialog is known as a re-INVITE.
     *
     *    Note that a single re-INVITE can modify the dialog and the
     *    parameters of the session at the same time.
     *
     * Either the caller or callee can modify an existing session.
     * https://tools.ietf.org/html/rfc3261#section-14
     * @param options - Options bucket
     */
    SessionDialog.prototype.invite = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending INVITE request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        // Note that a UAC MUST NOT initiate a new INVITE transaction within a
        // dialog while another INVITE transaction is in progress in either
        // direction.
        //
        //    1. If there is an ongoing INVITE client transaction, the TU MUST
        //       wait until the transaction reaches the completed or terminated
        //       state before initiating the new INVITE.
        //
        //    2. If there is an ongoing INVITE server transaction, the TU MUST
        //       wait until the transaction reaches the confirmed or terminated
        //       state before initiating the new INVITE.
        //
        // However, a UA MAY initiate a regular transaction while an INVITE
        // transaction is in progress.  A UA MAY also initiate an INVITE
        // transaction while a regular transaction is in progress.
        // https://tools.ietf.org/html/rfc3261#section-14.1
        if (this.reinviteUserAgentClient) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("There is an ongoing re-INVITE client transaction.");
        }
        if (this.reinviteUserAgentServer) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("There is an ongoing re-INVITE server transaction.");
        }
        return new re_invite_user_agent_client_1.ReInviteUserAgentClient(this, delegate, options);
    };
    /**
     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a
     * MESSAGE request is sent within a dialog, it is "associated" with any
     * media session or sessions associated with that dialog.
     * https://tools.ietf.org/html/rfc3428#section-4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.message = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending MESSAGE request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        var message = this.createOutgoingRequestMessage(messages_1.C.MESSAGE, options);
        return new message_user_agent_client_1.MessageUserAgentClient(this.core, message, delegate);
    };
    /**
     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent
     * sending the REFER of the status of the reference.
     * https://tools.ietf.org/html/rfc3515#section-2.4.4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.notify = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending NOTIFY request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        return new notify_user_agent_client_1.NotifyUserAgentClient(this, delegate, options);
    };
    /**
     * Assuming the response is to be transmitted reliably, the UAC MUST
     * create a new request with method PRACK.  This request is sent within
     * the dialog associated with the provisional response (indeed, the
     * provisional response may have created the dialog).  PRACK requests
     * MAY contain bodies, which are interpreted according to their type and
     * disposition.
     * https://tools.ietf.org/html/rfc3262#section-4
     * @param options - Options bucket.
     */
    SessionDialog.prototype.prack = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending PRACK request");
        return new prack_user_agent_client_1.PrackUserAgentClient(this, delegate, options);
    };
    /**
     * REFER is a SIP request and is constructed as defined in [1].  A REFER
     * request MUST contain exactly one Refer-To header field value.
     * https://tools.ietf.org/html/rfc3515#section-2.4.1
     * @param options - Options bucket.
     */
    SessionDialog.prototype.refer = function (delegate, options) {
        this.logger.log("INVITE dialog " + this.id + " sending REFER request");
        if (this.early) {
            // FIXME: TODO: This should throw a proper exception.
            throw new Error("Dialog not confirmed.");
        }
        // FIXME: TODO: Validate Refer-To header field value.
        return new refer_user_agent_client_1.ReferUserAgentClient(this, delegate, options);
    };
    /**
     * Requests sent within a dialog, as any other requests, are atomic.  If
     * a particular request is accepted by the UAS, all the state changes
     * associated with it are performed.  If the request is rejected, none
     * of the state changes are performed.
     * https://tools.ietf.org/html/rfc3261#section-12.2.2
     * @param message - Incoming request message within this dialog.
     */
    SessionDialog.prototype.receiveRequest = function (message) {
        this.logger.log("INVITE dialog " + this.id + " received " + message.method + " request");
        // Response retransmissions cease when an ACK request for the
        // response is received.  This is independent of whatever transport
        // protocols are used to send the response.
        // https://tools.ietf.org/html/rfc6026#section-8.1
        if (message.method === messages_1.C.ACK) {
            // If ackWait is true, then this is the ACK to the initial INVITE,
            // otherwise this is an ACK to an in dialog INVITE. In either case,
            // guard to make sure the sequence number of the ACK matches the INVITE.
            if (this.ackWait) {
                if (this.initialTransaction instanceof transactions_1.InviteClientTransaction) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                if (this.initialTransaction.request.cseq !== message.cseq) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                // Update before the delegate has a chance to handle the
                // message as delegate may callback into this dialog.
                this.ackWait = false;
            }
            else {
                if (!this.reinviteUserAgentServer) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {
                    this.logger.warn("INVITE dialog " + this.id + " received unexpected " + message.method + " request, dropping.");
                    return;
                }
                this.reinviteUserAgentServer = undefined;
            }
            this.signalingStateTransition(message);
            if (this.delegate && this.delegate.onAck) {
                this.delegate.onAck({ message: message });
            }
            return;
        }
        // Request within a dialog out of sequence guard.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.sequenceGuard(message)) {
            this.logger.log("INVITE dialog " + this.id + " rejected out of order " + message.method + " request.");
            return;
        }
        if (message.method === messages_1.C.INVITE) {
            // A UAS that receives a second INVITE before it sends the final
            // response to a first INVITE with a lower CSeq sequence number on the
            // same dialog MUST return a 500 (Server Internal Error) response to the
            // second INVITE and MUST include a Retry-After header field with a
            // randomly chosen value of between 0 and 10 seconds.
            // https://tools.ietf.org/html/rfc3261#section-14.2
            if (this.reinviteUserAgentServer) {
                // https://tools.ietf.org/html/rfc3261#section-20.33
                var retryAfter = Math.floor((Math.random() * 10)) + 1;
                var extraHeaders = ["Retry-After: " + retryAfter];
                this.core.replyStateless(message, { statusCode: 500, extraHeaders: extraHeaders });
                return;
            }
            // A UAS that receives an INVITE on a dialog while an INVITE it had sent
            // on that dialog is in progress MUST return a 491 (Request Pending)
            // response to the received INVITE.
            // https://tools.ietf.org/html/rfc3261#section-14.2
            if (this.reinviteUserAgentClient) {
                this.core.replyStateless(message, { statusCode: 491 });
                return;
            }
        }
        // Request within a dialog common processing.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        _super.prototype.receiveRequest.call(this, message);
        // Requests within a dialog MAY contain Record-Route and Contact header
        // fields.  However, these requests do not cause the dialog's route set
        // to be modified, although they may modify the remote target URI.
        // Specifically, requests that are not target refresh requests do not
        // modify the dialog's remote target URI, and requests that are target
        // refresh requests do.  For dialogs that have been established with an
        // INVITE, the only target refresh request defined is re-INVITE (see
        // Section 14).  Other extensions may define different target refresh
        // requests for dialogs established in other ways.
        //
        //    Note that an ACK is NOT a target refresh request.
        //
        // Target refresh requests only update the dialog's remote target URI,
        // and not the route set formed from the Record-Route.  Updating the
        // latter would introduce severe backwards compatibility problems with
        // RFC 2543-compliant systems.
        // https://tools.ietf.org/html/rfc3261#section-15
        if (message.method === messages_1.C.INVITE) {
            // FIXME: parser needs to be typed...
            var contact = message.parseHeader("contact");
            if (!contact) { // TODO: Review to make sure this will never happen
                throw new Error("Contact undefined.");
            }
            if (!(contact instanceof messages_1.NameAddrHeader)) {
                throw new Error("Contact not instance of NameAddrHeader.");
            }
            this.dialogState.remoteTarget = contact.uri;
        }
        // Switch on method and then delegate.
        switch (message.method) {
            case messages_1.C.BYE:
                // A UAS core receiving a BYE request for an existing dialog MUST follow
                // the procedures of Section 12.2.2 to process the request.  Once done,
                // the UAS SHOULD terminate the session (and therefore stop sending and
                // listening for media).  The only case where it can elect not to are
                // multicast sessions, where participation is possible even if the other
                // participant in the dialog has terminated its involvement in the
                // session.  Whether or not it ends its participation on the session,
                // the UAS core MUST generate a 2xx response to the BYE, and MUST pass
                // that to the server transaction for transmission.
                //
                // The UAS MUST still respond to any pending requests received for that
                // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response
                // be generated to those pending requests.
                // https://tools.ietf.org/html/rfc3261#section-15.1.2
                {
                    var uas = new bye_user_agent_server_1.ByeUserAgentServer(this, message);
                    this.delegate && this.delegate.onBye ?
                        this.delegate.onBye(uas) :
                        uas.accept();
                    this.dispose();
                }
                break;
            case messages_1.C.INFO:
                // If a UA receives an INFO request associated with an Info Package that
                // the UA has not indicated willingness to receive, the UA MUST send a
                // 469 (Bad Info Package) response (see Section 11.6), which contains a
                // Recv-Info header field with Info Packages for which the UA is willing
                // to receive INFO requests.
                {
                    var uas = new info_user_agent_server_1.InfoUserAgentServer(this, message);
                    this.delegate && this.delegate.onInfo ?
                        this.delegate.onInfo(uas) :
                        uas.reject({
                            statusCode: 469,
                            extraHeaders: ["Recv-Info :"]
                        });
                }
                break;
            case messages_1.C.INVITE:
                // If the new session description is not acceptable, the UAS can reject
                // it by returning a 488 (Not Acceptable Here) response for the re-
                // INVITE.  This response SHOULD include a Warning header field.
                // https://tools.ietf.org/html/rfc3261#section-14.2
                {
                    var uas = new re_invite_user_agent_server_1.ReInviteUserAgentServer(this, message);
                    this.signalingStateTransition(message);
                    this.delegate && this.delegate.onInvite ?
                        this.delegate.onInvite(uas) :
                        uas.reject({ statusCode: 488 }); // TODO: Warning header field.
                }
                break;
            case messages_1.C.MESSAGE:
                {
                    var uas = new message_user_agent_server_1.MessageUserAgentServer(this.core, message);
                    this.delegate && this.delegate.onMessage ?
                        this.delegate.onMessage(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.NOTIFY:
                // https://tools.ietf.org/html/rfc3515#section-2.4.4
                {
                    var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
                    this.delegate && this.delegate.onNotify ?
                        this.delegate.onNotify(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.PRACK:
                // https://tools.ietf.org/html/rfc3262#section-4
                {
                    var uas = new prack_user_agent_server_1.PrackUserAgentServer(this, message);
                    this.delegate && this.delegate.onPrack ?
                        this.delegate.onPrack(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.REFER:
                // https://tools.ietf.org/html/rfc3515#section-2.4.2
                {
                    var uas = new refer_user_agent_server_1.ReferUserAgentServer(this, message);
                    this.delegate && this.delegate.onRefer ?
                        this.delegate.onRefer(uas) :
                        uas.reject();
                }
                break;
            default:
                {
                    this.logger.log("INVITE dialog " + this.id + " received unimplemented " + message.method + " request");
                    this.core.replyStateless(message, { statusCode: 501 });
                }
                break;
        }
    };
    SessionDialog.prototype.reliableSequenceGuard = function (message) {
        var statusCode = message.statusCode;
        if (!statusCode) {
            throw new Error("Status code undefined");
        }
        if (statusCode > 100 && statusCode < 200) {
            // If a provisional response is received for an initial request, and
            // that response contains a Require header field containing the option
            // tag 100rel, the response is to be sent reliably.  If the response is
            // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be
            // ignored, and the procedures below MUST NOT be used.
            // https://tools.ietf.org/html/rfc3262#section-4
            var requireHeader = message.getHeader("require");
            var rseqHeader = message.getHeader("rseq");
            var rseq = requireHeader && requireHeader.includes("100rel") && rseqHeader ? Number(rseqHeader) : undefined;
            if (rseq) {
                // Handling of subsequent reliable provisional responses for the same
                // initial request follows the same rules as above, with the following
                // difference: reliable provisional responses are guaranteed to be in
                // order.  As a result, if the UAC receives another reliable provisional
                // response to the same request, and its RSeq value is not one higher
                // than the value of the sequence number, that response MUST NOT be
                // acknowledged with a PRACK, and MUST NOT be processed further by the
                // UAC.  An implementation MAY discard the response, or MAY cache the
                // response in the hopes of receiving the missing responses.
                // https://tools.ietf.org/html/rfc3262#section-4
                if (this.rseq && this.rseq + 1 !== rseq) {
                    return false;
                }
                // Once a reliable provisional response is received, retransmissions of
                // that response MUST be discarded.  A response is a retransmission when
                // its dialog ID, CSeq, and RSeq match the original response.  The UAC
                // MUST maintain a sequence number that indicates the most recently
                // received in-order reliable provisional response for the initial
                // request.  This sequence number MUST be maintained until a final
                // response is received for the initial request.  Its value MUST be
                // initialized to the RSeq header field in the first reliable
                // provisional response received for the initial request.
                // https://tools.ietf.org/html/rfc3262#section-4
                if (!this.rseq) {
                    this.rseq = rseq;
                }
            }
        }
        return true;
    };
    /**
     * If not in a stable signaling state, rollback to prior stable signaling state.
     */
    SessionDialog.prototype.signalingStateRollback = function () {
        if (this._signalingState === session_1.SignalingState.HaveLocalOffer ||
            this.signalingState === session_1.SignalingState.HaveRemoteOffer) {
            if (this._rollbackOffer && this._rollbackAnswer) {
                this._signalingState = session_1.SignalingState.Stable;
                this._offer = this._rollbackOffer;
                this._answer = this._rollbackAnswer;
            }
        }
    };
    /**
     * Update the signaling state of the dialog.
     * @param message - The message to base the update off of.
     */
    SessionDialog.prototype.signalingStateTransition = function (message) {
        var body = messages_1.getBody(message);
        // No body, no session. No, woman, no cry.
        if (!body || body.contentDisposition !== "session") {
            return;
        }
        // We've got an existing offer and answer which we may wish to rollback to
        if (this._signalingState === session_1.SignalingState.Stable) {
            this._rollbackOffer = this._offer;
            this._rollbackAnswer = this._answer;
        }
        // We're in UAS role, receiving incoming request with session description
        if (message instanceof messages_1.IncomingRequestMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAC role, receiving incoming response with session description
        if (message instanceof messages_1.IncomingResponseMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveRemoteOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAC role, sending outgoing request with session description
        if (message instanceof messages_1.OutgoingRequestMessage) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveLocalOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
        // We're in UAS role, sending outgoing response with session description
        if (messages_1.isBody(message)) {
            switch (this._signalingState) {
                case session_1.SignalingState.Initial:
                case session_1.SignalingState.Stable:
                    this._signalingState = session_1.SignalingState.HaveLocalOffer;
                    this._offer = body;
                    this._answer = undefined;
                    break;
                case session_1.SignalingState.HaveLocalOffer:
                    // You cannot make a new offer while one is in progress.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    // FIXME: What to do here?
                    break;
                case session_1.SignalingState.HaveRemoteOffer:
                    this._signalingState = session_1.SignalingState.Stable;
                    this._answer = body;
                    break;
                case session_1.SignalingState.Closed:
                    break;
                default:
                    throw new Error("Unexpected signaling state.");
            }
        }
    };
    SessionDialog.prototype.start2xxRetransmissionTimer = function () {
        var _this = this;
        if (this.initialTransaction instanceof transactions_1.InviteServerTransaction) {
            var transaction_1 = this.initialTransaction;
            // Once the response has been constructed, it is passed to the INVITE
            // server transaction.  In order to ensure reliable end-to-end
            // transport of the response, it is necessary to periodically pass
            // the response directly to the transport until the ACK arrives.  The
            // 2xx response is passed to the transport with an interval that
            // starts at T1 seconds and doubles for each retransmission until it
            // reaches T2 seconds (T1 and T2 are defined in Section 17).
            // Response retransmissions cease when an ACK request for the
            // response is received.  This is independent of whatever transport
            // protocols are used to send the response.
            // https://tools.ietf.org/html/rfc6026#section-8.1
            var timeout_1 = timers_1.Timers.T1;
            var retransmission_1 = function () {
                if (!_this.ackWait) {
                    _this.invite2xxTimer = undefined;
                    return;
                }
                _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                transaction_1.retransmitAcceptedResponse();
                timeout_1 = Math.min(timeout_1 * 2, timers_1.Timers.T2);
                _this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
            };
            this.invite2xxTimer = setTimeout(retransmission_1, timeout_1);
            // If the server retransmits the 2xx response for 64*T1 seconds without
            // receiving an ACK, the dialog is confirmed, but the session SHOULD be
            // terminated.  This is accomplished with a BYE, as described in Section 15.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            var stateChanged_1 = function () {
                if (transaction_1.state === transactions_1.TransactionState.Terminated) {
                    transaction_1.removeListener("stateChanged", stateChanged_1);
                    if (_this.invite2xxTimer) {
                        clearTimeout(_this.invite2xxTimer);
                        _this.invite2xxTimer = undefined;
                    }
                    if (_this.ackWait) {
                        if (_this.delegate && _this.delegate.onAckTimeout) {
                            _this.delegate.onAckTimeout();
                        }
                        else {
                            _this.bye();
                        }
                    }
                }
            };
            transaction_1.addListener("stateChanged", stateChanged_1);
        }
    };
    // FIXME: Refactor
    SessionDialog.prototype.startReInvite2xxRetransmissionTimer = function () {
        var _this = this;
        if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof transactions_1.InviteServerTransaction) {
            var transaction_2 = this.reinviteUserAgentServer.transaction;
            // Once the response has been constructed, it is passed to the INVITE
            // server transaction.  In order to ensure reliable end-to-end
            // transport of the response, it is necessary to periodically pass
            // the response directly to the transport until the ACK arrives.  The
            // 2xx response is passed to the transport with an interval that
            // starts at T1 seconds and doubles for each retransmission until it
            // reaches T2 seconds (T1 and T2 are defined in Section 17).
            // Response retransmissions cease when an ACK request for the
            // response is received.  This is independent of whatever transport
            // protocols are used to send the response.
            // https://tools.ietf.org/html/rfc6026#section-8.1
            var timeout_2 = timers_1.Timers.T1;
            var retransmission_2 = function () {
                if (!_this.reinviteUserAgentServer) {
                    _this.invite2xxTimer = undefined;
                    return;
                }
                _this.logger.log("No ACK for 2xx response received, attempting retransmission");
                transaction_2.retransmitAcceptedResponse();
                timeout_2 = Math.min(timeout_2 * 2, timers_1.Timers.T2);
                _this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
            };
            this.invite2xxTimer = setTimeout(retransmission_2, timeout_2);
            // If the server retransmits the 2xx response for 64*T1 seconds without
            // receiving an ACK, the dialog is confirmed, but the session SHOULD be
            // terminated.  This is accomplished with a BYE, as described in Section 15.
            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
            var stateChanged_2 = function () {
                if (transaction_2.state === transactions_1.TransactionState.Terminated) {
                    transaction_2.removeListener("stateChanged", stateChanged_2);
                    if (_this.invite2xxTimer) {
                        clearTimeout(_this.invite2xxTimer);
                        _this.invite2xxTimer = undefined;
                    }
                    if (_this.reinviteUserAgentServer) {
                        // FIXME: TODO: What to do here
                    }
                }
            };
            transaction_2.addListener("stateChanged", stateChanged_2);
        }
    };
    return SessionDialog;
}(dialog_1.Dialog));
exports.SessionDialog = SessionDialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var subscription_1 = __webpack_require__(/*! ../subscription */ "./node_modules/sip.js/lib/core/subscription/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var notify_user_agent_server_1 = __webpack_require__(/*! ../user-agents/notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js");
var re_subscribe_user_agent_client_1 = __webpack_require__(/*! ../user-agents/re-subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js");
var dialog_1 = __webpack_require__(/*! ./dialog */ "./node_modules/sip.js/lib/core/dialogs/dialog.js");
/**
 * Subscription Dialog.
 * @remarks
 * SIP-Specific Event Notification
 *
 * Abstract
 *
 *    This document describes an extension to the Session Initiation
 *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is
 *    to provide an extensible framework by which SIP nodes can request
 *    notification from remote nodes indicating that certain events have
 *    occurred.
 *
 *    Note that the event notification mechanisms defined herein are NOT
 *    intended to be a general-purpose infrastructure for all classes of
 *    event subscription and notification.
 *
 *    This document represents a backwards-compatible improvement on the
 *    original mechanism described by RFC 3265, taking into account several
 *    years of implementation experience.  Accordingly, this document
 *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to
 *    accommodate some small changes to the mechanism that were discussed
 *    in that document.
 *
 *  https://tools.ietf.org/html/rfc6665
 * @public
 */
var SubscriptionDialog = /** @class */ (function (_super) {
    tslib_1.__extends(SubscriptionDialog, _super);
    function SubscriptionDialog(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {
        var _this = _super.call(this, core, state) || this;
        _this.delegate = delegate;
        _this._autoRefresh = false;
        _this._subscriptionEvent = subscriptionEvent;
        _this._subscriptionExpires = subscriptionExpires;
        _this._subscriptionExpiresInitial = subscriptionExpires;
        _this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
        _this._subscriptionRefresh = undefined;
        _this._subscriptionRefreshLastSet = undefined;
        _this._subscriptionState = subscriptionState;
        _this.logger = core.loggerFactory.getLogger("sip.subscribe-dialog");
        _this.logger.log("SUBSCRIBE dialog " + _this.id + " constructed");
        return _this;
    }
    /**
     * When a UAC receives a response that establishes a dialog, it
     * constructs the state of the dialog.  This state MUST be maintained
     * for the duration of the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.1.2
     * @param outgoingRequestMessage - Outgoing request message for dialog.
     * @param incomingResponseMessage - Incoming response message creating dialog.
     */
    SubscriptionDialog.initialDialogStateForSubscription = function (outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {
        // If the request was sent over TLS, and the Request-URI contained a
        // SIPS URI, the "secure" flag is set to TRUE.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var secure = false; // FIXME: Currently no support for TLS.
        // The route set MUST be set to the list of URIs in the Record-Route
        // header field from the response, taken in reverse order and preserving
        // all URI parameters.  If no Record-Route header field is present in
        // the response, the route set MUST be set to the empty set.  This route
        // set, even if empty, overrides any pre-existing route set for future
        // requests in this dialog.  The remote target MUST be set to the URI
        // from the Contact header field of the response.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var routeSet = incomingNotifyRequestMessage.getHeaders("record-route");
        var contact = incomingNotifyRequestMessage.parseHeader("contact");
        if (!contact) { // TODO: Review to make sure this will never happen
            throw new Error("Contact undefined.");
        }
        if (!(contact instanceof messages_1.NameAddrHeader)) {
            throw new Error("Contact not instance of NameAddrHeader.");
        }
        var remoteTarget = contact.uri;
        // The local sequence number MUST be set to the value of the sequence
        // number in the CSeq header field of the request.  The remote sequence
        // number MUST be empty (it is established when the remote UA sends a
        // request within the dialog).  The call identifier component of the
        // dialog ID MUST be set to the value of the Call-ID in the request.
        // The local tag component of the dialog ID MUST be set to the tag in
        // the From field in the request, and the remote tag component of the
        // dialog ID MUST be set to the tag in the To field of the response.  A
        // UAC MUST be prepared to receive a response without a tag in the To
        // field, in which case the tag is considered to have a value of null.
        //
        //    This is to maintain backwards compatibility with RFC 2543, which
        //    did not mandate To tags.
        //
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        var localSequenceNumber = outgoingSubscribeRequestMessage.cseq;
        var remoteSequenceNumber = undefined;
        var callId = outgoingSubscribeRequestMessage.callId;
        var localTag = outgoingSubscribeRequestMessage.fromTag;
        var remoteTag = incomingNotifyRequestMessage.fromTag;
        if (!callId) { // TODO: Review to make sure this will never happen
            throw new Error("Call id undefined.");
        }
        if (!localTag) { // TODO: Review to make sure this will never happen
            throw new Error("From tag undefined.");
        }
        if (!remoteTag) { // TODO: Review to make sure this will never happen
            throw new Error("To tag undefined."); // FIXME: No backwards compatibility with RFC 2543
        }
        // The remote URI MUST be set to the URI in the To field, and the local
        // URI MUST be set to the URI in the From field.
        // https://tools.ietf.org/html/rfc3261#section-12.1.2
        if (!outgoingSubscribeRequestMessage.from) { // TODO: Review to make sure this will never happen
            throw new Error("From undefined.");
        }
        if (!outgoingSubscribeRequestMessage.to) { // TODO: Review to make sure this will never happen
            throw new Error("To undefined.");
        }
        var localURI = outgoingSubscribeRequestMessage.from.uri;
        var remoteURI = outgoingSubscribeRequestMessage.to.uri;
        // A dialog can also be in the "early" state, which occurs when it is
        // created with a provisional response, and then transition to the
        // "confirmed" state when a 2xx final response arrives.
        // https://tools.ietf.org/html/rfc3261#section-12
        var early = false;
        var dialogState = {
            id: callId + localTag + remoteTag,
            early: early,
            callId: callId,
            localTag: localTag,
            remoteTag: remoteTag,
            localSequenceNumber: localSequenceNumber,
            remoteSequenceNumber: remoteSequenceNumber,
            localURI: localURI,
            remoteURI: remoteURI,
            remoteTarget: remoteTarget,
            routeSet: routeSet,
            secure: secure
        };
        return dialogState;
    };
    SubscriptionDialog.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this.N) {
            clearTimeout(this.N);
            this.N = undefined;
        }
        this.refreshTimerClear();
        this.logger.log("SUBSCRIBE dialog " + this.id + " destroyed");
    };
    Object.defineProperty(SubscriptionDialog.prototype, "autoRefresh", {
        get: function () {
            return this._autoRefresh;
        },
        set: function (autoRefresh) {
            this._autoRefresh = true;
            this.refreshTimerSet();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionEvent", {
        get: function () {
            return this._subscriptionEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpires", {
        /** Number of seconds until subscription expires. */
        get: function () {
            var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;
            var secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;
            return Math.max(secondsUntilExpires, 0);
        },
        set: function (expires) {
            if (expires < 0) {
                throw new Error("Expires must be greater than or equal to zero.");
            }
            this._subscriptionExpires = expires;
            this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);
            if (this.autoRefresh) {
                var refresh = this.subscriptionRefresh;
                if (refresh === undefined || refresh >= expires) {
                    this.refreshTimerSet();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionExpiresInitial", {
        get: function () {
            return this._subscriptionExpiresInitial;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionRefresh", {
        /** Number of seconds until subscription auto refresh. */
        get: function () {
            if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {
                return undefined;
            }
            var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;
            var secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;
            return Math.max(secondsUntilExpires, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SubscriptionDialog.prototype, "subscriptionState", {
        get: function () {
            return this._subscriptionState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive in dialog request message from transport.
     * @param message -  The incoming request message.
     */
    SubscriptionDialog.prototype.receiveRequest = function (message) {
        this.logger.log("SUBSCRIBE dialog " + this.id + " received " + message.method + " request");
        // Request within a dialog out of sequence guard.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (!this.sequenceGuard(message)) {
            this.logger.log("SUBSCRIBE dialog " + this.id + " rejected out of order " + message.method + " request.");
            return;
        }
        // Request within a dialog common processing.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        _super.prototype.receiveRequest.call(this, message);
        // Switch on method and then delegate.
        switch (message.method) {
            case messages_1.C.NOTIFY:
                this.onNotify(message);
                break;
            default:
                this.logger.log("SUBSCRIBE dialog " + this.id + " received unimplemented " + message.method + " request");
                this.core.replyStateless(message, { statusCode: 501 });
                break;
        }
    };
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */
    SubscriptionDialog.prototype.refresh = function () {
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var options = {};
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push("Event: " + this.subscriptionEvent);
        options.extraHeaders.push("Expires: " + this.subscriptionExpiresInitial);
        options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        return this.subscribe(undefined, options);
    };
    /**
     * 4.1.2.2.  Refreshing of Subscriptions
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     * @param delegate - Delegate to handle responses.
     * @param options - Options bucket.
     */
    SubscriptionDialog.prototype.subscribe = function (delegate, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.subscriptionState !== subscription_1.SubscriptionState.Pending && this.subscriptionState !== subscription_1.SubscriptionState.Active) {
            // FIXME: This needs to be a proper exception
            throw new Error("Invalid state " + this.subscriptionState + ". May only re-subscribe while in state \"pending\" or \"active\".");
        }
        this.logger.log("SUBSCRIBE dialog " + this.id + " sending SUBSCRIBE request");
        var uac = new re_subscribe_user_agent_client_1.ReSubscribeUserAgentClient(this, delegate, options);
        // When refreshing a subscription, a subscriber starts Timer N, set to
        // 64*T1, when it sends the SUBSCRIBE request.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
        this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
        return uac;
    };
    /**
     * 4.4.1.  Dialog Creation and Termination
     * A subscription is destroyed after a notifier sends a NOTIFY request
     * with a "Subscription-State" of "terminated", or in certain error
     * situations described elsewhere in this document.
     * https://tools.ietf.org/html/rfc6665#section-4.4.1
     */
    SubscriptionDialog.prototype.terminate = function () {
        this.stateTransition(subscription_1.SubscriptionState.Terminated);
        this.onTerminated();
    };
    /**
     * 4.1.2.3.  Unsubscribing
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3
     */
    SubscriptionDialog.prototype.unsubscribe = function () {
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        var options = {};
        options.extraHeaders = (options.extraHeaders || []).slice();
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push("Event: " + this.subscriptionEvent);
        options.extraHeaders.push("Expires: 0");
        options.extraHeaders.push("Contact: " + this.core.configuration.contact.toString());
        return this.subscribe(undefined, options);
    };
    /**
     * Handle in dialog NOTIFY requests.
     * This does not include the first NOTIFY which created the dialog.
     * @param message - The incoming NOTIFY request message.
     */
    SubscriptionDialog.prototype.onNotify = function (message) {
        // If, for some reason, the event package designated in the "Event"
        // header field of the NOTIFY request is not supported, the subscriber
        // will respond with a 489 (Bad Event) response.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var event = message.parseHeader("Event").event;
        if (!event || event !== this.subscriptionEvent) {
            this.core.replyStateless(message, { statusCode: 489 });
            return;
        }
        // In the state diagram, "Re-subscription times out" means that an
        // attempt to refresh or update the subscription using a new SUBSCRIBE
        // request does not result in a NOTIFY request before the corresponding
        // Timer N expires.
        // https://tools.ietf.org/html/rfc6665#section-4.1.2
        if (this.N) {
            clearTimeout(this.N);
            this.N = undefined;
        }
        // NOTIFY requests MUST contain "Subscription-State" header fields that
        // indicate the status of the subscription.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = message.parseHeader("Subscription-State");
        if (!subscriptionState || !subscriptionState.state) {
            this.core.replyStateless(message, { statusCode: 489 });
            return;
        }
        var state = subscriptionState.state;
        var expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined;
        // Update our state and expiration.
        switch (state) {
            case "pending":
                this.stateTransition(subscription_1.SubscriptionState.Pending, expires);
                break;
            case "active":
                this.stateTransition(subscription_1.SubscriptionState.Active, expires);
                break;
            case "terminated":
                this.stateTransition(subscription_1.SubscriptionState.Terminated, expires);
                break;
            default:
                this.logger.warn("Unrecognized subscription state.");
                break;
        }
        // Delegate remainder of NOTIFY handling.
        var uas = new notify_user_agent_server_1.NotifyUserAgentServer(this, message);
        if (this.delegate && this.delegate.onNotify) {
            this.delegate.onNotify(uas);
        }
        else {
            uas.accept();
        }
    };
    SubscriptionDialog.prototype.onRefresh = function (request) {
        if (this.delegate && this.delegate.onRefresh) {
            this.delegate.onRefresh(request);
        }
    };
    SubscriptionDialog.prototype.onTerminated = function () {
        if (this.delegate && this.delegate.onTerminated) {
            this.delegate.onTerminated();
        }
    };
    SubscriptionDialog.prototype.refreshTimerClear = function () {
        if (this.refreshTimer) {
            clearTimeout(this.refreshTimer);
            this.refreshTimer = undefined;
        }
    };
    SubscriptionDialog.prototype.refreshTimerSet = function () {
        var _this = this;
        this.refreshTimerClear();
        if (this.autoRefresh && this.subscriptionExpires > 0) {
            var refresh = this.subscriptionExpires * 900;
            this._subscriptionRefresh = Math.floor(refresh / 1000);
            this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);
            this.refreshTimer = setTimeout(function () {
                _this.refreshTimer = undefined;
                _this._subscriptionRefresh = undefined;
                _this._subscriptionRefreshLastSet = undefined;
                _this.onRefresh(_this.refresh());
            }, refresh);
        }
    };
    SubscriptionDialog.prototype.stateTransition = function (newState, newExpires) {
        var _this = this;
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            _this.logger.warn("Invalid subscription state transition from " + _this.subscriptionState + " to " + newState);
        };
        switch (newState) {
            case subscription_1.SubscriptionState.Initial:
                invalidStateTransition();
                return;
            case subscription_1.SubscriptionState.NotifyWait:
                invalidStateTransition();
                return;
            case subscription_1.SubscriptionState.Pending:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending) {
                    invalidStateTransition();
                    return;
                }
                break;
            case subscription_1.SubscriptionState.Active:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                    invalidStateTransition();
                    return;
                }
                break;
            case subscription_1.SubscriptionState.Terminated:
                if (this.subscriptionState !== subscription_1.SubscriptionState.NotifyWait &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Pending &&
                    this.subscriptionState !== subscription_1.SubscriptionState.Active) {
                    invalidStateTransition();
                    return;
                }
                break;
            default:
                invalidStateTransition();
                return;
        }
        // If the "Subscription-State" value is "pending", the subscription has
        // been received by the notifier, but there is insufficient policy
        // information to grant or deny the subscription yet.  If the header
        // field also contains an "expires" parameter, the subscriber SHOULD
        // take it as the authoritative subscription duration and adjust
        // accordingly.  No further action is necessary on the part of the
        // subscriber.  The "retry-after" and "reason" parameters have no
        // semantics for "pending".
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        if (newState === subscription_1.SubscriptionState.Pending) {
            if (newExpires) {
                this.subscriptionExpires = newExpires;
            }
        }
        // If the "Subscription-State" header field value is "active", it means
        // that the subscription has been accepted and (in general) has been
        // authorized.  If the header field also contains an "expires"
        // parameter, the subscriber SHOULD take it as the authoritative
        // subscription duration and adjust accordingly.  The "retry-after" and
        // "reason" parameters have no semantics for "active".
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        if (newState === subscription_1.SubscriptionState.Active) {
            if (newExpires) {
                this.subscriptionExpires = newExpires;
            }
        }
        // If the "Subscription-State" value is "terminated", the subscriber
        // MUST consider the subscription terminated.  The "expires" parameter
        // has no semantics for "terminated" -- notifiers SHOULD NOT include an
        // "expires" parameter on a "Subscription-State" header field with a
        // value of "terminated", and subscribers MUST ignore any such
        // parameter, if present.
        if (newState === subscription_1.SubscriptionState.Terminated) {
            this.dispose();
        }
        this._subscriptionState = newState;
    };
    /**
     * When refreshing a subscription, a subscriber starts Timer N, set to
     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription terminated.  If the subscriber receives a success
     * response to the SUBSCRIBE request that indicates that no NOTIFY
     * request will be generated -- such as the 204 response defined for use
     * with the optional extension described in [RFC5839] -- then it MUST
     * cancel Timer N.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2
     */
    SubscriptionDialog.prototype.timer_N = function () {
        if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
            this.stateTransition(subscription_1.SubscriptionState.Terminated);
            this.onTerminated();
        }
    };
    return SubscriptionDialog;
}(dialog_1.Dialog));
exports.SubscriptionDialog = SubscriptionDialog;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/exception.js":
/*!**************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/exception.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
/**
 * An Exception is considered a condition that a reasonable application may wish to catch.
 * An Error indicates serious problems that a reasonable application should not try to catch.
 * @public
 */
var Exception = /** @class */ (function (_super) {
    tslib_1.__extends(Exception, _super);
    function Exception(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain
        return _this;
    }
    return Exception;
}(Error));
exports.Exception = Exception;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state-error */ "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transport-error */ "./node_modules/sip.js/lib/core/exceptions/transport-error.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/transaction-state-error.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var exception_1 = __webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js");
/**
 * Indicates that the operation could not be completed given the current transaction state.
 * @public
 */
var TransactionStateError = /** @class */ (function (_super) {
    tslib_1.__extends(TransactionStateError, _super);
    function TransactionStateError(message) {
        return _super.call(this, message ? message : "Transaction state error.") || this;
    }
    return TransactionStateError;
}(exception_1.Exception));
exports.TransactionStateError = TransactionStateError;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/exceptions/transport-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/exceptions/transport-error.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var exception_1 = __webpack_require__(/*! ./exception */ "./node_modules/sip.js/lib/core/exceptions/exception.js");
/**
 * Transport error.
 * @public
 */
var TransportError = /** @class */ (function (_super) {
    tslib_1.__extends(TransportError, _super);
    function TransportError(message) {
        return _super.call(this, message ? message : "Unspecified transport error.") || this;
    }
    return TransportError;
}(exception_1.Exception));
exports.TransportError = TransportError;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/index.js":
/*!***********************************************!*\
  !*** ./node_modules/sip.js/lib/core/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A core library implementing low level SIP protocol elements.
 * @packageDocumentation
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Directories
tslib_1.__exportStar(__webpack_require__(/*! ./dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./log */ "./node_modules/sip.js/lib/core/log/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/sip.js/lib/core/messages/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./node_modules/sip.js/lib/core/session/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./node_modules/sip.js/lib/core/subscription/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transactions */ "./node_modules/sip.js/lib/core/transactions/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./node_modules/sip.js/lib/core/user-agent-core/index.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agents */ "./node_modules/sip.js/lib/core/user-agents/index.js"), exports);
// Files
tslib_1.__exportStar(__webpack_require__(/*! ./timers */ "./node_modules/sip.js/lib/core/timers.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/index.js":
/*!***************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./logger-factory */ "./node_modules/sip.js/lib/core/log/logger-factory.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/sip.js/lib/core/log/logger.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/levels.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/levels.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Log levels.
 * @public
 */
var Levels;
(function (Levels) {
    Levels[Levels["error"] = 0] = "error";
    Levels[Levels["warn"] = 1] = "warn";
    Levels[Levels["log"] = 2] = "log";
    Levels[Levels["debug"] = 3] = "debug";
})(Levels = exports.Levels || (exports.Levels = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/logger-factory.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/logger-factory.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var levels_1 = __webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js");
var logger_1 = __webpack_require__(/*! ./logger */ "./node_modules/sip.js/lib/core/log/logger.js");
/**
 * Logger.
 * @public
 */
var LoggerFactory = /** @class */ (function () {
    function LoggerFactory() {
        this.builtinEnabled = true;
        this._level = levels_1.Levels.log;
        this.loggers = {};
        this.logger = this.getLogger("sip:loggerfactory");
    }
    Object.defineProperty(LoggerFactory.prototype, "level", {
        get: function () { return this._level; },
        set: function (newLevel) {
            if (newLevel >= 0 && newLevel <= 3) {
                this._level = newLevel;
            }
            else if (newLevel > 3) {
                this._level = 3;
            }
            else if (levels_1.Levels.hasOwnProperty(newLevel)) {
                this._level = newLevel;
            }
            else {
                this.logger.error("invalid 'level' parameter value: " + JSON.stringify(newLevel));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoggerFactory.prototype, "connector", {
        get: function () {
            return this._connector;
        },
        set: function (value) {
            if (!value) {
                this._connector = undefined;
            }
            else if (typeof value === "function") {
                this._connector = value;
            }
            else {
                this.logger.error("invalid 'connector' parameter value: " + JSON.stringify(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    LoggerFactory.prototype.getLogger = function (category, label) {
        if (label && this.level === 3) {
            return new logger_1.Logger(this, category, label);
        }
        else if (this.loggers[category]) {
            return this.loggers[category];
        }
        else {
            var logger = new logger_1.Logger(this, category);
            this.loggers[category] = logger;
            return logger;
        }
    };
    LoggerFactory.prototype.genericLog = function (levelToLog, category, label, content) {
        if (this.level >= levelToLog) {
            if (this.builtinEnabled) {
                this.print(levelToLog, category, label, content);
            }
        }
        if (this.connector) {
            this.connector(levels_1.Levels[levelToLog], category, label, content);
        }
    };
    LoggerFactory.prototype.print = function (levelToLog, category, label, content) {
        if (typeof content === "string") {
            var prefix = [new Date(), category];
            if (label) {
                prefix.push(label);
            }
            content = prefix.concat(content).join(" | ");
        }
        switch (levelToLog) {
            case levels_1.Levels.error:
                // tslint:disable-next-line:no-console
                console.error(content);
                break;
            case levels_1.Levels.warn:
                // tslint:disable-next-line:no-console
                console.warn(content);
                break;
            case levels_1.Levels.log:
                // tslint:disable-next-line:no-console
                console.log(content);
                break;
            case levels_1.Levels.debug:
                // tslint:disable-next-line:no-console
                console.debug(content);
                break;
            default:
                break;
        }
    };
    return LoggerFactory;
}());
exports.LoggerFactory = LoggerFactory;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/log/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sip.js/lib/core/log/logger.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var levels_1 = __webpack_require__(/*! ./levels */ "./node_modules/sip.js/lib/core/log/levels.js");
/**
 * Logger.
 * @public
 */
var Logger = /** @class */ (function () {
    function Logger(logger, category, label) {
        this.logger = logger;
        this.category = category;
        this.label = label;
    }
    Logger.prototype.error = function (content) { this.genericLog(levels_1.Levels.error, content); };
    Logger.prototype.warn = function (content) { this.genericLog(levels_1.Levels.warn, content); };
    Logger.prototype.log = function (content) { this.genericLog(levels_1.Levels.log, content); };
    Logger.prototype.debug = function (content) { this.genericLog(levels_1.Levels.debug, content); };
    Logger.prototype.genericLog = function (level, content) {
        this.logger.genericLog(level, this.category, this.label, content);
    };
    return Logger;
}());
exports.Logger = Logger;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/body.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/body.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js");
var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
var outgoing_request_message_1 = __webpack_require__(/*! ./outgoing-request-message */ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js");
/**
 * Create a Body given a legacy body type.
 * @param bodyLegacy - Body Object
 * @internal
 */
function fromBodyLegacy(bodyLegacy) {
    var content = (typeof bodyLegacy === "string") ? bodyLegacy : bodyLegacy.body;
    var contentType = (typeof bodyLegacy === "string") ? "application/sdp" : bodyLegacy.contentType;
    var contentDisposition = contentTypeToContentDisposition(contentType);
    var body = { contentDisposition: contentDisposition, contentType: contentType, content: content };
    return body;
}
exports.fromBodyLegacy = fromBodyLegacy;
/**
 * Given a message, get a normalized body.
 * The content disposition is inferred if not set.
 * @param message - The message.
 * @internal
 */
function getBody(message) {
    var contentDisposition;
    var contentType;
    var content;
    // We're in UAS role, receiving incoming request
    if (message instanceof incoming_request_message_1.IncomingRequestMessage) {
        if (message.body) {
            // FIXME: Parsing needs typing
            var parse = message.parseHeader("Content-Disposition");
            contentDisposition = parse ? parse.type : undefined;
            contentType = message.parseHeader("Content-Type");
            content = message.body;
        }
    }
    // We're in UAC role, receiving incoming response
    if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
        if (message.body) {
            // FIXME: Parsing needs typing
            var parse = message.parseHeader("Content-Disposition");
            contentDisposition = parse ? parse.type : undefined;
            contentType = message.parseHeader("Content-Type");
            content = message.body;
        }
    }
    // We're in UAC role, sending outgoing request
    if (message instanceof outgoing_request_message_1.OutgoingRequestMessage) {
        if (message.body) {
            contentDisposition = message.getHeader("Content-Disposition");
            contentType = message.getHeader("Content-Type");
            if (typeof message.body === "string") {
                // FIXME: OutgoingRequest should not allow a "string" body without a "Content-Type" header.
                if (!contentType) {
                    throw new Error("Header content type header does not equal body content type.");
                }
                content = message.body;
            }
            else {
                // FIXME: OutgoingRequest should not allow the "Content-Type" header not to match th body content type
                if (contentType && contentType !== message.body.contentType) {
                    throw new Error("Header content type header does not equal body content type.");
                }
                contentType = message.body.contentType;
                content = message.body.body;
            }
        }
    }
    // We're in UAS role, sending outgoing response
    if (isBody(message)) {
        contentDisposition = message.contentDisposition;
        contentType = message.contentType;
        content = message.content;
    }
    // No content, no body.
    if (!content) {
        return undefined;
    }
    if (contentType && !contentDisposition) {
        contentDisposition = contentTypeToContentDisposition(contentType);
    }
    if (!contentDisposition) {
        throw new Error("Content disposition undefined.");
    }
    if (!contentType) {
        throw new Error("Content type undefined.");
    }
    return {
        contentDisposition: contentDisposition,
        contentType: contentType,
        content: content
    };
}
exports.getBody = getBody;
/**
 * User-Defined Type Guard for Body.
 * @param body - Body to check.
 * @internal
 */
function isBody(body) {
    return body &&
        typeof body.content === "string" &&
        typeof body.contentType === "string" &&
        body.contentDisposition === undefined ? true : typeof body.contentDisposition === "string";
}
exports.isBody = isBody;
// If the Content-Disposition header field is missing, bodies of
// Content-Type application/sdp imply the disposition "session", while
// other content types imply "render".
// https://tools.ietf.org/html/rfc3261#section-13.2.1
function contentTypeToContentDisposition(contentType) {
    if (contentType === "application/sdp") {
        return "session";
    }
    else {
        return "render";
    }
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/digest-authentication.js":
/*!************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/digest-authentication.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var md5_1 = tslib_1.__importDefault(__webpack_require__(/*! crypto-js/md5 */ "./node_modules/crypto-js/md5.js"));
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Digest Authentication.
 * @internal
 */
var DigestAuthentication = /** @class */ (function () {
    /**
     * Constructor.
     * @param loggerFactory - LoggerFactory.
     * @param username - Username.
     * @param password - Password.
     */
    function DigestAuthentication(loggerFactory, username, password) {
        this.logger = loggerFactory.getLogger("sipjs.digestauthentication");
        this.username = username;
        this.password = password;
        this.nc = 0;
        this.ncHex = "00000000";
    }
    /**
     * Performs Digest authentication given a SIP request and the challenge
     * received in a response to that request.
     * @param request -
     * @param challenge -
     * @returns true if credentials were successfully generated, false otherwise.
     */
    DigestAuthentication.prototype.authenticate = function (request, challenge, body) {
        // Inspect and validate the challenge.
        this.algorithm = challenge.algorithm;
        this.realm = challenge.realm;
        this.nonce = challenge.nonce;
        this.opaque = challenge.opaque;
        this.stale = challenge.stale;
        if (this.algorithm) {
            if (this.algorithm !== "MD5") {
                this.logger.warn("challenge with Digest algorithm different than 'MD5', authentication aborted");
                return false;
            }
        }
        else {
            this.algorithm = "MD5";
        }
        if (!this.realm) {
            this.logger.warn("challenge without Digest realm, authentication aborted");
            return false;
        }
        if (!this.nonce) {
            this.logger.warn("challenge without Digest nonce, authentication aborted");
            return false;
        }
        // 'qop' can contain a list of values (Array). Let's choose just one.
        if (challenge.qop) {
            if (challenge.qop.indexOf("auth") > -1) {
                this.qop = "auth";
            }
            else if (challenge.qop.indexOf("auth-int") > -1) {
                this.qop = "auth-int";
            }
            else {
                // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
                this.logger.warn("challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted");
                return false;
            }
        }
        else {
            this.qop = undefined;
        }
        // Fill other attributes.
        this.method = request.method;
        this.uri = request.ruri;
        this.cnonce = utils_1.createRandomToken(12);
        this.nc += 1;
        this.updateNcHex();
        // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
        if (this.nc === 4294967296) {
            this.nc = 1;
            this.ncHex = "00000001";
        }
        // Calculate the Digest "response" value.
        this.calculateResponse(body);
        return true;
    };
    /**
     * Return the Proxy-Authorization or WWW-Authorization header value.
     */
    DigestAuthentication.prototype.toString = function () {
        var authParams = [];
        if (!this.response) {
            throw new Error("response field does not exist, cannot generate Authorization header");
        }
        authParams.push("algorithm=" + this.algorithm);
        authParams.push('username="' + this.username + '"');
        authParams.push('realm="' + this.realm + '"');
        authParams.push('nonce="' + this.nonce + '"');
        authParams.push('uri="' + this.uri + '"');
        authParams.push('response="' + this.response + '"');
        if (this.opaque) {
            authParams.push('opaque="' + this.opaque + '"');
        }
        if (this.qop) {
            authParams.push("qop=" + this.qop);
            authParams.push('cnonce="' + this.cnonce + '"');
            authParams.push("nc=" + this.ncHex);
        }
        return "Digest " + authParams.join(", ");
    };
    /**
     * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
     */
    DigestAuthentication.prototype.updateNcHex = function () {
        var hex = Number(this.nc).toString(16);
        this.ncHex = "00000000".substr(0, 8 - hex.length) + hex;
    };
    /**
     * Generate Digest 'response' value.
     */
    DigestAuthentication.prototype.calculateResponse = function (body) {
        var ha2;
        // HA1 = MD5(A1) = MD5(username:realm:password)
        var ha1 = md5_1.default(this.username + ":" + this.realm + ":" + this.password);
        if (this.qop === "auth") {
            // HA2 = MD5(A2) = MD5(method:digestURI)
            ha2 = md5_1.default(this.method + ":" + this.uri);
            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);
        }
        else if (this.qop === "auth-int") {
            // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
            ha2 = md5_1.default(this.method + ":" + this.uri + ":" + md5_1.default(body ? body : ""));
            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);
        }
        else if (this.qop === undefined) {
            // HA2 = MD5(A2) = MD5(method:digestURI)
            ha2 = md5_1.default(this.method + ":" + this.uri);
            // response = MD5(HA1:nonce:HA2)
            this.response = md5_1.default(ha1 + ":" + this.nonce + ":" + ha2);
        }
    };
    return DigestAuthentication;
}());
exports.DigestAuthentication = DigestAuthentication;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/grammar.js":
/*!**********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/grammar.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var pegGrammar = tslib_1.__importStar(__webpack_require__(/*! ../../grammar/dist/grammar */ "./node_modules/sip.js/lib/grammar/dist/grammar.js"));
/**
 * Grammar.
 * @internal
 */
var Grammar;
(function (Grammar) {
    /**
     * Parse.
     * @param input -
     * @param startRule -
     */
    function parse(input, startRule) {
        var options = { startRule: startRule };
        try {
            pegGrammar.parse(input, options);
        }
        catch (e) {
            options.data = -1;
        }
        return options.data;
    }
    Grammar.parse = parse;
    /**
     * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if
     * it is an invalid NameAddrHeader.
     * @param name_addr_header -
     */
    function nameAddrHeaderParse(nameAddrHeader) {
        var parsedNameAddrHeader = Grammar.parse(nameAddrHeader, "Name_Addr_Header");
        return parsedNameAddrHeader !== -1 ? parsedNameAddrHeader : undefined;
    }
    Grammar.nameAddrHeaderParse = nameAddrHeaderParse;
    /**
     * Parse the given string and returns a SIP.URI instance or undefined if
     * it is an invalid URI.
     * @param uri -
     */
    function URIParse(uri) {
        var parsedUri = Grammar.parse(uri, "SIP_URI");
        return parsedUri !== -1 ? parsedUri : undefined;
    }
    Grammar.URIParse = URIParse;
})(Grammar = exports.Grammar || (exports.Grammar = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-message.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-message.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var grammar_1 = __webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Incoming message.
 * @public
 */
var IncomingMessage = /** @class */ (function () {
    function IncomingMessage() {
        this.headers = {};
    }
    /**
     * Insert a header of the given name and value into the last position of the
     * header array.
     * @param name - header name
     * @param value - header value
     */
    IncomingMessage.prototype.addHeader = function (name, value) {
        var header = { raw: value };
        name = utils_1.headerize(name);
        if (this.headers[name]) {
            this.headers[name].push(header);
        }
        else {
            this.headers[name] = [header];
        }
    };
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */
    IncomingMessage.prototype.getHeader = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        if (header) {
            if (header[0]) {
                return header[0].raw;
            }
        }
        else {
            return;
        }
    };
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array - with all the headers of the specified name.
     */
    IncomingMessage.prototype.getHeaders = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        var result = [];
        if (!header) {
            return [];
        }
        for (var _i = 0, header_1 = header; _i < header_1.length; _i++) {
            var headerPart = header_1[_i];
            result.push(headerPart.raw);
        }
        return result;
    };
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */
    IncomingMessage.prototype.hasHeader = function (name) {
        return !!this.headers[utils_1.headerize(name)];
    };
    /**
     * Parse the given header on the given index.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     */
    IncomingMessage.prototype.parseHeader = function (name, idx) {
        if (idx === void 0) { idx = 0; }
        name = utils_1.headerize(name);
        if (!this.headers[name]) {
            // this.logger.log("header '" + name + "' not present");
            return;
        }
        else if (idx >= this.headers[name].length) {
            // this.logger.log("not so many '" + name + "' headers present");
            return;
        }
        var header = this.headers[name][idx];
        var value = header.raw;
        if (header.parsed) {
            return header.parsed;
        }
        // substitute '-' by '_' for grammar rule matching.
        var parsed = grammar_1.Grammar.parse(value, name.replace(/-/g, "_"));
        if (parsed === -1) {
            this.headers[name].splice(idx, 1); // delete from headers
            // this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
            return;
        }
        else {
            header.parsed = parsed;
            return parsed;
        }
    };
    /**
     * Message Header attribute selector. Alias of parseHeader.
     * @param name - header name
     * @param idx - header index
     * @returns Parsed header object, undefined if the
     *   header is not present or in case of a parsing error.
     *
     * @example
     * message.s('via',3).port
     */
    IncomingMessage.prototype.s = function (name, idx) {
        if (idx === void 0) { idx = 0; }
        return this.parseHeader(name, idx);
    };
    /**
     * Replace the value of the given header by the value.
     * @param name - header name
     * @param value - header value
     */
    IncomingMessage.prototype.setHeader = function (name, value) {
        this.headers[utils_1.headerize(name)] = [{ raw: value }];
    };
    IncomingMessage.prototype.toString = function () {
        return this.data;
    };
    return IncomingMessage;
}());
exports.IncomingMessage = IncomingMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-request-message.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js");
/**
 * Incoming request message.
 * @public
 */
var IncomingRequestMessage = /** @class */ (function (_super) {
    tslib_1.__extends(IncomingRequestMessage, _super);
    function IncomingRequestMessage() {
        return _super.call(this) || this;
    }
    return IncomingRequestMessage;
}(incoming_message_1.IncomingMessage));
exports.IncomingRequestMessage = IncomingRequestMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/incoming-response-message.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var incoming_message_1 = __webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js");
/**
 * Incoming response message.
 * @public
 */
var IncomingResponseMessage = /** @class */ (function (_super) {
    tslib_1.__extends(IncomingResponseMessage, _super);
    function IncomingResponseMessage() {
        return _super.call(this) || this;
    }
    return IncomingResponseMessage;
}(incoming_message_1.IncomingMessage));
exports.IncomingResponseMessage = IncomingResponseMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/index.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Directories
tslib_1.__exportStar(__webpack_require__(/*! ./methods */ "./node_modules/sip.js/lib/core/messages/methods/index.js"), exports);
// Files
tslib_1.__exportStar(__webpack_require__(/*! ./body */ "./node_modules/sip.js/lib/core/messages/body.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./digest-authentication */ "./node_modules/sip.js/lib/core/messages/digest-authentication.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-message */ "./node_modules/sip.js/lib/core/messages/incoming-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-request-message */ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./outgoing-response */ "./node_modules/sip.js/lib/core/messages/outgoing-response.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./parser */ "./node_modules/sip.js/lib/core/messages/parser.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./uri */ "./node_modules/sip.js/lib/core/messages/uri.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/methods/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/methods/constants.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * SIP Methods
 * @internal
 */
var C;
(function (C) {
    C.ACK = "ACK";
    C.BYE = "BYE";
    C.CANCEL = "CANCEL";
    C.INFO = "INFO";
    C.INVITE = "INVITE";
    C.MESSAGE = "MESSAGE";
    C.NOTIFY = "NOTIFY";
    C.OPTIONS = "OPTIONS";
    C.REGISTER = "REGISTER";
    C.UPDATE = "UPDATE";
    C.SUBSCRIBE = "SUBSCRIBE";
    C.PUBLISH = "PUBLISH";
    C.REFER = "REFER";
    C.PRACK = "PRACK";
})(C = exports.C || (exports.C = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/methods/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/methods/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./constants */ "./node_modules/sip.js/lib/core/messages/methods/constants.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/name-addr-header.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/name-addr-header.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js");
/**
 * Name Address SIP header.
 * @public
 */
var NameAddrHeader = /** @class */ (function (_super) {
    tslib_1.__extends(NameAddrHeader, _super);
    /**
     * Constructor
     * @param uri -
     * @param displayName -
     * @param parameters -
     */
    function NameAddrHeader(uri, displayName, parameters) {
        var _this = _super.call(this, parameters) || this;
        _this.uri = uri;
        _this._displayName = displayName;
        return _this;
    }
    Object.defineProperty(NameAddrHeader.prototype, "friendlyName", {
        get: function () {
            return this.displayName || this.uri.aor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NameAddrHeader.prototype, "displayName", {
        get: function () { return this._displayName; },
        set: function (value) {
            this._displayName = value;
        },
        enumerable: true,
        configurable: true
    });
    NameAddrHeader.prototype.clone = function () {
        return new NameAddrHeader(this.uri.clone(), this._displayName, JSON.parse(JSON.stringify(this.parameters)));
    };
    NameAddrHeader.prototype.toString = function () {
        var body = (this.displayName || this.displayName === "0") ? '"' + this.displayName + '" ' : "";
        body += "<" + this.uri.toString() + ">";
        for (var parameter in this.parameters) {
            if (this.parameters.hasOwnProperty(parameter)) {
                body += ";" + parameter;
                if (this.parameters[parameter] !== null) {
                    body += "=" + this.parameters[parameter];
                }
            }
        }
        return body;
    };
    return NameAddrHeader;
}(parameters_1.Parameters));
exports.NameAddrHeader = NameAddrHeader;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/outgoing-request-message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/outgoing-request-message.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var name_addr_header_1 = __webpack_require__(/*! ./name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js");
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * Outgoing SIP request message.
 * @public
 */
var OutgoingRequestMessage = /** @class */ (function () {
    function OutgoingRequestMessage(method, ruri, fromURI, toURI, options, extraHeaders, body) {
        this.headers = {};
        this.extraHeaders = [];
        this.options = OutgoingRequestMessage.getDefaultOptions();
        // Options - merge a deep copy
        if (options) {
            this.options = tslib_1.__assign(tslib_1.__assign({}, this.options), options);
            if (this.options.optionTags && this.options.optionTags.length) {
                this.options.optionTags = this.options.optionTags.slice();
            }
            if (this.options.routeSet && this.options.routeSet.length) {
                this.options.routeSet = this.options.routeSet.slice();
            }
        }
        // Extra headers - deep copy
        if (extraHeaders && extraHeaders.length) {
            this.extraHeaders = extraHeaders.slice();
        }
        // Body - deep copy
        if (body) {
            // TODO: internal representation should be Body
            // this.body = { ...body };
            this.body = {
                body: body.content,
                contentType: body.contentType
            };
        }
        // Method
        this.method = method;
        // RURI
        this.ruri = ruri.clone();
        // From
        this.fromURI = fromURI.clone();
        this.fromTag = this.options.fromTag ? this.options.fromTag : utils_1.newTag();
        this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);
        // To
        this.toURI = toURI.clone();
        this.toTag = this.options.toTag;
        this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);
        // Call-ID
        this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + utils_1.createRandomToken(15);
        // CSeq
        this.cseq = this.options.cseq;
        // The relative order of header fields with different field names is not
        // significant.  However, it is RECOMMENDED that header fields which are
        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
        // Max-Forwards, and Proxy-Authorization, for example) appear towards
        // the top of the message to facilitate rapid parsing.
        // https://tools.ietf.org/html/rfc3261#section-7.3.1
        this.setHeader("route", this.options.routeSet);
        this.setHeader("via", "");
        this.setHeader("to", this.to.toString());
        this.setHeader("from", this.from.toString());
        this.setHeader("cseq", this.cseq + " " + this.method);
        this.setHeader("call-id", this.callId);
        this.setHeader("max-forwards", "70");
    }
    /** Get a copy of the default options. */
    OutgoingRequestMessage.getDefaultOptions = function () {
        return {
            callId: "",
            callIdPrefix: "",
            cseq: 1,
            toDisplayName: "",
            toTag: "",
            fromDisplayName: "",
            fromTag: "",
            forceRport: false,
            hackViaTcp: false,
            optionTags: ["outbound"],
            routeSet: [],
            userAgentString: "sip.js",
            viaHost: ""
        };
    };
    OutgoingRequestMessage.makeNameAddrHeader = function (uri, displayName, tag) {
        var parameters = {};
        if (tag) {
            parameters.tag = tag;
        }
        return new name_addr_header_1.NameAddrHeader(uri, displayName, parameters);
    };
    /**
     * Get the value of the given header name at the given position.
     * @param name - header name
     * @returns Returns the specified header, undefined if header doesn't exist.
     */
    OutgoingRequestMessage.prototype.getHeader = function (name) {
        var header = this.headers[utils_1.headerize(name)];
        if (header) {
            if (header[0]) {
                return header[0];
            }
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                var exHeader = _a[_i];
                if (regexp.test(exHeader)) {
                    return exHeader.substring(exHeader.indexOf(":") + 1).trim();
                }
            }
        }
        return;
    };
    /**
     * Get the header/s of the given name.
     * @param name - header name
     * @returns Array with all the headers of the specified name.
     */
    OutgoingRequestMessage.prototype.getHeaders = function (name) {
        var result = [];
        var headerArray = this.headers[utils_1.headerize(name)];
        if (headerArray) {
            for (var _i = 0, headerArray_1 = headerArray; _i < headerArray_1.length; _i++) {
                var headerPart = headerArray_1[_i];
                result.push(headerPart);
            }
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _a = 0, _b = this.extraHeaders; _a < _b.length; _a++) {
                var exHeader = _b[_a];
                if (regexp.test(exHeader)) {
                    result.push(exHeader.substring(exHeader.indexOf(":") + 1).trim());
                }
            }
        }
        return result;
    };
    /**
     * Verify the existence of the given header.
     * @param name - header name
     * @returns true if header with given name exists, false otherwise
     */
    OutgoingRequestMessage.prototype.hasHeader = function (name) {
        if (this.headers[utils_1.headerize(name)]) {
            return true;
        }
        else {
            var regexp = new RegExp("^\\s*" + name + "\\s*:", "i");
            for (var _i = 0, _a = this.extraHeaders; _i < _a.length; _i++) {
                var extraHeader = _a[_i];
                if (regexp.test(extraHeader)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Replace the the given header by the given value.
     * @param name - header name
     * @param value - header value
     */
    OutgoingRequestMessage.prototype.setHeader = function (name, value) {
        this.headers[utils_1.headerize(name)] = (value instanceof Array) ? value : [value];
    };
    /**
     * The Via header field indicates the transport used for the transaction
     * and identifies the location where the response is to be sent.  A Via
     * header field value is added only after the transport that will be
     * used to reach the next hop has been selected (which may involve the
     * usage of the procedures in [4]).
     *
     * When the UAC creates a request, it MUST insert a Via into that
     * request.  The protocol name and protocol version in the header field
     * MUST be SIP and 2.0, respectively.  The Via header field value MUST
     * contain a branch parameter.  This parameter is used to identify the
     * transaction created by that request.  This parameter is used by both
     * the client and the server.
     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7
     * @param branchParameter - The branch parameter.
     * @param transport - The sent protocol transport.
     */
    OutgoingRequestMessage.prototype.setViaHeader = function (branch, transport) {
        // FIXME: Hack
        if (this.options.hackViaTcp) {
            transport = "TCP";
        }
        var via = "SIP/2.0/" + transport;
        via += " " + this.options.viaHost + ";branch=" + branch;
        if (this.options.forceRport) {
            via += ";rport";
        }
        this.setHeader("via", via);
        this.branch = branch;
    };
    OutgoingRequestMessage.prototype.toString = function () {
        var msg = "";
        msg += this.method + " " + this.ruri.toRaw() + " SIP/2.0\r\n";
        for (var header in this.headers) {
            if (this.headers[header]) {
                for (var _i = 0, _a = this.headers[header]; _i < _a.length; _i++) {
                    var headerPart = _a[_i];
                    msg += header + ": " + headerPart + "\r\n";
                }
            }
        }
        for (var _b = 0, _c = this.extraHeaders; _b < _c.length; _b++) {
            var header = _c[_b];
            msg += header.trim() + "\r\n";
        }
        msg += "Supported: " + this.options.optionTags.join(", ") + "\r\n";
        msg += "User-Agent: " + this.options.userAgentString + "\r\n";
        if (this.body) {
            if (typeof this.body === "string") {
                msg += "Content-Length: " + utils_1.str_utf8_length(this.body) + "\r\n\r\n";
                msg += this.body;
            }
            else {
                if (this.body.body && this.body.contentType) {
                    msg += "Content-Type: " + this.body.contentType + "\r\n";
                    msg += "Content-Length: " + utils_1.str_utf8_length(this.body.body) + "\r\n\r\n";
                    msg += this.body.body;
                }
                else {
                    msg += "Content-Length: " + 0 + "\r\n\r\n";
                }
            }
        }
        else {
            msg += "Content-Length: " + 0 + "\r\n\r\n";
        }
        return msg;
    };
    return OutgoingRequestMessage;
}());
exports.OutgoingRequestMessage = OutgoingRequestMessage;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/outgoing-response.js":
/*!********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/outgoing-response.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
/**
 * When a UAS wishes to construct a response to a request, it follows
 * the general procedures detailed in the following subsections.
 * Additional behaviors specific to the response code in question, which
 * are not detailed in this section, may also be required.
 * https://tools.ietf.org/html/rfc3261#section-8.2.6
 * @internal
 */
function constructOutgoingResponse(message, options) {
    var CRLF = "\r\n";
    if (options.statusCode < 100 || options.statusCode > 699) {
        throw new TypeError("Invalid statusCode: " + options.statusCode);
    }
    var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : utils_1.getReasonPhrase(options.statusCode);
    // SIP responses are distinguished from requests by having a Status-Line
    // as their start-line.  A Status-Line consists of the protocol version
    // followed by a numeric Status-Code and its associated textual phrase,
    // with each element separated by a single SP character.
    // https://tools.ietf.org/html/rfc3261#section-7.2
    var response = "SIP/2.0 " + options.statusCode + " " + reasonPhrase + CRLF;
    // One largely non-method-specific guideline for the generation of
    // responses is that UASs SHOULD NOT issue a provisional response for a
    // non-INVITE request.  Rather, UASs SHOULD generate a final response to
    // a non-INVITE request as soon as possible.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
    if (options.statusCode >= 100 && options.statusCode < 200) {
        // TODO
    }
    // When a 100 (Trying) response is generated, any Timestamp header field
    // present in the request MUST be copied into this 100 (Trying)
    // response.  If there is a delay in generating the response, the UAS
    // SHOULD add a delay value into the Timestamp value in the response.
    // This value MUST contain the difference between the time of sending of
    // the response and receipt of the request, measured in seconds.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1
    if (options.statusCode === 100) {
        // TODO
    }
    // The From field of the response MUST equal the From header field of
    // the request.  The Call-ID header field of the response MUST equal the
    // Call-ID header field of the request.  The CSeq header field of the
    // response MUST equal the CSeq field of the request.  The Via header
    // field values in the response MUST equal the Via header field values
    // in the request and MUST maintain the same ordering.
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
    var fromHeader = "From: " + message.getHeader("From") + CRLF;
    var callIdHeader = "Call-ID: " + message.callId + CRLF;
    var cSeqHeader = "CSeq: " + message.cseq + " " + message.method + CRLF;
    var viaHeaders = message.getHeaders("via").reduce(function (previous, current) {
        return previous + "Via: " + current + CRLF;
    }, "");
    // If a request contained a To tag in the request, the To header field
    // in the response MUST equal that of the request.  However, if the To
    // header field in the request did not contain a tag, the URI in the To
    // header field in the response MUST equal the URI in the To header
    // field; additionally, the UAS MUST add a tag to the To header field in
    // the response (with the exception of the 100 (Trying) response, in
    // which a tag MAY be present).  This serves to identify the UAS that is
    // responding, possibly resulting in a component of a dialog ID.  The
    // same tag MUST be used for all responses to that request, both final
    // and provisional (again excepting the 100 (Trying)).
    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2
    var toHeader = "To: " + message.getHeader("to");
    if (options.statusCode > 100 && !message.parseHeader("to").hasParam("tag")) {
        var toTag = options.toTag;
        if (!toTag) {
            // Stateless UAS Behavior...
            // o  To header tags MUST be generated for responses in a stateless
            //    manner - in a manner that will generate the same tag for the
            //    same request consistently.  For information on tag construction
            //    see Section 19.3.
            // https://tools.ietf.org/html/rfc3261#section-8.2.7
            toTag = utils_1.newTag(); // FIXME: newTag() currently generates random tags
        }
        toHeader += ";tag=" + toTag;
    }
    toHeader += CRLF;
    // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)
    // let recordRouteHeaders = "";
    // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {
    //   recordRouteHeaders = request.getHeaders("record-route").reduce((previous, current) => {
    //     return previous + "Record-Route: " + current + CRLF;
    //   }, "");
    // }
    // FIXME: TODO: needs review...
    var supportedHeader = "";
    if (options.supported) {
        supportedHeader = "Supported: " + options.supported.join(", ") + CRLF;
    }
    // FIXME: TODO: needs review...
    var userAgentHeader = "";
    if (options.userAgent) {
        userAgentHeader = "User-Agent: " + options.userAgent + CRLF;
    }
    var extensionHeaders = "";
    if (options.extraHeaders) {
        extensionHeaders = options.extraHeaders.reduce(function (previous, current) {
            return previous + current.trim() + CRLF;
        }, "");
    }
    // The relative order of header fields with different field names is not
    // significant.  However, it is RECOMMENDED that header fields which are
    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,
    // Max-Forwards, and Proxy-Authorization, for example) appear towards
    // the top of the message to facilitate rapid parsing.
    // https://tools.ietf.org/html/rfc3261#section-7.3.1
    // response += recordRouteHeaders;
    response += viaHeaders;
    response += fromHeader;
    response += toHeader;
    response += cSeqHeader;
    response += callIdHeader;
    response += supportedHeader;
    response += userAgentHeader;
    response += extensionHeaders;
    if (options.body) {
        response += "Content-Type: " + options.body.contentType + CRLF;
        response += "Content-Length: " + utils_1.str_utf8_length(options.body.content) + CRLF + CRLF;
        response += options.body.content;
    }
    else {
        response += "Content-Length: " + 0 + CRLF + CRLF;
    }
    return { message: response };
}
exports.constructOutgoingResponse = constructOutgoingResponse;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/parameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/parameters.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @internal
 */
var Parameters = /** @class */ (function () {
    function Parameters(parameters) {
        this.parameters = {};
        for (var param in parameters) {
            if (parameters.hasOwnProperty(param)) {
                this.setParam(param, parameters[param]);
            }
        }
    }
    Parameters.prototype.setParam = function (key, value) {
        if (key) {
            this.parameters[key.toLowerCase()] = (typeof value === "undefined" || value === null) ? null : value.toString();
        }
    };
    Parameters.prototype.getParam = function (key) {
        if (key) {
            return this.parameters[key.toLowerCase()];
        }
    };
    Parameters.prototype.hasParam = function (key) {
        if (key) {
            return !!this.parameters.hasOwnProperty(key.toLowerCase());
        }
        return false;
    };
    Parameters.prototype.deleteParam = function (parameter) {
        parameter = parameter.toLowerCase();
        if (this.parameters.hasOwnProperty(parameter)) {
            var value = this.parameters[parameter];
            delete this.parameters[parameter];
            return value;
        }
    };
    Parameters.prototype.clearParams = function () {
        this.parameters = {};
    };
    return Parameters;
}());
exports.Parameters = Parameters;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/parser.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var grammar_1 = __webpack_require__(/*! ./grammar */ "./node_modules/sip.js/lib/core/messages/grammar.js");
var incoming_request_message_1 = __webpack_require__(/*! ./incoming-request-message */ "./node_modules/sip.js/lib/core/messages/incoming-request-message.js");
var incoming_response_message_1 = __webpack_require__(/*! ./incoming-response-message */ "./node_modules/sip.js/lib/core/messages/incoming-response-message.js");
/**
 * Extract and parse every header of a SIP message.
 * @internal
 */
var Parser;
(function (Parser) {
    function getHeader(data, headerStart) {
        // 'start' position of the header.
        var start = headerStart;
        // 'end' position of the header.
        var end = 0;
        // 'partial end' position of the header.
        var partialEnd = 0;
        // End of message.
        if (data.substring(start, start + 2).match(/(^\r\n)/)) {
            return -2;
        }
        while (end === 0) {
            // Partial End of Header.
            partialEnd = data.indexOf("\r\n", start);
            // 'indexOf' returns -1 if the value to be found never occurs.
            if (partialEnd === -1) {
                return partialEnd;
            }
            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) &&
                data.charAt(partialEnd + 2).match(/(^\s+)/)) {
                // Not the end of the message. Continue from the next position.
                start = partialEnd + 2;
            }
            else {
                end = partialEnd;
            }
        }
        return end;
    }
    Parser.getHeader = getHeader;
    function parseHeader(message, data, headerStart, headerEnd) {
        var hcolonIndex = data.indexOf(":", headerStart);
        var headerName = data.substring(headerStart, hcolonIndex).trim();
        var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();
        var parsed;
        // If header-field is well-known, parse it.
        switch (headerName.toLowerCase()) {
            case "via":
            case "v":
                message.addHeader("via", headerValue);
                if (message.getHeaders("via").length === 1) {
                    parsed = message.parseHeader("Via");
                    if (parsed) {
                        message.via = parsed;
                        message.viaBranch = parsed.branch;
                    }
                }
                else {
                    parsed = 0;
                }
                break;
            case "from":
            case "f":
                message.setHeader("from", headerValue);
                parsed = message.parseHeader("from");
                if (parsed) {
                    message.from = parsed;
                    message.fromTag = parsed.getParam("tag");
                }
                break;
            case "to":
            case "t":
                message.setHeader("to", headerValue);
                parsed = message.parseHeader("to");
                if (parsed) {
                    message.to = parsed;
                    message.toTag = parsed.getParam("tag");
                }
                break;
            case "record-route":
                parsed = grammar_1.Grammar.parse(headerValue, "Record_Route");
                if (parsed === -1) {
                    parsed = undefined;
                    break;
                }
                if (!(parsed instanceof Array)) {
                    parsed = undefined;
                    break;
                }
                parsed.forEach(function (header) {
                    message.addHeader("record-route", headerValue.substring(header.position, header.offset));
                    message.headers["Record-Route"][message.getHeaders("record-route").length - 1].parsed = header.parsed;
                });
                break;
            case "call-id":
            case "i":
                message.setHeader("call-id", headerValue);
                parsed = message.parseHeader("call-id");
                if (parsed) {
                    message.callId = headerValue;
                }
                break;
            case "contact":
            case "m":
                parsed = grammar_1.Grammar.parse(headerValue, "Contact");
                if (parsed === -1) {
                    parsed = undefined;
                    break;
                }
                if (!(parsed instanceof Array)) {
                    parsed = undefined;
                    break;
                }
                parsed.forEach(function (header) {
                    message.addHeader("contact", headerValue.substring(header.position, header.offset));
                    message.headers.Contact[message.getHeaders("contact").length - 1].parsed = header.parsed;
                });
                break;
            case "content-length":
            case "l":
                message.setHeader("content-length", headerValue);
                parsed = message.parseHeader("content-length");
                break;
            case "content-type":
            case "c":
                message.setHeader("content-type", headerValue);
                parsed = message.parseHeader("content-type");
                break;
            case "cseq":
                message.setHeader("cseq", headerValue);
                parsed = message.parseHeader("cseq");
                if (parsed) {
                    message.cseq = parsed.value;
                }
                if (message instanceof incoming_response_message_1.IncomingResponseMessage) {
                    message.method = parsed.method;
                }
                break;
            case "max-forwards":
                message.setHeader("max-forwards", headerValue);
                parsed = message.parseHeader("max-forwards");
                break;
            case "www-authenticate":
                message.setHeader("www-authenticate", headerValue);
                parsed = message.parseHeader("www-authenticate");
                break;
            case "proxy-authenticate":
                message.setHeader("proxy-authenticate", headerValue);
                parsed = message.parseHeader("proxy-authenticate");
                break;
            case "refer-to":
            case "r":
                message.setHeader("refer-to", headerValue);
                parsed = message.parseHeader("refer-to");
                if (parsed) {
                    message.referTo = parsed;
                }
                break;
            default:
                // Do not parse this header.
                message.addHeader(headerName.toLowerCase(), headerValue);
                parsed = 0;
        }
        if (parsed === undefined) {
            return {
                error: "error parsing header '" + headerName + "'"
            };
        }
        else {
            return true;
        }
    }
    Parser.parseHeader = parseHeader;
    function parseMessage(data, logger) {
        var headerStart = 0;
        var headerEnd = data.indexOf("\r\n");
        if (headerEnd === -1) {
            logger.warn("no CRLF found, not a SIP message, discarded");
            return;
        }
        // Parse first line. Check if it is a Request or a Reply.
        var firstLine = data.substring(0, headerEnd);
        var parsed = grammar_1.Grammar.parse(firstLine, "Request_Response");
        var message;
        if (parsed === -1) {
            logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
            return;
        }
        else if (!parsed.status_code) {
            message = new incoming_request_message_1.IncomingRequestMessage();
            message.method = parsed.method;
            message.ruri = parsed.uri;
        }
        else {
            message = new incoming_response_message_1.IncomingResponseMessage();
            message.statusCode = parsed.status_code;
            message.reasonPhrase = parsed.reason_phrase;
        }
        message.data = data;
        headerStart = headerEnd + 2;
        // Loop over every line in data. Detect the end of each header and parse
        // it or simply add to the headers collection.
        var bodyStart;
        while (true) {
            headerEnd = getHeader(data, headerStart);
            // The SIP message has normally finished.
            if (headerEnd === -2) {
                bodyStart = headerStart + 2;
                break;
            }
            else if (headerEnd === -1) {
                // data.indexOf returned -1 due to a malformed message.
                logger.error("malformed message");
                return;
            }
            var parsedHeader = parseHeader(message, data, headerStart, headerEnd);
            if (parsedHeader !== true) {
                logger.error(parsed.error);
                return;
            }
            headerStart = headerEnd + 2;
        }
        // RFC3261 18.3.
        // If there are additional bytes in the transport packet
        // beyond the end of the body, they MUST be discarded.
        if (message.hasHeader("content-length")) {
            message.body = data.substr(bodyStart, Number(message.getHeader("content-length")));
        }
        else {
            message.body = data.substring(bodyStart);
        }
        return message;
    }
    Parser.parseMessage = parseMessage;
})(Parser = exports.Parser || (exports.Parser = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/uri.js":
/*!******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/uri.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var parameters_1 = __webpack_require__(/*! ./parameters */ "./node_modules/sip.js/lib/core/messages/parameters.js");
/**
 * URI.
 * @public
 */
var URI = /** @class */ (function (_super) {
    tslib_1.__extends(URI, _super);
    /**
     * Constructor
     * @param scheme -
     * @param user -
     * @param host -
     * @param port -
     * @param parameters -
     * @param headers -
     */
    function URI(scheme, user, host, port, parameters, headers) {
        var _this = _super.call(this, parameters) || this;
        _this.headers = {};
        // Checks
        if (!host) {
            throw new TypeError('missing or invalid "host" parameter');
        }
        // Initialize parameters
        scheme = scheme || "sip";
        for (var header in headers) {
            if (headers.hasOwnProperty(header)) {
                _this.setHeader(header, headers[header]);
            }
        }
        // Raw URI
        _this.raw = {
            scheme: scheme,
            user: user,
            host: host,
            port: port
        };
        // Normalized URI
        _this.normal = {
            scheme: scheme.toLowerCase(),
            user: user,
            host: host.toLowerCase(),
            port: port
        };
        return _this;
    }
    Object.defineProperty(URI.prototype, "scheme", {
        get: function () { return this.normal.scheme; },
        set: function (value) {
            this.raw.scheme = value;
            this.normal.scheme = value.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "user", {
        get: function () { return this.normal.user; },
        set: function (value) {
            this.normal.user = this.raw.user = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "host", {
        get: function () { return this.normal.host; },
        set: function (value) {
            this.raw.host = value;
            this.normal.host = value.toLowerCase();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "aor", {
        get: function () { return this.normal.user + "@" + this.normal.host; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "port", {
        get: function () { return this.normal.port; },
        set: function (value) {
            this.normal.port = this.raw.port = value === 0 ? value : value;
        },
        enumerable: true,
        configurable: true
    });
    URI.prototype.setHeader = function (name, value) {
        this.headers[this.headerize(name)] = (value instanceof Array) ? value : [value];
    };
    URI.prototype.getHeader = function (name) {
        if (name) {
            return this.headers[this.headerize(name)];
        }
    };
    URI.prototype.hasHeader = function (name) {
        return !!name && !!this.headers.hasOwnProperty(this.headerize(name));
    };
    URI.prototype.deleteHeader = function (header) {
        header = this.headerize(header);
        if (this.headers.hasOwnProperty(header)) {
            var value = this.headers[header];
            delete this.headers[header];
            return value;
        }
    };
    URI.prototype.clearHeaders = function () {
        this.headers = {};
    };
    URI.prototype.clone = function () {
        return new URI(this._raw.scheme, this._raw.user || "", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));
    };
    URI.prototype.toRaw = function () {
        return this._toString(this._raw);
    };
    URI.prototype.toString = function () {
        return this._toString(this._normal);
    };
    Object.defineProperty(URI.prototype, "_normal", {
        get: function () { return this.normal; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URI.prototype, "_raw", {
        get: function () { return this.raw; },
        enumerable: true,
        configurable: true
    });
    URI.prototype._toString = function (uri) {
        var uriString = uri.scheme + ":";
        // add slashes if it's not a sip(s) URI
        if (!uri.scheme.toLowerCase().match("^sips?$")) {
            uriString += "//";
        }
        if (uri.user) {
            uriString += this.escapeUser(uri.user) + "@";
        }
        uriString += uri.host;
        if (uri.port || uri.port === 0) {
            uriString += ":" + uri.port;
        }
        for (var parameter in this.parameters) {
            if (this.parameters.hasOwnProperty(parameter)) {
                uriString += ";" + parameter;
                if (this.parameters[parameter] !== null) {
                    uriString += "=" + this.parameters[parameter];
                }
            }
        }
        var headers = [];
        for (var header in this.headers) {
            if (this.headers.hasOwnProperty(header)) {
                for (var idx in this.headers[header]) {
                    if (this.headers[header].hasOwnProperty(idx)) {
                        headers.push(header + "=" + this.headers[header][idx]);
                    }
                }
            }
        }
        if (headers.length > 0) {
            uriString += "?" + headers.join("&");
        }
        return uriString;
    };
    /*
     * Hex-escape a SIP URI user.
     * @private
     * @param {String} user
     */
    URI.prototype.escapeUser = function (user) {
        var decodedUser;
        // FIXME: This is called by toString above which should never throw, but
        // decodeURIComponent can throw and I've seen one case in production where
        // it did throw resulting in a cascading failure. This class should be
        // fixed so that decodeURIComponent is not called at this point (in toString).
        // The user should be decoded when the URI is constructor or some other
        // place where we can catch the error before the URI is created or somesuch.
        try {
            decodedUser = decodeURIComponent(user);
        }
        catch (error) {
            throw error;
        }
        // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
        return encodeURIComponent(decodedUser)
            .replace(/%3A/ig, ":")
            .replace(/%2B/ig, "+")
            .replace(/%3F/ig, "?")
            .replace(/%2F/ig, "/");
    };
    URI.prototype.headerize = function (str) {
        var exceptions = {
            "Call-Id": "Call-ID",
            "Cseq": "CSeq",
            "Min-Se": "Min-SE",
            "Rack": "RAck",
            "Rseq": "RSeq",
            "Www-Authenticate": "WWW-Authenticate",
        };
        var name = str.toLowerCase().replace(/_/g, "-").split("-");
        var parts = name.length;
        var hname = "";
        for (var part = 0; part < parts; part++) {
            if (part !== 0) {
                hname += "-";
            }
            hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
        }
        if (exceptions[hname]) {
            hname = exceptions[hname];
        }
        return hname;
    };
    return URI;
}(parameters_1.Parameters));
exports.URI = URI;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/messages/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/messages/utils.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @param size -
 * @param base -
 * @internal
 */
function createRandomToken(size, base) {
    if (base === void 0) { base = 32; }
    var token = "";
    for (var i = 0; i < size; i++) {
        var r = Math.floor(Math.random() * base);
        token += r.toString(base);
    }
    return token;
}
exports.createRandomToken = createRandomToken;
/**
 * @internal
 */
function getReasonPhrase(code) {
    return REASON_PHRASE[code] || "";
}
exports.getReasonPhrase = getReasonPhrase;
/**
 * @internal
 */
function newTag() {
    return createRandomToken(10);
}
exports.newTag = newTag;
/**
 * @param str -
 * @internal
 */
function headerize(str) {
    var exceptions = {
        "Call-Id": "Call-ID",
        "Cseq": "CSeq",
        "Min-Se": "Min-SE",
        "Rack": "RAck",
        "Rseq": "RSeq",
        "Www-Authenticate": "WWW-Authenticate",
    };
    var name = str.toLowerCase().replace(/_/g, "-").split("-");
    var parts = name.length;
    var hname = "";
    for (var part = 0; part < parts; part++) {
        if (part !== 0) {
            hname += "-";
        }
        hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
    }
    if (exceptions[hname]) {
        hname = exceptions[hname];
    }
    return hname;
}
exports.headerize = headerize;
/**
 * @param str -
 * @internal
 */
function str_utf8_length(str) {
    return encodeURIComponent(str).replace(/%[A-F\d]{2}/g, "U").length;
}
exports.str_utf8_length = str_utf8_length;
/**
 * SIP Response Reasons
 * DOC: http://www.iana.org/assignments/sip-parameters
 * @internal
 */
var REASON_PHRASE = {
    100: "Trying",
    180: "Ringing",
    181: "Call Is Being Forwarded",
    182: "Queued",
    183: "Session Progress",
    199: "Early Dialog Terminated",
    200: "OK",
    202: "Accepted",
    204: "No Notification",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    305: "Use Proxy",
    380: "Alternative Service",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    410: "Gone",
    412: "Conditional Request Failed",
    413: "Request Entity Too Large",
    414: "Request-URI Too Long",
    415: "Unsupported Media Type",
    416: "Unsupported URI Scheme",
    417: "Unknown Resource-Priority",
    420: "Bad Extension",
    421: "Extension Required",
    422: "Session Interval Too Small",
    423: "Interval Too Brief",
    428: "Use Identity Header",
    429: "Provide Referrer Identity",
    430: "Flow Failed",
    433: "Anonymity Disallowed",
    436: "Bad Identity-Info",
    437: "Unsupported Certificate",
    438: "Invalid Identity Header",
    439: "First Hop Lacks Outbound Support",
    440: "Max-Breadth Exceeded",
    469: "Bad Info Package",
    470: "Consent Needed",
    478: "Unresolvable Destination",
    480: "Temporarily Unavailable",
    481: "Call/Transaction Does Not Exist",
    482: "Loop Detected",
    483: "Too Many Hops",
    484: "Address Incomplete",
    485: "Ambiguous",
    486: "Busy Here",
    487: "Request Terminated",
    488: "Not Acceptable Here",
    489: "Bad Event",
    491: "Request Pending",
    493: "Undecipherable",
    494: "Security Agreement Required",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Server Time-out",
    505: "Version Not Supported",
    513: "Message Too Large",
    580: "Precondition Failure",
    600: "Busy Everywhere",
    603: "Decline",
    604: "Does Not Exist Anywhere",
    606: "Not Acceptable"
};


/***/ }),

/***/ "./node_modules/sip.js/lib/core/session/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/sip.js/lib/core/session/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./session */ "./node_modules/sip.js/lib/core/session/session.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/session/session.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/session/session.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Session state.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-13
 * @public
 */
var SessionState;
(function (SessionState) {
    SessionState["Initial"] = "Initial";
    SessionState["Early"] = "Early";
    SessionState["AckWait"] = "AckWait";
    SessionState["Confirmed"] = "Confirmed";
    SessionState["Terminated"] = "Terminated";
})(SessionState = exports.SessionState || (exports.SessionState = {}));
/**
 * Offer/Answer state.
 * @remarks
 * ```txt
 *         Offer                Answer             RFC    Ini Est Early
 *  -------------------------------------------------------------------
 *  1. INVITE Req.          2xx INVITE Resp.     RFC 3261  Y   Y    N
 *  2. 2xx INVITE Resp.     ACK Req.             RFC 3261  Y   Y    N
 *  3. INVITE Req.          1xx-rel INVITE Resp. RFC 3262  Y   Y    N
 *  4. 1xx-rel INVITE Resp. PRACK Req.           RFC 3262  Y   Y    N
 *  5. PRACK Req.           200 PRACK Resp.      RFC 3262  N   Y    Y
 *  6. UPDATE Req.          2xx UPDATE Resp.     RFC 3311  N   Y    Y
 *
 *       Table 1: Summary of SIP Usage of the Offer/Answer Model
 * ```
 * https://tools.ietf.org/html/rfc6337#section-2.2
 * @public
 */
var SignalingState;
(function (SignalingState) {
    SignalingState["Initial"] = "Initial";
    SignalingState["HaveLocalOffer"] = "HaveLocalOffer";
    SignalingState["HaveRemoteOffer"] = "HaveRemoteOffer";
    SignalingState["Stable"] = "Stable";
    SignalingState["Closed"] = "Closed";
})(SignalingState = exports.SignalingState || (exports.SignalingState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/subscription/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/subscription/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./subscription */ "./node_modules/sip.js/lib/core/subscription/subscription.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/subscription/subscription.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/subscription/subscription.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Subscription state.
 * @remarks
 * https://tools.ietf.org/html/rfc6665#section-4.1.2
 * @public
 */
var SubscriptionState;
(function (SubscriptionState) {
    SubscriptionState["Initial"] = "Initial";
    SubscriptionState["NotifyWait"] = "NotifyWait";
    SubscriptionState["Pending"] = "Pending";
    SubscriptionState["Active"] = "Active";
    SubscriptionState["Terminated"] = "Terminated";
})(SubscriptionState = exports.SubscriptionState || (exports.SubscriptionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/timers.js":
/*!************************************************!*\
  !*** ./node_modules/sip.js/lib/core/timers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var T1 = 500;
var T2 = 4000;
var T4 = 5000;
/**
 * Timers.
 * @public
 */
exports.Timers = {
    T1: T1,
    T2: T2,
    T4: T4,
    TIMER_B: 64 * T1,
    TIMER_D: 0 * T1,
    TIMER_F: 64 * T1,
    TIMER_H: 64 * T1,
    TIMER_I: 0 * T4,
    TIMER_J: 0 * T1,
    TIMER_K: 0 * T4,
    TIMER_L: 64 * T1,
    TIMER_M: 64 * T1,
    TIMER_N: 64 * T1,
    PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1
};


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/client-transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/client-transaction.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js");
/**
 * Client Transaction.
 * @remarks
 * The client transaction provides its functionality through the
 * maintenance of a state machine.
 *
 * The TU communicates with the client transaction through a simple
 * interface.  When the TU wishes to initiate a new transaction, it
 * creates a client transaction and passes it the SIP request to send
 * and an IP address, port, and transport to which to send it.  The
 * client transaction begins execution of its state machine.  Valid
 * responses are passed up to the TU from the client transaction.
 * https://tools.ietf.org/html/rfc3261#section-17.1
 * @public
 */
var ClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(ClientTransaction, _super);
    function ClientTransaction(_request, transport, user, state, loggerCategory) {
        var _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory) || this;
        _this._request = _request;
        _this.user = user;
        // The Via header field indicates the transport used for the transaction
        // and identifies the location where the response is to be sent.  A Via
        // header field value is added only after the transport that will be
        // used to reach the next hop has been selected (which may involve the
        // usage of the procedures in [4]).
        // https://tools.ietf.org/html/rfc3261#section-8.1.1.7
        _request.setViaHeader(_this.id, transport.protocol);
        return _this;
    }
    ClientTransaction.makeId = function (request) {
        if (request.method === "CANCEL") {
            if (!request.branch) {
                throw new Error("Outgoing CANCEL request without a branch.");
            }
            return request.branch;
        }
        else {
            return "z9hG4bK" + Math.floor(Math.random() * 10000000);
        }
    };
    Object.defineProperty(ClientTransaction.prototype, "request", {
        /** The outgoing request the transaction handling. */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * A 408 to non-INVITE will always arrive too late to be useful ([3]),
     * The client already has full knowledge of the timeout. The only
     * information this message would convey is whether or not the server
     * believed the transaction timed out. However, with the current design
     * of the NIT, a client cannot do anything with this knowledge. Thus,
     * the 408 is simply wasting network resources and contributes to the
     * response bombardment illustrated in [3].
     * https://tools.ietf.org/html/rfc4320#section-4.1
     */
    ClientTransaction.prototype.onRequestTimeout = function () {
        if (this.user.onRequestTimeout) {
            this.user.onRequestTimeout();
        }
    };
    return ClientTransaction;
}(transaction_1.Transaction));
exports.ClientTransaction = ClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-server-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./non-invite-server-transaction */ "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-client-transaction */ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/invite-client-transaction.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * INVITE Client Transaction.
 * @remarks
 * The INVITE transaction consists of a three-way handshake.  The client
 * transaction sends an INVITE, the server transaction sends responses,
 * and the client transaction sends an ACK.
 * https://tools.ietf.org/html/rfc3261#section-17.1.1
 * @public
 */
var InviteClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(InviteClientTransaction, _super);
    /**
     * Constructor.
     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
     * Then `toString` is called on the outgoing request and the message is sent via the transport.
     * After construction the transaction will be in the "calling" state and the transaction id
     * will equal the branch parameter set in the Via header of the outgoing request.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1
     * @param request - The outgoing INVITE request.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function InviteClientTransaction(request, transport, user) {
        var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Calling, "sip.transaction.ict") || this;
        /**
         * Map of 2xx to-tag to ACK.
         * If value is not undefined, value is the ACK which was sent.
         * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.
         * Otherwise, a 2xx was not (yet) received for this transaction.
         */
        _this.ackRetransmissionCache = new Map();
        // FIXME: Timer A for unreliable transport not implemented
        //
        // If an unreliable transport is being used, the client transaction
        // MUST start timer A with a value of T1. If a reliable transport is being used,
        // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).
        // For any transport, the client transaction MUST start timer B with a value
        // of 64*T1 seconds (Timer B controls transaction timeouts).
        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
        //
        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
        // So Timer B should be cleared when the transaction state proceeds from "Calling".
        _this.B = setTimeout(function () { return _this.timer_B(); }, timers_1.Timers.TIMER_B);
        _this.send(request.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send initial outgoing request.");
        });
        return _this;
    }
    /**
     * Destructor.
     */
    InviteClientTransaction.prototype.dispose = function () {
        if (this.B) {
            clearTimeout(this.B);
            this.B = undefined;
        }
        if (this.D) {
            clearTimeout(this.D);
            this.D = undefined;
        }
        if (this.M) {
            clearTimeout(this.M);
            this.M = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(InviteClientTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "ict";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * ACK a 2xx final response.
     *
     * The transaction includes the ACK only if the final response was not a 2xx response (the
     * transaction will generate and send the ACK to the transport automagically). If the
     * final response was a 2xx, the ACK is not considered part of the transaction (the
     * transaction user needs to generate and send the ACK).
     *
     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final
     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled
     * by the transaction layer (instead of the UAC core). The "standard" approach is for
     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to
     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses
     * and any retransmissions of those ACKs as needed.
     *
     * @param ack - The outgoing ACK request.
     */
    InviteClientTransaction.prototype.ackResponse = function (ack) {
        var _this = this;
        var toTag = ack.toTag;
        if (!toTag) {
            throw new Error("To tag undefined.");
        }
        var id = "z9hG4bK" + Math.floor(Math.random() * 10000000);
        ack.setViaHeader(id, this.transport.protocol);
        this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache
        this.send(ack.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send ACK to 2xx response.");
        });
    };
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */
    InviteClientTransaction.prototype.receiveResponse = function (response) {
        var _this = this;
        var statusCode = response.statusCode;
        if (!statusCode || statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Calling:
                // If the client transaction receives a provisional response while in
                // the "Calling" state, it transitions to the "Proceeding" state. In the
                // "Proceeding" state, the client transaction SHOULD NOT retransmit the
                // request any longer. Furthermore, the provisional response MUST be
                // passed to the TU.  Any further provisional responses MUST be passed
                // up to the TU while in the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                if (statusCode >= 100 && statusCode <= 199) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When a 2xx response is received while in either the "Calling" or
                // "Proceeding" states, the client transaction MUST transition to
                // the "Accepted" state... The 2xx response MUST be passed up to the TU.
                // The client transaction MUST NOT generate an ACK to the 2xx response -- its
                // handling is delegated to the TU. A UAC core will send an ACK to
                // the 2xx response using a new transaction.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When in either the "Calling" or "Proceeding" states, reception of
                // a response with status code from 300-699 MUST cause the client
                // transaction to transition to "Completed". The client transaction
                // MUST pass the received response up to the TU, and the client
                // transaction MUST generate an ACK request, even if the transport is
                // reliable (guidelines for constructing the ACK from the response
                // are given in Section 17.1.1.3), and then pass the ACK to the
                // transport layer for transmission. The ACK MUST be sent to the
                // same address, port, and transport to which the original request was sent.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.ack(response);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // In the "Proceeding" state, the client transaction SHOULD NOT retransmit the
                // request any longer. Furthermore, the provisional response MUST be
                // passed to the TU.  Any further provisional responses MUST be passed
                // up to the TU while in the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
                if (statusCode >= 100 && statusCode <= 199) {
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When a 2xx response is received while in either the "Calling" or "Proceeding" states,
                // the client transaction MUST transition to the "Accepted" state...
                // The 2xx response MUST be passed up to the TU. The client
                // transaction MUST NOT generate an ACK to the 2xx response -- its
                // handling is delegated to the TU. A UAC core will send an ACK to
                // the 2xx response using a new transaction.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // When in either the "Calling" or "Proceeding" states, reception of
                // a response with status code from 300-699 MUST cause the client
                // transaction to transition to "Completed". The client transaction
                // MUST pass the received response up to the TU, and the client
                // transaction MUST generate an ACK request, even if the transport is
                // reliable (guidelines for constructing the ACK from the response
                // are given in Section 17.1.1.3), and then pass the ACK to the
                // transport layer for transmission. The ACK MUST be sent to the
                // same address, port, and transport to which the original request was sent.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.ack(response);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // The purpose of the "Accepted" state is to allow the client
                // transaction to continue to exist to receive, and pass to the TU,
                // any retransmissions of the 2xx response and any additional 2xx
                // responses from other branches of the INVITE if it forked
                // downstream. Timer M reflects the amount of time that the
                // transaction user will wait for such messages.
                //
                // Any 2xx responses that match this client transaction and that are
                // received while in the "Accepted" state MUST be passed up to the
                // TU. The client transaction MUST NOT generate an ACK to the 2xx
                // response. The client transaction takes no further action.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 200 && statusCode <= 299) {
                    // NOTE: This implementation herein is intentionally not RFC compliant.
                    // While the first 2xx response for a given branch is passed up to the TU,
                    // retransmissions of 2xx responses are absorbed and the ACK associated
                    // with the original response is resent. This approach is taken because
                    // our current transaction users are not currently in a good position to
                    // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)
                    //
                    // If we don't have a cache hit, pass the response to the TU.
                    if (!this.ackRetransmissionCache.has(response.toTag)) {
                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache
                        if (this.user.receiveResponse) {
                            this.user.receiveResponse(response);
                        }
                        return;
                    }
                    // If we have a cache hit, try pulling the ACK from cache and retransmitting it.
                    var ack = this.ackRetransmissionCache.get(response.toTag);
                    if (ack) {
                        this.send(ack.toString()).catch(function (error) {
                            _this.logTransportError(error, "Failed to send retransmission of ACK to 2xx response.");
                        });
                        return;
                    }
                    // If an ACK was not found in cache then we have received a retransmitted 2xx
                    // response before the TU responded to the original response (we don't have an ACK yet).
                    // So discard this response under the assumption that the TU will eventually
                    // get us a ACK for the original response.
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Any retransmissions of a response with status code 300-699 that
                // are received while in the "Completed" state MUST cause the ACK to
                // be re-passed to the transport layer for retransmission, but the
                // newly received response MUST NOT be passed up to the TU.
                // https://tools.ietf.org/html/rfc6026#section-8.4
                if (statusCode >= 300 && statusCode <= 699) {
                    this.ack(response);
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        // Any response received that does not match an existing client
        // transaction state machine is simply dropped. (Implementations are,
        // of course, free to log or do other implementation-specific things
        // with such responses, but the implementer should be sure to consider
        // the impact of large numbers of malicious stray responses.)
        // https://tools.ietf.org/html/rfc6026#section-7.2
        var message = "Received unexpected " + statusCode + " response while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * The client transaction SHOULD inform the TU that a transport failure
     * has occurred, and the client transaction SHOULD transition directly
     * to the "Terminated" state.  The TU will handle the failover
     * mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - The error.
     */
    InviteClientTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    InviteClientTransaction.prototype.typeToString = function () {
        return "INVITE client transaction";
    };
    InviteClientTransaction.prototype.ack = function (response) {
        var _this = this;
        // The ACK request constructed by the client transaction MUST contain
        // values for the Call-ID, From, and Request-URI that are equal to the
        // values of those header fields in the request passed to the transport
        // by the client transaction (call this the "original request"). The To
        // header field in the ACK MUST equal the To header field in the
        // response being acknowledged, and therefore will usually differ from
        // the To header field in the original request by the addition of the
        // tag parameter. The ACK MUST contain a single Via header field, and
        // this MUST be equal to the top Via header field of the original
        // request. The CSeq header field in the ACK MUST contain the same
        // value for the sequence number as was present in the original request,
        // but the method parameter MUST be equal to "ACK".
        //
        // If the INVITE request whose response is being acknowledged had Route
        // header fields, those header fields MUST appear in the ACK. This is
        // to ensure that the ACK can be routed properly through any downstream
        // stateless proxies.
        // https://tools.ietf.org/html/rfc3261#section-17.1.1.3
        var ruri = this.request.ruri;
        var callId = this.request.callId;
        var cseq = this.request.cseq;
        var from = this.request.getHeader("from");
        var to = response.getHeader("to");
        var via = this.request.getHeader("via");
        var route = this.request.getHeader("route");
        if (!from) {
            throw new Error("From undefined.");
        }
        if (!to) {
            throw new Error("To undefined.");
        }
        if (!via) {
            throw new Error("Via undefined.");
        }
        var ack = "ACK " + ruri + " SIP/2.0\r\n";
        if (route) {
            ack += "Route: " + route + "\r\n";
        }
        ack += "Via: " + via + "\r\n";
        ack += "To: " + to + "\r\n";
        ack += "From: " + from + "\r\n";
        ack += "Call-ID: " + callId + "\r\n";
        ack += "CSeq: " + cseq + " ACK\r\n";
        ack += "Max-Forwards: 70\r\n";
        ack += "Content-Length: 0\r\n\r\n";
        // TOOO: "User-Agent" header
        this.send(ack).catch(function (error) {
            _this.logTransportError(error, "Failed to send ACK to non-2xx response.");
        });
        return;
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    InviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Calling:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Calling) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Calling &&
                    this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Calling &&
                    this.state !== transaction_state_1.TransactionState.Accepted &&
                    this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender
        // will wait for an INVITE message to be acknowledged (a SIP response message is received).
        // So Timer B should be cleared when the transaction state proceeds from "Calling".
        if (this.B) {
            clearTimeout(this.B);
            this.B = undefined;
        }
        if (newState === transaction_state_1.TransactionState.Proceeding) {
            // Timers have no effect on "Proceeding" state.
            // In the "Proceeding" state, the client transaction
            // SHOULD NOT retransmit the request any longer.
            // https://tools.ietf.org/html/rfc3261#section-17.1.1.2
        }
        // The client transaction MUST start Timer D when it enters the "Completed" state
        // for any reason, with a value of at least 32 seconds for unreliable transports,
        // and a value of zero seconds for reliable transports.
        // https://tools.ietf.org/html/rfc6026#section-8.4
        if (newState === transaction_state_1.TransactionState.Completed) {
            this.D = setTimeout(function () { return _this.timer_D(); }, timers_1.Timers.TIMER_D);
        }
        // The client transaction MUST transition to the "Accepted" state,
        // and Timer M MUST be started with a value of 64*T1.
        // https://tools.ietf.org/html/rfc6026#section-8.4
        if (newState === transaction_state_1.TransactionState.Accepted) {
            this.M = setTimeout(function () { return _this.timer_M(); }, timers_1.Timers.TIMER_M);
        }
        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * When timer A fires, the client transaction MUST retransmit the
     * request by passing it to the transport layer, and MUST reset the
     * timer with a value of 2*T1.
     * When timer A fires 2*T1 seconds later, the request MUST be
     * retransmitted again (assuming the client transaction is still in this
     * state). This process MUST continue so that the request is
     * retransmitted with intervals that double after each transmission.
     * These retransmissions SHOULD only be done while the client
     * transaction is in the "Calling" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */
    InviteClientTransaction.prototype.timer_A = function () {
        // TODO
    };
    /**
     * If the client transaction is still in the "Calling" state when timer
     * B fires, the client transaction SHOULD inform the TU that a timeout
     * has occurred.  The client transaction MUST NOT generate an ACK.
     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2
     */
    InviteClientTransaction.prototype.timer_B = function () {
        this.logger.debug("Timer B expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Calling) {
            this.onRequestTimeout();
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer D fires while the client transaction is in the "Completed" state,
     * the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */
    InviteClientTransaction.prototype.timer_D = function () {
        this.logger.debug("Timer D expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer M fires while the client transaction is in the "Accepted"
     * state, the client transaction MUST move to the "Terminated" state.
     * https://tools.ietf.org/html/rfc6026#section-8.4
     */
    InviteClientTransaction.prototype.timer_M = function () {
        this.logger.debug("Timer M expired for INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Accepted) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return InviteClientTransaction;
}(client_transaction_1.ClientTransaction));
exports.InviteClientTransaction = InviteClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/invite-server-transaction.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.1
 * @public
 */
var InviteServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(InviteServerTransaction, _super);
    /**
     * Constructor.
     * Upon construction, a "100 Trying" reply will be immediately sent.
     * After construction the transaction will be in the "proceeding" state and the transaction
     * `id` will equal the branch parameter set in the Via header of the incoming request.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     * @param request - Incoming INVITE request from the transport.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function InviteServerTransaction(request, transport, user) {
        return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Proceeding, "sip.transaction.ist") || this;
    }
    /**
     * Destructor.
     */
    InviteServerTransaction.prototype.dispose = function () {
        this.stopProgressExtensionTimer();
        if (this.H) {
            clearTimeout(this.H);
            this.H = undefined;
        }
        if (this.I) {
            clearTimeout(this.I);
            this.I = undefined;
        }
        if (this.L) {
            clearTimeout(this.L);
            this.L = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(InviteServerTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "ist";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */
    InviteServerTransaction.prototype.receiveRequest = function (request) {
        var _this = this;
        switch (this.state) {
            case transaction_state_1.TransactionState.Proceeding:
                // If a request retransmission is received while in the "Proceeding" state, the most
                // recent provisional response that was received from the TU MUST be passed to the
                // transport layer for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE) {
                    if (this.lastProvisionalResponse) {
                        this.send(this.lastProvisionalResponse).catch(function (error) {
                            _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                        });
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // While in the "Accepted" state, any retransmissions of the INVITE
                // received will match this transaction state machine and will be
                // absorbed by the machine without changing its state. These
                // retransmissions are not passed onto the TU.
                // https://tools.ietf.org/html/rfc6026#section-7.1
                if (request.method === messages_1.C.INVITE) {
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Furthermore, while in the "Completed" state, if a request retransmission is
                // received, the server SHOULD pass the response to the transport for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE) {
                    if (!this.lastFinalResponse) {
                        throw new Error("Last final response undefined.");
                    }
                    this.send(this.lastFinalResponse).catch(function (error) {
                        _this.logTransportError(error, "Failed to send retransmission of final response.");
                    });
                    return;
                }
                // If an ACK is received while the server transaction is in the "Completed" state,
                // the server transaction MUST transition to the "Confirmed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.ACK) {
                    this.stateTransition(transaction_state_1.TransactionState.Confirmed);
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Confirmed:
                // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
                // triggered from retransmissions of the final response.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                // For good measure absorb any additional messages that arrive (should not happen).
                if (request.method === messages_1.C.INVITE || request.method === messages_1.C.ACK) {
                    return;
                }
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "INVITE server transaction received unexpected " + request.method + " request while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response.
     * @param response - Response.
     */
    InviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
        var _this = this;
        if (statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Proceeding:
                // The TU passes any number of provisional responses to the server
                // transaction. So long as the server transaction is in the
                // "Proceeding" state, each of these MUST be passed to the transport
                // layer for transmission. They are not sent reliably by the
                // transaction layer (they are not retransmitted by it) and do not cause
                // a change in the state of the server transaction.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (statusCode >= 100 && statusCode <= 199) {
                    this.lastProvisionalResponse = response;
                    // Start the progress extension timer only for a non-100 provisional response.
                    if (statusCode > 100) {
                        this.startProgressExtensionTimer(); // FIXME: remove
                    }
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 1xx response.");
                    });
                    return;
                }
                // If, while in the "Proceeding" state, the TU passes a 2xx response
                // to the server transaction, the server transaction MUST pass this
                // response to the transport layer for transmission. It is not
                // retransmitted by the server transaction; retransmissions of 2xx
                // responses are handled by the TU. The server transaction MUST then
                // transition to the "Accepted" state.
                // https://tools.ietf.org/html/rfc6026#section-8.5
                if (statusCode >= 200 && statusCode <= 299) {
                    this.lastFinalResponse = response;
                    this.stateTransition(transaction_state_1.TransactionState.Accepted);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 2xx response.");
                    });
                    return;
                }
                // While in the "Proceeding" state, if the TU passes a response with
                // status code from 300 to 699 to the server transaction, the response
                // MUST be passed to the transport layer for transmission, and the state
                // machine MUST enter the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.1
                if (statusCode >= 300 && statusCode <= 699) {
                    this.lastFinalResponse = response;
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send non-2xx final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Accepted:
                // While in the "Accepted" state, if the TU passes a 2xx response,
                // the server transaction MUST pass the response to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc6026#section-8.7
                if (statusCode >= 200 && statusCode <= 299) {
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send 2xx response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                break;
            case transaction_state_1.TransactionState.Confirmed:
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
        this.logger.error(message);
        throw new Error(message);
    };
    /**
     * Retransmit the last 2xx response. This is a noop if not in the "accepted" state.
     */
    InviteServerTransaction.prototype.retransmitAcceptedResponse = function () {
        var _this = this;
        if (this.state === transaction_state_1.TransactionState.Accepted && this.lastFinalResponse) {
            this.send(this.lastFinalResponse).catch(function (error) {
                _this.logTransportError(error, "Failed to send 2xx response.");
            });
        }
    };
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and MUST remain in the current state.
     * https://tools.ietf.org/html/rfc6026#section-8.8
     */
    InviteServerTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
    };
    /** For logging. */
    InviteServerTransaction.prototype.typeToString = function () {
        return "INVITE server transaction";
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    InviteServerTransaction.prototype.stateTransition = function (newState) {
        var _this = this;
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Proceeding:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Accepted:
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Confirmed:
                if (this.state !== transaction_state_1.TransactionState.Completed) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Accepted &&
                    this.state !== transaction_state_1.TransactionState.Completed &&
                    this.state !== transaction_state_1.TransactionState.Confirmed) {
                    invalidStateTransition();
                }
                break;
            default:
                invalidStateTransition();
        }
        // On any state transition, stop resending provisional responses
        this.stopProgressExtensionTimer();
        // The purpose of the "Accepted" state is to absorb retransmissions of an accepted INVITE request.
        // Any such retransmissions are absorbed entirely within the server transaction.
        // They are not passed up to the TU since any downstream UAS cores that accepted the request have
        // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Accepted) {
            this.L = setTimeout(function () { return _this.timer_L(); }, timers_1.Timers.TIMER_L);
        }
        // When the "Completed" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.
        // Timer H determines when the server transaction abandons retransmitting the response.
        // If an ACK is received while the server transaction is in the "Completed" state,
        // the server transaction MUST transition to the "Confirmed" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.1
        if (newState === transaction_state_1.TransactionState.Completed) {
            // FIXME: Missing timer G for unreliable transports.
            this.H = setTimeout(function () { return _this.timer_H(); }, timers_1.Timers.TIMER_H);
        }
        // The purpose of the "Confirmed" state is to absorb any additional ACK messages that arrive,
        // triggered from retransmissions of the final response. When this state is entered, timer I
        // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable
        // transports. Once timer I fires, the server MUST transition to the "Terminated" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.1
        if (newState === transaction_state_1.TransactionState.Confirmed) {
            // FIXME: This timer is not getting set correctly for unreliable transports.
            this.I = setTimeout(function () { return _this.timer_I(); }, timers_1.Timers.TIMER_I);
        }
        // Once the transaction is in the "Terminated" state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc6026#section-8.7
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */
    InviteServerTransaction.prototype.startProgressExtensionTimer = function () {
        var _this = this;
        // Start the progress extension timer only for the first non-100 provisional response.
        if (this.progressExtensionTimer === undefined) {
            this.progressExtensionTimer = setInterval(function () {
                _this.logger.debug("Progress extension timer expired for INVITE server transaction " + _this.id + ".");
                if (!_this.lastProvisionalResponse) {
                    throw new Error("Last provisional response undefined.");
                }
                _this.send(_this.lastProvisionalResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                });
            }, timers_1.Timers.PROVISIONAL_RESPONSE_INTERVAL);
        }
    };
    /**
     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1
     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.
     */
    InviteServerTransaction.prototype.stopProgressExtensionTimer = function () {
        if (this.progressExtensionTimer !== undefined) {
            clearInterval(this.progressExtensionTimer);
            this.progressExtensionTimer = undefined;
        }
    };
    /**
     * While in the "Proceeding" state, if the TU passes a response with status code
     * from 300 to 699 to the server transaction, the response MUST be passed to the
     * transport layer for transmission, and the state machine MUST enter the "Completed" state.
     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for
     * reliable transports. If timer G fires, the response is passed to the transport layer once
     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,
     * when timer G fires, the response is passed to the transport again for transmission, and
     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case
     * it is reset with the value of T2.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_G = function () {
        // TODO
    };
    /**
     * If timer H fires while in the "Completed" state, it implies that the ACK was never received.
     * In this case, the server transaction MUST transition to the "Terminated" state, and MUST
     * indicate to the TU that a transaction failure has occurred.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_H = function () {
        this.logger.debug("Timer H expired for INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.logger.warn("ACK to negative final response was never received, terminating transaction.");
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * Once timer I fires, the server MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.1
     */
    InviteServerTransaction.prototype.timer_I = function () {
        this.logger.debug("Timer I expired for INVITE server transaction " + this.id + ".");
        this.stateTransition(transaction_state_1.TransactionState.Terminated);
    };
    /**
     * When Timer L fires and the state machine is in the "Accepted" state, the machine MUST
     * transition to the "Terminated" state. Once the transaction is in the "Terminated" state,
     * it MUST be destroyed immediately. Timer L reflects the amount of time the server
     * transaction could receive 2xx responses for retransmission from the
     * TU while it is waiting to receive an ACK.
     * https://tools.ietf.org/html/rfc6026#section-7.1
     * https://tools.ietf.org/html/rfc6026#section-8.7
     */
    InviteServerTransaction.prototype.timer_L = function () {
        this.logger.debug("Timer L expired for INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Accepted) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return InviteServerTransaction;
}(server_transaction_1.ServerTransaction));
exports.InviteServerTransaction = InviteServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var client_transaction_1 = __webpack_require__(/*! ./client-transaction */ "./node_modules/sip.js/lib/core/transactions/client-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * Non-INVITE Client Transaction.
 * @remarks
 * Non-INVITE transactions do not make use of ACK.
 * They are simple request-response interactions.
 * https://tools.ietf.org/html/rfc3261#section-17.1.2
 * @public
 */
var NonInviteClientTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(NonInviteClientTransaction, _super);
    /**
     * Constructor
     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.
     * Then `toString` is called on the outgoing request and the message is sent via the transport.
     * After construction the transaction will be in the "calling" state and the transaction id
     * will equal the branch parameter set in the Via header of the outgoing request.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2
     * @param request - The outgoing Non-INVITE request.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function NonInviteClientTransaction(request, transport, user) {
        var _this = _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nict") || this;
        // FIXME: Timer E for unreliable transports not implemented.
        //
        // The "Trying" state is entered when the TU initiates a new client
        // transaction with a request.  When entering this state, the client
        // transaction SHOULD set timer F to fire in 64*T1 seconds. The request
        // MUST be passed to the transport layer for transmission.
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        _this.F = setTimeout(function () { return _this.timer_F(); }, timers_1.Timers.TIMER_F);
        _this.send(request.toString()).catch(function (error) {
            _this.logTransportError(error, "Failed to send initial outgoing request.");
        });
        return _this;
    }
    /**
     * Destructor.
     */
    NonInviteClientTransaction.prototype.dispose = function () {
        if (this.F) {
            clearTimeout(this.F);
            this.F = undefined;
        }
        if (this.K) {
            clearTimeout(this.K);
            this.K = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(NonInviteClientTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "nict";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handler for incoming responses from the transport which match this transaction.
     * @param response - The incoming response.
     */
    NonInviteClientTransaction.prototype.receiveResponse = function (response) {
        var statusCode = response.statusCode;
        if (!statusCode || statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // If a provisional response is received while in the "Trying" state, the
                // response MUST be passed to the TU, and then the client transaction
                // SHOULD move to the "Proceeding" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 100 && statusCode <= 199) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                // If a final response (status codes 200-699) is received while in the
                // "Trying" state, the response MUST be passed to the TU, and the
                // client transaction MUST transition to the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    if (statusCode === 408) {
                        this.onRequestTimeout();
                        return;
                    }
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // If a provisional response is received while in the "Proceeding" state,
                // the response MUST be passed to the TU. (From Figure 6)
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 100 && statusCode <= 199) {
                    if (this.user.receiveResponse) {
                        return this.user.receiveResponse(response);
                    }
                }
                // If a final response (status codes 200-699) is received while in the
                // "Proceeding" state, the response MUST be passed to the TU, and the
                // client transaction MUST transition to the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    if (statusCode === 408) {
                        this.onRequestTimeout();
                        return;
                    }
                    if (this.user.receiveResponse) {
                        this.user.receiveResponse(response);
                    }
                    return;
                }
            case transaction_state_1.TransactionState.Completed:
                // The "Completed" state exists to buffer any additional response
                // retransmissions that may be received (which is why the client
                // transaction remains there only for unreliable transports).
                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
                return;
            case transaction_state_1.TransactionState.Terminated:
                // For good measure just absorb additional response retransmissions.
                return;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "Non-INVITE client transaction received unexpected " + statusCode + " response while in state " + this.state + ".";
        this.logger.warn(message);
        return;
    };
    /**
     * The client transaction SHOULD inform the TU that a transport failure has occurred,
     * and the client transaction SHOULD transition directly to the "Terminated" state.
     * The TU will handle the fail over mechanisms described in [4].
     * https://tools.ietf.org/html/rfc3261#section-17.1.4
     * @param error - Transport error
     */
    NonInviteClientTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    NonInviteClientTransaction.prototype.typeToString = function () {
        return "non-INVITE client transaction";
    };
    /**
     * Execute a state transition.
     * @param newState - New state.
     */
    NonInviteClientTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Trying:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Trying) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Trying &&
                    this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Trying &&
                    this.state !== transaction_state_1.TransactionState.Proceeding &&
                    this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // Once the client transaction enters the "Completed" state, it MUST set
        // Timer K to fire in T4 seconds for unreliable transports, and zero
        // seconds for reliable transports  The "Completed" state exists to
        // buffer any additional response retransmissions that may be received
        // (which is why the client transaction remains there only for unreliable transports).
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        if (newState === transaction_state_1.TransactionState.Completed) {
            if (this.F) {
                clearTimeout(this.F);
                this.F = undefined;
            }
            this.K = setTimeout(function () { return _this.timer_K(); }, timers_1.Timers.TIMER_K);
        }
        // Once the transaction is in the terminated state, it MUST be destroyed immediately.
        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        // Update state.
        this.setState(newState);
    };
    /**
     * If Timer F fires while the client transaction is still in the
     * "Trying" state, the client transaction SHOULD inform the TU about the
     * timeout, and then it SHOULD enter the "Terminated" state.
     * If timer F fires while in the "Proceeding" state, the TU MUST be informed of
     * a timeout, and the client transaction MUST transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */
    NonInviteClientTransaction.prototype.timer_F = function () {
        this.logger.debug("Timer F expired for non-INVITE client transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Trying || this.state === transaction_state_1.TransactionState.Proceeding) {
            this.onRequestTimeout();
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    /**
     * If Timer K fires while in this (COMPLETED) state, the client transaction
     * MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2
     */
    NonInviteClientTransaction.prototype.timer_K = function () {
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return NonInviteClientTransaction;
}(client_transaction_1.ClientTransaction));
exports.NonInviteClientTransaction = NonInviteClientTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/non-invite-server-transaction.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var server_transaction_1 = __webpack_require__(/*! ./server-transaction */ "./node_modules/sip.js/lib/core/transactions/server-transaction.js");
var transaction_state_1 = __webpack_require__(/*! ./transaction-state */ "./node_modules/sip.js/lib/core/transactions/transaction-state.js");
/**
 * Non-INVITE Server Transaction.
 * @remarks
 * https://tools.ietf.org/html/rfc3261#section-17.2.2
 * @public
 */
var NonInviteServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(NonInviteServerTransaction, _super);
    /**
     * Constructor.
     * After construction the transaction will be in the "trying": state and the transaction
     * `id` will equal the branch parameter set in the Via header of the incoming request.
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     * @param request - Incoming Non-INVITE request from the transport.
     * @param transport - The transport.
     * @param user - The transaction user.
     */
    function NonInviteServerTransaction(request, transport, user) {
        return _super.call(this, request, transport, user, transaction_state_1.TransactionState.Trying, "sip.transaction.nist") || this;
    }
    /**
     * Destructor.
     */
    NonInviteServerTransaction.prototype.dispose = function () {
        if (this.J) {
            clearTimeout(this.J);
            this.J = undefined;
        }
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(NonInviteServerTransaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            return "nist";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Receive requests from transport matching this transaction.
     * @param request - Request matching this transaction.
     */
    NonInviteServerTransaction.prototype.receiveRequest = function (request) {
        var _this = this;
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // Once in the "Trying" state, any further request retransmissions are discarded.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // If a retransmission of the request is received while in the "Proceeding" state,
                // the most recently sent provisional response MUST be passed to the transport layer for retransmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                if (!this.lastResponse) {
                    throw new Error("Last response undefined.");
                }
                this.send(this.lastResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of provisional response.");
                });
                break;
            case transaction_state_1.TransactionState.Completed:
                // While in the "Completed" state, the server transaction MUST pass the final response to the transport
                // layer for retransmission whenever a retransmission of the request is received. Any other final responses
                // passed by the TU to the server transaction MUST be discarded while in the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                if (!this.lastResponse) {
                    throw new Error("Last response undefined.");
                }
                this.send(this.lastResponse).catch(function (error) {
                    _this.logTransportError(error, "Failed to send retransmission of final response.");
                });
                break;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
    };
    /**
     * Receive responses from TU for this transaction.
     * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.
     * @param response - Response to send.
     */
    NonInviteServerTransaction.prototype.receiveResponse = function (statusCode, response) {
        var _this = this;
        if (statusCode < 100 || statusCode > 699) {
            throw new Error("Invalid status code " + statusCode);
        }
        // An SIP element MUST NOT send any provisional response with a
        // Status-Code other than 100 to a non-INVITE request.
        // An SIP element MUST NOT respond to a non-INVITE request with a
        // Status-Code of 100 over any unreliable transport, such as UDP,
        // before the amount of time it takes a client transaction's Timer E to be reset to T2.
        // An SIP element MAY respond to a non-INVITE request with a
        // Status-Code of 100 over a reliable transport at any time.
        // https://tools.ietf.org/html/rfc4320#section-4.1
        if (statusCode > 100 && statusCode <= 199) {
            throw new Error("Provisional response other than 100 not allowed.");
        }
        switch (this.state) {
            case transaction_state_1.TransactionState.Trying:
                // While in the "Trying" state, if the TU passes a provisional response
                // to the server transaction, the server transaction MUST enter the "Proceeding" state.
                // The response MUST be passed to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                this.lastResponse = response;
                if (statusCode >= 100 && statusCode < 200) {
                    this.stateTransition(transaction_state_1.TransactionState.Proceeding);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send provisional response.");
                    });
                    return;
                }
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Proceeding:
                // Any further provisional responses that are received from the TU while
                // in the "Proceeding" state MUST be passed to the transport layer for transmission.
                // If the TU passes a final response (status codes 200-699) to the server while in
                // the "Proceeding" state, the transaction MUST enter the "Completed" state, and
                // the response MUST be passed to the transport layer for transmission.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                this.lastResponse = response;
                if (statusCode >= 200 && statusCode <= 699) {
                    this.stateTransition(transaction_state_1.TransactionState.Completed);
                    this.send(response).catch(function (error) {
                        _this.logTransportError(error, "Failed to send final response.");
                    });
                    return;
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                // Any other final responses passed by the TU to the server
                // transaction MUST be discarded while in the "Completed" state.
                // https://tools.ietf.org/html/rfc3261#section-17.2.2
                return;
            case transaction_state_1.TransactionState.Terminated:
                break;
            default:
                throw new Error("Invalid state " + this.state);
        }
        var message = "Non-INVITE server transaction received unexpected " + statusCode + " response from TU while in state " + this.state + ".";
        this.logger.error(message);
        throw new Error(message);
    };
    /**
     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.
     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD
     * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.4
     */
    NonInviteServerTransaction.prototype.onTransportError = function (error) {
        if (this.user.onTransportError) {
            this.user.onTransportError(error);
        }
        this.stateTransition(transaction_state_1.TransactionState.Terminated, true);
    };
    /** For logging. */
    NonInviteServerTransaction.prototype.typeToString = function () {
        return "non-INVITE server transaction";
    };
    NonInviteServerTransaction.prototype.stateTransition = function (newState, dueToTransportError) {
        var _this = this;
        if (dueToTransportError === void 0) { dueToTransportError = false; }
        // Assert valid state transitions.
        var invalidStateTransition = function () {
            throw new Error("Invalid state transition from " + _this.state + " to " + newState);
        };
        switch (newState) {
            case transaction_state_1.TransactionState.Trying:
                invalidStateTransition();
                break;
            case transaction_state_1.TransactionState.Proceeding:
                if (this.state !== transaction_state_1.TransactionState.Trying) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Completed:
                if (this.state !== transaction_state_1.TransactionState.Trying && this.state !== transaction_state_1.TransactionState.Proceeding) {
                    invalidStateTransition();
                }
                break;
            case transaction_state_1.TransactionState.Terminated:
                if (this.state !== transaction_state_1.TransactionState.Proceeding && this.state !== transaction_state_1.TransactionState.Completed) {
                    if (!dueToTransportError) {
                        invalidStateTransition();
                    }
                }
                break;
            default:
                invalidStateTransition();
        }
        // When the server transaction enters the "Completed" state, it MUST set Timer J to fire
        // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.
        // https://tools.ietf.org/html/rfc3261#section-17.2.2
        if (newState === transaction_state_1.TransactionState.Completed) {
            this.J = setTimeout(function () { return _this.timer_J(); }, timers_1.Timers.TIMER_J);
        }
        // The server transaction MUST be destroyed the instant it enters the "Terminated" state.
        // https://tools.ietf.org/html/rfc3261#section-17.2.2
        if (newState === transaction_state_1.TransactionState.Terminated) {
            this.dispose();
        }
        this.setState(newState);
    };
    /**
     * The server transaction remains in this state until Timer J fires,
     * at which point it MUST transition to the "Terminated" state.
     * https://tools.ietf.org/html/rfc3261#section-17.2.2
     */
    NonInviteServerTransaction.prototype.timer_J = function () {
        this.logger.debug("Timer J expired for NON-INVITE server transaction " + this.id + ".");
        if (this.state === transaction_state_1.TransactionState.Completed) {
            this.stateTransition(transaction_state_1.TransactionState.Terminated);
        }
    };
    return NonInviteServerTransaction;
}(server_transaction_1.ServerTransaction));
exports.NonInviteServerTransaction = NonInviteServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/server-transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/server-transaction.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transaction_1 = __webpack_require__(/*! ./transaction */ "./node_modules/sip.js/lib/core/transactions/transaction.js");
/**
 * Server Transaction.
 * @remarks
 * The server transaction is responsible for the delivery of requests to
 * the TU and the reliable transmission of responses.  It accomplishes
 * this through a state machine.  Server transactions are created by the
 * core when a request is received, and transaction handling is desired
 * for that request (this is not always the case).
 * https://tools.ietf.org/html/rfc3261#section-17.2
 * @public
 */
var ServerTransaction = /** @class */ (function (_super) {
    tslib_1.__extends(ServerTransaction, _super);
    function ServerTransaction(_request, transport, user, state, loggerCategory) {
        var _this = _super.call(this, transport, user, _request.viaBranch, state, loggerCategory) || this;
        _this._request = _request;
        _this.user = user;
        return _this;
    }
    Object.defineProperty(ServerTransaction.prototype, "request", {
        /** The incoming request the transaction handling. */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    return ServerTransaction;
}(transaction_1.Transaction));
exports.ServerTransaction = ServerTransaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/transaction-state.js":
/*!************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/transaction-state.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Transaction state.
 * @public
 */
var TransactionState;
(function (TransactionState) {
    TransactionState["Accepted"] = "Accepted";
    TransactionState["Calling"] = "Calling";
    TransactionState["Completed"] = "Completed";
    TransactionState["Confirmed"] = "Confirmed";
    TransactionState["Proceeding"] = "Proceeding";
    TransactionState["Terminated"] = "Terminated";
    TransactionState["Trying"] = "Trying";
})(TransactionState = exports.TransactionState || (exports.TransactionState = {}));


/***/ }),

/***/ "./node_modules/sip.js/lib/core/transactions/transaction.js":
/*!******************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/transactions/transaction.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
/**
 * Transaction.
 * @remarks
 * SIP is a transactional protocol: interactions between components take
 * place in a series of independent message exchanges.  Specifically, a
 * SIP transaction consists of a single request and any responses to
 * that request, which include zero or more provisional responses and
 * one or more final responses.  In the case of a transaction where the
 * request was an INVITE (known as an INVITE transaction), the
 * transaction also includes the ACK only if the final response was not
 * a 2xx response.  If the response was a 2xx, the ACK is not considered
 * part of the transaction.
 * https://tools.ietf.org/html/rfc3261#section-17
 * @public
 */
var Transaction = /** @class */ (function (_super) {
    tslib_1.__extends(Transaction, _super);
    function Transaction(_transport, _user, _id, _state, loggerCategory) {
        var _this = _super.call(this) || this;
        _this._transport = _transport;
        _this._user = _user;
        _this._id = _id;
        _this._state = _state;
        _this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);
        _this.logger.debug("Constructing " + _this.typeToString() + " with id " + _this.id + ".");
        return _this;
    }
    /**
     * Destructor.
     * Once the transaction is in the "terminated" state, it is destroyed
     * immediately and there is no need to call `dispose`. However, if a
     * transaction needs to be ended prematurely, the transaction user may
     * do so by calling this method (for example, perhaps the UA is shutting down).
     * No state transition will occur upon calling this method, all outstanding
     * transmission timers will be cancelled, and use of the transaction after
     * calling `dispose` is undefined.
     */
    Transaction.prototype.dispose = function () {
        this.logger.debug("Destroyed " + this.typeToString() + " with id " + this.id + ".");
    };
    Object.defineProperty(Transaction.prototype, "id", {
        /** Transaction id. */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "kind", {
        /** Transaction kind. Deprecated. */
        get: function () {
            throw new Error("Invalid kind.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "state", {
        /** Transaction state. */
        get: function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transaction.prototype, "transport", {
        /** Transaction transport. */
        get: function () {
            return this._transport;
        },
        enumerable: true,
        configurable: true
    });
    Transaction.prototype.on = function (name, callback) { return _super.prototype.on.call(this, name, callback); };
    Transaction.prototype.logTransportError = function (error, message) {
        this.logger.error(error.message);
        this.logger.error("Transport error occurred in " + this.typeToString() + " with id " + this.id + ".");
        this.logger.error(message);
    };
    /**
     * Pass message to transport for transmission. If transport fails,
     * the transaction user is notified by callback to onTransportError().
     * @returns
     * Rejects with `TransportError` if transport fails.
     */
    Transaction.prototype.send = function (message) {
        var _this = this;
        return this.transport.send(message).catch(function (error) {
            // If the transport rejects, it SHOULD reject with a TransportError.
            // But the transport may be external code, so we are careful
            // make sure we convert it to a TransportError if need be.
            if (error instanceof exceptions_1.TransportError) {
                _this.onTransportError(error);
                throw error;
            }
            var transportError;
            if (error && typeof error.message === "string") {
                transportError = new exceptions_1.TransportError(error.message);
            }
            else {
                transportError = new exceptions_1.TransportError();
            }
            _this.onTransportError(transportError);
            throw transportError;
        });
    };
    Transaction.prototype.setState = function (state) {
        this.logger.debug("State change to \"" + state + "\" on " + this.typeToString() + " with id " + this.id + ".");
        this._state = state;
        if (this._user.onStateChange) {
            this._user.onStateChange(state);
        }
        this.emit("stateChanged");
    };
    Transaction.prototype.typeToString = function () {
        return "UnknownType";
    };
    return Transaction;
}(events_1.EventEmitter));
exports.Transaction = Transaction;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
/**
 * FIXME: TODO: Should be configurable/variable.
 */
exports.AllowedMethods = [
    messages_1.C.ACK,
    messages_1.C.BYE,
    messages_1.C.CANCEL,
    messages_1.C.INFO,
    messages_1.C.INVITE,
    messages_1.C.MESSAGE,
    messages_1.C.NOTIFY,
    messages_1.C.OPTIONS,
    messages_1.C.PRACK,
    messages_1.C.REFER,
    messages_1.C.REGISTER,
    messages_1.C.SUBSCRIBE
];


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-core */ "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agents_1 = __webpack_require__(/*! ../user-agents */ "./node_modules/sip.js/lib/core/user-agents/index.js");
var allowed_methods_1 = __webpack_require__(/*! ./allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
/**
 * This is ported from UA.C.ACCEPTED_BODY_TYPES.
 * FIXME: TODO: Should be configurable/variable.
 */
var acceptedBodyTypes = [
    "application/sdp",
    "application/dtmf-relay"
];
/**
 * User Agent Core.
 * @remarks
 * Core designates the functions specific to a particular type
 * of SIP entity, i.e., specific to either a stateful or stateless
 * proxy, a user agent or registrar.  All cores, except those for
 * the stateless proxy, are transaction users.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAC Core: The set of processing functions required of a UAC that
 * reside above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 *
 * UAS Core: The set of processing functions required at a UAS that
 * resides above the transaction and transport layers.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentCore = /** @class */ (function () {
    /**
     * Constructor.
     * @param configuration - Configuration.
     * @param delegate - Delegate.
     */
    function UserAgentCore(configuration, delegate) {
        if (delegate === void 0) { delegate = {}; }
        /** UACs. */
        this.userAgentClients = new Map();
        /** UASs. */
        this.userAgentServers = new Map();
        this.configuration = configuration;
        this.delegate = delegate;
        this.dialogs = new Map();
        this.subscribers = new Map();
        this.logger = configuration.loggerFactory.getLogger("sip.user-agent-core");
    }
    /** Destructor. */
    UserAgentCore.prototype.dispose = function () {
        this.reset();
    };
    /** Reset. */
    UserAgentCore.prototype.reset = function () {
        this.dialogs.forEach(function (dialog) { return dialog.dispose(); });
        this.dialogs.clear();
        this.subscribers.forEach(function (subscriber) { return subscriber.dispose(); });
        this.subscribers.clear();
        this.userAgentClients.forEach(function (uac) { return uac.dispose(); });
        this.userAgentClients.clear();
        this.userAgentServers.forEach(function (uac) { return uac.dispose(); });
        this.userAgentServers.clear();
    };
    Object.defineProperty(UserAgentCore.prototype, "loggerFactory", {
        /** Logger factory. */
        get: function () {
            return this.configuration.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentCore.prototype, "transport", {
        /** Transport. */
        get: function () {
            var transport = this.configuration.transportAccessor();
            if (!transport) {
                throw new Error("Transport undefined.");
            }
            return transport;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Send INVITE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.invite = function (request, delegate) {
        return new user_agents_1.InviteUserAgentClient(this, request, delegate);
    };
    /**
     * Send MESSAGE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.message = function (request, delegate) {
        return new user_agents_1.MessageUserAgentClient(this, request, delegate);
    };
    /**
     * Send PUBLISH.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.publish = function (request, delegate) {
        return new user_agents_1.PublishUserAgentClient(this, request, delegate);
    };
    /**
     * Send REGISTER.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.register = function (request, delegate) {
        return new user_agents_1.RegisterUserAgentClient(this, request, delegate);
    };
    /**
     * Send SUBSCRIBE.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.subscribe = function (request, delegate) {
        return new user_agents_1.SubscribeUserAgentClient(this, request, delegate);
    };
    /**
     * Send a request.
     * @param request - Outgoing request.
     * @param delegate - Request delegate.
     */
    UserAgentCore.prototype.request = function (request, delegate) {
        return new user_agents_1.UserAgentClient(transactions_1.NonInviteClientTransaction, this, request, delegate);
    };
    /**
     * Outgoing request message factory function.
     * @param method - Method.
     * @param requestURI - Request-URI.
     * @param fromURI - From URI.
     * @param toURI - To URI.
     * @param options - Request options.
     * @param extraHeaders - Extra headers to add.
     * @param body - Message body.
     */
    UserAgentCore.prototype.makeOutgoingRequestMessage = function (method, requestURI, fromURI, toURI, options, extraHeaders, body) {
        // default values from user agent configuration
        var callIdPrefix = this.configuration.sipjsId;
        var fromDisplayName = this.configuration.displayName;
        var forceRport = this.configuration.viaForceRport;
        var hackViaTcp = this.configuration.hackViaTcp;
        var optionTags = this.configuration.supportedOptionTags.slice();
        if (method === messages_1.C.REGISTER) {
            optionTags.push("path", "gruu");
        }
        if (method === messages_1.C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {
            optionTags.push("gruu");
        }
        var routeSet = this.configuration.routeSet;
        var userAgentString = this.configuration.userAgentHeaderFieldValue;
        var viaHost = this.configuration.viaHost;
        var defaultOptions = {
            callIdPrefix: callIdPrefix,
            forceRport: forceRport,
            fromDisplayName: fromDisplayName,
            hackViaTcp: hackViaTcp,
            optionTags: optionTags,
            routeSet: routeSet,
            userAgentString: userAgentString,
            viaHost: viaHost,
        };
        // merge provided options with default options
        var requestOptions = tslib_1.__assign(tslib_1.__assign({}, defaultOptions), options);
        return new messages_1.OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);
    };
    /**
     * Handle an incoming request message from the transport.
     * @param message - Incoming request message from transport layer.
     */
    UserAgentCore.prototype.receiveIncomingRequestFromTransport = function (message) {
        this.receiveRequestFromTransport(message);
    };
    /**
     * Handle an incoming response message from the transport.
     * @param message - Incoming response message from transport layer.
     */
    UserAgentCore.prototype.receiveIncomingResponseFromTransport = function (message) {
        this.receiveResponseFromTransport(message);
    };
    /**
     * A stateless UAS is a UAS that does not maintain transaction state.
     * It replies to requests normally, but discards any state that would
     * ordinarily be retained by a UAS after a response has been sent.  If a
     * stateless UAS receives a retransmission of a request, it regenerates
     * the response and re-sends it, just as if it were replying to the first
     * instance of the request. A UAS cannot be stateless unless the request
     * processing for that method would always result in the same response
     * if the requests are identical. This rules out stateless registrars,
     * for example.  Stateless UASs do not use a transaction layer; they
     * receive requests directly from the transport layer and send responses
     * directly to the transport layer.
     * https://tools.ietf.org/html/rfc3261#section-8.2.7
     * @param message - Incoming request message to reply to.
     * @param statusCode - Status code to reply with.
     */
    UserAgentCore.prototype.replyStateless = function (message, options) {
        var _this = this;
        var userAgent = this.configuration.userAgentHeaderFieldValue;
        var supported = this.configuration.supportedOptionTagsResponse;
        options = tslib_1.__assign(tslib_1.__assign({}, options), { userAgent: userAgent, supported: supported });
        var response = messages_1.constructOutgoingResponse(message, options);
        this.transport.send(response.message).catch(function (error) {
            // If the transport rejects, it SHOULD reject with a TransportError.
            // But the transport may be external code, so we are careful...
            if (error instanceof Error) {
                _this.logger.error(error.message);
            }
            _this.logger.error("Transport error occurred sending stateless reply to " + message.method + " request.");
            // TODO: Currently there is no hook to provide notification that a transport error occurred
            // and throwing would result in an uncaught error (in promise), so we silently eat the error.
            // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.
        });
        return response;
    };
    /**
     * In Section 18.2.1, replace the last paragraph with:
     *
     * Next, the server transport attempts to match the request to a
     * server transaction.  It does so using the matching rules described
     * in Section 17.2.3.  If a matching server transaction is found, the
     * request is passed to that transaction for processing.  If no match
     * is found, the request is passed to the core, which may decide to
     * construct a new server transaction for that request.
     * https://tools.ietf.org/html/rfc6026#section-8.10
     * @param message - Incoming request message from transport layer.
     */
    UserAgentCore.prototype.receiveRequestFromTransport = function (message) {
        // When a request is received from the network by the server, it has to
        // be matched to an existing transaction.  This is accomplished in the
        // following manner.
        //
        // The branch parameter in the topmost Via header field of the request
        // is examined.  If it is present and begins with the magic cookie
        // "z9hG4bK", the request was generated by a client transaction
        // compliant to this specification.  Therefore, the branch parameter
        // will be unique across all transactions sent by that client.  The
        // request matches a transaction if:
        //
        //    1. the branch parameter in the request is equal to the one in the
        //       top Via header field of the request that created the
        //       transaction, and
        //
        //    2. the sent-by value in the top Via of the request is equal to the
        //       one in the request that created the transaction, and
        //
        //    3. the method of the request matches the one that created the
        //       transaction, except for ACK, where the method of the request
        //       that created the transaction is INVITE.
        //
        // This matching rule applies to both INVITE and non-INVITE transactions
        // alike.
        //
        //    The sent-by value is used as part of the matching process because
        //    there could be accidental or malicious duplication of branch
        //    parameters from different clients.
        // https://tools.ietf.org/html/rfc3261#section-17.2.3
        var transactionId = message.viaBranch; // FIXME: Currently only using rule 1...
        var uas = this.userAgentServers.get(transactionId);
        // When receiving an ACK that matches an existing INVITE server
        // transaction and that does not contain a branch parameter containing
        // the magic cookie defined in RFC 3261, the matching transaction MUST
        // be checked to see if it is in the "Accepted" state.  If it is, then
        // the ACK must be passed directly to the transaction user instead of
        // being absorbed by the transaction state machine.  This is necessary
        // as requests from RFC 2543 clients will not include a unique branch
        // parameter, and the mechanisms for calculating the transaction ID from
        // such a request will be the same for both INVITE and ACKs.
        // https://tools.ietf.org/html/rfc6026#section-6
        // Any ACKs received from the network while in the "Accepted" state MUST be
        // passed directly to the TU and not absorbed.
        // https://tools.ietf.org/html/rfc6026#section-7.1
        if (message.method === messages_1.C.ACK) {
            if (uas && uas.transaction.state === transactions_1.TransactionState.Accepted) {
                if (uas instanceof user_agents_1.InviteUserAgentServer) {
                    // These are ACKs matching an INVITE server transaction.
                    // These should never happen with RFC 3261 compliant user agents
                    // (would be a broken ACK to negative final response or something)
                    // but is apparently how RFC 2543 user agents do things.
                    // We are not currently supporting this case.
                    // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).
                    this.logger.warn("Discarding out of dialog ACK after 2xx response sent on transaction " + transactionId + ".");
                    return;
                }
            }
        }
        // The CANCEL method requests that the TU at the server side cancel a
        // pending transaction.  The TU determines the transaction to be
        // cancelled by taking the CANCEL request, and then assuming that the
        // request method is anything but CANCEL or ACK and applying the
        // transaction matching procedures of Section 17.2.3.  The matching
        // transaction is the one to be cancelled.
        // https://tools.ietf.org/html/rfc3261#section-9.2
        if (message.method === messages_1.C.CANCEL) {
            if (uas) {
                // Regardless of the method of the original request, as long as the
                // CANCEL matched an existing transaction, the UAS answers the CANCEL
                // request itself with a 200 (OK) response.
                // https://tools.ietf.org/html/rfc3261#section-9.2
                this.replyStateless(message, { statusCode: 200 });
                // If the transaction for the original request still exists, the behavior
                // of the UAS on receiving a CANCEL request depends on whether it has already
                // sent a final response for the original request. If it has, the CANCEL
                // request has no effect on the processing of the original request, no
                // effect on any session state, and no effect on the responses generated
                // for the original request. If the UAS has not issued a final response
                // for the original request, its behavior depends on the method of the
                // original request. If the original request was an INVITE, the UAS
                // SHOULD immediately respond to the INVITE with a 487 (Request
                // Terminated).
                // https://tools.ietf.org/html/rfc3261#section-9.2
                if (uas.transaction instanceof transactions_1.InviteServerTransaction &&
                    uas.transaction.state === transactions_1.TransactionState.Proceeding) {
                    if (uas instanceof user_agents_1.InviteUserAgentServer) {
                        uas.receiveCancel(message);
                    }
                    // A CANCEL request has no impact on the processing of
                    // transactions with any other method defined in this specification.
                    // https://tools.ietf.org/html/rfc3261#section-9.2
                }
            }
            else {
                // If the UAS did not find a matching transaction for the CANCEL
                // according to the procedure above, it SHOULD respond to the CANCEL
                // with a 481 (Call Leg/Transaction Does Not Exist).
                // https://tools.ietf.org/html/rfc3261#section-9.2
                this.replyStateless(message, { statusCode: 481 });
            }
            return;
        }
        // If a matching server transaction is found, the request is passed to that
        // transaction for processing.
        // https://tools.ietf.org/html/rfc6026#section-8.10
        if (uas) {
            uas.transaction.receiveRequest(message);
            return;
        }
        // If no match is found, the request is passed to the core, which may decide to
        // construct a new server transaction for that request.
        // https://tools.ietf.org/html/rfc6026#section-8.10
        this.receiveRequest(message);
        return;
    };
    /**
     * UAC and UAS procedures depend strongly on two factors.  First, based
     * on whether the request or response is inside or outside of a dialog,
     * and second, based on the method of a request.  Dialogs are discussed
     * thoroughly in Section 12; they represent a peer-to-peer relationship
     * between user agents and are established by specific SIP methods, such
     * as INVITE.
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveRequest = function (message) {
        // 8.2 UAS Behavior
        // UASs SHOULD process the requests in the order of the steps that
        // follow in this section (that is, starting with authentication, then
        // inspecting the method, the header fields, and so on throughout the
        // remainder of this section).
        // https://tools.ietf.org/html/rfc3261#section-8.2
        // 8.2.1 Method Inspection
        // Once a request is authenticated (or authentication is skipped), the
        // UAS MUST inspect the method of the request.  If the UAS recognizes
        // but does not support the method of a request, it MUST generate a 405
        // (Method Not Allowed) response.  Procedures for generating responses
        // are described in Section 8.2.6.  The UAS MUST also add an Allow
        // header field to the 405 (Method Not Allowed) response.  The Allow
        // header field MUST list the set of methods supported by the UAS
        // generating the message.
        // https://tools.ietf.org/html/rfc3261#section-8.2.1
        if (allowed_methods_1.AllowedMethods.indexOf(message.method) === -1) {
            var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
            this.replyStateless(message, {
                statusCode: 405,
                extraHeaders: [allowHeader]
            });
            return;
        }
        // 8.2.2 Header Inspection
        // https://tools.ietf.org/html/rfc3261#section-8.2.2
        if (!message.ruri) { // FIXME: A request message should always have an ruri
            throw new Error("Request-URI undefined.");
        }
        // 8.2.2.1 To and Request-URI
        // If the Request-URI uses a scheme not supported by the UAS, it SHOULD
        // reject the request with a 416 (Unsupported URI Scheme) response.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        if (message.ruri.scheme !== "sip") {
            this.replyStateless(message, { statusCode: 416 });
            return;
        }
        // 8.2.2.1 To and Request-URI
        // If the Request-URI does not identify an address that the
        // UAS is willing to accept requests for, it SHOULD reject
        // the request with a 404 (Not Found) response.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        var ruri = message.ruri;
        var ruriMatches = function (uri) {
            return !!uri && uri.user === ruri.user;
        };
        if (!ruriMatches(this.configuration.aor) &&
            !(ruriMatches(this.configuration.contact.uri) ||
                ruriMatches(this.configuration.contact.pubGruu) ||
                ruriMatches(this.configuration.contact.tempGruu))) {
            this.logger.warn("Request-URI does not point to us.");
            if (message.method !== messages_1.C.ACK) {
                this.replyStateless(message, { statusCode: 404 });
            }
            return;
        }
        // 8.2.2.1 To and Request-URI
        // Other potential sources of received Request-URIs include
        // the Contact header fields of requests and responses sent by the UA
        // that establish or refresh dialogs.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1
        if (message.method === messages_1.C.INVITE) {
            if (!message.hasHeader("Contact")) {
                this.replyStateless(message, {
                    statusCode: 400,
                    reasonPhrase: "Missing Contact Header"
                });
                return;
            }
        }
        // 8.2.2.2 Merged Requests
        // If the request has no tag in the To header field, the UAS core MUST
        // check the request against ongoing transactions.  If the From tag,
        // Call-ID, and CSeq exactly match those associated with an ongoing
        // transaction, but the request does not match that transaction (based
        // on the matching rules in Section 17.2.3), the UAS core SHOULD
        // generate a 482 (Loop Detected) response and pass it to the server
        // transaction.
        //
        //    The same request has arrived at the UAS more than once, following
        //    different paths, most likely due to forking.  The UAS processes
        //    the first such request received and responds with a 482 (Loop
        //    Detected) to the rest of them.
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.2
        if (!message.toTag) {
            var transactionId = message.viaBranch;
            if (!this.userAgentServers.has(transactionId)) {
                var mergedRequest = Array.from(this.userAgentServers.values())
                    .some(function (uas) {
                    return uas.transaction.request.fromTag === message.fromTag &&
                        uas.transaction.request.callId === message.callId &&
                        uas.transaction.request.cseq === message.cseq;
                });
                if (mergedRequest) {
                    this.replyStateless(message, { statusCode: 482 });
                    return;
                }
            }
        }
        // 8.2.2.3 Require
        // https://tools.ietf.org/html/rfc3261#section-8.2.2.3
        // TODO
        // 8.2.3 Content Processing
        // https://tools.ietf.org/html/rfc3261#section-8.2.3
        // TODO
        // 8.2.4 Applying Extensions
        // https://tools.ietf.org/html/rfc3261#section-8.2.4
        // TODO
        // 8.2.5 Processing the Request
        // Assuming all of the checks in the previous subsections are passed,
        // the UAS processing becomes method-specific.
        // https://tools.ietf.org/html/rfc3261#section-8.2.5
        // The UAS will receive the request from the transaction layer.  If the
        // request has a tag in the To header field, the UAS core computes the
        // dialog identifier corresponding to the request and compares it with
        // existing dialogs.  If there is a match, this is a mid-dialog request.
        // In that case, the UAS first applies the same processing rules for
        // requests outside of a dialog, discussed in Section 8.2.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        if (message.toTag) {
            this.receiveInsideDialogRequest(message);
        }
        else {
            this.receiveOutsideDialogRequest(message);
        }
        return;
    };
    /**
     * Once a dialog has been established between two UAs, either of them
     * MAY initiate new transactions as needed within the dialog.  The UA
     * sending the request will take the UAC role for the transaction.  The
     * UA receiving the request will take the UAS role.  Note that these may
     * be different roles than the UAs held during the transaction that
     * established the dialog.
     * https://tools.ietf.org/html/rfc3261#section-12.2
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveInsideDialogRequest = function (message) {
        // NOTIFY requests are matched to such SUBSCRIBE requests if they
        // contain the same "Call-ID", a "To" header field "tag" parameter that
        // matches the "From" header field "tag" parameter of the SUBSCRIBE
        // request, and the same "Event" header field.  Rules for comparisons of
        // the "Event" header fields are described in Section 8.2.1.
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (message.method === messages_1.C.NOTIFY) {
            var event_1 = message.parseHeader("Event");
            if (!event_1 || !event_1.event) {
                this.replyStateless(message, { statusCode: 489 });
                return;
            }
            // FIXME: Subscriber id should also matching on event id.
            var subscriberId = message.callId + message.toTag + event_1.event;
            var subscriber = this.subscribers.get(subscriberId);
            if (subscriber) {
                var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                subscriber.onNotify(uas);
                return;
            }
        }
        // Requests sent within a dialog, as any other requests, are atomic.  If
        // a particular request is accepted by the UAS, all the state changes
        // associated with it are performed.  If the request is rejected, none
        // of the state changes are performed.
        //
        //    Note that some requests, such as INVITEs, affect several pieces of
        //    state.
        //
        // The UAS will receive the request from the transaction layer.  If the
        // request has a tag in the To header field, the UAS core computes the
        // dialog identifier corresponding to the request and compares it with
        // existing dialogs.  If there is a match, this is a mid-dialog request.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        var dialogId = message.callId + message.toTag + message.fromTag;
        var dialog = this.dialogs.get(dialogId);
        if (dialog) {
            // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS
            // You got the question right.
            //
            // And you got the right answer too. :-)
            //
            //   Thanks,
            //   Paul
            //
            // Robert Sparks wrote:
            // > So I've lost track of the question during the musing.
            // >
            // > I _think_ the fundamental question being asked is this:
            // >
            // > Is an endpoint required to reject (with a 481) an OPTIONS request that
            // > arrives with at to-tag but does not match any existing dialog state.
            // > (Assuming some earlier requirement hasn't forced another error code). Or
            // > is it OK if it just sends
            // > a 200 OK anyhow.
            // >
            // > My take on the collection of specs is that its _not_ ok for it to send
            // > the 200 OK anyhow and that it is required to send
            // > the 481. I base this primarily on these sentences from 11.2 in 3261:
            // >
            // >    The response to an OPTIONS is constructed using the standard rules
            // >    for a SIP response as discussed in Section 8.2.6.  The response code
            // >    chosen MUST be the same that would have been chosen had the request
            // >    been an INVITE.
            // >
            // > Did I miss the point of the question?
            // >
            // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:
            // >
            // >> [Including Robert in hopes of getting his insight on this.]
            // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html
            //
            // Requests that do not change in any way the state of a dialog may be
            // received within a dialog (for example, an OPTIONS request).  They are
            // processed as if they had been received outside the dialog.
            // https://tools.ietf.org/html/rfc3261#section-12.2.2
            if (message.method === messages_1.C.OPTIONS) {
                var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                this.replyStateless(message, {
                    statusCode: 200,
                    extraHeaders: [allowHeader, acceptHeader]
                });
                return;
            }
            // Pass the incoming request to the dialog for further handling.
            dialog.receiveRequest(message);
            return;
        }
        // The most important behaviors of a stateless UAS are the following:
        // ...
        // o  A stateless UAS MUST ignore ACK requests.
        // ...
        // https://tools.ietf.org/html/rfc3261#section-8.2.7
        if (message.method === messages_1.C.ACK) {
            // If a final response to an INVITE was sent statelessly,
            // the corresponding ACK:
            // - will not match an existing transaction
            // - may have tag in the To header field
            // - not not match any existing dialogs
            // Absorb unmatched ACKs.
            return;
        }
        // If the request has a tag in the To header field, but the dialog
        // identifier does not match any existing dialogs, the UAS may have
        // crashed and restarted, or it may have received a request for a
        // different (possibly failed) UAS (the UASs can construct the To tags
        // so that a UAS can identify that the tag was for a UAS for which it is
        // providing recovery).  Another possibility is that the incoming
        // request has been simply mis-routed.  Based on the To tag, the UAS MAY
        // either accept or reject the request.  Accepting the request for
        // acceptable To tags provides robustness, so that dialogs can persist
        // even through crashes.  UAs wishing to support this capability must
        // take into consideration some issues such as choosing monotonically
        // increasing CSeq sequence numbers even across reboots, reconstructing
        // the route set, and accepting out-of-range RTP timestamps and sequence
        // numbers.
        //
        // If the UAS wishes to reject the request because it does not wish to
        // recreate the dialog, it MUST respond to the request with a 481
        // (Call/Transaction Does Not Exist) status code and pass that to the
        // server transaction.
        // https://tools.ietf.org/html/rfc3261#section-12.2.2
        this.replyStateless(message, { statusCode: 481 });
        return;
    };
    /**
     * Assuming all of the checks in the previous subsections are passed,
     * the UAS processing becomes method-specific.
     *  https://tools.ietf.org/html/rfc3261#section-8.2.5
     * @param message - Incoming request message.
     */
    UserAgentCore.prototype.receiveOutsideDialogRequest = function (message) {
        switch (message.method) {
            case messages_1.C.ACK:
                // Absorb stray out of dialog ACKs
                break;
            case messages_1.C.BYE:
                // If the BYE does not match an existing dialog, the UAS core SHOULD
                // generate a 481 (Call/Transaction Does Not Exist) response and pass
                // that to the server transaction. This rule means that a BYE sent
                // without tags by a UAC will be rejected.
                // https://tools.ietf.org/html/rfc3261#section-15.1.2
                this.replyStateless(message, { statusCode: 481 });
                break;
            case messages_1.C.CANCEL:
                throw new Error("Unexpected out of dialog request method " + message.method + ".");
                break;
            case messages_1.C.INFO:
                // Use of the INFO method does not constitute a separate dialog usage.
                // INFO messages are always part of, and share the fate of, an invite
                // dialog usage [RFC5057].  INFO messages cannot be sent as part of
                // other dialog usages, or outside an existing dialog.
                // https://tools.ietf.org/html/rfc6086#section-1
                this.replyStateless(message, { statusCode: 405 }); // Should never happen
                break;
            case messages_1.C.INVITE:
                // https://tools.ietf.org/html/rfc3261#section-13.3.1
                {
                    var uas = new user_agents_1.InviteUserAgentServer(this, message);
                    this.delegate.onInvite ?
                        this.delegate.onInvite(uas) :
                        uas.reject();
                }
                break;
            case messages_1.C.MESSAGE:
                // MESSAGE requests are discouraged inside a dialog.  Implementations
                // are restricted from creating a usage for the purpose of carrying a
                // sequence of MESSAGE requests (though some implementations use it that
                // way, against the standard recommendation).
                // https://tools.ietf.org/html/rfc5057#section-5.3
                {
                    var uas = new user_agents_1.MessageUserAgentServer(this, message);
                    this.delegate.onMessage ?
                        this.delegate.onMessage(uas) :
                        uas.accept();
                }
                break;
            case messages_1.C.NOTIFY:
                // Obsoleted by: RFC 6665
                // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,
                // it is the responsibility of the parties defining those mechanisms to
                // ensure that correlation of a NOTIFY message to the corresponding
                // subscription is possible.  Designers of such mechanisms are also
                // warned to make a distinction between sending a NOTIFY message to a
                // subscriber who is aware of the subscription, and sending a NOTIFY
                // message to an unsuspecting node.  The latter behavior is invalid, and
                // MUST receive a "481 Subscription does not exist" response (unless
                // some other 400- or 500-class error code is more applicable), as
                // described in section 3.2.4.  In other words, knowledge of a
                // subscription must exist in both the subscriber and the notifier to be
                // valid, even if installed via a non-SUBSCRIBE mechanism.
                // https://tools.ietf.org/html/rfc3265#section-3.2
                //
                // NOTIFY requests are sent to inform subscribers of changes in state to
                // which the subscriber has a subscription.  Subscriptions are created
                // using the SUBSCRIBE method.  In legacy implementations, it is
                // possible that other means of subscription creation have been used.
                // However, this specification does not allow the creation of
                // subscriptions except through SUBSCRIBE requests and (for backwards-
                // compatibility) REFER requests [RFC3515].
                // https://tools.ietf.org/html/rfc6665#section-3.2
                {
                    var uas = new user_agents_1.NotifyUserAgentServer(this, message);
                    this.delegate.onNotify ?
                        this.delegate.onNotify(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.OPTIONS:
                // https://tools.ietf.org/html/rfc3261#section-11.2
                {
                    var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
                    var acceptHeader = "Accept: " + acceptedBodyTypes.toString();
                    this.replyStateless(message, {
                        statusCode: 200,
                        extraHeaders: [allowHeader, acceptHeader]
                    });
                }
                break;
            case messages_1.C.REFER:
                // https://tools.ietf.org/html/rfc3515#section-2.4.2
                {
                    var uas = new user_agents_1.ReferUserAgentServer(this, message);
                    this.delegate.onRefer ?
                        this.delegate.onRefer(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.REGISTER:
                // https://tools.ietf.org/html/rfc3261#section-10.3
                {
                    var uas = new user_agents_1.RegisterUserAgentServer(this, message);
                    this.delegate.onRegister ?
                        this.delegate.onRegister(uas) :
                        uas.reject({ statusCode: 405 });
                }
                break;
            case messages_1.C.SUBSCRIBE:
                // https://tools.ietf.org/html/rfc6665#section-4.2
                {
                    var uas = new user_agents_1.SubscribeUserAgentServer(this, message);
                    this.delegate.onSubscribe ?
                        this.delegate.onSubscribe(uas) :
                        uas.reject({ statusCode: 480 });
                }
                break;
            default:
                throw new Error("Unexpected out of dialog request method " + message.method + ".");
        }
        return;
    };
    /**
     * Responses are first processed by the transport layer and then passed
     * up to the transaction layer.  The transaction layer performs its
     * processing and then passes the response up to the TU.  The majority
     * of response processing in the TU is method specific.  However, there
     * are some general behaviors independent of the method.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3
     * @param message - Incoming response message from transport layer.
     */
    UserAgentCore.prototype.receiveResponseFromTransport = function (message) {
        // 8.1.3.1 Transaction Layer Errors
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
        // Handled by transaction layer callbacks.
        // 8.1.3.2 Unrecognized Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1
        // TODO
        // 8.1.3.3 Vias
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.3
        if (message.getHeaders("via").length > 1) {
            this.logger.warn("More than one Via header field present in the response, dropping");
            return;
        }
        // 8.1.3.4 Processing 3xx Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.4
        // TODO
        // 8.1.3.5 Processing 4xx Responses
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
        // TODO
        // When the transport layer in the client receives a response, it has to
        // determine which client transaction will handle the response, so that
        // the processing of Sections 17.1.1 and 17.1.2 can take place.  The
        // branch parameter in the top Via header field is used for this
        // purpose.  A response matches a client transaction under two
        // conditions:
        //
        //    1.  If the response has the same value of the branch parameter in
        //        the top Via header field as the branch parameter in the top
        //        Via header field of the request that created the transaction.
        //
        //    2.  If the method parameter in the CSeq header field matches the
        //        method of the request that created the transaction.  The
        //        method is needed since a CANCEL request constitutes a
        //        different transaction, but shares the same value of the branch
        //        parameter.
        // https://tools.ietf.org/html/rfc3261#section-17.1.3
        var userAgentClientId = message.viaBranch + message.method;
        var userAgentClient = this.userAgentClients.get(userAgentClientId);
        // The client transport uses the matching procedures of Section
        // 17.1.3 to attempt to match the response to an existing
        // transaction.  If there is a match, the response MUST be passed to
        // that transaction.  Otherwise, any element other than a stateless
        // proxy MUST silently discard the response.
        // https://tools.ietf.org/html/rfc6026#section-8.9
        if (userAgentClient) {
            userAgentClient.transaction.receiveResponse(message);
        }
        else {
            this.logger.warn("Discarding unmatched " + message.statusCode + " response to " + message.method + " " + userAgentClientId + ".");
        }
    };
    return UserAgentCore;
}());
exports.UserAgentCore = UserAgentCore;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * BYE UAC.
 * @public
 */
var ByeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ByeUserAgentClient, _super);
    function ByeUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.BYE, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.dispose();
        return _this;
    }
    return ByeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ByeUserAgentClient = ByeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * BYE UAS.
 * @public
 */
var ByeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ByeUserAgentServer, _super);
    function ByeUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return ByeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ByeUserAgentServer = ByeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * CANCEL UAC.
 * @public
 */
var CancelUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(CancelUserAgentClient, _super);
    function CancelUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return CancelUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.CancelUserAgentClient = CancelUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./bye-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/bye-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./cancel-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/cancel-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./info-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./message-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./notify-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./publish-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./prack-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-invite-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./re-subscribe-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./refer-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./register-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./subscribe-user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js"), exports);


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * INFO UAC.
 * @public
 */
var InfoUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(InfoUserAgentClient, _super);
    function InfoUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.INFO, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return InfoUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.InfoUserAgentClient = InfoUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/info-user-agent-server.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * INFO UAS.
 * @public
 */
var InfoUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(InfoUserAgentServer, _super);
    function InfoUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return InfoUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.InfoUserAgentServer = InfoUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * INVITE UAC.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.2 UAC Processing
 * https://tools.ietf.org/html/rfc3261#section-13.2
 * @public
 */
var InviteUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(InviteUserAgentClient, _super);
    function InviteUserAgentClient(core, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteClientTransaction, core, message, delegate) || this;
        _this.confirmedDialogAcks = new Map();
        _this.confirmedDialogs = new Map();
        _this.earlyDialogs = new Map();
        _this.delegate = delegate;
        return _this;
    }
    InviteUserAgentClient.prototype.dispose = function () {
        // The UAC core considers the INVITE transaction completed 64*T1 seconds
        // after the reception of the first 2xx response.  At this point all the
        // early dialogs that have not transitioned to established dialogs are
        // terminated.  Once the INVITE transaction is considered completed by
        // the UAC core, no more new 2xx responses are expected to arrive.
        //
        // If, after acknowledging any 2xx response to an INVITE, the UAC does
        // not want to continue with that dialog, then the UAC MUST terminate
        // the dialog by sending a BYE request as described in Section 15.
        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
        this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
        this.earlyDialogs.clear();
        _super.prototype.dispose.call(this);
    };
    /**
     * Special case for transport error while sending ACK.
     * @param error - Transport error
     */
    InviteUserAgentClient.prototype.onTransportError = function (error) {
        if (this.transaction.state === transactions_1.TransactionState.Calling) {
            return _super.prototype.onTransportError.call(this, error);
        }
        // If not in 'calling' state, the transport error occurred while sending an ACK.
        this.logger.error(error.message);
        this.logger.error("User agent client request transport error while sending ACK.");
    };
    /**
     * Once the INVITE has been passed to the INVITE client transaction, the
     * UAC waits for responses for the INVITE.
     * https://tools.ietf.org/html/rfc3261#section-13.2.2
     * @param incomingResponse - Incoming response to INVITE request.
     */
    InviteUserAgentClient.prototype.receiveResponse = function (message) {
        var _this = this;
        if (!this.authenticationGuard(message)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                return;
            case /^1[0-9]{2}$/.test(statusCode):
                // Zero, one or multiple provisional responses may arrive before one or
                // more final responses are received.  Provisional responses for an
                // INVITE request can create "early dialogs".  If a provisional response
                // has a tag in the To field, and if the dialog ID of the response does
                // not match an existing dialog, one is constructed using the procedures
                // defined in Section 12.1.2.
                //
                // The early dialog will only be needed if the UAC needs to send a
                // request to its peer within the dialog before the initial INVITE
                // transaction completes.  Header fields present in a provisional
                // response are applicable as long as the dialog is in the early state
                // (for example, an Allow header field in a provisional response
                // contains the methods that can be used in the dialog while this is in
                // the early state).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.1
                {
                    // Provisional without to tag, no dialog to create.
                    if (!message.toTag) {
                        this.logger.warn("Non-100 1xx INVITE response received without a to tag, dropping.");
                        return;
                    }
                    // Compute dialog state.
                    var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                    // Have existing early dialog or create a new one.
                    var earlyDialog = this.earlyDialogs.get(dialogState.id);
                    if (!earlyDialog) {
                        var transaction = this.transaction;
                        if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                            throw new Error("Transaction not instance of InviteClientTransaction.");
                        }
                        earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                        this.earlyDialogs.set(earlyDialog.id, earlyDialog);
                    }
                    // Guard against out of order reliable provisional responses.
                    // Note that this is where the rseq tracking is done.
                    if (!earlyDialog.reliableSequenceGuard(message)) {
                        this.logger.warn("1xx INVITE reliable response received out of order, dropping.");
                        return;
                    }
                    // If the initial offer is in an INVITE, the answer MUST be in a
                    // reliable non-failure message from UAS back to UAC which is
                    // correlated to that INVITE.  For this specification, that is
                    // only the final 2xx response to that INVITE.  That same exact
                    // answer MAY also be placed in any provisional responses sent
                    // prior to the answer.  The UAC MUST treat the first session
                    // description it receives as the answer, and MUST ignore any
                    // session descriptions in subsequent responses to the initial
                    // INVITE.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    if (earlyDialog.signalingState === session_1.SignalingState.Initial ||
                        earlyDialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                        earlyDialog.signalingStateTransition(message);
                    }
                    // Pass response to delegate.
                    var session_2 = earlyDialog;
                    if (this.delegate && this.delegate.onProgress) {
                        this.delegate.onProgress({
                            message: message,
                            session: session_2,
                            prack: function (options) {
                                var outgoingPrackRequest = session_2.prack(undefined, options);
                                return outgoingPrackRequest;
                            }
                        });
                    }
                }
                return;
            case /^2[0-9]{2}$/.test(statusCode):
                // Multiple 2xx responses may arrive at the UAC for a single INVITE
                // request due to a forking proxy.  Each response is distinguished by
                // the tag parameter in the To header field, and each represents a
                // distinct dialog, with a distinct dialog identifier.
                //
                // If the dialog identifier in the 2xx response matches the dialog
                // identifier of an existing dialog, the dialog MUST be transitioned to
                // the "confirmed" state, and the route set for the dialog MUST be
                // recomputed based on the 2xx response using the procedures of Section
                // 12.2.1.2.  Otherwise, a new dialog in the "confirmed" state MUST be
                // constructed using the procedures of Section 12.1.2.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                {
                    // Compute dialog state.
                    var dialogState = dialogs_1.Dialog.initialDialogStateForUserAgentClient(this.message, message);
                    // NOTE: Currently our transaction layer is caching the 2xx ACKs and
                    // handling retransmissions of the ACK which is an approach which is
                    // not to spec. In any event, this block is intended to provide a to
                    // spec implementation of ACK retransmissions, but it should not be
                    // hit currently.
                    var dialog = this.confirmedDialogs.get(dialogState.id);
                    if (dialog) {
                        // Once the ACK has been constructed, the procedures of [4] are used to
                        // determine the destination address, port and transport.  However, the
                        // request is passed to the transport layer directly for transmission,
                        // rather than a client transaction.  This is because the UAC core
                        // handles retransmissions of the ACK, not the transaction layer.  The
                        // ACK MUST be passed to the client transport every time a
                        // retransmission of the 2xx final response that triggered the ACK
                        // arrives.
                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                        var outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);
                        if (outgoingAckRequest) {
                            var transaction = this.transaction;
                            if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                                throw new Error("Client transaction not instance of InviteClientTransaction.");
                            }
                            transaction.ackResponse(outgoingAckRequest.message);
                        }
                        else {
                            // If still waiting for an ACK, drop the retransmission of the 2xx final response.
                        }
                        return;
                    }
                    // If the dialog identifier in the 2xx response matches the dialog
                    // identifier of an existing dialog, the dialog MUST be transitioned to
                    // the "confirmed" state, and the route set for the dialog MUST be
                    // recomputed based on the 2xx response using the procedures of Section
                    // 12.2.1.2. Otherwise, a new dialog in the "confirmed" state MUST be
                    // constructed using the procedures of Section 12.1.2.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                    dialog = this.earlyDialogs.get(dialogState.id);
                    if (dialog) {
                        dialog.confirm();
                        dialog.recomputeRouteSet(message);
                        this.earlyDialogs.delete(dialog.id);
                        this.confirmedDialogs.set(dialog.id, dialog);
                    }
                    else {
                        var transaction = this.transaction;
                        if (!(transaction instanceof transactions_1.InviteClientTransaction)) {
                            throw new Error("Transaction not instance of InviteClientTransaction.");
                        }
                        dialog = new dialogs_1.SessionDialog(transaction, this.core, dialogState);
                        this.confirmedDialogs.set(dialog.id, dialog);
                    }
                    // If the initial offer is in an INVITE, the answer MUST be in a
                    // reliable non-failure message from UAS back to UAC which is
                    // correlated to that INVITE.  For this specification, that is
                    // only the final 2xx response to that INVITE.  That same exact
                    // answer MAY also be placed in any provisional responses sent
                    // prior to the answer.  The UAC MUST treat the first session
                    // description it receives as the answer, and MUST ignore any
                    // session descriptions in subsequent responses to the initial
                    // INVITE.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.1
                    if (dialog.signalingState === session_1.SignalingState.Initial ||
                        dialog.signalingState === session_1.SignalingState.HaveLocalOffer) {
                        dialog.signalingStateTransition(message);
                    }
                    // Session Initiated! :)
                    var session_3 = dialog;
                    // The UAC core MUST generate an ACK request for each 2xx received from
                    // the transaction layer.  The header fields of the ACK are constructed
                    // in the same way as for any request sent within a dialog (see Section
                    // 12) with the exception of the CSeq and the header fields related to
                    // authentication.  The sequence number of the CSeq header field MUST be
                    // the same as the INVITE being acknowledged, but the CSeq method MUST
                    // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If
                    // the 2xx contains an offer (based on the rules above), the ACK MUST
                    // carry an answer in its body.  If the offer in the 2xx response is not
                    // acceptable, the UAC core MUST generate a valid answer in the ACK and
                    // then send a BYE immediately.
                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4
                    if (this.delegate && this.delegate.onAccept) {
                        this.delegate.onAccept({
                            message: message,
                            session: session_3,
                            ack: function (options) {
                                var outgoingAckRequest = session_3.ack(options);
                                _this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                                return outgoingAckRequest;
                            }
                        });
                    }
                    else {
                        var outgoingAckRequest = session_3.ack();
                        this.confirmedDialogAcks.set(session_3.id, outgoingAckRequest);
                    }
                }
                return;
            case /^3[0-9]{2}$/.test(statusCode):
                // 12.3 Termination of a Dialog
                //
                // Independent of the method, if a request outside of a dialog generates
                // a non-2xx final response, any early dialogs created through
                // provisional responses to that request are terminated.  The mechanism
                // for terminating confirmed dialogs is method specific.  In this
                // specification, the BYE method terminates a session and the dialog
                // associated with it.  See Section 15 for details.
                // https://tools.ietf.org/html/rfc3261#section-12.3
                // All early dialogs are considered terminated upon reception of the
                // non-2xx final response.
                //
                // After having received the non-2xx final response the UAC core
                // considers the INVITE transaction completed.  The INVITE client
                // transaction handles the generation of ACKs for the response (see
                // Section 17).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                this.earlyDialogs.clear();
                // A 3xx response may contain one or more Contact header field values
                // providing new addresses where the callee might be reachable.
                // Depending on the status code of the 3xx response (see Section 21.3),
                // the UAC MAY choose to try those new addresses.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.2
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                return;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                // 12.3 Termination of a Dialog
                //
                // Independent of the method, if a request outside of a dialog generates
                // a non-2xx final response, any early dialogs created through
                // provisional responses to that request are terminated.  The mechanism
                // for terminating confirmed dialogs is method specific.  In this
                // specification, the BYE method terminates a session and the dialog
                // associated with it.  See Section 15 for details.
                // https://tools.ietf.org/html/rfc3261#section-12.3
                // All early dialogs are considered terminated upon reception of the
                // non-2xx final response.
                //
                // After having received the non-2xx final response the UAC core
                // considers the INVITE transaction completed.  The INVITE client
                // transaction handles the generation of ACKs for the response (see
                // Section 17).
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                this.earlyDialogs.forEach(function (earlyDialog) { return earlyDialog.dispose(); });
                this.earlyDialogs.clear();
                // A single non-2xx final response may be received for the INVITE.  4xx,
                // 5xx and 6xx responses may contain a Contact header field value
                // indicating the location where additional information about the error
                // can be found.  Subsequent final responses (which would only arrive
                // under error conditions) MUST be ignored.
                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                return;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
        throw new Error("Executing what should be an unreachable code path receiving " + statusCode + " response.");
    };
    return InviteUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.InviteUserAgentClient = InviteUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var dialogs_1 = __webpack_require__(/*! ../dialogs */ "./node_modules/sip.js/lib/core/dialogs/index.js");
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
var session_1 = __webpack_require__(/*! ../session */ "./node_modules/sip.js/lib/core/session/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var allowed_methods_1 = __webpack_require__(/*! ../user-agent-core/allowed-methods */ "./node_modules/sip.js/lib/core/user-agent-core/allowed-methods.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * INVITE UAS.
 * @remarks
 * 13 Initiating a Session
 * https://tools.ietf.org/html/rfc3261#section-13
 * 13.1 Overview
 * https://tools.ietf.org/html/rfc3261#section-13.1
 * 13.3 UAS Processing
 * https://tools.ietf.org/html/rfc3261#section-13.3
 * @public
 */
var InviteUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(InviteUserAgentServer, _super);
    function InviteUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    InviteUserAgentServer.prototype.dispose = function () {
        if (this.earlyDialog) {
            this.earlyDialog.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * 13.3.1.4 The INVITE is Accepted
     * The UAS core generates a 2xx response.  This response establishes a
     * dialog, and therefore follows the procedures of Section 12.1.1 in
     * addition to those of Section 8.2.6.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4
     * @param options - Accept options bucket.
     */
    InviteUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (!this.acceptable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
        }
        // This response establishes a dialog...
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!this.confirmedDialog) {
            if (this.earlyDialog) {
                this.earlyDialog.confirm();
                this.confirmedDialog = this.earlyDialog;
                this.earlyDialog = undefined;
            }
            else {
                var transaction = this.transaction;
                if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                    throw new Error("Transaction not instance of InviteClientTransaction.");
                }
                var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);
                this.confirmedDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
            }
        }
        // When a UAS responds to a request with a response that establishes a
        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
        // header field values from the request into the response (including the
        // URIs, URI parameters, and any Record-Route header field parameters,
        // whether they are known or unknown to the UAS) and MUST maintain the
        // order of those values.  The UAS MUST add a Contact header field to
        // the response.  The Contact header field contains an address where the
        // UAS would like to be contacted for subsequent requests in the dialog
        // (which includes the ACK for a 2xx response in the case of an INVITE).
        // Generally, the host portion of this URI is the IP address or FQDN of
        // the host.  The URI provided in the Contact header field MUST be a SIP
        // or SIPS URI.  If the request that initiated the dialog contained a
        // SIPS URI in the Request-URI or in the top Record-Route header field
        // value, if there was any, or the Contact header field if there was no
        // Record-Route header field, the Contact header field in the response
        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
        // same URI can be used in messages outside this dialog).  The same way,
        // the scope of the URI in the Contact header field of the INVITE is not
        // limited to this dialog either.  It can therefore be used in messages
        // to the UAC even outside this dialog.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var recordRouteHeader = this.message
            .getHeaders("record-route")
            .map(function (header) { return "Record-Route: " + header; });
        var contactHeader = "Contact: " + this.core.configuration.contact.toString();
        // A 2xx response to an INVITE SHOULD contain the Allow header field and
        // the Supported header field, and MAY contain the Accept header field.
        // Including these header fields allows the UAC to determine the
        // features and extensions supported by the UAS for the duration of the
        // call, without probing.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        // FIXME: TODO: This should not be hard coded.
        var allowHeader = "Allow: " + allowed_methods_1.AllowedMethods.toString();
        // FIXME: TODO: Supported header (see reply())
        // FIXME: TODO: Accept header
        // If the INVITE request contained an offer, and the UAS had not yet
        // sent an answer, the 2xx MUST contain an answer.  If the INVITE did
        // not contain an offer, the 2xx MUST contain an offer if the UAS had
        // not yet sent an offer.
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!options.body) {
            if (this.confirmedDialog.signalingState === session_1.SignalingState.Stable) {
                options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response
            }
            else if (this.confirmedDialog.signalingState === session_1.SignalingState.Initial ||
                this.confirmedDialog.signalingState === session_1.SignalingState.HaveRemoteOffer) {
                throw new Error("Response must have a body.");
            }
        }
        options.statusCode = options.statusCode || 200;
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
        options.extraHeaders.push(allowHeader);
        options.extraHeaders.push(contactHeader);
        var response = _super.prototype.accept.call(this, options);
        var session = this.confirmedDialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            // Once the UAS has sent or received an answer to the initial
            // offer, it MUST NOT generate subsequent offers in any responses
            // to the initial INVITE.  This means that a UAS based on this
            // specification alone can never generate subsequent offers until
            // completion of the initial transaction.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            if (this.confirmedDialog.signalingState !== session_1.SignalingState.Stable) {
                this.confirmedDialog.signalingStateTransition(options.body);
            }
        }
        return result;
    };
    /**
     * 13.3.1.1 Progress
     * If the UAS is not able to answer the invitation immediately, it can
     * choose to indicate some kind of progress to the UAC (for example, an
     * indication that a phone is ringing).  This is accomplished with a
     * provisional response between 101 and 199.  These provisional
     * responses establish early dialogs and therefore follow the procedures
     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY
     * send as many provisional responses as it likes.  Each of these MUST
     * indicate the same dialog ID.  However, these will not be delivered
     * reliably.
     *
     * If the UAS desires an extended period of time to answer the INVITE,
     * it will need to ask for an "extension" in order to prevent proxies
     * from canceling the transaction.  A proxy has the option of canceling
     * a transaction when there is a gap of 3 minutes between responses in a
     * transaction.  To prevent cancellation, the UAS MUST send a non-100
     * provisional response at every minute, to handle the possibility of
     * lost provisional responses.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1
     * @param options - Progress options bucket.
     */
    InviteUserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        if (!this.progressable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
        }
        // This response establishes a dialog...
        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4
        if (!this.earlyDialog) {
            var transaction = this.transaction;
            if (!(transaction instanceof transactions_1.InviteServerTransaction)) {
                throw new Error("Transaction not instance of InviteClientTransaction.");
            }
            var state = dialogs_1.Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);
            this.earlyDialog = new dialogs_1.SessionDialog(transaction, this.core, state);
        }
        // When a UAS responds to a request with a response that establishes a
        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route
        // header field values from the request into the response (including the
        // URIs, URI parameters, and any Record-Route header field parameters,
        // whether they are known or unknown to the UAS) and MUST maintain the
        // order of those values.  The UAS MUST add a Contact header field to
        // the response.  The Contact header field contains an address where the
        // UAS would like to be contacted for subsequent requests in the dialog
        // (which includes the ACK for a 2xx response in the case of an INVITE).
        // Generally, the host portion of this URI is the IP address or FQDN of
        // the host.  The URI provided in the Contact header field MUST be a SIP
        // or SIPS URI.  If the request that initiated the dialog contained a
        // SIPS URI in the Request-URI or in the top Record-Route header field
        // value, if there was any, or the Contact header field if there was no
        // Record-Route header field, the Contact header field in the response
        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the
        // same URI can be used in messages outside this dialog).  The same way,
        // the scope of the URI in the Contact header field of the INVITE is not
        // limited to this dialog either.  It can therefore be used in messages
        // to the UAC even outside this dialog.
        // https://tools.ietf.org/html/rfc3261#section-12.1.1
        var recordRouteHeader = this.message
            .getHeaders("record-route")
            .map(function (header) { return "Record-Route: " + header; });
        var contactHeader = "Contact: " + this.core.configuration.contact;
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);
        options.extraHeaders.push(contactHeader);
        var response = _super.prototype.progress.call(this, options);
        var session = this.earlyDialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            // Once the UAS has sent or received an answer to the initial
            // offer, it MUST NOT generate subsequent offers in any responses
            // to the initial INVITE.  This means that a UAS based on this
            // specification alone can never generate subsequent offers until
            // completion of the initial transaction.
            // https://tools.ietf.org/html/rfc3261#section-13.2.1
            if (this.earlyDialog.signalingState !== session_1.SignalingState.Stable) {
                this.earlyDialog.signalingStateTransition(options.body);
            }
        }
        return result;
    };
    /**
     * 13.3.1.2 The INVITE is Redirected
     * If the UAS decides to redirect the call, a 3xx response is sent.  A
     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved
     * Temporarily) response SHOULD contain a Contact header field
     * containing one or more URIs of new addresses to be tried.  The
     * response is passed to the INVITE server transaction, which will deal
     * with its retransmissions.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */
    InviteUserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        return _super.prototype.redirect.call(this, contacts, options);
    };
    /**
     * 13.3.1.3 The INVITE is Rejected
     * A common scenario occurs when the callee is currently not willing or
     * able to take additional calls at this end system.  A 486 (Busy Here)
     * SHOULD be returned in such a scenario.
     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3
     * @param options - Reject options bucket.
     */
    InviteUserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 486 }; }
        return _super.prototype.reject.call(this, options);
    };
    return InviteUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.InviteUserAgentServer = InviteUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-client.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * MESSAGE UAC.
 * @public
 */
var MessageUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(MessageUserAgentClient, _super);
    function MessageUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return MessageUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.MessageUserAgentClient = MessageUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/message-user-agent-server.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * MESSAGE UAS.
 * @public
 */
var MessageUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(MessageUserAgentServer, _super);
    function MessageUserAgentServer(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
    }
    return MessageUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.MessageUserAgentServer = MessageUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-client.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * NOTIFY UAS.
 * @public
 */
var NotifyUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(NotifyUserAgentClient, _super);
    function NotifyUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.NOTIFY, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return NotifyUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.NotifyUserAgentClient = NotifyUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/notify-user-agent-server.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * NOTIFY UAS.
 * @public
 */
var NotifyUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(NotifyUserAgentServer, _super);
    /**
     * NOTIFY UAS constructor.
     * @param dialogOrCore - Dialog for in dialog NOTIFY, UserAgentCore for out of dialog NOTIFY (deprecated).
     * @param message - Incoming NOTIFY request message.
     */
    function NotifyUserAgentServer(dialogOrCore, message, delegate) {
        var _this = this;
        var userAgentCore = instanceOfDialog(dialogOrCore) ?
            dialogOrCore.userAgentCore :
            dialogOrCore;
        _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
        return _this;
    }
    return NotifyUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.NotifyUserAgentServer = NotifyUserAgentServer;
function instanceOfDialog(object) {
    return object.userAgentCore !== undefined;
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-client.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * PRACK UAC.
 * @public
 */
var PrackUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(PrackUserAgentClient, _super);
    function PrackUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.PRACK, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.signalingStateTransition(message);
        return _this;
    }
    return PrackUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.PrackUserAgentClient = PrackUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/prack-user-agent-server.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * PRACK UAS.
 * @public
 */
var PrackUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(PrackUserAgentServer, _super);
    function PrackUserAgentServer(dialog, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        // Update dialog signaling state with offer/answer in body
        dialog.signalingStateTransition(message);
        _this.dialog = dialog;
        return _this;
    }
    /**
     * Update the dialog signaling state on a 2xx response.
     * @param options - Options bucket.
     */
    PrackUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (options.body) {
            // Update dialog signaling state with offer/answer in body
            this.dialog.signalingStateTransition(options.body);
        }
        return _super.prototype.accept.call(this, options);
    };
    return PrackUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.PrackUserAgentServer = PrackUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/publish-user-agent-client.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * PUBLISH UAC.
 * @public
 */
var PublishUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(PublishUserAgentClient, _super);
    function PublishUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return PublishUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.PublishUserAgentClient = PublishUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-client.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * Re-INVITE UAC.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.1 UAC Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.1
 * @public
 */
var ReInviteUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReInviteUserAgentClient, _super);
    function ReInviteUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.INVITE, options);
        _this = _super.call(this, transactions_1.InviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        _this.delegate = delegate;
        dialog.signalingStateTransition(message);
        // FIXME: TODO: next line obviously needs to be improved...
        dialog.reinviteUserAgentClient = _this; // let the dialog know re-invite request sent
        _this.dialog = dialog;
        return _this;
    }
    ReInviteUserAgentClient.prototype.receiveResponse = function (message) {
        var _this = this;
        if (!this.authenticationGuard(message, this.dialog)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                break;
            case /^1[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onProgress) {
                    this.delegate.onProgress({
                        message: message,
                        session: this.dialog,
                        prack: function (options) {
                            throw new Error("Unimplemented.");
                        }
                    });
                }
                break;
            case /^2[0-9]{2}$/.test(statusCode):
                // Update dialog signaling state with offer/answer in body
                this.dialog.signalingStateTransition(message);
                if (this.delegate && this.delegate.onAccept) {
                    this.delegate.onAccept({
                        message: message,
                        session: this.dialog,
                        ack: function (options) {
                            var outgoingAckRequest = _this.dialog.ack(options);
                            return outgoingAckRequest;
                        }
                    });
                }
                break;
            case /^3[0-9]{2}$/.test(statusCode):
                this.dialog.signalingStateRollback();
                this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                break;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                this.dialog.signalingStateRollback();
                this.dialog.reinviteUserAgentClient = undefined; // ACK was handled by transaction
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                else {
                    // If a UA receives a non-2xx final response to a re-INVITE, the session
                    // parameters MUST remain unchanged, as if no re-INVITE had been issued.
                    // Note that, as stated in Section 12.2.1.2, if the non-2xx final
                    // response is a 481 (Call/Transaction Does Not Exist), or a 408
                    // (Request Timeout), or no response at all is received for the re-
                    // INVITE (that is, a timeout is returned by the INVITE client
                    // transaction), the UAC will terminate the dialog.
                    //
                    // If a UAC receives a 491 response to a re-INVITE, it SHOULD start a
                    // timer with a value T chosen as follows:
                    //
                    //    1. If the UAC is the owner of the Call-ID of the dialog ID
                    //       (meaning it generated the value), T has a randomly chosen value
                    //       between 2.1 and 4 seconds in units of 10 ms.
                    //
                    //    2. If the UAC is not the owner of the Call-ID of the dialog ID, T
                    //       has a randomly chosen value of between 0 and 2 seconds in units
                    //       of 10 ms.
                    //
                    // When the timer fires, the UAC SHOULD attempt the re-INVITE once more,
                    // if it still desires for that session modification to take place.  For
                    // example, if the call was already hung up with a BYE, the re-INVITE
                    // would not take place.
                    // https://tools.ietf.org/html/rfc3261#section-14.1
                    // FIXME: TODO: The above.
                }
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
    };
    return ReInviteUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReInviteUserAgentClient = ReInviteUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-invite-user-agent-server.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * Re-INVITE UAS.
 * @remarks
 * 14 Modifying an Existing Session
 * https://tools.ietf.org/html/rfc3261#section-14
 * 14.2 UAS Behavior
 * https://tools.ietf.org/html/rfc3261#section-14.2
 * @public
 */
var ReInviteUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReInviteUserAgentServer, _super);
    function ReInviteUserAgentServer(dialog, message, delegate) {
        var _this = _super.call(this, transactions_1.InviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
        dialog.reinviteUserAgentServer = _this;
        _this.dialog = dialog;
        return _this;
    }
    /**
     * Update the dialog signaling state on a 2xx response.
     * @param options - Options bucket.
     */
    ReInviteUserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        // FIXME: The next two lines SHOULD go away, but I suppose it's technically harmless...
        // These are here because some versions of SIP.js prior to 0.13.8 set the route set
        // of all in dialog ACKs based on the Record-Route headers in the associated 2xx
        // response. While this worked for dialog forming 2xx responses, it was technically
        // broken for re-INVITE ACKS as it only worked if the UAS populated the Record-Route
        // headers in the re-INVITE 2xx response (which is not required and a waste of bandwidth
        // as the should be ignored if present in re-INVITE ACKS) and the UAS populated
        // the Record-Route headers with the correct values (would be weird not too, but...).
        // Anyway, for now the technically useless Record-Route headers are being added
        // to maintain "backwards compatibility" with the older broken versions of SIP.js.
        options.extraHeaders = options.extraHeaders || [];
        options.extraHeaders = options.extraHeaders.concat(this.dialog.routeSet.map(function (route) { return "Record-Route: " + route; }));
        // Send and return the response
        var response = _super.prototype.accept.call(this, options);
        var session = this.dialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        if (options.body) {
            // Update dialog signaling state with offer/answer in body
            this.dialog.signalingStateTransition(options.body);
        }
        // Update dialog
        this.dialog.reConfirm();
        return result;
    };
    /**
     * Update the dialog signaling state on a 1xx response.
     * @param options - Progress options bucket.
     */
    ReInviteUserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        // Send and return the response
        var response = _super.prototype.progress.call(this, options);
        var session = this.dialog;
        var result = tslib_1.__assign(tslib_1.__assign({}, response), { session: session });
        // Update dialog signaling state
        if (options.body) {
            this.dialog.signalingStateTransition(options.body);
        }
        return result;
    };
    /**
     * TODO: Not Yet Supported
     * @param contacts - Contacts to redirect to.
     * @param options - Redirect options bucket.
     */
    ReInviteUserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
        throw new Error("Unimplemented.");
    };
    /**
     * 3.1 Background on Re-INVITE Handling by UASs
     * An error response to a re-INVITE has the following semantics.  As
     * specified in Section 12.2.2 of RFC 3261 [RFC3261], if a re-INVITE is
     * rejected, no state changes are performed.
     * https://tools.ietf.org/html/rfc6141#section-3.1
     * @param options - Reject options bucket.
     */
    ReInviteUserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 488 }; }
        this.dialog.signalingStateRollback();
        this.dialog.reinviteUserAgentServer = undefined; // ACK will be handled by transaction
        return _super.prototype.reject.call(this, options);
    };
    return ReInviteUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReInviteUserAgentServer = ReInviteUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-client.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * Re-SUBSCRIBE UAC.
 * @public
 */
var ReSubscribeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReSubscribeUserAgentClient, _super);
    function ReSubscribeUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.SUBSCRIBE, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        _this.dialog = dialog;
        return _this;
    }
    ReSubscribeUserAgentClient.prototype.waitNotifyStop = function () {
        // TODO: Placeholder. Not utilized currently.
        return;
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    ReSubscribeUserAgentClient.prototype.receiveResponse = function (message) {
        if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
            //  The "Expires" header field in a 200-class response to SUBSCRIBE
            //  request indicates the actual duration for which the subscription will
            //  remain active (unless refreshed).  The received value might be
            //  smaller than the value indicated in the SUBSCRIBE request but cannot
            //  be larger; see Section 4.2.1 for details.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
            var expires = message.getHeader("Expires");
            if (!expires) {
                this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
            }
            else {
                var subscriptionExpiresReceived = Number(expires);
                if (this.dialog.subscriptionExpires > subscriptionExpiresReceived) {
                    this.dialog.subscriptionExpires = subscriptionExpiresReceived;
                }
            }
        }
        if (message.statusCode && message.statusCode >= 400 && message.statusCode < 700) {
            // If a SUBSCRIBE request to refresh a subscription receives a 404, 405,
            // 410, 416, 480-485, 489, 501, or 604 response, the subscriber MUST
            // consider the subscription terminated.  (See [RFC5057] for further
            // details and notes about the effect of error codes on dialogs and
            // usages within dialog, such as subscriptions).  If the subscriber
            // wishes to re-subscribe to the state, he does so by composing an
            // unrelated initial SUBSCRIBE request with a freshly generated Call-ID
            // and a new, unique "From" tag (see Section 4.1.2.1).
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
            var errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];
            if (errorCodes.indexOf(message.statusCode) !== -1) {
                this.dialog.terminate();
            }
            // If a SUBSCRIBE request to refresh a subscription fails with any error
            // code other than those listed above, the original subscription is
            // still considered valid for the duration of the most recently known
            // "Expires" value as negotiated by the most recent successful SUBSCRIBE
            // transaction, or as communicated by a NOTIFY request in its
            // "Subscription-State" header field "expires" parameter.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.2
        }
        _super.prototype.receiveResponse.call(this, message);
    };
    return ReSubscribeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReSubscribeUserAgentClient = ReSubscribeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/re-subscribe-user-agent-server.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * Re-SUBSCRIBE UAS.
 * @public
 */
var ReSubscribeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReSubscribeUserAgentServer, _super);
    function ReSubscribeUserAgentServer(dialog, message, delegate) {
        return _super.call(this, transactions_1.NonInviteServerTransaction, dialog.userAgentCore, message, delegate) || this;
    }
    return ReSubscribeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReSubscribeUserAgentServer = ReSubscribeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-client.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * REFER UAC.
 * @public
 */
var ReferUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(ReferUserAgentClient, _super);
    function ReferUserAgentClient(dialog, delegate, options) {
        var _this = this;
        var message = dialog.createOutgoingRequestMessage(messages_1.C.REFER, options);
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, dialog.userAgentCore, message, delegate) || this;
        return _this;
    }
    return ReferUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.ReferUserAgentClient = ReferUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/refer-user-agent-server.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * REFER UAS.
 * @public
 */
var ReferUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(ReferUserAgentServer, _super);
    /**
     * REFER UAS constructor.
     * @param dialogOrCore - Dialog for in dialog REFER, UserAgentCore for out of dialog REFER.
     * @param message - Incoming REFER request message.
     */
    function ReferUserAgentServer(dialogOrCore, message, delegate) {
        var _this = this;
        var userAgentCore = instanceOfSessionDialog(dialogOrCore) ?
            dialogOrCore.userAgentCore :
            dialogOrCore;
        _this = _super.call(this, transactions_1.NonInviteServerTransaction, userAgentCore, message, delegate) || this;
        return _this;
    }
    return ReferUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.ReferUserAgentServer = ReferUserAgentServer;
function instanceOfSessionDialog(object) {
    return object.userAgentCore !== undefined;
}


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-client.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * REGISTER UAC.
 * @public
 */
var RegisterUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterUserAgentClient, _super);
    function RegisterUserAgentClient(core, message, delegate) {
        return _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
    }
    return RegisterUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.RegisterUserAgentClient = RegisterUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/register-user-agent-server.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * REGISTER UAS.
 * @public
 */
var RegisterUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(RegisterUserAgentServer, _super);
    function RegisterUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    return RegisterUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.RegisterUserAgentServer = RegisterUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var subscription_dialog_1 = __webpack_require__(/*! ../dialogs/subscription-dialog */ "./node_modules/sip.js/lib/core/dialogs/subscription-dialog.js");
var subscription_1 = __webpack_require__(/*! ../subscription */ "./node_modules/sip.js/lib/core/subscription/index.js");
var timers_1 = __webpack_require__(/*! ../timers */ "./node_modules/sip.js/lib/core/timers.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_client_1 = __webpack_require__(/*! ./user-agent-client */ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js");
/**
 * SUBSCRIBE UAC.
 * @remarks
 * 4.1.  Subscriber Behavior
 * https://tools.ietf.org/html/rfc6665#section-4.1
 *
 * User agent client for installation of a single subscription per SUBSCRIBE request.
 * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.
 * @public
 */
var SubscribeUserAgentClient = /** @class */ (function (_super) {
    tslib_1.__extends(SubscribeUserAgentClient, _super);
    function SubscribeUserAgentClient(core, message, delegate) {
        var _this = this;
        // Get event from request message.
        var event = message.getHeader("Event");
        if (!event) {
            throw new Error("Event undefined");
        }
        // Get expires from request message.
        var expires = message.getHeader("Expires");
        if (!expires) {
            throw new Error("Expires undefined");
        }
        _this = _super.call(this, transactions_1.NonInviteClientTransaction, core, message, delegate) || this;
        _this.delegate = delegate;
        // FIXME: Subscriber id should also be matching on event id.
        _this.subscriberId = message.callId + message.fromTag + event;
        _this.subscriptionExpiresRequested = _this.subscriptionExpires = Number(expires);
        _this.subscriptionEvent = event;
        _this.subscriptionState = subscription_1.SubscriptionState.NotifyWait;
        // Start waiting for a NOTIFY we can use to create a subscription.
        _this.waitNotifyStart();
        return _this;
    }
    /**
     * Destructor.
     * Note that Timer N may live on waiting for an initial NOTIFY and
     * the delegate may still receive that NOTIFY. If you don't want
     * that behavior then either clear the delegate so the delegate
     * doesn't get called (a 200 will be sent in response to the NOTIFY)
     * or call `waitNotifyStop` which will clear Timer N and remove this
     * UAC from the core (a 481 will be sent in response to the NOTIFY).
     */
    SubscribeUserAgentClient.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle out of dialog NOTIFY associated with SUBSCRIBE request.
     * This is the first NOTIFY received after the SUBSCRIBE request.
     * @param uas - User agent server handling the subscription creating NOTIFY.
     */
    SubscribeUserAgentClient.prototype.onNotify = function (uas) {
        // NOTIFY requests are matched to such SUBSCRIBE requests if they
        // contain the same "Call-ID", a "To" header field "tag" parameter that
        // matches the "From" header field "tag" parameter of the SUBSCRIBE
        // request, and the same "Event" header field.  Rules for comparisons of
        // the "Event" header fields are described in Section 8.2.1.
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        var event = uas.message.parseHeader("Event").event;
        if (!event || event !== this.subscriptionEvent) {
            this.logger.warn("Failed to parse event.");
            uas.reject({ statusCode: 489 });
            return;
        }
        // NOTIFY requests MUST contain "Subscription-State" header fields that
        // indicate the status of the subscription.
        // https://tools.ietf.org/html/rfc6665#section-4.1.3
        var subscriptionState = uas.message.parseHeader("Subscription-State");
        if (!subscriptionState || !subscriptionState.state) {
            this.logger.warn("Failed to parse subscription state.");
            uas.reject({ statusCode: 489 });
            return;
        }
        // Validate subscription state.
        var state = subscriptionState.state;
        switch (state) {
            case "pending":
                break;
            case "active":
                break;
            case "terminated":
                break;
            default:
                this.logger.warn("Invalid subscription state " + state);
                uas.reject({ statusCode: 489 });
                return;
        }
        // Dialogs usages are created upon completion of a NOTIFY transaction
        // for a new subscription, unless the NOTIFY request contains a
        // "Subscription-State" of "terminated."
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (state !== "terminated") {
            // The Contact header field MUST be present and contain exactly one SIP
            // or SIPS URI in any request that can result in the establishment of a
            // dialog.
            // https://tools.ietf.org/html/rfc3261#section-8.1.1.8
            var contact = uas.message.parseHeader("contact");
            if (!contact) {
                this.logger.warn("Failed to parse contact.");
                uas.reject({ statusCode: 489 });
                return;
            }
        }
        // In accordance with the rules for proxying non-INVITE requests as
        // defined in [RFC3261], successful SUBSCRIBE requests will receive only
        // one 200-class response; however, due to forking, the subscription may
        // have been accepted by multiple nodes.  The subscriber MUST therefore
        // be prepared to receive NOTIFY requests with "From:" tags that differ
        // from the "To:" tag received in the SUBSCRIBE 200-class response.
        //
        // If multiple NOTIFY requests are received in different dialogs in
        // response to a single SUBSCRIBE request, each dialog represents a
        // different destination to which the SUBSCRIBE request was forked.
        // Subscriber handling in such situations varies by event package; see
        // Section 5.4.9 for details.
        // https://tools.ietf.org/html/rfc6665#section-4.1.4
        // Each event package MUST specify whether forked SUBSCRIBE requests are
        // allowed to install multiple subscriptions.
        //
        // If such behavior is not allowed, the first potential dialog-
        // establishing message will create a dialog.  All subsequent NOTIFY
        // requests that correspond to the SUBSCRIBE request (i.e., have
        // matching "To", "From", "Call-ID", and "Event" header fields, as well
        // as "From" header field "tag" parameter and "Event" header field "id"
        // parameter) but that do not match the dialog would be rejected with a
        // 481 response.  Note that the 200-class response to the SUBSCRIBE
        // request can arrive after a matching NOTIFY request has been received;
        // such responses might not correlate to the same dialog established by
        // the NOTIFY request.  Except as required to complete the SUBSCRIBE
        // transaction, such non-matching 200-class responses are ignored.
        //
        // If installing of multiple subscriptions by way of a single forked
        // SUBSCRIBE request is allowed, the subscriber establishes a new dialog
        // towards each notifier by returning a 200-class response to each
        // NOTIFY request.  Each dialog is then handled as its own entity and is
        // refreshed independently of the other dialogs.
        //
        // In the case that multiple subscriptions are allowed, the event
        // package MUST specify whether merging of the notifications to form a
        // single state is required, and how such merging is to be performed.
        // Note that it is possible that some event packages may be defined in
        // such a way that each dialog is tied to a mutually exclusive state
        // that is unaffected by the other dialogs; this MUST be clearly stated
        // if it is the case.
        // https://tools.ietf.org/html/rfc6665#section-5.4.9
        // *** NOTE: This implementation is only for event packages which
        // do not allow forked requests to install multiple subscriptions.
        // As such and in accordance with the specification, we stop waiting
        // and any future NOTIFY requests will be rejected with a 481.
        if (this.dialog) {
            throw new Error("Dialog already created. This implementation only supports install of single subscriptions.");
        }
        this.waitNotifyStop();
        // Update expires.
        this.subscriptionExpires =
            subscriptionState.expires ?
                Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) :
                this.subscriptionExpires;
        // Update subscription state.
        switch (state) {
            case "pending":
                this.subscriptionState = subscription_1.SubscriptionState.Pending;
                break;
            case "active":
                this.subscriptionState = subscription_1.SubscriptionState.Active;
                break;
            case "terminated":
                this.subscriptionState = subscription_1.SubscriptionState.Terminated;
                break;
            default:
                throw new Error("Unrecognized state " + state + ".");
        }
        // Dialogs usages are created upon completion of a NOTIFY transaction
        // for a new subscription, unless the NOTIFY request contains a
        // "Subscription-State" of "terminated."
        // https://tools.ietf.org/html/rfc6665#section-4.4.1
        if (this.subscriptionState !== subscription_1.SubscriptionState.Terminated) {
            // Because the dialog usage is established by the NOTIFY request, the
            // route set at the subscriber is taken from the NOTIFY request itself,
            // as opposed to the route set present in the 200-class response to the
            // SUBSCRIBE request.
            // https://tools.ietf.org/html/rfc6665#section-4.4.1
            var dialogState = subscription_dialog_1.SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message);
            // Subscription Initiated! :)
            this.dialog = new subscription_dialog_1.SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);
        }
        // Delegate.
        if (this.delegate && this.delegate.onNotify) {
            var request = uas;
            var subscription = this.dialog;
            this.delegate.onNotify({ request: request, subscription: subscription });
        }
        else {
            uas.accept();
        }
    };
    SubscribeUserAgentClient.prototype.waitNotifyStart = function () {
        var _this = this;
        if (!this.N) {
            // Add ourselves to the core's subscriber map.
            // This allows the core to route out of dialog NOTIFY messages to us.
            this.core.subscribers.set(this.subscriberId, this);
            this.N = setTimeout(function () { return _this.timer_N(); }, timers_1.Timers.TIMER_N);
        }
    };
    SubscribeUserAgentClient.prototype.waitNotifyStop = function () {
        if (this.N) {
            // Remove ourselves to the core's subscriber map.
            // Any future out of dialog NOTIFY messages will be rejected with a 481.
            this.core.subscribers.delete(this.subscriberId);
            clearTimeout(this.N);
            this.N = undefined;
        }
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    SubscribeUserAgentClient.prototype.receiveResponse = function (message) {
        if (!this.authenticationGuard(message)) {
            return;
        }
        if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {
            //  The "Expires" header field in a 200-class response to SUBSCRIBE
            //  request indicates the actual duration for which the subscription will
            //  remain active (unless refreshed).  The received value might be
            //  smaller than the value indicated in the SUBSCRIBE request but cannot
            //  be larger; see Section 4.2.1 for details.
            // https://tools.ietf.org/html/rfc6665#section-4.1.2.1
            // The "Expires" values present in SUBSCRIBE 200-class responses behave
            // in the same way as they do in REGISTER responses: the server MAY
            // shorten the interval but MUST NOT lengthen it.
            //
            //    If the duration specified in a SUBSCRIBE request is unacceptably
            //    short, the notifier may be able to send a 423 response, as
            //    described earlier in this section.
            //
            // 200-class responses to SUBSCRIBE requests will not generally contain
            // any useful information beyond subscription duration; their primary
            // purpose is to serve as a reliability mechanism.  State information
            // will be communicated via a subsequent NOTIFY request from the
            // notifier.
            // https://tools.ietf.org/html/rfc6665#section-4.2.1.1
            var expires = message.getHeader("Expires");
            if (!expires) {
                this.logger.warn("Expires header missing in a 200-class response to SUBSCRIBE");
            }
            else {
                var subscriptionExpiresReceived = Number(expires);
                if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {
                    this.logger.warn("Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request");
                }
                if (subscriptionExpiresReceived < this.subscriptionExpires) {
                    this.subscriptionExpires = subscriptionExpiresReceived;
                }
            }
            // If a NOTIFY arrived before 200-class response a dialog may have been created.
            // Updated the dialogs expiration only if this indicates earlier expiration.
            if (this.dialog) {
                if (this.dialog.subscriptionExpires > this.subscriptionExpires) {
                    this.dialog.subscriptionExpires = this.subscriptionExpires;
                }
            }
        }
        if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {
            this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.
        }
        _super.prototype.receiveResponse.call(this, message);
    };
    /**
     * To ensure that subscribers do not wait indefinitely for a
     * subscription to be established, a subscriber starts a Timer N, set to
     * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires
     * prior to the receipt of a NOTIFY request, the subscriber considers
     * the subscription failed, and cleans up any state associated with the
     * subscription attempt.
     * https://tools.ietf.org/html/rfc6665#section-4.1.2.4
     */
    SubscribeUserAgentClient.prototype.timer_N = function () {
        this.logger.warn("Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.");
        this.waitNotifyStop();
        if (this.delegate && this.delegate.onNotifyTimeout) {
            this.delegate.onNotifyTimeout();
        }
    };
    return SubscribeUserAgentClient;
}(user_agent_client_1.UserAgentClient));
exports.SubscribeUserAgentClient = SubscribeUserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-server.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var user_agent_server_1 = __webpack_require__(/*! ./user-agent-server */ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js");
/**
 * SUBSCRIBE UAS.
 * @public
 */
var SubscribeUserAgentServer = /** @class */ (function (_super) {
    tslib_1.__extends(SubscribeUserAgentServer, _super);
    function SubscribeUserAgentServer(core, message, delegate) {
        var _this = _super.call(this, transactions_1.NonInviteServerTransaction, core, message, delegate) || this;
        _this.core = core;
        return _this;
    }
    return SubscribeUserAgentServer;
}(user_agent_server_1.UserAgentServer));
exports.SubscribeUserAgentServer = SubscribeUserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/user-agent-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
/**
 * User Agent Client (UAC).
 * @remarks
 * A user agent client is a logical entity
 * that creates a new request, and then uses the client
 * transaction state machinery to send it.  The role of UAC lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software initiates a request, it acts as a UAC for
 * the duration of that transaction.  If it receives a request
 * later, it assumes the role of a user agent server for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentClient = /** @class */ (function () {
    function UserAgentClient(transactionConstructor, core, message, delegate) {
        this.transactionConstructor = transactionConstructor;
        this.core = core;
        this.message = message;
        this.delegate = delegate;
        this.challenged = false;
        this.stale = false;
        this.logger = this.loggerFactory.getLogger("sip.user-agent-client");
        this.init();
    }
    UserAgentClient.prototype.dispose = function () {
        this.transaction.dispose();
    };
    Object.defineProperty(UserAgentClient.prototype, "loggerFactory", {
        get: function () {
            return this.core.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentClient.prototype, "transaction", {
        /** The transaction associated with this request. */
        get: function () {
            if (!this._transaction) {
                throw new Error("Transaction undefined.");
            }
            return this._transaction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Since requests other than INVITE are responded to immediately, sending a
     * CANCEL for a non-INVITE request would always create a race condition.
     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.
     * https://tools.ietf.org/html/rfc3261#section-9.1
     * @param options - Cancel options bucket.
     */
    UserAgentClient.prototype.cancel = function (reason, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (!this.transaction) {
            throw new Error("Transaction undefined.");
        }
        if (!this.message.to) {
            throw new Error("To undefined.");
        }
        if (!this.message.from) {
            throw new Error("From undefined.");
        }
        // The following procedures are used to construct a CANCEL request.  The
        // Request-URI, Call-ID, To, the numeric part of CSeq, and From header
        // fields in the CANCEL request MUST be identical to those in the
        // request being cancelled, including tags.  A CANCEL constructed by a
        // client MUST have only a single Via header field value matching the
        // top Via value in the request being cancelled.  Using the same values
        // for these header fields allows the CANCEL to be matched with the
        // request it cancels (Section 9.2 indicates how such matching occurs).
        // However, the method part of the CSeq header field MUST have a value
        // of CANCEL.  This allows it to be identified and processed as a
        // transaction in its own right (See Section 17).
        // https://tools.ietf.org/html/rfc3261#section-9.1
        var message = this.core.makeOutgoingRequestMessage(messages_1.C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {
            toTag: this.message.toTag,
            fromTag: this.message.fromTag,
            callId: this.message.callId,
            cseq: this.message.cseq
        }, options.extraHeaders);
        // TODO: Revisit this.
        // The CANCEL needs to use the same branch parameter so that
        // it matches the INVITE transaction, but this is a hacky way to do this.
        // Or at the very least not well documented. If the the branch parameter
        // is set on the outgoing request, the transaction will use it.
        // Otherwise the transaction will make a new one.
        message.branch = this.message.branch;
        if (this.message.headers.Route) {
            message.headers.Route = this.message.headers.Route;
        }
        if (reason) {
            message.setHeader("Reason", reason);
        }
        // If no provisional response has been received, the CANCEL request MUST
        // NOT be sent; rather, the client MUST wait for the arrival of a
        // provisional response before sending the request. If the original
        // request has generated a final response, the CANCEL SHOULD NOT be
        // sent, as it is an effective no-op, since CANCEL has no effect on
        // requests that have already generated a final response.
        // https://tools.ietf.org/html/rfc3261#section-9.1
        if (this.transaction.state === transactions_1.TransactionState.Proceeding) {
            var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, this.core, message);
        }
        else {
            this.transaction.once("stateChanged", function () {
                if (_this.transaction && _this.transaction.state === transactions_1.TransactionState.Proceeding) {
                    var uac = new UserAgentClient(transactions_1.NonInviteClientTransaction, _this.core, message);
                }
            });
        }
        return message;
    };
    /**
     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
     * response is received, the UAC SHOULD follow the authorization
     * procedures of Section 22.2 and Section 22.3 to retry the request with
     * credentials.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5
     * 22 Usage of HTTP Authentication
     * https://tools.ietf.org/html/rfc3261#section-22
     * 22.1 Framework
     * https://tools.ietf.org/html/rfc3261#section-22.1
     * 22.2 User-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.2
     * 22.3 Proxy-to-User Authentication
     * https://tools.ietf.org/html/rfc3261#section-22.3
     *
     * FIXME: This "guard for and retry the request with credentials"
     * implementation is not complete and at best minimally passable.
     * @param response - The incoming response to guard.
     * @param dialog - If defined, the dialog within which the response was received.
     * @returns True if the program execution is to continue in the branch in question.
     *          Otherwise the request is retried with credentials and current request processing must stop.
     */
    UserAgentClient.prototype.authenticationGuard = function (message, dialog) {
        var statusCode = message.statusCode;
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)
        // response is received, the UAC SHOULD follow the authorization
        // procedures of Section 22.2 and Section 22.3 to retry the request with
        // credentials.
        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5
        if (statusCode !== 401 && statusCode !== 407) {
            return true;
        }
        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
        var challenge;
        var authorizationHeaderName;
        if (statusCode === 401) {
            challenge = message.parseHeader("www-authenticate");
            authorizationHeaderName = "authorization";
        }
        else {
            challenge = message.parseHeader("proxy-authenticate");
            authorizationHeaderName = "proxy-authorization";
        }
        // Verify it seems a valid challenge.
        if (!challenge) {
            this.logger.warn(statusCode + " with wrong or missing challenge, cannot authenticate");
            return true;
        }
        // Avoid infinite authentications.
        if (this.challenged && (this.stale || challenge.stale !== true)) {
            this.logger.warn(statusCode + " apparently in authentication loop, cannot authenticate");
            return true;
        }
        // Get credentials.
        if (!this.credentials) {
            this.credentials = this.core.configuration.authenticationFactory();
            if (!this.credentials) {
                this.logger.warn("Unable to obtain credentials, cannot authenticate");
                return true;
            }
        }
        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.message, challenge)) {
            return true;
        }
        this.challenged = true;
        if (challenge.stale) {
            this.stale = true;
        }
        // If response to out of dialog request, assume incrementing the CSeq will suffice.
        var cseq = this.message.cseq += 1;
        // If response to in dialog request, get a valid next CSeq number.
        if (dialog && dialog.localSequenceNumber) {
            dialog.incrementLocalSequenceNumber();
            cseq = this.message.cseq = dialog.localSequenceNumber;
        }
        this.message.setHeader("cseq", cseq + " " + this.message.method);
        this.message.setHeader(authorizationHeaderName, this.credentials.toString());
        // Calling init (again) will swap out our existing client transaction with a new one.
        // FIXME: HACK: An assumption is being made here that there is nothing that needs to
        // be cleaned up beyond the client transaction which is being replaced. For example,
        // it is assumed that no early dialogs have been created.
        this.init();
        return false;
    };
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     */
    UserAgentClient.prototype.onRequestTimeout = function () {
        this.logger.warn("User agent client request timed out. Generating internal 408 Request Timeout.");
        var message = new messages_1.IncomingResponseMessage();
        message.statusCode = 408;
        message.reasonPhrase = "Request Timeout";
        this.receiveResponse(message);
        return;
    };
    /**
     * 8.1.3.1 Transaction Layer Errors
     * In some cases, the response returned by the transaction layer will
     * not be a SIP message, but rather a transaction layer error.  When a
     * timeout error is received from the transaction layer, it MUST be
     * treated as if a 408 (Request Timeout) status code has been received.
     * If a fatal transport error is reported by the transport layer
     * (generally, due to fatal ICMP errors in UDP or connection failures in
     * TCP), the condition MUST be treated as a 503 (Service Unavailable)
     * status code.
     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1
     * @param error - Transport error
     */
    UserAgentClient.prototype.onTransportError = function (error) {
        this.logger.error(error.message);
        this.logger.error("User agent client request transport error. Generating internal 503 Service Unavailable.");
        var message = new messages_1.IncomingResponseMessage();
        message.statusCode = 503;
        message.reasonPhrase = "Service Unavailable";
        this.receiveResponse(message);
    };
    /**
     * Receive a response from the transaction layer.
     * @param message - Incoming response message.
     */
    UserAgentClient.prototype.receiveResponse = function (message) {
        if (!this.authenticationGuard(message)) {
            return;
        }
        var statusCode = message.statusCode ? message.statusCode.toString() : "";
        if (!statusCode) {
            throw new Error("Response status code undefined.");
        }
        switch (true) {
            case /^100$/.test(statusCode):
                if (this.delegate && this.delegate.onTrying) {
                    this.delegate.onTrying({ message: message });
                }
                break;
            case /^1[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onProgress) {
                    this.delegate.onProgress({ message: message });
                }
                break;
            case /^2[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onAccept) {
                    this.delegate.onAccept({ message: message });
                }
                break;
            case /^3[0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onRedirect) {
                    this.delegate.onRedirect({ message: message });
                }
                break;
            case /^[4-6][0-9]{2}$/.test(statusCode):
                if (this.delegate && this.delegate.onReject) {
                    this.delegate.onReject({ message: message });
                }
                break;
            default:
                throw new Error("Invalid status code " + statusCode);
        }
    };
    UserAgentClient.prototype.init = function () {
        var _this = this;
        // We are the transaction user.
        var user = {
            loggerFactory: this.loggerFactory,
            onRequestTimeout: function () { return _this.onRequestTimeout(); },
            onStateChange: function (newState) {
                if (newState === transactions_1.TransactionState.Terminated) {
                    // Remove the terminated transaction from the core.
                    _this.core.userAgentClients.delete(userAgentClientId);
                    // FIXME: HACK: Our transaction may have been swapped out with a new one
                    // post authentication (see above), so make sure to only to dispose of
                    // ourselves if this terminating transaction is our current transaction.
                    if (transaction === _this._transaction) {
                        _this.dispose();
                    }
                }
            },
            onTransportError: function (error) { return _this.onTransportError(error); },
            receiveResponse: function (message) { return _this.receiveResponse(message); }
        };
        // Create a new transaction with us as the user.
        var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
        this._transaction = transaction;
        // Add the new transaction to the core.
        var userAgentClientId = transaction.id + transaction.request.method;
        this.core.userAgentClients.set(userAgentClientId, this);
    };
    return UserAgentClient;
}());
exports.UserAgentClient = UserAgentClient;


/***/ }),

/***/ "./node_modules/sip.js/lib/core/user-agents/user-agent-server.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sip.js/lib/core/user-agents/user-agent-server.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var exceptions_1 = __webpack_require__(/*! ../exceptions */ "./node_modules/sip.js/lib/core/exceptions/index.js");
var messages_1 = __webpack_require__(/*! ../messages */ "./node_modules/sip.js/lib/core/messages/index.js");
var utils_1 = __webpack_require__(/*! ../messages/utils */ "./node_modules/sip.js/lib/core/messages/utils.js");
var transactions_1 = __webpack_require__(/*! ../transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
/**
 * User Agent Server (UAS).
 * @remarks
 * A user agent server is a logical entity
 * that generates a response to a SIP request.  The response
 * accepts, rejects, or redirects the request.  This role lasts
 * only for the duration of that transaction.  In other words, if
 * a piece of software responds to a request, it acts as a UAS for
 * the duration of that transaction.  If it generates a request
 * later, it assumes the role of a user agent client for the
 * processing of that transaction.
 * https://tools.ietf.org/html/rfc3261#section-6
 * @public
 */
var UserAgentServer = /** @class */ (function () {
    function UserAgentServer(transactionConstructor, core, message, delegate) {
        this.transactionConstructor = transactionConstructor;
        this.core = core;
        this.message = message;
        this.delegate = delegate;
        this.logger = this.loggerFactory.getLogger("sip.user-agent-server");
        this.toTag = message.toTag ? message.toTag : utils_1.newTag();
        this.init();
    }
    UserAgentServer.prototype.dispose = function () {
        this.transaction.dispose();
    };
    Object.defineProperty(UserAgentServer.prototype, "loggerFactory", {
        get: function () {
            return this.core.loggerFactory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "transaction", {
        /** The transaction associated with this request. */
        get: function () {
            if (!this._transaction) {
                throw new Error("Transaction undefined.");
            }
            return this._transaction;
        },
        enumerable: true,
        configurable: true
    });
    UserAgentServer.prototype.accept = function (options) {
        if (options === void 0) { options = { statusCode: 200 }; }
        if (!this.acceptable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not acceptable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 200 || statusCode > 299) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.progress = function (options) {
        if (options === void 0) { options = { statusCode: 180 }; }
        if (!this.progressable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not progressable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 101 || statusCode > 199) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.redirect = function (contacts, options) {
        if (options === void 0) { options = { statusCode: 302 }; }
        if (!this.redirectable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not redirectable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 300 || statusCode > 399) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var contactHeaders = new Array();
        contacts.forEach(function (contact) { return contactHeaders.push("Contact: " + contact.toString()); });
        options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.reject = function (options) {
        if (options === void 0) { options = { statusCode: 480 }; }
        if (!this.rejectable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not rejectable in state " + this.transaction.state + ".");
        }
        var statusCode = options.statusCode;
        if (statusCode < 400 || statusCode > 699) {
            throw new TypeError("Invalid statusCode: " + statusCode);
        }
        var response = this.reply(options);
        return response;
    };
    UserAgentServer.prototype.trying = function (options) {
        if (!this.tryingable) {
            throw new exceptions_1.TransactionStateError(this.message.method + " not tryingable in state " + this.transaction.state + ".");
        }
        var response = this.reply({ statusCode: 100 });
        return response;
    };
    /**
     * If the UAS did not find a matching transaction for the CANCEL
     * according to the procedure above, it SHOULD respond to the CANCEL
     * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction
     * for the original request still exists, the behavior of the UAS on
     * receiving a CANCEL request depends on whether it has already sent a
     * final response for the original request.  If it has, the CANCEL
     * request has no effect on the processing of the original request, no
     * effect on any session state, and no effect on the responses generated
     * for the original request.  If the UAS has not issued a final response
     * for the original request, its behavior depends on the method of the
     * original request.  If the original request was an INVITE, the UAS
     * SHOULD immediately respond to the INVITE with a 487 (Request
     * Terminated).  A CANCEL request has no impact on the processing of
     * transactions with any other method defined in this specification.
     * https://tools.ietf.org/html/rfc3261#section-9.2
     * @param request - Incoming CANCEL request.
     */
    UserAgentServer.prototype.receiveCancel = function (message) {
        // Note: Currently CANCEL is being handled as a special case.
        // No UAS is created to handle the CANCEL and the response to
        // it CANCEL is being handled statelessly by the user agent core.
        // As such, there is currently no way to externally impact the
        // response to the a CANCEL request.
        if (this.delegate && this.delegate.onCancel) {
            this.delegate.onCancel(message);
        }
    };
    Object.defineProperty(UserAgentServer.prototype, "acceptable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Proceeding ||
                    this.transaction.state === transactions_1.TransactionState.Accepted);
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "progressable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return false; // https://tools.ietf.org/html/rfc4320#section-4.1
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "redirectable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "rejectable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return (this.transaction.state === transactions_1.TransactionState.Trying ||
                    this.transaction.state === transactions_1.TransactionState.Proceeding);
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserAgentServer.prototype, "tryingable", {
        get: function () {
            if (this.transaction instanceof transactions_1.InviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Proceeding;
            }
            if (this.transaction instanceof transactions_1.NonInviteServerTransaction) {
                return this.transaction.state === transactions_1.TransactionState.Trying;
            }
            throw new Error("Unknown transaction type.");
        },
        enumerable: true,
        configurable: true
    });
    /**
     * When a UAS wishes to construct a response to a request, it follows
     * the general procedures detailed in the following subsections.
     * Additional behaviors specific to the response code in question, which
     * are not detailed in this section, may also be required.
     *
     * Once all procedures associated with the creation of a response have
     * been completed, the UAS hands the response back to the server
     * transaction from which it received the request.
     * https://tools.ietf.org/html/rfc3261#section-8.2.6
     * @param statusCode - Status code to reply with.
     * @param options - Reply options bucket.
     */
    UserAgentServer.prototype.reply = function (options) {
        if (!options.toTag && options.statusCode !== 100) {
            options.toTag = this.toTag;
        }
        options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;
        options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;
        var response = messages_1.constructOutgoingResponse(this.message, options);
        this.transaction.receiveResponse(options.statusCode, response.message);
        return response;
    };
    UserAgentServer.prototype.init = function () {
        var _this = this;
        // We are the transaction user.
        var user = {
            loggerFactory: this.loggerFactory,
            onStateChange: function (newState) {
                if (newState === transactions_1.TransactionState.Terminated) {
                    // Remove the terminated transaction from the core.
                    _this.core.userAgentServers.delete(userAgentServerId);
                    _this.dispose();
                }
            },
            onTransportError: function (error) {
                _this.logger.error(error.message);
                if (_this.delegate && _this.delegate.onTransportError) {
                    _this.delegate.onTransportError(error);
                }
                else {
                    _this.logger.error("User agent server response transport error.");
                }
            }
        };
        // Create a new transaction with us as the user.
        var transaction = new this.transactionConstructor(this.message, this.core.transport, user);
        this._transaction = transaction;
        // Add the new transaction to the core.
        var userAgentServerId = transaction.id;
        this.core.userAgentServers.set(transaction.id, this);
    };
    return UserAgentServer;
}());
exports.UserAgentServer = UserAgentServer;


/***/ }),

/***/ "./node_modules/sip.js/lib/grammar/dist/grammar.js":
/*!*********************************************************!*\
  !*** ./node_modules/sip.js/lib/grammar/dist/grammar.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// tslint:disable:interface-name
// tslint:disable: trailing-comma
// tslint:disable: object-literal-sort-keys
// tslint:disable: max-line-length
// tslint:disable: only-arrow-functions
// tslint:disable: one-variable-per-declaration
// tslint:disable: no-consecutive-blank-lines
// tslint:disable: align
// tslint:disable: radix
// tslint:disable: quotemark
// tslint:disable: semicolon
// tslint:disable: object-literal-shorthand
// tslint:disable: variable-name
// tslint:disable: no-var-keyword
// tslint:disable: whitespace
// tslint:disable: curly
// tslint:disable: prefer-const
// tslint:disable: object-literal-key-quotes
// tslint:disable: no-string-literal
// tslint:disable: one-line
// tslint:disable: no-unused-expression
// tslint:disable: space-before-function-paren
// tslint:disable: arrow-return-shorthand
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
// Generated by PEG.js v. 0.10.0 (ts-pegjs plugin v. 0.2.6 )
//
// https://pegjs.org/   https://github.com/metadevpro/ts-pegjs
var name_addr_header_1 = __webpack_require__(/*! ../../core/messages/name-addr-header */ "./node_modules/sip.js/lib/core/messages/name-addr-header.js");
var uri_1 = __webpack_require__(/*! ../../core/messages/uri */ "./node_modules/sip.js/lib/core/messages/uri.js");
var SyntaxError = /** @class */ (function (_super) {
    tslib_1.__extends(SyntaxError, _super);
    function SyntaxError(message, expected, found, location) {
        var _this = _super.call(this) || this;
        _this.message = message;
        _this.expected = expected;
        _this.found = found;
        _this.location = location;
        _this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, SyntaxError);
        }
        return _this;
    }
    SyntaxError.buildMessage = function (expected, found) {
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/"/g, "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
        }
        function classEscape(s) {
            return s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g, "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g, function (ch) { return "\\x0" + hex(ch); })
                .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return "\\x" + hex(ch); });
        }
        function describeExpectation(expectation) {
            switch (expectation.type) {
                case "literal":
                    return "\"" + literalEscape(expectation.text) + "\"";
                case "class":
                    var escapedParts = expectation.parts.map(function (part) {
                        return Array.isArray(part)
                            ? classEscape(part[0]) + "-" + classEscape(part[1])
                            : classEscape(part);
                    });
                    return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                case "any":
                    return "any character";
                case "end":
                    return "end of input";
                case "other":
                    return expectation.description;
            }
        }
        function describeExpected(expected1) {
            var descriptions = expected1.map(describeExpectation);
            var i;
            var j;
            descriptions.sort();
            if (descriptions.length > 0) {
                for (i = 1, j = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }
            switch (descriptions.length) {
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ")
                        + ", or "
                        + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found1) {
            return found1 ? "\"" + literalEscape(found1) + "\"" : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    return SyntaxError;
}(Error));
exports.SyntaxError = SyntaxError;
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 };
    var peg$startRuleIndex = 119;
    var peg$consts = [
        "\r\n",
        peg$literalExpectation("\r\n", false),
        /^[0-9]/,
        peg$classExpectation([["0", "9"]], false, false),
        /^[a-zA-Z]/,
        peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
        /^[0-9a-fA-F]/,
        peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
        /^[\0-\xFF]/,
        peg$classExpectation([["\0", "\xFF"]], false, false),
        /^["]/,
        peg$classExpectation(["\""], false, false),
        " ",
        peg$literalExpectation(" ", false),
        "\t",
        peg$literalExpectation("\t", false),
        /^[a-zA-Z0-9]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
        ";",
        peg$literalExpectation(";", false),
        "/",
        peg$literalExpectation("/", false),
        "?",
        peg$literalExpectation("?", false),
        ":",
        peg$literalExpectation(":", false),
        "@",
        peg$literalExpectation("@", false),
        "&",
        peg$literalExpectation("&", false),
        "=",
        peg$literalExpectation("=", false),
        "+",
        peg$literalExpectation("+", false),
        "$",
        peg$literalExpectation("$", false),
        ",",
        peg$literalExpectation(",", false),
        "-",
        peg$literalExpectation("-", false),
        "_",
        peg$literalExpectation("_", false),
        ".",
        peg$literalExpectation(".", false),
        "!",
        peg$literalExpectation("!", false),
        "~",
        peg$literalExpectation("~", false),
        "*",
        peg$literalExpectation("*", false),
        "'",
        peg$literalExpectation("'", false),
        "(",
        peg$literalExpectation("(", false),
        ")",
        peg$literalExpectation(")", false),
        "%",
        peg$literalExpectation("%", false),
        function () { return " "; },
        function () { return ':'; },
        /^[!-~]/,
        peg$classExpectation([["!", "~"]], false, false),
        /^[\x80-\uFFFF]/,
        peg$classExpectation([["\x80", "\uFFFF"]], false, false),
        /^[\x80-\xBF]/,
        peg$classExpectation([["\x80", "\xBF"]], false, false),
        /^[a-f]/,
        peg$classExpectation([["a", "f"]], false, false),
        "`",
        peg$literalExpectation("`", false),
        "<",
        peg$literalExpectation("<", false),
        ">",
        peg$literalExpectation(">", false),
        "\\",
        peg$literalExpectation("\\", false),
        "[",
        peg$literalExpectation("[", false),
        "]",
        peg$literalExpectation("]", false),
        "{",
        peg$literalExpectation("{", false),
        "}",
        peg$literalExpectation("}", false),
        function () { return "*"; },
        function () { return "/"; },
        function () { return "="; },
        function () { return "("; },
        function () { return ")"; },
        function () { return ">"; },
        function () { return "<"; },
        function () { return ","; },
        function () { return ";"; },
        function () { return ":"; },
        function () { return "\""; },
        /^[!-']/,
        peg$classExpectation([["!", "'"]], false, false),
        /^[*-[]/,
        peg$classExpectation([["*", "["]], false, false),
        /^[\]-~]/,
        peg$classExpectation([["]", "~"]], false, false),
        function (contents) {
            return contents;
        },
        /^[#-[]/,
        peg$classExpectation([["#", "["]], false, false),
        /^[\0-\t]/,
        peg$classExpectation([["\0", "\t"]], false, false),
        /^[\x0B-\f]/,
        peg$classExpectation([["\x0B", "\f"]], false, false),
        /^[\x0E-\x7F]/,
        peg$classExpectation([["\x0E", "\x7F"]], false, false),
        function () {
            options = options || { data: {} };
            options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);
            delete options.data.scheme;
            delete options.data.user;
            delete options.data.host;
            delete options.data.host_type;
            delete options.data.port;
        },
        function () {
            options = options || { data: {} };
            options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
            delete options.data.scheme;
            delete options.data.user;
            delete options.data.host;
            delete options.data.host_type;
            delete options.data.port;
            delete options.data.uri_params;
            if (options.startRule === 'SIP_URI') {
                options.data = options.data.uri;
            }
        },
        "sips",
        peg$literalExpectation("sips", true),
        "sip",
        peg$literalExpectation("sip", true),
        function (uri_scheme) {
            options = options || { data: {} };
            options.data.scheme = uri_scheme;
        },
        function () {
            options = options || { data: {} };
            options.data.user = decodeURIComponent(text().slice(0, -1));
        },
        function () {
            options = options || { data: {} };
            options.data.password = text();
        },
        function () {
            options = options || { data: {} };
            options.data.host = text();
            return options.data.host;
        },
        function () {
            options = options || { data: {} };
            options.data.host_type = 'domain';
            return text();
        },
        /^[a-zA-Z0-9_\-]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
        /^[a-zA-Z0-9\-]/,
        peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "-"], false, false),
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv6';
            return text();
        },
        "::",
        peg$literalExpectation("::", false),
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv6';
            return text();
        },
        function () {
            options = options || { data: {} };
            options.data.host_type = 'IPv4';
            return text();
        },
        "25",
        peg$literalExpectation("25", false),
        /^[0-5]/,
        peg$classExpectation([["0", "5"]], false, false),
        "2",
        peg$literalExpectation("2", false),
        /^[0-4]/,
        peg$classExpectation([["0", "4"]], false, false),
        "1",
        peg$literalExpectation("1", false),
        /^[1-9]/,
        peg$classExpectation([["1", "9"]], false, false),
        function (port) {
            options = options || { data: {} };
            port = parseInt(port.join(''));
            options.data.port = port;
            return port;
        },
        "transport=",
        peg$literalExpectation("transport=", true),
        "udp",
        peg$literalExpectation("udp", true),
        "tcp",
        peg$literalExpectation("tcp", true),
        "sctp",
        peg$literalExpectation("sctp", true),
        "tls",
        peg$literalExpectation("tls", true),
        function (transport) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['transport'] = transport.toLowerCase();
        },
        "user=",
        peg$literalExpectation("user=", true),
        "phone",
        peg$literalExpectation("phone", true),
        "ip",
        peg$literalExpectation("ip", true),
        function (user) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['user'] = user.toLowerCase();
        },
        "method=",
        peg$literalExpectation("method=", true),
        function (method) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['method'] = method;
        },
        "ttl=",
        peg$literalExpectation("ttl=", true),
        function (ttl) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['ttl'] = ttl;
        },
        "maddr=",
        peg$literalExpectation("maddr=", true),
        function (maddr) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['maddr'] = maddr;
        },
        "lr",
        peg$literalExpectation("lr", true),
        function () {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            options.data.uri_params['lr'] = undefined;
        },
        function (param, value) {
            options = options || { data: {} };
            if (!options.data.uri_params)
                options.data.uri_params = {};
            if (value === null) {
                value = undefined;
            }
            else {
                value = value[1];
            }
            options.data.uri_params[param.toLowerCase()] = value;
        },
        function (hname, hvalue) {
            hname = hname.join('').toLowerCase();
            hvalue = hvalue.join('');
            options = options || { data: {} };
            if (!options.data.uri_headers)
                options.data.uri_headers = {};
            if (!options.data.uri_headers[hname]) {
                options.data.uri_headers[hname] = [hvalue];
            }
            else {
                options.data.uri_headers[hname].push(hvalue);
            }
        },
        function () {
            options = options || { data: {} };
            // lots of tests fail if this isn't guarded...
            if (options.startRule === 'Refer_To') {
                options.data.uri = new uri_1.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);
                delete options.data.scheme;
                delete options.data.user;
                delete options.data.host;
                delete options.data.host_type;
                delete options.data.port;
                delete options.data.uri_params;
            }
        },
        "//",
        peg$literalExpectation("//", false),
        function () {
            options = options || { data: {} };
            options.data.scheme = text();
        },
        peg$literalExpectation("SIP", true),
        function () {
            options = options || { data: {} };
            options.data.sip_version = text();
        },
        "INVITE",
        peg$literalExpectation("INVITE", false),
        "ACK",
        peg$literalExpectation("ACK", false),
        "VXACH",
        peg$literalExpectation("VXACH", false),
        "OPTIONS",
        peg$literalExpectation("OPTIONS", false),
        "BYE",
        peg$literalExpectation("BYE", false),
        "CANCEL",
        peg$literalExpectation("CANCEL", false),
        "REGISTER",
        peg$literalExpectation("REGISTER", false),
        "SUBSCRIBE",
        peg$literalExpectation("SUBSCRIBE", false),
        "NOTIFY",
        peg$literalExpectation("NOTIFY", false),
        "REFER",
        peg$literalExpectation("REFER", false),
        "PUBLISH",
        peg$literalExpectation("PUBLISH", false),
        function () {
            options = options || { data: {} };
            options.data.method = text();
            return options.data.method;
        },
        function (status_code) {
            options = options || { data: {} };
            options.data.status_code = parseInt(status_code.join(''));
        },
        function () {
            options = options || { data: {} };
            options.data.reason_phrase = text();
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        function () {
            var idx, length;
            options = options || { data: {} };
            length = options.data.multi_header.length;
            for (idx = 0; idx < length; idx++) {
                if (options.data.multi_header[idx].parsed === null) {
                    options.data = null;
                    break;
                }
            }
            if (options.data !== null) {
                options.data = options.data.multi_header;
            }
            else {
                options.data = -1;
            }
        },
        function () {
            var header;
            options = options || { data: {} };
            if (!options.data.multi_header)
                options.data.multi_header = [];
            try {
                header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                delete options.data.uri;
                delete options.data.displayName;
                delete options.data.params;
            }
            catch (e) {
                header = null;
            }
            options.data.multi_header.push({ 'position': peg$currPos,
                'offset': location().start.offset,
                'parsed': header
            });
        },
        function (displayName) {
            displayName = text().trim();
            if (displayName[0] === '\"') {
                displayName = displayName.substring(1, displayName.length - 1);
            }
            options = options || { data: {} };
            options.data.displayName = displayName;
        },
        "q",
        peg$literalExpectation("q", true),
        function (q) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['q'] = q;
        },
        "expires",
        peg$literalExpectation("expires", true),
        function (expires) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            options.data.params['expires'] = expires;
        },
        function (delta_seconds) {
            return parseInt(delta_seconds.join(''));
        },
        "0",
        peg$literalExpectation("0", false),
        function () {
            return parseFloat(text());
        },
        function (param, value) {
            options = options || { data: {} };
            if (!options.data.params)
                options.data.params = {};
            if (value === null) {
                value = undefined;
            }
            else {
                value = value[1];
            }
            options.data.params[param.toLowerCase()] = value;
        },
        "render",
        peg$literalExpectation("render", true),
        "session",
        peg$literalExpectation("session", true),
        "icon",
        peg$literalExpectation("icon", true),
        "alert",
        peg$literalExpectation("alert", true),
        function () {
            options = options || { data: {} };
            if (options.startRule === 'Content_Disposition') {
                options.data.type = text().toLowerCase();
            }
        },
        "handling",
        peg$literalExpectation("handling", true),
        "optional",
        peg$literalExpectation("optional", true),
        "required",
        peg$literalExpectation("required", true),
        function (length) {
            options = options || { data: {} };
            options.data = parseInt(length.join(''));
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        "text",
        peg$literalExpectation("text", true),
        "image",
        peg$literalExpectation("image", true),
        "audio",
        peg$literalExpectation("audio", true),
        "video",
        peg$literalExpectation("video", true),
        "application",
        peg$literalExpectation("application", true),
        "message",
        peg$literalExpectation("message", true),
        "multipart",
        peg$literalExpectation("multipart", true),
        "x-",
        peg$literalExpectation("x-", true),
        function (cseq_value) {
            options = options || { data: {} };
            options.data.value = parseInt(cseq_value.join(''));
        },
        function (expires) { options = options || { data: {} }; options.data = expires; },
        function (event_type) {
            options = options || { data: {} };
            options.data.event = event_type.toLowerCase();
        },
        function () {
            options = options || { data: {} };
            var tag = options.data.tag;
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            if (tag) {
                options.data.setParam('tag', tag);
            }
        },
        "tag",
        peg$literalExpectation("tag", true),
        function (tag) { options = options || { data: {} }; options.data.tag = tag; },
        function (forwards) {
            options = options || { data: {} };
            options.data = parseInt(forwards.join(''));
        },
        function (min_expires) { options = options || { data: {} }; options.data = min_expires; },
        function () {
            options = options || { data: {} };
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
        },
        "digest",
        peg$literalExpectation("Digest", true),
        "realm",
        peg$literalExpectation("realm", true),
        function (realm) { options = options || { data: {} }; options.data.realm = realm; },
        "domain",
        peg$literalExpectation("domain", true),
        "nonce",
        peg$literalExpectation("nonce", true),
        function (nonce) { options = options || { data: {} }; options.data.nonce = nonce; },
        "opaque",
        peg$literalExpectation("opaque", true),
        function (opaque) { options = options || { data: {} }; options.data.opaque = opaque; },
        "stale",
        peg$literalExpectation("stale", true),
        "true",
        peg$literalExpectation("true", true),
        function () { options = options || { data: {} }; options.data.stale = true; },
        "false",
        peg$literalExpectation("false", true),
        function () { options = options || { data: {} }; options.data.stale = false; },
        "algorithm",
        peg$literalExpectation("algorithm", true),
        "md5",
        peg$literalExpectation("MD5", true),
        "md5-sess",
        peg$literalExpectation("MD5-sess", true),
        function (algorithm) {
            options = options || { data: {} };
            options.data.algorithm = algorithm.toUpperCase();
        },
        "qop",
        peg$literalExpectation("qop", true),
        "auth-int",
        peg$literalExpectation("auth-int", true),
        "auth",
        peg$literalExpectation("auth", true),
        function (qop_value) {
            options = options || { data: {} };
            options.data.qop || (options.data.qop = []);
            options.data.qop.push(qop_value.toLowerCase());
        },
        function (rack_value) {
            options = options || { data: {} };
            options.data.value = parseInt(rack_value.join(''));
        },
        function () {
            var idx, length;
            options = options || { data: {} };
            length = options.data.multi_header.length;
            for (idx = 0; idx < length; idx++) {
                if (options.data.multi_header[idx].parsed === null) {
                    options.data = null;
                    break;
                }
            }
            if (options.data !== null) {
                options.data = options.data.multi_header;
            }
            else {
                options.data = -1;
            }
        },
        function () {
            var header;
            options = options || { data: {} };
            if (!options.data.multi_header)
                options.data.multi_header = [];
            try {
                header = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
                delete options.data.uri;
                delete options.data.displayName;
                delete options.data.params;
            }
            catch (e) {
                header = null;
            }
            options.data.multi_header.push({ 'position': peg$currPos,
                'offset': location().start.offset,
                'parsed': header
            });
        },
        function () {
            options = options || { data: {} };
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
        },
        function () {
            options = options || { data: {} };
            if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {
                options.data = -1;
            }
        },
        function () {
            options = options || { data: {} };
            options.data = {
                call_id: options.data
            };
        },
        "from-tag",
        peg$literalExpectation("from-tag", true),
        function (from_tag) {
            options = options || { data: {} };
            options.data.replaces_from_tag = from_tag;
        },
        "to-tag",
        peg$literalExpectation("to-tag", true),
        function (to_tag) {
            options = options || { data: {} };
            options.data.replaces_to_tag = to_tag;
        },
        "early-only",
        peg$literalExpectation("early-only", true),
        function () {
            options = options || { data: {} };
            options.data.early_only = true;
        },
        function (head, r) { return r; },
        function (head, tail) { return list(head, tail); },
        function (value) {
            options = options || { data: {} };
            if (options.startRule === 'Require') {
                options.data = value || [];
            }
        },
        function (rseq_value) {
            options = options || { data: {} };
            options.data.value = parseInt(rseq_value.join(''));
        },
        "active",
        peg$literalExpectation("active", true),
        "pending",
        peg$literalExpectation("pending", true),
        "terminated",
        peg$literalExpectation("terminated", true),
        function () {
            options = options || { data: {} };
            options.data.state = text();
        },
        "reason",
        peg$literalExpectation("reason", true),
        function (reason) {
            options = options || { data: {} };
            if (typeof reason !== 'undefined')
                options.data.reason = reason;
        },
        function (expires) {
            options = options || { data: {} };
            if (typeof expires !== 'undefined')
                options.data.expires = expires;
        },
        "retry_after",
        peg$literalExpectation("retry_after", true),
        function (retry_after) {
            options = options || { data: {} };
            if (typeof retry_after !== 'undefined')
                options.data.retry_after = retry_after;
        },
        "deactivated",
        peg$literalExpectation("deactivated", true),
        "probation",
        peg$literalExpectation("probation", true),
        "rejected",
        peg$literalExpectation("rejected", true),
        "timeout",
        peg$literalExpectation("timeout", true),
        "giveup",
        peg$literalExpectation("giveup", true),
        "noresource",
        peg$literalExpectation("noresource", true),
        "invariant",
        peg$literalExpectation("invariant", true),
        function (value) {
            options = options || { data: {} };
            if (options.startRule === 'Supported') {
                options.data = value || [];
            }
        },
        function () {
            options = options || { data: {} };
            var tag = options.data.tag;
            options.data = new name_addr_header_1.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);
            if (tag) {
                options.data.setParam('tag', tag);
            }
        },
        "ttl",
        peg$literalExpectation("ttl", true),
        function (via_ttl_value) {
            options = options || { data: {} };
            options.data.ttl = via_ttl_value;
        },
        "maddr",
        peg$literalExpectation("maddr", true),
        function (via_maddr) {
            options = options || { data: {} };
            options.data.maddr = via_maddr;
        },
        "received",
        peg$literalExpectation("received", true),
        function (via_received) {
            options = options || { data: {} };
            options.data.received = via_received;
        },
        "branch",
        peg$literalExpectation("branch", true),
        function (via_branch) {
            options = options || { data: {} };
            options.data.branch = via_branch;
        },
        "rport",
        peg$literalExpectation("rport", true),
        function (response_port) {
            options = options || { data: {} };
            if (typeof response_port !== 'undefined')
                options.data.rport = response_port.join('');
        },
        function (via_protocol) {
            options = options || { data: {} };
            options.data.protocol = via_protocol;
        },
        peg$literalExpectation("UDP", true),
        peg$literalExpectation("TCP", true),
        peg$literalExpectation("TLS", true),
        peg$literalExpectation("SCTP", true),
        function (via_transport) {
            options = options || { data: {} };
            options.data.transport = via_transport;
        },
        function () {
            options = options || { data: {} };
            options.data.host = text();
        },
        function (via_sent_by_port) {
            options = options || { data: {} };
            options.data.port = parseInt(via_sent_by_port.join(''));
        },
        function (ttl) {
            return parseInt(ttl.join(''));
        },
        function (deltaSeconds) {
            options = options || { data: {} };
            if (options.startRule === 'Session_Expires') {
                options.data.deltaSeconds = deltaSeconds;
            }
        },
        "refresher",
        peg$literalExpectation("refresher", false),
        "uas",
        peg$literalExpectation("uas", false),
        "uac",
        peg$literalExpectation("uac", false),
        function (endpoint) {
            options = options || { data: {} };
            if (options.startRule === 'Session_Expires') {
                options.data.refresher = endpoint;
            }
        },
        function (deltaSeconds) {
            options = options || { data: {} };
            if (options.startRule === 'Min_SE') {
                options.data = deltaSeconds;
            }
        },
        "stuns",
        peg$literalExpectation("stuns", true),
        "stun",
        peg$literalExpectation("stun", true),
        function (scheme) {
            options = options || { data: {} };
            options.data.scheme = scheme;
        },
        function (host) {
            options = options || { data: {} };
            options.data.host = host;
        },
        "?transport=",
        peg$literalExpectation("?transport=", false),
        "turns",
        peg$literalExpectation("turns", true),
        "turn",
        peg$literalExpectation("turn", true),
        function (transport) {
            options = options || { data: {} };
            options.data.transport = transport;
        },
        function () {
            options = options || { data: {} };
            options.data = text();
        },
        "Referred-By",
        peg$literalExpectation("Referred-By", false),
        "b",
        peg$literalExpectation("b", false),
        "cid",
        peg$literalExpectation("cid", false)
    ];
    var peg$bytecode = [
        peg$decode("2 \"\"6 7!"),
        peg$decode("4\"\"\"5!7#"),
        peg$decode("4$\"\"5!7%"),
        peg$decode("4&\"\"5!7'"),
        peg$decode(";'.# &;("),
        peg$decode("4(\"\"5!7)"),
        peg$decode("4*\"\"5!7+"),
        peg$decode("2,\"\"6,7-"),
        peg$decode("2.\"\"6.7/"),
        peg$decode("40\"\"5!71"),
        peg$decode("22\"\"6273.\x89 &24\"\"6475.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode(";).# &;,"),
        peg$decode("2F\"\"6F7G.} &2H\"\"6H7I.q &2J\"\"6J7K.e &2L\"\"6L7M.Y &2N\"\"6N7O.M &2P\"\"6P7Q.A &2R\"\"6R7S.5 &2T\"\"6T7U.) &2V\"\"6V7W"),
        peg$decode("%%2X\"\"6X7Y/5#;#/,$;#/#$+#)(#'#(\"'#&'#/\"!&,)"),
        peg$decode("%%$;$0#*;$&/,#; /#$+\")(\"'#&'#.\" &\"/=#$;$/&#0#*;$&&&#/'$8\":Z\" )(\"'#&'#"),
        peg$decode(";..\" &\""),
        peg$decode("%$;'.# &;(0)*;'.# &;(&/?#28\"\"6879/0$;//'$8#:[# )(#'#(\"'#&'#"),
        peg$decode("%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\")(\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
        peg$decode("4\\\"\"5!7].# &;3"),
        peg$decode("4^\"\"5!7_"),
        peg$decode("4`\"\"5!7a"),
        peg$decode(";!.) &4b\"\"5!7c"),
        peg$decode("%$;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x9E#0\x9B*;).\x95 &2F\"\"6F7G.\x89 &2J\"\"6J7K.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
        peg$decode("%$;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O/\x92#0\x8F*;).\x89 &2F\"\"6F7G.} &2L\"\"6L7M.q &2X\"\"6X7Y.e &2P\"\"6P7Q.Y &2H\"\"6H7I.M &2@\"\"6@7A.A &2d\"\"6d7e.5 &2R\"\"6R7S.) &2N\"\"6N7O&&&#/\"!&,)"),
        peg$decode("2T\"\"6T7U.\xE3 &2V\"\"6V7W.\xD7 &2f\"\"6f7g.\xCB &2h\"\"6h7i.\xBF &2:\"\"6:7;.\xB3 &2D\"\"6D7E.\xA7 &22\"\"6273.\x9B &28\"\"6879.\x8F &2j\"\"6j7k.\x83 &;&.} &24\"\"6475.q &2l\"\"6l7m.e &2n\"\"6n7o.Y &26\"\"6677.M &2>\"\"6>7?.A &2p\"\"6p7q.5 &2r\"\"6r7s.) &;'.# &;("),
        peg$decode("%$;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s/\u0134#0\u0131*;).\u012B &2F\"\"6F7G.\u011F &2J\"\"6J7K.\u0113 &2L\"\"6L7M.\u0107 &2X\"\"6X7Y.\xFB &2P\"\"6P7Q.\xEF &2H\"\"6H7I.\xE3 &2@\"\"6@7A.\xD7 &2d\"\"6d7e.\xCB &2R\"\"6R7S.\xBF &2N\"\"6N7O.\xB3 &2T\"\"6T7U.\xA7 &2V\"\"6V7W.\x9B &2f\"\"6f7g.\x8F &2h\"\"6h7i.\x83 &28\"\"6879.w &2j\"\"6j7k.k &;&.e &24\"\"6475.Y &2l\"\"6l7m.M &2n\"\"6n7o.A &26\"\"6677.5 &2p\"\"6p7q.) &2r\"\"6r7s&&&#/\"!&,)"),
        peg$decode("%;//?#2P\"\"6P7Q/0$;//'$8#:t# )(#'#(\"'#&'#"),
        peg$decode("%;//?#24\"\"6475/0$;//'$8#:u# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2>\"\"6>7?/0$;//'$8#:v# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2T\"\"6T7U/0$;//'$8#:w# )(#'#(\"'#&'#"),
        peg$decode("%;//?#2V\"\"6V7W/0$;//'$8#:x# )(#'#(\"'#&'#"),
        peg$decode("%2h\"\"6h7i/0#;//'$8\":y\" )(\"'#&'#"),
        peg$decode("%;//6#2f\"\"6f7g/'$8\":z\" )(\"'#&'#"),
        peg$decode("%;//?#2D\"\"6D7E/0$;//'$8#:{# )(#'#(\"'#&'#"),
        peg$decode("%;//?#22\"\"6273/0$;//'$8#:|# )(#'#(\"'#&'#"),
        peg$decode("%;//?#28\"\"6879/0$;//'$8#:}# )(#'#(\"'#&'#"),
        peg$decode("%;//0#;&/'$8\":~\" )(\"'#&'#"),
        peg$decode("%;&/0#;//'$8\":~\" )(\"'#&'#"),
        peg$decode("%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\"'#&'#"),
        peg$decode("4\x7F\"\"5!7\x80.A &4\x81\"\"5!7\x82.5 &4\x83\"\"5!7\x84.) &;3.# &;."),
        peg$decode("%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\"'#&'#/\"!&,)"),
        peg$decode("%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\"!&,)/1$;&/($8$:\x85$!!)($'#(#'#(\"'#&'#"),
        peg$decode(";..G &2L\"\"6L7M.; &4\x86\"\"5!7\x87./ &4\x83\"\"5!7\x84.# &;3"),
        peg$decode("%2j\"\"6j7k/J#4\x88\"\"5!7\x89.5 &4\x8A\"\"5!7\x8B.) &4\x8C\"\"5!7\x8D/#$+\")(\"'#&'#"),
        peg$decode("%;N/M#28\"\"6879/>$;O.\" &\"/0$;S/'$8$:\x8E$ )($'#(#'#(\"'#&'#"),
        peg$decode("%;N/d#28\"\"6879/U$;O.\" &\"/G$;S/>$;_/5$;l.\" &\"/'$8&:\x8F& )(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\x90\"\"5$7\x91.) &3\x92\"\"5#7\x93/' 8!:\x94!! )"),
        peg$decode("%;P/]#%28\"\"6879/,#;R/#$+\")(\"'#&'#.\" &\"/6$2:\"\"6:7;/'$8#:\x95# )(#'#(\"'#&'#"),
        peg$decode("$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#"),
        peg$decode("2<\"\"6<7=.q &2>\"\"6>7?.e &2@\"\"6@7A.Y &2B\"\"6B7C.M &2D\"\"6D7E.A &22\"\"6273.5 &26\"\"6677.) &24\"\"6475"),
        peg$decode("%$;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E0e*;+._ &;-.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E&/& 8!:\x96! )"),
        peg$decode("%;T/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;U.) &;\\.# &;X/& 8!:\x97! )"),
        peg$decode("%$%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#0<*%;V/2#2J\"\"6J7K/#$+\")(\"'#&'#&/D#;W/;$2J\"\"6J7K.\" &\"/'$8#:\x98# )(#'#(\"'#&'#"),
        peg$decode("$4\x99\"\"5!7\x9A/,#0)*4\x99\"\"5!7\x9A&&&#"),
        peg$decode("%4$\"\"5!7%/?#$4\x9B\"\"5!7\x9C0)*4\x9B\"\"5!7\x9C&/#$+\")(\"'#&'#"),
        peg$decode("%2l\"\"6l7m/?#;Y/6$2n\"\"6n7o/'$8#:\x9D# )(#'#(\"'#&'#"),
        peg$decode("%%;Z/\xB3#28\"\"6879/\xA4$;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0790 &%2\x9E\"\"6\x9E7\x9F/\xA4#;Z/\x9B$28\"\"6879/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u06F9 &%2\x9E\"\"6\x9E7\x9F/\x8C#;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u067A &%2\x9E\"\"6\x9E7\x9F/t#;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0613 &%2\x9E\"\"6\x9E7\x9F/\\#;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\"'#&'#.\u05C4 &%2\x9E\"\"6\x9E7\x9F/D#;Z/;$28\"\"6879/,$;[/#$+$)($'#(#'#(\"'#&'#.\u058D &%2\x9E\"\"6\x9E7\x9F/,#;[/#$+\")(\"'#&'#.\u056E &%2\x9E\"\"6\x9E7\x9F/,#;Z/#$+\")(\"'#&'#.\u054F &%;Z/\x9B#2\x9E\"\"6\x9E7\x9F/\x8C$;Z/\x83$28\"\"6879/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u04C7 &%;Z/\xAA#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x83$2\x9E\"\"6\x9E7\x9F/t$;Z/k$28\"\"6879/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0430 &%;Z/\xB9#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x92$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/k$2\x9E\"\"6\x9E7\x9F/\\$;Z/S$28\"\"6879/D$;Z/;$28\"\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u038A &%;Z/\xC8#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA1$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/z$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/S$2\x9E\"\"6\x9E7\x9F/D$;Z/;$28\"\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u02D5 &%;Z/\xD7#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0211 &%;Z/\xFE#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xD7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xB0$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x89$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/b$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/;$2\x9E\"\"6\x9E7\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#.\u0126 &%;Z/\u011C#%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xF5$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xCE$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\xA7$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/\x80$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/Y$%28\"\"6879/,#;Z/#$+\")(\"'#&'#.\" &\"/2$2\x9E\"\"6\x9E7\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\"'#&'#/& 8!:\xA0! )"),
        peg$decode("%;#/M#;#.\" &\"/?$;#.\" &\"/1$;#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;Z/;#28\"\"6879/,$;Z/#$+#)(#'#(\"'#&'#.# &;\\"),
        peg$decode("%;]/o#2J\"\"6J7K/`$;]/W$2J\"\"6J7K/H$;]/?$2J\"\"6J7K/0$;]/'$8':\xA1' )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%2\xA2\"\"6\xA27\xA3/2#4\xA4\"\"5!7\xA5/#$+\")(\"'#&'#.\x98 &%2\xA6\"\"6\xA67\xA7/;#4\xA8\"\"5!7\xA9/,$;!/#$+#)(#'#(\"'#&'#.j &%2\xAA\"\"6\xAA7\xAB/5#;!/,$;!/#$+#)(#'#(\"'#&'#.B &%4\xAC\"\"5!7\xAD/,#;!/#$+\")(\"'#&'#.# &;!"),
        peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\xAE!! )"),
        peg$decode("$%22\"\"6273/,#;`/#$+\")(\"'#&'#0<*%22\"\"6273/,#;`/#$+\")(\"'#&'#&"),
        peg$decode(";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g"),
        peg$decode("%3\xAF\"\"5*7\xB0/a#3\xB1\"\"5#7\xB2.G &3\xB3\"\"5#7\xB4.; &3\xB5\"\"5$7\xB6./ &3\xB7\"\"5#7\xB8.# &;6/($8\":\xB9\"! )(\"'#&'#"),
        peg$decode("%3\xBA\"\"5%7\xBB/I#3\xBC\"\"5%7\xBD./ &3\xBE\"\"5\"7\xBF.# &;6/($8\":\xC0\"! )(\"'#&'#"),
        peg$decode("%3\xC1\"\"5'7\xC2/1#;\x90/($8\":\xC3\"! )(\"'#&'#"),
        peg$decode("%3\xC4\"\"5$7\xC5/1#;\xF0/($8\":\xC6\"! )(\"'#&'#"),
        peg$decode("%3\xC7\"\"5&7\xC8/1#;T/($8\":\xC9\"! )(\"'#&'#"),
        peg$decode("%3\xCA\"\"5\"7\xCB/N#%2>\"\"6>7?/,#;6/#$+\")(\"'#&'#.\" &\"/'$8\":\xCC\" )(\"'#&'#"),
        peg$decode("%;h/P#%2>\"\"6>7?/,#;i/#$+\")(\"'#&'#.\" &\"/)$8\":\xCD\"\"! )(\"'#&'#"),
        peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
        peg$decode("%$;j/&#0#*;j&&&#/\"!&,)"),
        peg$decode(";k.) &;+.# &;-"),
        peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &28\"\"6879.A &2<\"\"6<7=.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
        peg$decode("%26\"\"6677/n#;m/e$$%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#0<*%2<\"\"6<7=/,#;m/#$+\")(\"'#&'#&/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;n/A#2>\"\"6>7?/2$;o/)$8#:\xCE#\"\" )(#'#(\"'#&'#"),
        peg$decode("$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#"),
        peg$decode("$;p.) &;+.# &;-0/*;p.) &;+.# &;-&"),
        peg$decode("2l\"\"6l7m.e &2n\"\"6n7o.Y &24\"\"6475.M &26\"\"6677.A &28\"\"6879.5 &2@\"\"6@7A.) &2B\"\"6B7C"),
        peg$decode(";\x91.# &;r"),
        peg$decode("%;\x90/G#;'/>$;s/5$;'/,$;\x84/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";M.# &;t"),
        peg$decode("%;\x7F/E#28\"\"6879/6$;u.# &;x/'$8#:\xCF# )(#'#(\"'#&'#"),
        peg$decode("%;v.# &;w/J#%26\"\"6677/,#;\x83/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%2\xD0\"\"6\xD07\xD1/:#;\x80/1$;w.\" &\"/#$+#)(#'#(\"'#&'#"),
        peg$decode("%24\"\"6475/,#;{/#$+\")(\"'#&'#"),
        peg$decode("%;z/3#$;y0#*;y&/#$+\")(\"'#&'#"),
        peg$decode(";*.) &;+.# &;-"),
        peg$decode(";+.\x8F &;-.\x89 &22\"\"6273.} &26\"\"6677.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode("%;|/e#$%24\"\"6475/,#;|/#$+\")(\"'#&'#0<*%24\"\"6475/,#;|/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;~0#*;~&/e#$%22\"\"6273/,#;}/#$+\")(\"'#&'#0<*%22\"\"6273/,#;}/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("$;~0#*;~&"),
        peg$decode(";+.w &;-.q &28\"\"6879.e &2:\"\"6:7;.Y &2<\"\"6<7=.M &2>\"\"6>7?.A &2@\"\"6@7A.5 &2B\"\"6B7C.) &2D\"\"6D7E"),
        peg$decode("%%;\"/\x87#$;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K0M*;\".G &;!.A &2@\"\"6@7A.5 &2F\"\"6F7G.) &2J\"\"6J7K&/#$+\")(\"'#&'#/& 8!:\xD2! )"),
        peg$decode(";\x81.# &;\x82"),
        peg$decode("%%;O/2#2:\"\"6:7;/#$+\")(\"'#&'#.\" &\"/,#;S/#$+\")(\"'#&'#.\" &\""),
        peg$decode("$;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A/\x8C#0\x89*;+.\x83 &;-.} &2B\"\"6B7C.q &2D\"\"6D7E.e &22\"\"6273.Y &28\"\"6879.M &2:\"\"6:7;.A &2<\"\"6<7=.5 &2>\"\"6>7?.) &2@\"\"6@7A&&&#"),
        peg$decode("$;y0#*;y&"),
        peg$decode("%3\x92\"\"5#7\xD3/q#24\"\"6475/b$$;!/&#0#*;!&&&#/L$2J\"\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\xD4% )(%'#($'#(#'#(\"'#&'#"),
        peg$decode("2\xD5\"\"6\xD57\xD6"),
        peg$decode("2\xD7\"\"6\xD77\xD8"),
        peg$decode("2\xD9\"\"6\xD97\xDA"),
        peg$decode("2\xDB\"\"6\xDB7\xDC"),
        peg$decode("2\xDD\"\"6\xDD7\xDE"),
        peg$decode("2\xDF\"\"6\xDF7\xE0"),
        peg$decode("2\xE1\"\"6\xE17\xE2"),
        peg$decode("2\xE3\"\"6\xE37\xE4"),
        peg$decode("2\xE5\"\"6\xE57\xE6"),
        peg$decode("2\xE7\"\"6\xE77\xE8"),
        peg$decode("2\xE9\"\"6\xE97\xEA"),
        peg$decode("%;\x85.Y &;\x86.S &;\x88.M &;\x89.G &;\x8A.A &;\x8B.; &;\x8C.5 &;\x8F./ &;\x8D.) &;\x8E.# &;6/& 8!:\xEB! )"),
        peg$decode("%;\x84/G#;'/>$;\x92/5$;'/,$;\x94/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%;\x93/' 8!:\xEC!! )"),
        peg$decode("%;!/5#;!/,$;!/#$+#)(#'#(\"'#&'#"),
        peg$decode("%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\xED! )"),
        peg$decode("%;\xB6/Y#$%;A/,#;\xB6/#$+\")(\"'#&'#06*%;A/,#;\xB6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;9/N#%2:\"\"6:7;/,#;9/#$+\")(\"'#&'#.\" &\"/'$8\":\xEE\" )(\"'#&'#"),
        peg$decode("%;:.c &%;\x98/Y#$%;A/,#;\x98/#$+\")(\"'#&'#06*%;A/,#;\x98/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/& 8!:\xEF! )"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\x9B/#$+\")(\"'#&'#06*%;B/,#;\x9B/#$+\")(\"'#&'#&/'$8\":\xF0\" )(\"'#&'#"),
        peg$decode("%;\x9A.\" &\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%%;6/Y#$%;./,#;6/#$+\")(\"'#&'#06*%;./,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#.# &;H/' 8!:\xF1!! )"),
        peg$decode(";\x9C.) &;\x9D.# &;\xA0"),
        peg$decode("%3\xF2\"\"5!7\xF3/:#;</1$;\x9F/($8#:\xF4#! )(#'#(\"'#&'#"),
        peg$decode("%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\xF7#! )(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\xF8!! )"),
        peg$decode("%2\xF9\"\"6\xF97\xFA/o#%2J\"\"6J7K/M#;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+$)($'#(#'#(\"'#&'#.\" &\"/'$8\":\xFB\" )(\"'#&'#"),
        peg$decode("%;6/J#%;</,#;\xA1/#$+\")(\"'#&'#.\" &\"/)$8\":\xFC\"\"! )(\"'#&'#"),
        peg$decode(";6.) &;T.# &;H"),
        peg$decode("%;\xA3/Y#$%;B/,#;\xA4/#$+\")(\"'#&'#06*%;B/,#;\xA4/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%3\xFD\"\"5&7\xFE.G &3\xFF\"\"5'7\u0100.; &3\u0101\"\"5$7\u0102./ &3\u0103\"\"5%7\u0104.# &;6/& 8!:\u0105! )"),
        peg$decode(";\xA5.# &;\xA0"),
        peg$decode("%3\u0106\"\"5(7\u0107/M#;</D$3\u0108\"\"5(7\u0109./ &3\u010A\"\"5(7\u010B.# &;6/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u010C!! )"),
        peg$decode("%;\xA9/& 8!:\u010D! )"),
        peg$decode("%;\xAA/k#;;/b$;\xAF/Y$$%;B/,#;\xB0/#$+\")(\"'#&'#06*%;B/,#;\xB0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\xAB.# &;\xAC"),
        peg$decode("3\u010E\"\"5$7\u010F.S &3\u0110\"\"5%7\u0111.G &3\u0112\"\"5%7\u0113.; &3\u0114\"\"5%7\u0115./ &3\u0116\"\"5+7\u0117.# &;\xAD"),
        peg$decode("3\u0118\"\"5'7\u0119./ &3\u011A\"\"5)7\u011B.# &;\xAD"),
        peg$decode(";6.# &;\xAE"),
        peg$decode("%3\u011C\"\"5\"7\u011D/,#;6/#$+\")(\"'#&'#"),
        peg$decode(";\xAD.# &;6"),
        peg$decode("%;6/5#;</,$;\xB1/#$+#)(#'#(\"'#&'#"),
        peg$decode(";6.# &;H"),
        peg$decode("%;\xB3/5#;./,$;\x90/#$+#)(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u011E!! )"),
        peg$decode("%;\x9E/' 8!:\u011F!! )"),
        peg$decode("%;\xB6/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u0120\"!!)(\"'#&'#"),
        peg$decode("%%;7/e#$%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#0<*%2J\"\"6J7K/,#;7/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/\"!&,)"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\xB8/#$+\")(\"'#&'#06*%;B/,#;\xB8/#$+\")(\"'#&'#&/'$8\":\u0121\" )(\"'#&'#"),
        peg$decode(";\xB9.# &;\xA0"),
        peg$decode("%3\u0122\"\"5#7\u0123/:#;</1$;6/($8#:\u0124#! )(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u0125!! )"),
        peg$decode("%;\x9E/' 8!:\u0126!! )"),
        peg$decode("%$;\x9A0#*;\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8%:\u0127% )(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";\xBE"),
        peg$decode("%3\u0128\"\"5&7\u0129/k#;./b$;\xC1/Y$$%;A/,#;\xC1/#$+\")(\"'#&'#06*%;A/,#;\xC1/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#.# &;\xBF"),
        peg$decode("%;6/k#;./b$;\xC0/Y$$%;A/,#;\xC0/#$+\")(\"'#&'#06*%;A/,#;\xC0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;6/;#;</2$;6.# &;H/#$+#)(#'#(\"'#&'#"),
        peg$decode(";\xC2.G &;\xC4.A &;\xC6.; &;\xC8.5 &;\xC9./ &;\xCA.) &;\xCB.# &;\xC0"),
        peg$decode("%3\u012A\"\"5%7\u012B/5#;</,$;\xC3/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;I/' 8!:\u012C!! )"),
        peg$decode("%3\u012D\"\"5&7\u012E/\x97#;</\x8E$;D/\x85$;\xC5/|$$%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\xC5/#$+\")(\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode(";t.# &;w"),
        peg$decode("%3\u012F\"\"5%7\u0130/5#;</,$;\xC7/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;I/' 8!:\u0131!! )"),
        peg$decode("%3\u0132\"\"5&7\u0133/:#;</1$;I/($8#:\u0134#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0135\"\"5%7\u0136/]#;</T$%3\u0137\"\"5$7\u0138/& 8!:\u0139! ).4 &%3\u013A\"\"5%7\u013B/& 8!:\u013C! )/#$+#)(#'#(\"'#&'#"),
        peg$decode("%3\u013D\"\"5)7\u013E/R#;</I$3\u013F\"\"5#7\u0140./ &3\u0141\"\"5(7\u0142.# &;6/($8#:\u0143#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0144\"\"5#7\u0145/\x93#;</\x8A$;D/\x81$%;\xCC/e#$%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#0<*%2D\"\"6D7E/,#;\xCC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\u0146\"\"5(7\u0147./ &3\u0148\"\"5$7\u0149.# &;6/' 8!:\u014A!! )"),
        peg$decode("%;6/Y#$%;A/,#;6/#$+\")(\"'#&'#06*%;A/,#;6/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\xCF/G#;./>$;\xCF/5$;./,$;\x90/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u014B!! )"),
        peg$decode("%;\xD1/]#$%;A/,#;\xD1/#$+\")(\"'#&'#06*%;A/,#;\xD1/#$+\")(\"'#&'#&/'$8\":\u014C\" )(\"'#&'#"),
        peg$decode("%;\x99/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014D\" )(\"'#&'#"),
        peg$decode("%;L.O &;\x99.I &%;@.\" &\"/:#;t/1$;?.\" &\"/#$+#)(#'#(\"'#&'#/]#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/'$8\":\u014E\" )(\"'#&'#"),
        peg$decode("%;\xD4/]#$%;B/,#;\xD5/#$+\")(\"'#&'#06*%;B/,#;\xD5/#$+\")(\"'#&'#&/'$8\":\u014F\" )(\"'#&'#"),
        peg$decode("%;\x96/& 8!:\u0150! )"),
        peg$decode("%3\u0151\"\"5(7\u0152/:#;</1$;6/($8#:\u0153#! )(#'#(\"'#&'#.g &%3\u0154\"\"5&7\u0155/:#;</1$;6/($8#:\u0156#! )(#'#(\"'#&'#.: &%3\u0157\"\"5*7\u0158/& 8!:\u0159! ).# &;\xA0"),
        peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u015C!! )"),
        peg$decode("%;\xD8/Y#$%;A/,#;\xD8/#$+\")(\"'#&'#06*%;A/,#;\xD8/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\x99/Y#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%$;!/&#0#*;!&&&#/' 8!:\u015D!! )"),
        peg$decode("%;\xDB/Y#$%;B/,#;\xDC/#$+\")(\"'#&'#06*%;B/,#;\xDC/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%3\u015E\"\"5&7\u015F.; &3\u0160\"\"5'7\u0161./ &3\u0162\"\"5*7\u0163.# &;6/& 8!:\u0164! )"),
        peg$decode("%3\u0165\"\"5&7\u0166/:#;</1$;\xDD/($8#:\u0167#! )(#'#(\"'#&'#.} &%3\xF5\"\"5'7\xF6/:#;</1$;\x9E/($8#:\u0168#! )(#'#(\"'#&'#.P &%3\u0169\"\"5+7\u016A/:#;</1$;\x9E/($8#:\u016B#! )(#'#(\"'#&'#.# &;\xA0"),
        peg$decode("3\u016C\"\"5+7\u016D.k &3\u016E\"\"5)7\u016F._ &3\u0170\"\"5(7\u0171.S &3\u0172\"\"5'7\u0173.G &3\u0174\"\"5&7\u0175.; &3\u0176\"\"5*7\u0177./ &3\u0178\"\"5)7\u0179.# &;6"),
        peg$decode(";1.\" &\""),
        peg$decode("%%;6/k#$%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#0<*%;A/2#;6/)$8\":\u015A\"\"$ )(\"'#&'#&/)$8\":\u015B\"\"! )(\"'#&'#.\" &\"/' 8!:\u017A!! )"),
        peg$decode("%;L.# &;\x99/]#$%;B/,#;\xE1/#$+\")(\"'#&'#06*%;B/,#;\xE1/#$+\")(\"'#&'#&/'$8\":\u017B\" )(\"'#&'#"),
        peg$decode(";\xB9.# &;\xA0"),
        peg$decode("%;\xE3/Y#$%;A/,#;\xE3/#$+\")(\"'#&'#06*%;A/,#;\xE3/#$+\")(\"'#&'#&/#$+\")(\"'#&'#"),
        peg$decode("%;\xEA/k#;./b$;\xED/Y$$%;B/,#;\xE4/#$+\")(\"'#&'#06*%;B/,#;\xE4/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\xE5.; &;\xE6.5 &;\xE7./ &;\xE8.) &;\xE9.# &;\xA0"),
        peg$decode("%3\u017C\"\"5#7\u017D/:#;</1$;\xF0/($8#:\u017E#! )(#'#(\"'#&'#"),
        peg$decode("%3\u017F\"\"5%7\u0180/:#;</1$;T/($8#:\u0181#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0182\"\"5(7\u0183/F#;</=$;\\.) &;Y.# &;X/($8#:\u0184#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0185\"\"5&7\u0186/:#;</1$;6/($8#:\u0187#! )(#'#(\"'#&'#"),
        peg$decode("%3\u0188\"\"5%7\u0189/A#;</8$$;!0#*;!&/($8#:\u018A#! )(#'#(\"'#&'#"),
        peg$decode("%;\xEB/G#;;/>$;6/5$;;/,$;\xEC/#$+%)(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%3\x92\"\"5#7\xD3.# &;6/' 8!:\u018B!! )"),
        peg$decode("%3\xB1\"\"5#7\u018C.G &3\xB3\"\"5#7\u018D.; &3\xB7\"\"5#7\u018E./ &3\xB5\"\"5$7\u018F.# &;6/' 8!:\u0190!! )"),
        peg$decode("%;\xEE/D#%;C/,#;\xEF/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;U.) &;\\.# &;X/& 8!:\u0191! )"),
        peg$decode("%%;!.\" &\"/[#;!.\" &\"/M$;!.\" &\"/?$;!.\" &\"/1$;!.\" &\"/#$+%)(%'#($'#(#'#(\"'#&'#/' 8!:\u0192!! )"),
        peg$decode("%%;!/?#;!.\" &\"/1$;!.\" &\"/#$+#)(#'#(\"'#&'#/' 8!:\u0193!! )"),
        peg$decode(";\xBE"),
        peg$decode("%;\x9E/^#$%;B/,#;\xF3/#$+\")(\"'#&'#06*%;B/,#;\xF3/#$+\")(\"'#&'#&/($8\":\u0194\"!!)(\"'#&'#"),
        peg$decode(";\xF4.# &;\xA0"),
        peg$decode("%2\u0195\"\"6\u01957\u0196/L#;</C$2\u0197\"\"6\u01977\u0198.) &2\u0199\"\"6\u01997\u019A/($8#:\u019B#! )(#'#(\"'#&'#"),
        peg$decode("%;\x9E/^#$%;B/,#;\xA0/#$+\")(\"'#&'#06*%;B/,#;\xA0/#$+\")(\"'#&'#&/($8\":\u019C\"!!)(\"'#&'#"),
        peg$decode("%;6/5#;0/,$;\xF7/#$+#)(#'#(\"'#&'#"),
        peg$decode("$;2.) &;4.# &;.0/*;2.) &;4.# &;.&"),
        peg$decode("$;%0#*;%&"),
        peg$decode("%;\xFA/;#28\"\"6879/,$;\xFB/#$+#)(#'#(\"'#&'#"),
        peg$decode("%3\u019D\"\"5%7\u019E.) &3\u019F\"\"5$7\u01A0/' 8!:\u01A1!! )"),
        peg$decode("%;\xFC/J#%28\"\"6879/,#;^/#$+\")(\"'#&'#.\" &\"/#$+\")(\"'#&'#"),
        peg$decode("%;\\.) &;X.# &;\x82/' 8!:\u01A2!! )"),
        peg$decode(";\".S &;!.M &2F\"\"6F7G.A &2J\"\"6J7K.5 &2H\"\"6H7I.) &2N\"\"6N7O"),
        peg$decode("2L\"\"6L7M.\x95 &2B\"\"6B7C.\x89 &2<\"\"6<7=.} &2R\"\"6R7S.q &2T\"\"6T7U.e &2V\"\"6V7W.Y &2P\"\"6P7Q.M &2@\"\"6@7A.A &2D\"\"6D7E.5 &22\"\"6273.) &2>\"\"6>7?"),
        peg$decode("%;\u0100/b#28\"\"6879/S$;\xFB/J$%2\u01A3\"\"6\u01A37\u01A4/,#;\xEC/#$+\")(\"'#&'#.\" &\"/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%3\u01A5\"\"5%7\u01A6.) &3\u01A7\"\"5$7\u01A8/' 8!:\u01A1!! )"),
        peg$decode("%3\xB1\"\"5#7\xB2.6 &3\xB3\"\"5#7\xB4.* &$;+0#*;+&/' 8!:\u01A9!! )"),
        peg$decode("%;\u0104/\x87#2F\"\"6F7G/x$;\u0103/o$2F\"\"6F7G/`$;\u0103/W$2F\"\"6F7G/H$;\u0103/?$2F\"\"6F7G/0$;\u0105/'$8):\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
        peg$decode("%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode("%;\u0103/,#;\u0103/#$+\")(\"'#&'#"),
        peg$decode("%;\u0103/5#;\u0103/,$;\u0103/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;q/T#$;m0#*;m&/D$%; /,#;\xF8/#$+\")(\"'#&'#.\" &\"/#$+#)(#'#(\"'#&'#"),
        peg$decode("%2\u01AB\"\"6\u01AB7\u01AC.) &2\u01AD\"\"6\u01AD7\u01AE/w#;0/n$;\u0108/e$$%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#0<*%;B/2#;\u0109.# &;\xA0/#$+\")(\"'#&'#&/#$+$)($'#(#'#(\"'#&'#"),
        peg$decode(";\x99.# &;L"),
        peg$decode("%2\u01AF\"\"6\u01AF7\u01B0/5#;</,$;\u010A/#$+#)(#'#(\"'#&'#"),
        peg$decode("%;D/S#;,/J$2:\"\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\"'#&'#")
    ];
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [{ line: 1, column: 1 }];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if (options.startRule !== undefined) {
        if (!(options.startRule in peg$startRuleIndices)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }
        peg$startRuleIndex = peg$startRuleIndices[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location1);
    }
    function error(message, location1) {
        location1 = location1 !== undefined
            ? location1
            : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location1);
    }
    function peg$literalExpectation(text1, ignoreCase) {
        return { type: "literal", text: text1, ignoreCase: ignoreCase };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }
    function peg$anyExpectation() {
        return { type: "any" };
    }
    function peg$endExpectation() {
        return { type: "end" };
    }
    function peg$otherExpectation(description) {
        return { type: "other", description: description };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) {
            return details;
        }
        else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
                p--;
            }
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                }
                else {
                    details.column++;
                }
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        return {
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
    }
    function peg$fail(expected1) {
        if (peg$currPos < peg$maxFailPos) {
            return;
        }
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected1);
    }
    function peg$buildSimpleError(message, location1) {
        return new SyntaxError(message, [], "", location1);
    }
    function peg$buildStructuredError(expected1, found, location1) {
        return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
    }
    function peg$decode(s) {
        return s.split("").map(function (ch) { return ch.charCodeAt(0) - 32; });
    }
    function peg$parseRule(index) {
        var bc = peg$bytecode[index];
        var ip = 0;
        var ips = [];
        var end = bc.length;
        var ends = [];
        var stack = [];
        var params;
        while (true) {
            while (ip < end) {
                switch (bc[ip]) {
                    case 0:
                        stack.push(peg$consts[bc[ip + 1]]);
                        ip += 2;
                        break;
                    case 1:
                        stack.push(undefined);
                        ip++;
                        break;
                    case 2:
                        stack.push(null);
                        ip++;
                        break;
                    case 3:
                        stack.push(peg$FAILED);
                        ip++;
                        break;
                    case 4:
                        stack.push([]);
                        ip++;
                        break;
                    case 5:
                        stack.push(peg$currPos);
                        ip++;
                        break;
                    case 6:
                        stack.pop();
                        ip++;
                        break;
                    case 7:
                        peg$currPos = stack.pop();
                        ip++;
                        break;
                    case 8:
                        stack.length -= bc[ip + 1];
                        ip += 2;
                        break;
                    case 9:
                        stack.splice(-2, 1);
                        ip++;
                        break;
                    case 10:
                        stack[stack.length - 2].push(stack.pop());
                        ip++;
                        break;
                    case 11:
                        stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                        ip += 2;
                        break;
                    case 12:
                        stack.push(input.substring(stack.pop(), peg$currPos));
                        ip++;
                        break;
                    case 13:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1]) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 14:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1] === peg$FAILED) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 15:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (stack[stack.length - 1] !== peg$FAILED) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 16:
                        if (stack[stack.length - 1] !== peg$FAILED) {
                            ends.push(end);
                            ips.push(ip);
                            end = ip + 2 + bc[ip + 1];
                            ip += 2;
                        }
                        else {
                            ip += 2 + bc[ip + 1];
                        }
                        break;
                    case 17:
                        ends.push(end);
                        ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                        if (input.length > peg$currPos) {
                            end = ip + 3 + bc[ip + 1];
                            ip += 3;
                        }
                        else {
                            end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                            ip += 3 + bc[ip + 1];
                        }
                        break;
                    case 18:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 19:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 20:
                        ends.push(end);
                        ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                        if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                            end = ip + 4 + bc[ip + 2];
                            ip += 4;
                        }
                        else {
                            end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                            ip += 4 + bc[ip + 2];
                        }
                        break;
                    case 21:
                        stack.push(input.substr(peg$currPos, bc[ip + 1]));
                        peg$currPos += bc[ip + 1];
                        ip += 2;
                        break;
                    case 22:
                        stack.push(peg$consts[bc[ip + 1]]);
                        peg$currPos += peg$consts[bc[ip + 1]].length;
                        ip += 2;
                        break;
                    case 23:
                        stack.push(peg$FAILED);
                        if (peg$silentFails === 0) {
                            peg$fail(peg$consts[bc[ip + 1]]);
                        }
                        ip += 2;
                        break;
                    case 24:
                        peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                        ip += 2;
                        break;
                    case 25:
                        peg$savedPos = peg$currPos;
                        ip++;
                        break;
                    case 26:
                        params = bc.slice(ip + 4, ip + 4 + bc[ip + 3])
                            .map(function (p) { return stack[stack.length - 1 - p]; });
                        stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
                        ip += 4 + bc[ip + 3];
                        break;
                    case 27:
                        stack.push(peg$parseRule(bc[ip + 1]));
                        ip += 2;
                        break;
                    case 28:
                        peg$silentFails++;
                        ip++;
                        break;
                    case 29:
                        peg$silentFails--;
                        ip++;
                        break;
                    default:
                        throw new Error("Invalid opcode: " + bc[ip] + ".");
                }
            }
            if (ends.length > 0) {
                end = ends.pop();
                ip = ips.pop();
            }
            else {
                break;
            }
        }
        return stack[0];
    }
    options.data = {}; // Object to which header attributes will be assigned during parsing
    function list(head, tail) {
        return [head].concat(tail);
    }
    peg$result = peg$parseRule(peg$startRuleIndex);
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
        return peg$result;
    }
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
            ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
            : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}
exports.parse = peg$parse;


/***/ }),

/***/ "./node_modules/sip.js/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/sip.js/lib/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var core_1 = __webpack_require__(/*! ./core */ "./node_modules/sip.js/lib/core/index.js");
exports.DigestAuthentication = core_1.DigestAuthentication;
exports.Grammar = core_1.Grammar;
exports.IncomingRequest = core_1.IncomingRequestMessage;
exports.IncomingResponse = core_1.IncomingResponseMessage;
exports.LoggerFactory = core_1.LoggerFactory;
exports.NameAddrHeader = core_1.NameAddrHeader;
exports.OutgoingRequest = core_1.OutgoingRequestMessage;
exports.Parser = core_1.Parser;
exports.Timers = core_1.Timers;
exports.URI = core_1.URI;
var ClientContext_1 = __webpack_require__(/*! ./ClientContext */ "./node_modules/sip.js/lib/ClientContext.js");
exports.ClientContext = ClientContext_1.ClientContext;
var Constants_1 = __webpack_require__(/*! ./Constants */ "./node_modules/sip.js/lib/Constants.js");
exports.C = Constants_1.C;
var Enums_1 = __webpack_require__(/*! ./Enums */ "./node_modules/sip.js/lib/Enums.js");
exports.DialogStatus = Enums_1.DialogStatus;
exports.SessionStatus = Enums_1.SessionStatus;
exports.TypeStrings = Enums_1.TypeStrings;
exports.UAStatus = Enums_1.UAStatus;
var Exceptions_1 = __webpack_require__(/*! ./Exceptions */ "./node_modules/sip.js/lib/Exceptions.js");
exports.Exceptions = Exceptions_1.Exceptions;
var PublishContext_1 = __webpack_require__(/*! ./PublishContext */ "./node_modules/sip.js/lib/PublishContext.js");
exports.PublishContext = PublishContext_1.PublishContext;
var ReferContext_1 = __webpack_require__(/*! ./ReferContext */ "./node_modules/sip.js/lib/ReferContext.js");
exports.ReferClientContext = ReferContext_1.ReferClientContext;
exports.ReferServerContext = ReferContext_1.ReferServerContext;
var RegisterContext_1 = __webpack_require__(/*! ./RegisterContext */ "./node_modules/sip.js/lib/RegisterContext.js");
exports.RegisterContext = RegisterContext_1.RegisterContext;
var ServerContext_1 = __webpack_require__(/*! ./ServerContext */ "./node_modules/sip.js/lib/ServerContext.js");
exports.ServerContext = ServerContext_1.ServerContext;
var Session_1 = __webpack_require__(/*! ./Session */ "./node_modules/sip.js/lib/Session.js");
exports.InviteClientContext = Session_1.InviteClientContext;
exports.InviteServerContext = Session_1.InviteServerContext;
exports.Session = Session_1.Session;
var Subscription_1 = __webpack_require__(/*! ./Subscription */ "./node_modules/sip.js/lib/Subscription.js");
exports.Subscription = Subscription_1.Subscription;
var Transport_1 = __webpack_require__(/*! ./Transport */ "./node_modules/sip.js/lib/Transport.js");
exports.Transport = Transport_1.Transport;
var transactions_1 = __webpack_require__(/*! ./core/transactions */ "./node_modules/sip.js/lib/core/transactions/index.js");
var Transactions = {
    InviteClientTransaction: transactions_1.InviteClientTransaction,
    InviteServerTransaction: transactions_1.InviteServerTransaction,
    NonInviteClientTransaction: transactions_1.NonInviteClientTransaction,
    NonInviteServerTransaction: transactions_1.NonInviteServerTransaction
};
exports.Transactions = Transactions;
var UA_1 = __webpack_require__(/*! ./UA */ "./node_modules/sip.js/lib/UA.js");
exports.makeUserAgentCoreConfigurationFromUA = UA_1.makeUserAgentCoreConfigurationFromUA;
exports.UA = UA_1.UA;
var Utils_1 = __webpack_require__(/*! ./Utils */ "./node_modules/sip.js/lib/Utils.js");
exports.Utils = Utils_1.Utils;
var Web = tslib_1.__importStar(__webpack_require__(/*! ./Web/index */ "./node_modules/sip.js/lib/Web/index.js"));
exports.Web = Web;
var version = Constants_1.C.version;
exports.version = version;
var name = "sip.js";
exports.name = name;
var Core = tslib_1.__importStar(__webpack_require__(/*! ./core/index */ "./node_modules/sip.js/lib/core/index.js"));
exports.Core = Core;


/***/ }),

/***/ "./node_modules/sip.js/lib/version.js":
/*!********************************************!*\
  !*** ./node_modules/sip.js/lib/version.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LIBRARY_VERSION = "0.15.11";


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__extends", function() { return __extends; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__rest", function() { return __rest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__decorate", function() { return __decorate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__param", function() { return __param; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__metadata", function() { return __metadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__awaiter", function() { return __awaiter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__generator", function() { return __generator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__createBinding", function() { return __createBinding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__exportStar", function() { return __exportStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__values", function() { return __values; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__read", function() { return __read; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spread", function() { return __spread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__spreadArrays", function() { return __spreadArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__await", function() { return __await; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function() { return __asyncGenerator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function() { return __asyncDelegator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__asyncValues", function() { return __asyncValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function() { return __makeTemplateObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importStar", function() { return __importStar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__importDefault", function() { return __importDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function() { return __classPrivateFieldGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function() { return __classPrivateFieldSet; });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./src/clv-sipjs.js":
/*!**************************!*\
  !*** ./src/clv-sipjs.js ***!
  \**************************/
/*! exports provided: clvDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_clv_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/clv-device */ "./src/lib/clv-device.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clvDevice", function() { return _lib_clv_device__WEBPACK_IMPORTED_MODULE_0__["clvDevice"]; });




/***/ }),

/***/ "./src/lib/clv-call.js":
/*!*****************************!*\
  !*** ./src/lib/clv-call.js ***!
  \*****************************/
/*! exports provided: clvCall */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(SIP) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clvCall", function() { return clvCall; });
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! es6-event-emitter */ "./node_modules/es6-event-emitter/dist/emitter.js");
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(es6_event_emitter__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }


var clvCall = /*#__PURE__*/function (_EventEmitter) {
  _inherits(clvCall, _EventEmitter);

  var _super = _createSuper(clvCall);

  /**
  * Create a clvCall. Normally created by clvDevice.
  *
  * Once a call is created, you can either make a call with `makeCall()`
  * or set yourself up to recieve an incoming call with `incomingCall()`
  *
  * @param {UA} UA - A SIP.js User Agent
  * @param {String} inviteUri - A Properly formatted SIP.js invite URI (create with SIP.URI)
  *
  * @emits clvCall#connecting
  */
  function clvCall(UA) {
    var _this;

    _classCallCheck(this, clvCall);

    _this = _super.call(this);
    _this._mute = false;
    _this._status = 'starting';
    _this._callType = '';
    _this.UA = UA;
    _this._docBody = document.getElementsByTagName('body')[0];
    _this.audioElement = false;

    _this.UA.start();

    return _this;
  }
  /**
  * Make a call to a phone number
  *
  * @param {URI} inviteUri - A SIP.js URI that includes the phone number to connect to
  */


  _createClass(clvCall, [{
    key: "makeCall",
    value: function makeCall(inviteUri) {
      this._callType = 'outgoing';
      this._session = this.UA.invite(inviteUri, this._getAudioElement());

      this._attatchSessionEvents(this._session);
    }
    /**
    * Set up to handle an incoming call.
    * The calling function will then be able to accept or reject the call.
    *
    * @param {Session} session - A SIP.js Session, specifically of the SIP.ServerContext type
    */

  }, {
    key: "incomingCall",
    value: function incomingCall(session) {
      this._callType = 'incoming';
      this._session = session;

      this._attatchSessionEvents();
    }
  }, {
    key: "_getAudioElement",
    value: function _getAudioElement() {
      if (!this.audioElement) {
        console.log("this.audioElement", this.audioElement);
        this.audioElement = document.createElement('audio');
        this.audioElement.className = 'clv-sipjs-remote-audio';

        this._docBody.appendChild(this.audioElement);
      }

      return this.audioElement;
    }
  }, {
    key: "_attatchSessionEvents",
    value: function _attatchSessionEvents(session) {
      var _this2 = this;

      /**
      * connecting event:
      *
      * Fired as the system starts to make the connection.
      * This is after the userMedia (microphone) has been aquired.
      *
      * @event clvCall#connecting
      * @type {object}
      */
      this._session.on("connecting", function () {
        _this2.trigger("connecting");

        _this2._status = 'initiating';
      });
      /**
      * progress event:
      *
      * Usually fired twice during call intialization, once for TRYING and once for RINGING.
      *
      * @event clvCall#progress
      * @type {object}
      * @property {object} response - Details of the response
      */


      this._session.on("progress", function (response) {
        if (response.statusCode == 183 && response.body && _this2._session.hasOffer && !_this2._session.dialog) {
          if (!response.hasHeader('require') || response.getHeader('require').indexOf('100rel') === -1) {
            if (_this2._session.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {
              // @hack: https://github.com/onsip/SIP.js/issues/242
              _this2._session.status = SIP.Session.C.STATUS_EARLY_MEDIA; // this._waitingForApplyingAnswer(session, response)
            }
          }
        }

        _this2.trigger("progress", response);
      });
      /**
      * accepted event:
      *
      * Fired when the call was accepted by the callee. The call is now connected.
      *
      * @event clvCall#accepted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("accepted", function (data) {
        _this2.trigger("accepted", data), _this2._status = 'connected';
      });
      /**
      * dtmf event:
      *
      * Sent when the user has successfully sent a DTMF (keypad) signal.
      *
      * @event clvCall#dtmf
      * @type {object}
      * @property {object} request - Details of the request
      * @property {string} dtmf - the key(s) that were submitted
      */


      this._session.on("dtmf", function (request, dtmf) {
        return _this2.trigger("dtmf", request, dtmf);
      });
      /**
      * muted event:
      *
      * Fired when the system has successfully responded to a mute request.
      *
      * @event clvCall#muted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("muted", function (data) {
        return _this2.trigger("muted", data);
      });
      /**
      * unmuted event
      *
      * Fired when the system has successfully responded to an unmute request.
      *
      * @event clvCall#unmuted
      * @type {object}
      * @property {object} data - Details of the response
      */


      this._session.on("unmuted", function (data) {
        return _this2.trigger("unmuted", data);
      });
      /**
      * cancel event:
      *
      * Fired when the call was terminated before end to end connection was established,
      * usually by the user's request.
      *
      * @event clvCall#cancel
      */


      this._session.on("cancel", function () {
        _this2.trigger("cancel");

        _this2._status = 'ended';
      });
      /**
      * refer event
      *
      * @event clvCall#refer
      * @property {function} callback
      * @property {object} response
      * @property {object} newSession
      */


      this._session.on("refer", function (callback, response, newSession) {
        _this2.trigger("rejected");
      });
      /**
      * replaced event
      *
      * @event clvCall#replaced
      * @property {object} newSession
      */


      this._session.on("replaced", function (newSession) {
        _this2.trigger("rejected", newSession);
      });
      /**
      * rejected event
      *
      * @event clvCall#rejected
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("rejected", function (response, cause) {
        _this2.trigger("rejected", response, cause);

        _this2._status = 'ended';
      });
      /**
      * failed event
      *
      * @event clvCall#failed
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("failed", function (response, cause) {
        _this2.trigger("failed", response, cause);

        _this2._status = 'ended';
      });
      /**
      * terminated event
      *
      * @event clvCall#terminated
      * @property {object} response
      * @property {object} cause
      */


      this._session.on("terminated", function (message, cause) {
        _this2.trigger("terminated", message, cause);

        _this2._status = 'ended';
      });
      /**
      * bye event
      *
      * @event clvCall#bye
      */


      this._session.on("bye", function () {
        _this2.trigger("bye");

        _this2._status = 'ended';
      });
      /**
      * userMediaRequest event:
      *
      * Fired when the every time the system checks to see if it has microphone permission from the user.
      * You can use this to detect when the browser's "Allow website to use microphone" dialog is open,
      * but you will need to be somewhat careful. This event will fire even if the user already has
      * given permission, then will be immediately followed by a {@link clvCall#userMedia} event.
      * If you wish to have your UI display some sort of "asking for permission" element, you may need to
      * debounce this event; listening for {@link clvCall#userMedia} to cancel your UI update.
      *
      * @event clvCall#userMediaRequest
      * @property {object} constraints
      */


      this._session.on('trackAdded', function () {
        if (session) {
          var pc = session.sessionDescriptionHandler.peerConnection; // var this.audioElement = this.audioElement;
          // this.audioElement.className = 'clv-sipjs-remote-audio';

          var remoteStream = new MediaStream();
          pc.getReceivers().forEach(function (receiver) {
            remoteStream.addTrack(receiver.track);
          });

          if (typeof session.passedOptions.srcObject !== 'undefined') {
            session.passedOptions.srcObject = remoteStream;
          } else if (typeof session.passedOptions.mozSrcObject !== 'undefined') {
            session.passedOptions.mozSrcObject = remoteStream;
          } else if (typeof session.passedOptions.src !== 'undefined') {
            session.passedOptions.src = URL.createObjectURL(remoteStream);
          } else {
            console.log('Error attaching stream to element.');
          }

          session.passedOptions.play();
        }
      }); // this._session.mediaHandler.on("userMediaRequest", (constraints) => {this.trigger("userMediaRequest", constraints);});
      // /**
      // * userMedia event:
      // *
      // * Fired when the system has aquired permission to use the microphone. This will happen either
      // * immediately after {@link clvCall#userMediaRequest} if the user has previously given permission
      // * or after the user approves the request.
      // *
      // * @event clvCall#userMedia
      // * @property {object} stream
      // */
      // this._session.mediaHandler.on("userMedia", (stream) => {this.trigger("userMedia", stream);});
      // /**
      // * userMediaFailed event:
      // *
      // * Fired when the user refuses permission to use the microphone. There is no way back from this
      // * except for the user to go into browser settings and remove the exception for your site.
      // *
      // * @event clvCall#userMediaFailed
      // * @property {object} error
      // */
      // this._session.mediaHandler.on("userMediaFailed", (error) => {this.trigger("userMediaFailed", error);});
      // /**
      // * iceGathering event
      // *
      // * @event clvCall#iceGathering
      // */
      // this._session.mediaHandler.on("iceGathering", () => {this.trigger("iceGathering");});
      // /**
      // * iceCandidate event
      // *
      // * @event clvCall#iceCandidate
      // * @property {object} candidate
      // */
      // this._session.mediaHandler.on("iceCandidate", (candidate) => {this.trigger("iceCandidate", candidate);});
      // /**
      // * iceGatheringComplete event
      // *
      // * @event clvCall#iceGatheringComplete
      // */
      // this._session.mediaHandler.on("iceGatheringComplete", () => {this.trigger("iceGatheringComplete");});
      // /**
      // * iceConnection event
      // *
      // * @event clvCall#iceConnection
      // */
      // this._session.mediaHandler.on("iceConnection", () => {this.trigger("iceConnection");});
      // /**
      // * iceConnectionChecking event
      // *
      // * @event clvCall#iceConnectionChecking
      // */
      // this._session.mediaHandler.on("iceConnectionChecking", () => {this.trigger("iceConnectionChecking");});
      // /**
      // * iceConnectionConnected event
      // *
      // * @event clvCall#iceConnectionConnected
      // */
      // this._session.mediaHandler.on("iceConnectionConnected", () => {this.trigger("iceConnectionConnected");});
      // /**
      // * iceConnectionCompleted event
      // *
      // * @event clvCall#iceConnectionCompleted
      // */
      // this._session.mediaHandler.on("iceConnectionCompleted", () => {this.trigger("iceConnectionCompleted");});
      // /**
      // * iceConnectionFailed event
      // *
      // * @event clvCall#iceConnectionFailed
      // */
      // this._session.mediaHandler.on("iceConnectionFailed", () => {this.trigger("iceConnectionFailed");});
      // /**
      // * iceConnectionDisconnected event
      // *
      // * @event clvCall#iceConnectionDisconnected
      // */
      // this._session.mediaHandler.on("iceConnectionDisconnected", () => {this.trigger("iceConnectionDisconnected");});
      // /**
      // * iceConnectionClosed event
      // *
      // * @event clvCall#iceConnectionClosed
      // */
      // this._session.mediaHandler.on("iceConnectionClosed", () => {this.trigger("iceConnectionClosed");});
      // /**
      // * getDescription event
      // *
      // * @event clvCall#getDescription
      // * @property {object} sdpWrapper
      // */
      // this._session.mediaHandler.on("getDescription", (sdpWrapper) => {this.trigger("getDescription", sdpWrapper);});
      // /**
      // * setDescription event
      // *
      // * @event clvCall#setDescription
      // * @property {object} sdpWrapper
      // */
      // this._session.mediaHandler.on("setDescription", (sdpWrapper) => {this.trigger("setDescription", sdpWrapper);});
      // /**
      // * dataChannel event
      // *
      // * @event clvCall#dataChannel
      // * @property {object} dataChannel
      // */
      // this._session.mediaHandler.on("dataChannel", (dataChannel) => {this.trigger("dataChannel", dataChannel);});
      // /**
      // * addStream event
      // *
      // * @event clvCall#addStream
      // * @property {object} stream
      // */
      // this._session.mediaHandler.on("addStream", (stream) => { this.trigger("addStream", stream); });

    }
    /**
     * Accept an incoming call.
     * When a call is received `clvDevice` will create a new `clvCall` for the session
     * and emit a `incomingInvite` event.
     * The new `clvCall` is passed along with the event. Call `accept()` to accept the call.
     */

  }, {
    key: "answer",
    value: function answer() {
      if (this._callType !== 'incoming') {
        console.error("accept() method is only valid on incoming calls");
        return;
      }

      this._session.accept({
        media: {
          constraints: {
            audio: true,
            video: false
          },
          render: {
            remote: this._getAudioElement()
          }
        },
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: false
          },
          render: {
            remote: this._getAudioElement()
          }
        }
      });

      this._attatchSessionEvents(this);
    }
    /**
     * Reject an incoming call.
     * When a call is received `clvDevice` will create a new `clvCall` for the session
     * and emit a `incomingInvite` event.
     * The new `clvCall` is passed along with the event. Call `reject()` to reject the call.
     */

  }, {
    key: "reject",
    value: function reject() {
      if (this._callType !== 'incoming') {
        console.error("reject() method is only valid on incoming calls");
        return;
      }

      this._session.reject();
    }
    /**
     * The request object contains metadata about the current session,
     * including the who the call is going `to` and in the case of incoming calls,
     * who the call is coming `from`.
     *
     * @return {object} request
     */

  }, {
    key: "request",
    get: function get() {
      if (!this._session) {
        return false;
      }

      if (this._callType === 'incoming') {
        return this._session.transaction.request;
      } else if (this._callType === 'outgoing') {
        return this._session.request;
      } else {
        return false;
      }
    }
    /**
    * Is the call still initiating?
    *
    * @return {Boolean} isInitiating
    */

  }, {
    key: "isInitiating",
    value: function isInitiating() {
      return this._status === 'initiating';
    }
    /**
    * Has the call connected?
    *
    * @return {Boolean} isConnected
    */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._status === 'connected';
    }
    /**
    * Has the call ended?
    *
    * @return {Boolean} isEnded
    */

  }, {
    key: "isEnded",
    value: function isEnded() {
      return this._status === 'ended';
    }
    /**
    * Is this an incoming call?
    *
    * @return {Boolean} isIncoming
    */

  }, {
    key: "isIncoming",
    value: function isIncoming() {
      return this._callType === 'incoming';
    }
    /**
    * Is this an outgoing call?
    *
    * @return {Boolean} isOutgoing
    */

  }, {
    key: "isOutgoing",
    value: function isOutgoing() {
      return this._callType === 'outgoing';
    }
    /**
    * End the session
    *
    * @emits clvCall#terminated
    */

  }, {
    key: "terminate",
    value: function terminate() {
      this._session.terminate();
    }
    /**
    * Shutdown the connection to the WebRTC servers
    * @deprecated Please use clvDevice.stopWS instead.
    */

  }, {
    key: "shutdown",
    value: function shutdown() {
      this.UA.stop();
    }
    /**
    * Toggle mute
    *
    * @param {boolean} isMute - if true you want mute to be ON
    */

  }, {
    key: "mute",
    value: function mute(isMute
    /*bool*/
    ) {
      this._mute = isMute;

      if (this._mute) {
        this._session.mute();
      } else {
        this._session.unmute();
      }
    }
    /**
    * Toggle hold
    *
    * @param {boolean} isHold - if true you want mute to be ON
    */

  }, {
    key: "hold",
    value: function hold(isHold
    /*bool*/
    ) {
      if (isHold) {
        this._session.hold();
      } else {
        this._session.unhold();
      }
    }
    /**
    * Current mute state
    *
    * @return {boolean} true if call is on mute
    */

  }, {
    key: "isMuted",
    value: function isMuted() {
      return this._mute;
    }
    /**
    * Send phone keypad presses (DTMF tones)
    *
    * Used after the call is in progress.
    *
    * @param {string} digits - a string containg digits 0-9, *, #
    * @emits clvCall#dtmf
    */

  }, {
    key: "sendDigits",
    value: function sendDigits(digits) {
      this._session.dtmf(digits);
    }
    /**
    * Send phone keypad presses (DTMF tones)
    *
    * Used after the call is in progress.
    *
    * @param {string} digits - a string containg digits 0-9, *, #
    * @emits clvCall#dtmf
    */

  }, {
    key: "refer",
    value: function refer(digits) {
      this._session.refer(digits);
    }
    /**
    * The "simple" status.
    *
    * All of the many phases of the call boiled down into 3 states: Initiating, Connected and Ended.
    *
    * @return {string} one of initiating, connected, ended
    */

  }, {
    key: "status",
    value: function status() {
      return this._status;
    }
  }, {
    key: "_waitingForApplyingAnswer",
    value: function _waitingForApplyingAnswer(session, response) {
      var i = 1,
          clearTimer;
      setTimeout(function check() {
        i++;
        clearTimer = setTimeout(check, 10);

        if (session && session.hasAnswer || i > 14) {
          if (session.hasAnswer) {
            clearTimeout(clearTimer);
          } else if (i === 15) {
            clearTimeout(clearTimer);
            session.sessionDescriptionHandler.setDescription(response.body)["catch"](function (error) {
              session.logger.warn(error);
              session.failed(response, C.causes.BAD_MEDIA_DESCRIPTION);
              session.terminate({
                statusCode: 488,
                reason_phrase: 'Bad Media Description'
              });
            });
          }
        }
      }, 10);
    }
  }]);

  return clvCall;
}(es6_event_emitter__WEBPACK_IMPORTED_MODULE_0___default.a);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! sip.js */ "./node_modules/sip.js/lib/index.js")))

/***/ }),

/***/ "./src/lib/clv-device.js":
/*!*******************************!*\
  !*** ./src/lib/clv-device.js ***!
  \*******************************/
/*! exports provided: clvDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clvDevice", function() { return clvDevice; });
/* harmony import */ var sip_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sip.js */ "./node_modules/sip.js/lib/index.js");
/* harmony import */ var sip_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sip_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! es6-event-emitter */ "./node_modules/es6-event-emitter/dist/emitter.js");
/* harmony import */ var es6_event_emitter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(es6_event_emitter__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _clv_call__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clv-call */ "./src/lib/clv-call.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
* Represents the software phone running in a web browser or other context.
*
* @class
*/

var clvDevice = /*#__PURE__*/function (_EventEmitter) {
  _inherits(clvDevice, _EventEmitter);

  var _super = _createSuper(clvDevice);

  /**
  * Create a new clvDevice.
  *
  * @param {Object} config Configuration Object
  * @param {String} config.host The host name or IP address of the SIP server
  * @param {String} config.port The port of the SIP server
  * @param {String} config.wsServers URI(s) of the WebSocket Servers. Format `wss://123.0.0.0:5066`. An array of strings is also accepted.
  * @param {String} config.username The username for the SIP server
  * @param {String} config.password The passweord for the SIP server
  * @param {String} config.displayName The human readable name passed in the from field. Will be used for Caller ID
  * @param {String} config.stunServers URI(s) for how to connect to the STUN servers. Format `stun:stun.clv.com:8000`. An array of strings is also accepted.
  * @param {Object} config.turnServers Details for how to connect to the TURN servers. An array of objects is also accepted.
  * @param {String} config.turnServers.urls URI(s) for the TURN server(s). Format `turn:turn.clv.com:8000?transport=tcp`. An array of strings is also accepted.
  * @param {String} config.turnServers.username Username to authenticate on TURN server(s)
  * @param {String} config.turnServers.password Password to authenticate on TURN server(s)
  * @param {String} config.registrarServer URI for the registrar Server. Format `sip:123.0.0.0:5066`
  * @param {Boolean} config.traceSip If true, SIP traces will be logged to the dev console.
  * @param {String} config.logLevel One of "debug", "log", "warn", "error", "off".  default is "log"
    */
  function clvDevice(config) {
    var _this;

    _classCallCheck(this, clvDevice);

    _this = _super.call(this);

    if (!config || _typeof(config) !== 'object') {
      throw new TypeError("clvDevice: Missing config");
    }

    if (!config.host) {
      throw new TypeError("clvDevice: Missing 'host' parameter");
    }

    _this.config = config;
    _this.host = config.host;
    _this.port = config.port;
    _this.uri = "sip:".concat(config.username, "@").concat(config.host);
    _this.path = config.path || '';
    _this.wsServers = arrayify(config.wsServers);
    _this.username = config.username;
    _this.password = config.password;
    _this.displayName = config.displayName || config.username;
    _this.stunServers = arrayify(config.stunServers);
    _this.turnServers = config.turnServers;
    _this.registrarServer = config.registrarServer;
    _this._userAgent = null;

    _this._ensureConnectivityWithSipServer(); // let uri = new SIP.URI("sip", this.username, this.host, this.port).toString();


    var sipUAConfig = {
      uri: "sip:".concat(_this.username, "@").concat(_this.host),
      transportOptions: {
        wsServers: ["".concat(config.wsServers)]
      },
      authorizationUsersip: _this.username,
      password: _this.password,
      displayName: _this.displayName,
      // stunServers: this.stunServers,
      // turnServers: this.turnServers,
      // registrarServer: this.registrarServer
      sessionDescriptionHandlerOptions: {
        constraints: {
          audio: true,
          video: false
        }
      }
    };

    if (config.traceSip) {
      sipUAConfig.traceSip = true;
    }

    if (config.logLevel) {
      if (config.logLevel === "off") {
        sipUAConfig.log = {
          builtinEnabled: false
        };
      } else {
        sipUAConfig.log = {
          level: config.logLevel
        };
      }
    }

    _this._userAgent = new sip_js__WEBPACK_IMPORTED_MODULE_0__["UA"](sipUAConfig);
    /**
    * wsConnecting event
    *
    * Fired when the device attempts to connect to the WebSocket server.
    * If the connection drops, the device will try to reconnect and this event will fire again.
    *
    * @event clvDevice#wsConnecting
    * @type {object}
    * @property {number} attempts - the number of connection attempts that have been made
    */

    _this._userAgent.on("connecting", function (args) {
      _this.trigger("wsConnecting", {
        attempts: args.attempts
      });
    });
    /**
    * wsConnected event
    *
    * Fired when the WebSocket connection has been established.
    *
    * @event clvDevice#wsConnected
    */


    _this._userAgent.on("connected", function () {
      _this.trigger("wsConnected");
    });
    /**
    * wsDisconnected event
    *
    * Fried when the WebSocket connection attempt fails.
    *
    * @event clvDevice#wsDisconnected
    */


    _this._userAgent.on("disconnected", function () {
      _this.trigger("wsDisconnected");
    });
    /**
    * registered event
    *
    * Fired when a the device has been successfully registered to recieve calls.
    *
    * @event clvDevice#registered
    */


    _this._userAgent.on("registered", function () {
      _this.trigger("registered");
    });
    /**
    * unregistered event
    *
    * Fired as the result of a call to `unregister()` or if a periodic re-registration fails.
    *
    * @event clvDevice#unregistered
    * @type {object}
    * @property {object} cause - null if `unregister()` was called, otherwise see [SIPjs causes]{@link http://sipjs.com/api/0.15.0/causes/}
    * @property {object} response - The SIP message which caused the failure, if it exists.
    */


    _this._userAgent.on("unregistered", function (response, cause) {
      _this.trigger("unregistered", {
        cause: cause,
        response: response
      });
    });
    /**
    * registrationFailed event
    *
    * Fired when a registration attepmt fails.
    *
    * @event clvDevice#registrationFailed
    * @type {object}
    * @property {object} cause - see [SIPjs causes]{@link http://sipjs.com/api/0.15.0/causes/}
    * @property {object} response - The SIP message which caused the failure, if it exists.
    */


    _this._userAgent.on("registrationFailed", function (cause, response) {
      _this.trigger("registrationFailed", {
        cause: cause,
        response: response
      });
    });
    /**
    * incomingInvite event
    *
    * Fired when the device recieves an INVITE request
    * @event clvDevice#invite
    * @type {Session}
    */


    _this._userAgent.on("invite", function (session) {
      _this._activeCall = new _clv_call__WEBPACK_IMPORTED_MODULE_2__["clvCall"](_this._userAgent);

      _this._activeCall.incomingCall(session);

      _this.trigger("invite", {
        id: session.id,
        phoneNumber: session.remoteIdentity._displayName,
        status: session.status,
        type: 'incoming'
      });
    });
    /**
    * message event
    *
    * @event clvDevice#message
    * @type {object}
    * @property {object} message - Contains the SIP message sent and server context necessary to receive and send replies.
    */


    _this._userAgent.on("message", function (message) {
      _this.trigger("message", {
        message: message
      });
    });

    return _this;
  }
  /**
  * Start the connection to the WebSocket server, and restore the previous state if stopped.
  * You need to start the WebSocket connection before you can send or recieve calls. If you
  * try to `initiateCall` without first starting the connection, it will be started for you,
  * but it will not be stopped when the call is terminated.
  */


  _createClass(clvDevice, [{
    key: "startWS",
    value: function startWS() {
      this._userAgent.start();
    }
    /**
    * Stop the connection to the WebSocket server, saving the state so it can be restored later
    * (by `start`).
    */

  }, {
    key: "stopWS",
    value: function stopWS() {
      this._userAgent.stop();
    }
    /**
    * Status of the WebSocket connection
    *
    * @return {Boolean} isConnected `true` if the device is connected to the WebSocket server, `false` otherwise
    */

  }, {
    key: "isWSConnected",
    value: function isWSConnected() {
      return this._userAgent.isConnected();
    }
    /**
    * Register the device with the SIP server so that it can receive incoming calls.
    *
    * @param {Object} options
    * @param {String[]} options.extraHeaders SIP headers that will be added to each REGISTER request. Each header is string in the format `"X-Header-Name: Header-value"`.
    * @emits clvDevice#registered
    */

  }, {
    key: "register",
    value: function register(options) {
      this._userAgent.register(options);
    }
    /**
    * Unregister the device from the SIP server; it will no longer recieve incoming calls.
    *
    * @param {Object} options
    * @param {Boolean} options.all [Optional] - if set & `true` it will unregister *all* bindings for the SIP user.
    * @param {String[]} options.extraHeaders SIP headers that will be added to each REGISTER request. Each header is string in the format `"X-Header-Name: Header-value"`.
    * @emits clvDevice#unregistered
    */

  }, {
    key: "unregister",
    value: function unregister(options) {
      this._userAgent.register(options);
    }
    /**
    * Status of SIP registration
    *
    * @return {Boolean} isRegistered `true` if the device is registered with the SIP Server, `false` otherwise
    */

  }, {
    key: "isRegistered",
    value: function isRegistered() {
      return this._userAgent.isRegistered();
    }
    /**
    * Make a phone call
    *
    * @param {String} phoneNumber The desination phone number to connect to. Just digits, no punctuation. Example `"12065551111"`.
    * @return {clvCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "initiateCall",
    value: function initiateCall(phoneNumber) {
      var _this2 = this;

      // let uri = new SIP.URI("sip", phoneNumber, this.host, this.port).toString();
      this._activeCall = new _clv_call__WEBPACK_IMPORTED_MODULE_2__["clvCall"](this._userAgent);

      this._activeCall.makeCall(phoneNumber);

      console.log(this._activeCall._session);

      this._activeCall._session.on("cancel", function (data) {
        _this2.trigger("cancel", data);
      });

      this._activeCall._session.on("bye", function (data) {
        _this2.trigger("bye", data);
      });

      this._activeCall._session.on("replaced", function (data) {
        _this2.trigger("replaced", data);
      });

      this._activeCall._session.on("failed", function (response, cause) {
        _this2.trigger("failed", response, cause);
      });

      this._activeCall._session.on("rejected", function (response, cause) {
        _this2.trigger("rejected", response, cause);
      });

      this._activeCall._session.on("constructed", function (data) {
        _this2.trigger("constructed", data);
      });

      this._activeCall._session.on("track added", function (data) {
        _this2.trigger("accept call", data);
      });

      return this._activeCall;
    }
    /**
    * Answer phone call
    *
    * @return {clvCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "accept",
    value: function accept() {
      var _this3 = this;

      this._activeCall._session.accept();

      this._activeCall._session.on('trackAdded', function () {
        var pc = this.sessionDescriptionHandler.peerConnection; // var this.audioElement = this.audioElement;

        var player = document.getElementsByClassName("clv-sipjs-remote-audio")[0]; // this.audioElement.className = 'clv-sipjs-remote-audio';

        var remoteStream = new MediaStream();
        pc.getReceivers().forEach(function (receiver) {
          remoteStream.addTrack(receiver.track);
        });

        if (typeof player.srcObject !== 'undefined') {
          player.srcObject = remoteStream;
        } else if (typeof player.mozSrcObject !== 'undefined') {
          player.mozSrcObject = remoteStream;
        } else if (typeof player.src !== 'undefined') {
          player.src = URL.createObjectURL(remoteStream);
        } else {
          console.log('Error attaching stream to element.');
        }

        player.play();
        return this._activeCall;
      });

      this._activeCall._session.on("cancel", function (data) {
        _this3.trigger("cancel", data);
      });

      this._activeCall._session.on("bye", function (data) {
        _this3.trigger("bye", data);
      });

      this._activeCall._session.on("replaced", function (data) {
        _this3.trigger("replaced", data);
      });

      this._activeCall._session.on("failed", function (response, cause) {
        _this3.trigger("failed", response, cause);
      });

      this._activeCall._session.on("rejected", function (response, cause) {
        _this3.trigger("rejected", response, cause);
      });

      this.trigger("accepted", {
        id: this._activeCall._session.id,
        phoneNumber: this._activeCall._session.remoteIdentity.displayName,
        startTime: this._activeCall._session.startTime ? this._activeCall._session.startTime : new Date(),
        status: this._activeCall._session.status
      });
    }
    /**
    * Get a reference to the call currently in progress
    *
    * @return {clvCall} activeCall Keep an eye on the call's state by listening to events emitted by activeCall
    */

  }, {
    key: "activeCall",
    value: function activeCall() {
      return this._activeCall;
    }
    /**
     * Refer
     * @param {String} phoneNumber The phonenumber can to refer
     */

  }, {
    key: "referNumber",
    value: function referNumber(phoneNumber) {
      this._refer = new sip_js__WEBPACK_IMPORTED_MODULE_0__["ReferClientContext"](this._userAgent, this._activeCall._session, phoneNumber);

      this._refer.refer();

      return this._refer;
    }
    /**
     * isMuted
     * @param {Boolean} isMuted The isMuted can to refer
     */

  }, {
    key: "mute",
    value: function mute(isMute) {
      var pc = this._activeCall._session.sessionDescriptionHandler.peerConnection;
      var audioTracks = pc.getLocalStreams()[0].getAudioTracks(); // if MediaStream has reference to microphone

      if (audioTracks[0]) {
        audioTracks[0].enabled = !isMute;
      }

      return pc;
    }
    /**
     * isHold
     * @param {Boolean} isHold The isMuted can to refer
     */

  }, {
    key: "hold",
    value: function hold(isHold) {
      if (isHold) {
        this._activeCall._session.hold();

        return this._activeCall._session;
      } else {
        this._activeCall._session.unhold();

        return this._activeCall._session;
      }
    }
    /**
    * End the session
    *
    * @emits TelnyxCall#terminated
    */

  }, {
    key: "reject",
    value: function reject() {
      this._activeCall._session.terminate();
    } // Ensure that we can connect to the SIP server.
    // Due to a bug in chrome, we need to open an http connection to the SIP server
    // before trying to connect via Web Socket.
    //
    //  https://bugs.chromium.org/p/chromium/issues/detail?id=329884

  }, {
    key: "_ensureConnectivityWithSipServer",
    value: function _ensureConnectivityWithSipServer() {
      try {
        var xhr = new XMLHttpRequest();
        xhr.addEventListener("error", function () {
          console.info("Failed http connection to SIP server is expected. It is related to a chrome bug.");
        });
        xhr.open("GET", "https://".concat(this.host, ":").concat(this.port), true);
        xhr.send();
      } catch (e) {// do nothing. If an error occurs, it's not going to matter here.
      }
    }
  }]);

  return clvDevice;
}(es6_event_emitter__WEBPACK_IMPORTED_MODULE_1___default.a);

function arrayify(item) {
  if (Array.isArray(item)) {
    return item.slice(0); // Shallow Copy
  } else {
    var arr = [];
    arr.push(item);
    return arr;
  }
}



/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbHYtc2lwanMvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2Nsdi1zaXBqcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy93ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29mLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZm9yLW9mLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2h0bWwuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItZGVmaW5lLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1ncG8uanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1jb2xsZWN0aW9uLWZyb20uanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL191aWQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2NvcmUuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9tZDUuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL2VzNi1ldmVudC1lbWl0dGVyL2Rpc3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9DbGllbnRDb250ZXh0LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9FbnVtcy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9FeGNlcHRpb25zLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1B1Ymxpc2hDb250ZXh0LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1JlZmVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9SZWdpc3RlckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvU2VydmVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9TZXNzaW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1Nlc3Npb24vRFRNRi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9TZXNzaW9uL0RUTUZWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvU3Vic2NyaXB0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9VQS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9VdGlscy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9XZWIvTW9kaWZpZXJzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1dlYi9TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1dlYi9TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvV2ViL1NpbXBsZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9XZWIvVHJhbnNwb3J0LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL1dlYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvYnllLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9lbWl0dGVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9leGNlcHRpb25zL2NvbnRlbnQtdHlwZS11bnN1cHBvcnRlZC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9yZXF1ZXN0LXBlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL2V4Y2VwdGlvbnMvc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9leGNlcHRpb25zL3Nlc3Npb24tdGVybWluYXRlZC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9hcGkvZXhjZXB0aW9ucy9zdGF0ZS10cmFuc2l0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9pbmZvLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9tZXNzYWdlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9ub3RpZmljYXRpb24uanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvYXBpL3JlZmVycmFsLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9zZXNzaW9uLXN0YXRlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2FwaS9zZXNzaW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZGlhbG9ncy9kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9kaWFsb2dzL2luZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZGlhbG9ncy9zZXNzaW9uLWRpYWxvZy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2RpYWxvZ3Mvc3Vic2NyaXB0aW9uLWRpYWxvZy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2V4Y2VwdGlvbnMvZXhjZXB0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvZXhjZXB0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2V4Y2VwdGlvbnMvdHJhbnNhY3Rpb24tc3RhdGUtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9leGNlcHRpb25zL3RyYW5zcG9ydC1lcnJvci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2luZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbG9nL2luZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbG9nL2xldmVscy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2xvZy9sb2dnZXItZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL2xvZy9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9ib2R5LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvZGlnZXN0LWF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvZ3JhbW1hci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL21lc3NhZ2VzL2luY29taW5nLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9pbmNvbWluZy1yZXNwb25zZS1tZXNzYWdlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9tZXRob2RzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL21lc3NhZ2VzL21ldGhvZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9uYW1lLWFkZHItaGVhZGVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvb3V0Z29pbmctcmVxdWVzdC1tZXNzYWdlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvb3V0Z29pbmctcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9tZXNzYWdlcy9wYXJhbWV0ZXJzLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvcGFyc2VyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvdXJpLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvbWVzc2FnZXMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS9zZXNzaW9uL2luZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvc2Vzc2lvbi9zZXNzaW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvc3Vic2NyaXB0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvc3Vic2NyaXB0aW9uL3N1YnNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RpbWVycy5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy9jbGllbnQtdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS90cmFuc2FjdGlvbnMvaW52aXRlLWNsaWVudC10cmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy9pbnZpdGUtc2VydmVyLXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdHJhbnNhY3Rpb25zL25vbi1pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdHJhbnNhY3Rpb25zL25vbi1pbnZpdGUtc2VydmVyLXRyYW5zYWN0aW9uLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdHJhbnNhY3Rpb25zL3NlcnZlci10cmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3RyYW5zYWN0aW9ucy90cmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnQtY29yZS9hbGxvd2VkLW1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50LWNvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50LWNvcmUvdXNlci1hZ2VudC1jb3JlLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvYnllLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvYnllLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvY2FuY2VsLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvaW5mby11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL2ludml0ZS11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL2ludml0ZS11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL21lc3NhZ2UtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9tZXNzYWdlLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvbm90aWZ5LXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcHJhY2stdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3B1Ymxpc2gtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZS1zdWJzY3JpYmUtdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZS1zdWJzY3JpYmUtdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3JlZmVyLXVzZXItYWdlbnQtc2VydmVyLmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvcmVnaXN0ZXItdXNlci1hZ2VudC1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvY29yZS91c2VyLWFnZW50cy9yZWdpc3Rlci11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3N1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3N1YnNjcmliZS11c2VyLWFnZW50LXNlcnZlci5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvc2lwLmpzL2xpYi9jb3JlL3VzZXItYWdlbnRzL3VzZXItYWdlbnQtY2xpZW50LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL25vZGVfbW9kdWxlcy9zaXAuanMvbGliL2NvcmUvdXNlci1hZ2VudHMvdXNlci1hZ2VudC1zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvZ3JhbW1hci9kaXN0L2dyYW1tYXIuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vbm9kZV9tb2R1bGVzL3NpcC5qcy9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwid2VicGFjazovL2Nsdi1zaXBqcy8uL3NyYy9jbHYtc2lwanMuanMiLCJ3ZWJwYWNrOi8vY2x2LXNpcGpzLy4vc3JjL2xpYi9jbHYtY2FsbC5qcyIsIndlYnBhY2s6Ly9jbHYtc2lwanMvLi9zcmMvbGliL2Nsdi1kZXZpY2UuanMiXSwibmFtZXMiOlsiY2x2Q2FsbCIsIlVBIiwiX211dGUiLCJfc3RhdHVzIiwiX2NhbGxUeXBlIiwiX2RvY0JvZHkiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiYXVkaW9FbGVtZW50Iiwic3RhcnQiLCJpbnZpdGVVcmkiLCJfc2Vzc2lvbiIsImludml0ZSIsIl9nZXRBdWRpb0VsZW1lbnQiLCJfYXR0YXRjaFNlc3Npb25FdmVudHMiLCJzZXNzaW9uIiwiY29uc29sZSIsImxvZyIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmRDaGlsZCIsIm9uIiwidHJpZ2dlciIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImJvZHkiLCJoYXNPZmZlciIsImRpYWxvZyIsImhhc0hlYWRlciIsImdldEhlYWRlciIsImluZGV4T2YiLCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIiwiaGFzRGVzY3JpcHRpb24iLCJzdGF0dXMiLCJTSVAiLCJTZXNzaW9uIiwiQyIsIlNUQVRVU19FQVJMWV9NRURJQSIsImRhdGEiLCJyZXF1ZXN0IiwiZHRtZiIsImNhbGxiYWNrIiwibmV3U2Vzc2lvbiIsImNhdXNlIiwibWVzc2FnZSIsInBjIiwicGVlckNvbm5lY3Rpb24iLCJyZW1vdGVTdHJlYW0iLCJNZWRpYVN0cmVhbSIsImdldFJlY2VpdmVycyIsImZvckVhY2giLCJyZWNlaXZlciIsImFkZFRyYWNrIiwidHJhY2siLCJwYXNzZWRPcHRpb25zIiwic3JjT2JqZWN0IiwibW96U3JjT2JqZWN0Iiwic3JjIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwicGxheSIsImVycm9yIiwiYWNjZXB0IiwibWVkaWEiLCJjb25zdHJhaW50cyIsImF1ZGlvIiwidmlkZW8iLCJyZW5kZXIiLCJyZW1vdGUiLCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyIsInJlamVjdCIsInRyYW5zYWN0aW9uIiwidGVybWluYXRlIiwic3RvcCIsImlzTXV0ZSIsIm11dGUiLCJ1bm11dGUiLCJpc0hvbGQiLCJob2xkIiwidW5ob2xkIiwiZGlnaXRzIiwicmVmZXIiLCJpIiwiY2xlYXJUaW1lciIsInNldFRpbWVvdXQiLCJjaGVjayIsImhhc0Fuc3dlciIsImNsZWFyVGltZW91dCIsInNldERlc2NyaXB0aW9uIiwibG9nZ2VyIiwid2FybiIsImZhaWxlZCIsImNhdXNlcyIsIkJBRF9NRURJQV9ERVNDUklQVElPTiIsInJlYXNvbl9waHJhc2UiLCJFdmVudEVtaXR0ZXIiLCJjbHZEZXZpY2UiLCJjb25maWciLCJUeXBlRXJyb3IiLCJob3N0IiwicG9ydCIsInVyaSIsInVzZXJuYW1lIiwicGF0aCIsIndzU2VydmVycyIsImFycmF5aWZ5IiwicGFzc3dvcmQiLCJkaXNwbGF5TmFtZSIsInN0dW5TZXJ2ZXJzIiwidHVyblNlcnZlcnMiLCJyZWdpc3RyYXJTZXJ2ZXIiLCJfdXNlckFnZW50IiwiX2Vuc3VyZUNvbm5lY3Rpdml0eVdpdGhTaXBTZXJ2ZXIiLCJzaXBVQUNvbmZpZyIsInRyYW5zcG9ydE9wdGlvbnMiLCJhdXRob3JpemF0aW9uVXNlcnNpcCIsInRyYWNlU2lwIiwibG9nTGV2ZWwiLCJidWlsdGluRW5hYmxlZCIsImxldmVsIiwiYXJncyIsImF0dGVtcHRzIiwiX2FjdGl2ZUNhbGwiLCJpbmNvbWluZ0NhbGwiLCJpZCIsInBob25lTnVtYmVyIiwicmVtb3RlSWRlbnRpdHkiLCJfZGlzcGxheU5hbWUiLCJ0eXBlIiwiaXNDb25uZWN0ZWQiLCJvcHRpb25zIiwicmVnaXN0ZXIiLCJpc1JlZ2lzdGVyZWQiLCJtYWtlQ2FsbCIsInBsYXllciIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdGFydFRpbWUiLCJEYXRlIiwiX3JlZmVyIiwiUmVmZXJDbGllbnRDb250ZXh0IiwiYXVkaW9UcmFja3MiLCJnZXRMb2NhbFN0cmVhbXMiLCJnZXRBdWRpb1RyYWNrcyIsImVuYWJsZWQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJpbmZvIiwib3BlbiIsInNlbmQiLCJlIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsInNsaWNlIiwiYXJyIiwicHVzaCJdLCJtYXBwaW5ncyI6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O0FBQ2hDO0FBQ0EscUNBQXFDLG1CQUFPLENBQUMsZ0RBQVE7QUFDckQ7QUFDQSxNQUFNLEVBT0o7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDLEc7Ozs7Ozs7Ozs7OztBQzNRWTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx1QkFBdUIsbUJBQU8sQ0FBQyxvR0FBc0M7O0FBRXJFOztBQUVBLG9CQUFvQixtQkFBTyxDQUFDLDhGQUFtQzs7QUFFL0Q7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHdGQUFnQzs7QUFFdkQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7O0FBRUQsMEI7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQzFIYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGdCQUFnQixtQkFBTyxDQUFDLHVEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsscUNBQXFDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDhDQUE4QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsK0JBQStCLEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsdURBQXVEO0FBQ3hIO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDdlZhO0FBQ2IsOENBQThDLGNBQWM7QUFD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Qy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9LQUFvSztBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsMEJBQTBCLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQ0FBbUMsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FB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Q0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0RBQWtELEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxREFBcUQsRUFBRTtBQUMxRixxREFBcUQsa0RBQWtELEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQzdqQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxjQUFjLG1CQUFPLENBQUMsZ0RBQU87QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsa0VBQVU7QUFDdkMscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDRGQUF1Qjs7Ozs7Ozs7Ozs7OztBQ0x2QztBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBYTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBWTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsMkRBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsNkVBQWlCO0FBQzlDLDhCQUE4QixtQkFBTyxDQUFDLGlIQUFzQztBQUM1RSw4QkFBOEIsbUJBQU8sQ0FBQyxpSEFBc0M7QUFDNUUsK0JBQStCLG1CQUFPLENBQUMsbUhBQXVDO0FBQzlFLCtCQUErQixtQkFBTyxDQUFDLG1IQUF1QztBQUM5RSxrQ0FBa0MsbUJBQU8sQ0FBQyx5SEFBMEM7QUFDcEYsa0NBQWtDLG1CQUFPLENBQUMseUhBQTBDO0FBQ3BGLGlDQUFpQyxtQkFBTyxDQUFDLHVIQUF5QztBQUNsRixpQ0FBaUMsbUJBQU8sQ0FBQyx1SEFBeUM7QUFDbEYsZ0NBQWdDLG1CQUFPLENBQUMscUhBQXdDO0FBQ2hGLGdDQUFnQyxtQkFBTyxDQUFDLHFIQUF3QztBQUNoRixvQ0FBb0MsbUJBQU8sQ0FBQyw2SEFBNEM7QUFDeEYsb0NBQW9DLG1CQUFPLENBQUMsNkhBQTRDO0FBQ3hGLGdDQUFnQyxtQkFBTyxDQUFDLHFIQUF3QztBQUNoRixnQ0FBZ0MsbUJBQU8sQ0FBQyxxSEFBd0M7QUFDaEYsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQThDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtCQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQzdlYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZIYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QixvQ0FBb0MsbUJBQU8sQ0FBQyxzREFBZTtBQUMzRCxjQUFjLG1CQUFPLENBQUMsaUVBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQkFBZ0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDOU9hO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaElhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7QUMzQ2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBVztBQUNuQyxpQ0FBaUMsbUJBQU8sQ0FBQyx1R0FBNEI7QUFDckUsa0NBQWtDLG1CQUFPLENBQUMseUdBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7Ozs7OztBQ25lYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsMkRBQVc7QUFDbEMsMkJBQTJCLG1CQUFPLENBQUMsK0ZBQXNCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLDZGQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx3QkFBd0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDdFlhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsY0FBYyxtQkFBTyxDQUFDLGdEQUFPO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQywyREFBVztBQUNsQywyQkFBMkIsbUJBQU8sQ0FBQywrRkFBc0I7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsNkZBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0IsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGFBQWEsNkNBQTZDO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsOEJBQThCLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZLG1CQUFtQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7Ozs7O0FDcFFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxnREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDdkUsWUFBWSxtQkFBTyxDQUFDLCtFQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QixFQUFFO0FBQ25GLGlFQUFpRSx3QkFBd0IsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHlCQUF5QixFQUFFO0FBQ25GLGlFQUFpRSx3QkFBd0IsRUFBRTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVksRUFBRTtBQUNuQyxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUNBQWlDO0FBQ2pDLFVBQVU7QUFDVixpQ0FBaUM7QUFDakMscUJBQXFCLFlBQVksRUFBRTtBQUNuQyxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DLHFCQUFxQixZQUFZLEVBQUU7QUFDbkMscUJBQXFCLFlBQVksRUFBRTtBQUNuQyxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DLHFCQUFxQixZQUFZLEVBQUU7QUFDbkMscUJBQXFCLFlBQVksRUFBRTtBQUNuQyxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DLHFCQUFxQixVQUFVLEVBQUUsRUFBRTtBQUNuQyxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DLHFCQUFxQixhQUFhLEVBQUU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSx5QkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLHVCQUF1QixTQUFTLEdBQUcsd0JBQXdCLEVBQUU7QUFDekY7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUIsU0FBUyxHQUFHLHdCQUF3QixFQUFFO0FBQ3JGO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLHVCQUF1QixTQUFTLEdBQUcsNEJBQTRCLEVBQUU7QUFDakc7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUIsU0FBUyxHQUFHLDRCQUE0QixFQUFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QixTQUFTLEdBQUcsNEJBQTRCLEVBQUU7QUFDM0Y7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUIsU0FBUyxHQUFHLDhCQUE4QixFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QixTQUFTLEdBQUcsMkJBQTJCLEVBQUU7QUFDckY7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUIsU0FBUyxHQUFHLDRCQUE0QixFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0EsU0FBUztBQUNULDRCQUE0QixVQUFVLEVBQUU7QUFDeEMsK0JBQStCLHlCQUF5QixFQUFFO0FBQzFEO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QixFQUFFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFTVSxRQUFULENBQWtCOEMsSUFBbEIsRUFBd0I7RUFDdEIsSUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWNGLElBQWQsQ0FBSixFQUF5QjtJQUN2QixPQUFPQSxJQUFJLENBQUNHLEtBQUwsQ0FBVyxDQUFYLENBQVAsQ0FEdUIsQ0FDRDtFQUN2QixDQUZELE1BRU87SUFDTCxJQUFJQyxHQUFHLEdBQUcsRUFBVjtJQUNBQSxHQUFHLENBQUNDLElBQUosQ0FBU0wsSUFBVDtJQUNBLE9BQU9JLEdBQVA7RUFDRDtBQUNGIiwiZmlsZSI6ImNsdi1zaXBqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiY2x2LXNpcGpzXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNsdi1zaXBqc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjbHYtc2lwanNcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2Nsdi1zaXBqcy5qc1wiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuV2Vha01hcDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIENvbnN0cnVjdG9yLCBuYW1lLCBmb3JiaWRkZW5GaWVsZCkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IobmFtZSArICc6IGluY29ycmVjdCBpbnZvY2F0aW9uIScpO1xuICB9IHJldHVybiBpdDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZ2V0V2VhayA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGNyZWF0ZUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpO1xudmFyICRoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBhcnJheUZpbmQgPSBjcmVhdGVBcnJheU1ldGhvZCg1KTtcbnZhciBhcnJheUZpbmRJbmRleCA9IGNyZWF0ZUFycmF5TWV0aG9kKDYpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gIHJldHVybiB0aGF0Ll9sIHx8ICh0aGF0Ll9sID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYSA9IFtdO1xufTtcbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gYXJyYXlGaW5kKHN0b3JlLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5hLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uIChpdCkge1xuICAgICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gICAgfSk7XG4gICAgaWYgKH5pbmRleCkgdGhpcy5hLnNwbGljZShpbmRleCwgMSk7XG4gICAgcmV0dXJuICEhfmluZGV4O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGlkKys7ICAgICAgLy8gY29sbGVjdGlvbiBpZFxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgLy8gbGVhayBzdG9yZSBmb3IgdW5jYXVnaHQgZnJvemVuIG9iamVjdHNcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKSAmJiBkZWxldGUgZGF0YVt0aGlzLl9pXTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4zLjMuNCBXZWFrTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuNC4zLjQgV2Vha1NldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIGlmICghaXNPYmplY3Qoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIE5BTUUpKS5oYXMoa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgJGhhcyhkYXRhLCB0aGlzLl9pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZSh0aGF0KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgZWxzZSBkYXRhW3RoYXQuX2ldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIHVmc3RvcmU6IHVuY2F1Z2h0RnJvemVuU3RvcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBlYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIEJhc2UgPSBnbG9iYWxbTkFNRV07XG4gIHZhciBDID0gQmFzZTtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIHByb3RvID0gQyAmJiBDLnByb3RvdHlwZTtcbiAgdmFyIE8gPSB7fTtcbiAgaWYgKCFERVNDUklQVE9SUyB8fCB0eXBlb2YgQyAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBwcm90by5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpIHtcbiAgICAvLyBjcmVhdGUgY29sbGVjdGlvbiBjb25zdHJ1Y3RvclxuICAgIEMgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIG1ldGEuTkVFRCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FLCAnX2MnKTtcbiAgICAgIHRhcmdldC5fYyA9IG5ldyBCYXNlKCk7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0YXJnZXRbQURERVJdLCB0YXJnZXQpO1xuICAgIH0pO1xuICAgIGVhY2goJ2FkZCxjbGVhcixkZWxldGUsZm9yRWFjaCxnZXQsaGFzLHNldCxrZXlzLHZhbHVlcyxlbnRyaWVzLHRvSlNPTicuc3BsaXQoJywnKSwgZnVuY3Rpb24gKEtFWSkge1xuICAgICAgdmFyIElTX0FEREVSID0gS0VZID09ICdhZGQnIHx8IEtFWSA9PSAnc2V0JztcbiAgICAgIGlmIChLRVkgaW4gcHJvdG8gJiYgIShJU19XRUFLICYmIEtFWSA9PSAnY2xlYXInKSkgaGlkZShDLnByb3RvdHlwZSwgS0VZLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsIEtFWSk7XG4gICAgICAgIGlmICghSVNfQURERVIgJiYgSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkpIHJldHVybiBLRVkgPT0gJ2dldCcgPyB1bmRlZmluZWQgOiBmYWxzZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2NbS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICByZXR1cm4gSVNfQURERVIgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgSVNfV0VBSyB8fCBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Muc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHNldFRvU3RyaW5nVGFnKEMsIE5BTUUpO1xuXG4gIE9bTkFNRV0gPSBDO1xuICAkZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV07XG4gIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIga2V5LCBvd24sIG91dDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAob3duICYmIGhhcyhleHBvcnRzLCBrZXkpKSBjb250aW51ZTtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IG93biA/IHRhcmdldFtrZXldIDogc291cmNlW2tleV07XG4gICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzXG4gICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV1cbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpXG4gICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnlcbiAgICA6IElTX1dSQVAgJiYgdGFyZ2V0W2tleV0gPT0gb3V0ID8gKGZ1bmN0aW9uIChDKSB7XG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykge1xuICAgICAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IEMoYSwgYik7XG4gICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7XG4gICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07XG4gICAgICByZXR1cm4gRjtcbiAgICAvLyBtYWtlIHN0YXRpYyB2ZXJzaW9ucyBmb3IgcHJvdG90eXBlIG1ldGhvZHNcbiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlXG4gICAgaWYgKElTX1BST1RPKSB7XG4gICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7XG4gICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJVxuICAgICAgaWYgKHR5cGUgJiAkZXhwb3J0LlIgJiYgZXhwUHJvdG8gJiYgIWV4cFByb3RvW2tleV0pIGhpZGUoZXhwUHJvdG8sIGtleSwgb3V0KTtcbiAgICB9XG4gIH1cbn07XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iLCJ2YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xudmFyIEJSRUFLID0ge307XG52YXIgUkVUVVJOID0ge307XG52YXIgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1IpIHtcbiAgdmFyIGl0ZXJGbiA9IElURVJBVE9SID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpO1xuICB2YXIgZiA9IGN0eChmbiwgdGhhdCwgZW50cmllcyA/IDIgOiAxKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ZXJhYmxlICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIC8vIGZhc3QgY2FzZSBmb3IgYXJyYXlzIHdpdGggZGVmYXVsdCBpdGVyYXRvclxuICBpZiAoaXNBcnJheUl0ZXIoaXRlckZuKSkgZm9yIChsZW5ndGggPSB0b0xlbmd0aChpdGVyYWJsZS5sZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTspIHtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZiAocmVzdWx0ID09PSBCUkVBSyB8fCByZXN1bHQgPT09IFJFVFVSTikgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmV4cG9ydHMuQlJFQUsgPSBCUkVBSztcbmV4cG9ydHMuUkVUVVJOID0gUkVUVVJOO1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpO1xufTtcbiIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsIi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBkZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgJGl0ZXJDcmVhdGUgPSByZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG52YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7XG52YXIgS0VZUyA9ICdrZXlzJztcbnZhciBWQUxVRVMgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTO1xuICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlO1xuICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcbiAgdmFyICRuYXRpdmUgPSBwcm90b1tJVEVSQVRPUl0gfHwgcHJvdG9bRkZfSVRFUkFUT1JdIHx8IERFRkFVTFQgJiYgcHJvdG9bREVGQVVMVF07XG4gIHZhciAkZGVmYXVsdCA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpO1xuICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkO1xuICB2YXIgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmU7XG4gIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlO1xuICAvLyBGaXggbmF0aXZlXG4gIGlmICgkYW55TmF0aXZlKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYgKCFMSUJSQVJZICYmIHR5cGVvZiBJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykgaGlkZShJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IsIHJldHVyblRoaXMpO1xuICAgIH1cbiAgfVxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAkZGVmYXVsdCA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuICRuYXRpdmUuY2FsbCh0aGlzKTsgfTtcbiAgfVxuICAvLyBEZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKSB7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7XG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKGtleSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIwIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCJ2YXIgaWQgPSAwO1xudmFyIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnLmNvbmNhdChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5LCAnKV8nLCAoKytpZCArIHB4KS50b1N0cmluZygzNikpO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XG52YXIgV0VBS19NQVAgPSAnV2Vha01hcCc7XG52YXIgZ2V0V2VhayA9IG1ldGEuZ2V0V2VhaztcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSB3ZWFrLnVmc3RvcmU7XG52YXIgSW50ZXJuYWxNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgfTtcbn07XG5cbnZhciBtZXRob2RzID0ge1xuICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICBpZiAoaXNPYmplY3Qoa2V5KSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgV0VBS19NQVApKS5nZXQoa2V5KTtcbiAgICAgIHJldHVybiBkYXRhID8gZGF0YVt0aGlzLl9pXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG4gIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSwga2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIDIzLjMgV2Vha01hcCBPYmplY3RzXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShXRUFLX01BUCwgd3JhcHBlciwgbWV0aG9kcywgd2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbmlmIChOQVRJVkVfV0VBS19NQVAgJiYgSVNfSUUxMSkge1xuICBJbnRlcm5hbE1hcCA9IHdlYWsuZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgV0VBS19NQVApO1xuICBhc3NpZ24oSW50ZXJuYWxNYXAucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgZWFjaChbJ2RlbGV0ZScsICdoYXMnLCAnZ2V0JywgJ3NldCddLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHByb3RvID0gJFdlYWtNYXAucHJvdG90eXBlO1xuICAgIHZhciBtZXRob2QgPSBwcm90b1trZXldO1xuICAgIHJlZGVmaW5lKHByb3RvLCBrZXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmIChpc09iamVjdChhKSAmJiAhaXNFeHRlbnNpYmxlKGEpKSB7XG4gICAgICAgIGlmICghdGhpcy5fZikgdGhpcy5fZiA9IG5ldyBJbnRlcm5hbE1hcCgpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCI7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0cm9vdC5DcnlwdG9KUyA9IGZhY3RvcnkoKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbCBvZiBPYmplY3QuY3JlYXRlXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9O1xuXG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBvYmo7XG5cblx0ICAgICAgICAgICAgc3VidHlwZSA9IG5ldyBGKCk7XG5cblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgIH07XG5cdCAgICB9KCkpXG5cblx0ICAgIC8qKlxuXHQgICAgICogQ3J5cHRvSlMgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYiA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2Ugb2JqZWN0IGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZSA9IENfbGliLkJhc2UgPSAoZnVuY3Rpb24gKCkge1xuXG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIFByb3BlcnRpZXMgdG8gY29weSBpbnRvIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJyxcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGV4dGVuZDogZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cblx0ICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gY3JlYXRlKHRoaXMpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XG5cdCAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5taXhJbihvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCBpbml0aWFsaXplclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3Rcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdC5wcm90b3R5cGUgPSBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlciA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBFeHRlbmRzIHRoaXMgb2JqZWN0IGFuZCBydW5zIHRoZSBpbml0IG1ldGhvZC5cblx0ICAgICAgICAgICAgICogQXJndW1lbnRzIHRvIGNyZWF0ZSgpIHdpbGwgYmUgcGFzc2VkIHRvIGluaXQoKS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGluc3RhbmNlID0gTXlUeXBlLmNyZWF0ZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmV4dGVuZCgpO1xuXHQgICAgICAgICAgICAgICAgaW5zdGFuY2UuaW5pdC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIGludG8gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIFRoZSBwcm9wZXJ0aWVzIHRvIG1peCBpbi5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIE15VHlwZS5taXhJbih7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gcHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSUUgd29uJ3QgY29weSB0b1N0cmluZyB1c2luZyB0aGUgbG9vcCBhYm92ZVxuXHQgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh3b3Jkcywgc2lnQnl0ZXMpIHtcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XG5cblx0ICAgICAgICAgICAgaWYgKHNpZ0J5dGVzICE9IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHdvcmRzLmxlbmd0aCAqIDQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoQ3J5cHRvSlMuZW5jLlV0ZjgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZW5jb2Rlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGVuY29kZXIgfHwgSGV4KS5zdHJpbmdpZnkodGhpcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5MS5jb25jYXQod29yZEFycmF5Mik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY29uY2F0OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRXb3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbmNhdFxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSB8PSB0aGF0Qnl0ZSA8PCAoMjQgLSAoKHRoaXNTaWdCeXRlcyArIGkpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZW1vdmVzIGluc2lnbmlmaWNhbnQgYml0cy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xhbXA6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXBcblx0ICAgICAgICAgICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgd29yZHMubGVuZ3RoID0gTWF0aC5jZWlsKHNpZ0J5dGVzIC8gNCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLndvcmRzID0gdGhpcy53b3Jkcy5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSB3b3JkIGFycmF5IGZpbGxlZCB3aXRoIHJhbmRvbSBieXRlcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByYW5kb206IGZ1bmN0aW9uIChuQnl0ZXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cblx0ICAgICAgICAgICAgdmFyIHIgPSAoZnVuY3Rpb24gKG1fdykge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1fdyA9IG1fdztcblx0ICAgICAgICAgICAgICAgIHZhciBtX3ogPSAweDNhZGU2OGIxO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1feiA9ICgweDkwNjkgKiAobV96ICYgMHhGRkZGKSArIChtX3ogPj4gMHgxMCkpICYgbWFzaztcblx0ICAgICAgICAgICAgICAgICAgICBtX3cgPSAoMHg0NjUwICogKG1fdyAmIDB4RkZGRikgKyAobV93ID4+IDB4MTApKSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICgobV96IDw8IDB4MTApICsgbV93KSAmIG1hc2s7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAwLjU7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChNYXRoLnJhbmRvbSgpID4gLjUgPyAxIDogLTEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcmNhY2hlOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuXHQgICAgICAgICAgICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKChfcigpICogMHgxMDAwMDAwMDApIHwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEVuY29kZXIgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEhleCA9IENfZW5jLkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuSGV4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgaGV4Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gaGV4Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UoaGV4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaGV4U3RyTGVuZ3RoID0gaGV4U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAzXSB8PSBwYXJzZUludChoZXhTdHIuc3Vic3RyKGksIDIpLCAxNikgPDwgKDI0IC0gKGkgJSA4KSAqIDQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBMYXRpbjEgPSBDX2VuYy5MYXRpbjEgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbGF0aW4xU3RyaW5nID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMUNoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXRpbjFDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBMYXRpbjEgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAobGF0aW4xU3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFTdHJMZW5ndGggPSBsYXRpbjFTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0aW4xU3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtOCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGY4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0Zjguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgVVRGLTggZGF0YScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjgucGFyc2UodXRmOFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBMYXRpbjEucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHV0ZjhTdHIpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemUgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG5cdCAgICAgKi9cblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBibG9jayBhbGdvcml0aG0ncyBkYXRhIGJ1ZmZlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5LmluaXQoKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYXBwZW5kLiBTdHJpbmdzIGFyZSBjb252ZXJ0ZWQgdG8gYSBXb3JkQXJyYXkgdXNpbmcgVVRGLTguXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YS5jb25jYXQoZGF0YSk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBkb0ZsdXNoIFdoZXRoZXIgYWxsIGJsb2NrcyBhbmQgcGFydGlhbCBibG9ja3Mgc2hvdWxkIGJlIHByb2Nlc3NlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX3Byb2Nlc3M6IGZ1bmN0aW9uIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xuXHQgICAgICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuQnl0ZXNSZWFkeTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdChwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBoYXNoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxuXHQgICAgICovXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGhhc2hlciB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcblx0ICAgICAgICAgICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHRoaXMuX2RvUmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIGhhc2hlciB3aXRoIGEgbWVzc2FnZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBoYXNoXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCdtZXNzYWdlJyk7XG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiA1MTIvMzIsXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gYSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGhhc2hlci5pbml0KGNmZykuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgSG1hY1NIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENfYWxnby5ITUFDLmluaXQoaGFzaGVyLCBrZXkpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFsZ29yaXRobSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ28gPSB7fTtcblxuXHQgICAgcmV0dXJuIEM7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7IiwiOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcIi4vY29yZVwiKSk7XG5cdH1cblx0ZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1wiLi9jb3JlXCJdLCBmYWN0b3J5KTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBHbG9iYWwgKGJyb3dzZXIpXG5cdFx0ZmFjdG9yeShyb290LkNyeXB0b0pTKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBDb25zdGFudHMgdGFibGVcblx0ICAgIHZhciBUID0gW107XG5cblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICBUW2ldID0gKE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkgKiAweDEwMDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTUQ1IGhhc2ggYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzZcblx0ICAgICAgICAgICAgXSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb1Byb2Nlc3NCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcblx0ICAgICAgICAgICAgICAgIHZhciBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgOCkgIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMSAgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMiAgPSBNW29mZnNldCArIDJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNCAgPSBNW29mZnNldCArIDRdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNSAgPSBNW29mZnNldCArIDVdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNyAgPSBNW29mZnNldCArIDddO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOCAgPSBNW29mZnNldCArIDhdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTAgPSBNW29mZnNldCArIDEwXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzExID0gTVtvZmZzZXQgKyAxMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTMgPSBNW29mZnNldCArIDEzXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE0ID0gTVtvZmZzZXQgKyAxNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFsYmVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEsICAxMiwgVFsxXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTcsIFRbMl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA3LCAgVFs0XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF81LCAgMTIsIFRbNV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzcsICAyMiwgVFs3XSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNywgIFRbOF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTEsIDIyLCBUWzExXSk7XG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEzLCAxMiwgVFsxM10pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE3LCBUWzE0XSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDUsICBUWzE2XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNCwgVFsxOF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMCwgIDIwLCBUWzE5XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEwLCA5LCAgVFsyMV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA1LCAgVFsyNF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksICBUWzI1XSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzgsICAyMCwgVFsyN10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsICBUWzI4XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNCwgVFszMF0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfMTIsIDIwLCBUWzMxXSk7XG5cblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA0LCAgVFszMl0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfOCwgIDExLCBUWzMzXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE0LCAyMywgVFszNV0pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgIDQsICBUWzM2XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzcsICAxNiwgVFszOF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTAsIDIzLCBUWzM5XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzAsICAxMSwgVFs0MV0pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgIDE2LCBUWzQyXSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksICA0LCAgVFs0NF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTIsIDExLCBUWzQ1XSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsICAyMywgVFs0N10pO1xuXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzcsICAxMCwgVFs0OV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTQsIDE1LCBUWzUwXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA2LCAgVFs1Ml0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgIDEwLCBUWzUzXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsICAyMSwgVFs1NV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDYsICBUWzU2XSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsICAxNSwgVFs1OF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTMsIDIxLCBUWzU5XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE1LCBUWzYyXSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgIHwgKG5CaXRzVG90YWxIID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCAyNCkgfCAobkJpdHNUb3RhbEwgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSAoZGF0YVdvcmRzLmxlbmd0aCArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5faGFzaDtcblx0ICAgICAgICAgICAgdmFyIEggPSBoYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICAgICAgdmFyIEhfaSA9IEhbaV07XG5cblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAoKChIX2kgPDwgMjQpIHwgKEhfaSA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIEZGKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoKGIgJiBkKSB8IChjICYgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIEhIKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIElJKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG5cdCAgICB9XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5NRDUoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLk1ENSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKE1ENSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjTUQ1KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5NRDU7XG5cbn0pKTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2syID0gcmVxdWlyZSgnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG5cbnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTtcblxudmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpO1xuXG52YXIgX3dlYWtNYXAgPSByZXF1aXJlKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvd2Vhay1tYXAnKTtcblxudmFyIF93ZWFrTWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dlYWtNYXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZW1pdHRlciA9IG5ldyBfd2Vha01hcDIuZGVmYXVsdCgpO1xuXG52YXIgRW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRW1pdHRlcigpIHtcblx0XHQoMCwgX2NsYXNzQ2FsbENoZWNrMy5kZWZhdWx0KSh0aGlzLCBFbWl0dGVyKTtcblxuXHRcdGVtaXR0ZXIuc2V0KHRoaXMsIHtcblx0XHRcdGV2ZW50czoge31cblx0XHR9KTtcblxuXHRcdHRoaXMuZXZlbnRMZW5ndGggPSAwO1xuXHR9XG5cblx0KDAsIF9jcmVhdGVDbGFzczMuZGVmYXVsdCkoRW1pdHRlciwgW3tcblx0XHRrZXk6ICdvbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYikge1xuXHRcdFx0dmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG5cdFx0XHRpZiAodHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSBjYWxsYmFjayBtZXRob2QuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXTtcblx0XHRcdHRoaXMuZXZlbnRzW2V2ZW50XS5wdXNoKHtcblx0XHRcdFx0Y2I6IGNiLFxuXHRcdFx0XHRvbmNlOiBvbmNlXG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5ldmVudExlbmd0aCsrO1xuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdvZmYnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGNiKSB7XG5cdFx0XHRpZiAodHlwZW9mIGNiID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSBjYWxsYmFjayBtZXRob2QuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgdGhpcy5ldmVudHNbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IG5vdCBmb3VuZCAtIHRoZSBldmVudCB5b3UgcHJvdmlkZWQgaXM6ICcgKyBldmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF07XG5cblx0XHRcdGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHRcdGlmICh2LmNiID09PSBjYikge1xuXHRcdFx0XHRcdGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuXG5cdFx0XHRcdHRoaXMuZXZlbnRMZW5ndGgtLTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAndHJpZ2dlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcblx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cblx0XHRcdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHRcdFx0XHRhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBldmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIGV2ZW50IHRvIHRyaWdnZXIuJyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF07XG5cdFx0XHR2YXIgb25jZUxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHRpZiAodHlwZW9mIGxpc3RlbmVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcblx0XHRcdFx0XHR2LmNiLmFwcGx5KF90aGlzLCBhcmdzKTtcblxuXHRcdFx0XHRcdGlmICh2Lm9uY2UpIG9uY2VMaXN0ZW5lcnMudW5zaGlmdChrKTtcblxuXHRcdFx0XHRcdG9uY2VMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShrLCAxKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ29uY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBjYikge1xuXHRcdFx0dGhpcy5vbihldmVudCwgY2IsIHRydWUpO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2Rlc3Ryb3knLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdFx0ZW1pdHRlci5kZWxldGUodGhpcyk7XG5cblx0XHRcdHRoaXMuZXZlbnRMZW5ndGggPSAwO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ2V2ZW50cycsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gZW1pdHRlci5nZXQodGhpcykuZXZlbnRzO1xuXHRcdH1cblx0fV0pO1xuXHRyZXR1cm4gRW1pdHRlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRW1pdHRlcjsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xudmFyIENsaWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2xpZW50Q29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDbGllbnRDb250ZXh0KHVhLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0ge307XG4gICAgICAgIENsaWVudENvbnRleHQuaW5pdGlhbGl6ZXIoX3RoaXMsIHVhLCBtZXRob2QsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2xpZW50Q29udGV4dC5pbml0aWFsaXplciA9IGZ1bmN0aW9uIChvYmpUb0NvbnN0cnVjdCwgdWEsIG1ldGhvZCwgb3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgb2JqVG9Db25zdHJ1Y3QudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuQ2xpZW50Q29udGV4dDtcbiAgICAgICAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gICAgICAgIGlmIChvcmlnaW5hbFRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgb2JqVG9Db25zdHJ1Y3QudWEgPSB1YTtcbiAgICAgICAgb2JqVG9Db25zdHJ1Y3QubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLmNsaWVudGNvbnRleHRcIik7XG4gICAgICAgIG9ialRvQ29uc3RydWN0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdmFyIHRhcmdldCA9IHVhLm5vcm1hbGl6ZVRhcmdldChvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0YXJnZXQ6IFwiICsgb3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tVVJJID0gdWEudXNlckFnZW50Q29yZS5jb25maWd1cmF0aW9uLmFvcjtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbXMgJiYgb3B0aW9ucy5wYXJhbXMuZnJvbVVyaSkge1xuICAgICAgICAgICAgZnJvbVVSSSA9XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLnBhcmFtcy5mcm9tVXJpID09PSBcInN0cmluZ1wiKSA/XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5HcmFtbWFyLlVSSVBhcnNlKG9wdGlvbnMucGFyYW1zLmZyb21VcmkpIDpcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMuZnJvbVVyaTtcbiAgICAgICAgICAgIGlmICghZnJvbVVSSSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGZyb20gVVJJOiBcIiArIG9wdGlvbnMucGFyYW1zLmZyb21VcmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0b1VSSSA9IHRhcmdldDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJhbXMgJiYgb3B0aW9ucy5wYXJhbXMudG9VcmkpIHtcbiAgICAgICAgICAgIHRvVVJJID1cbiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMucGFyYW1zLnRvVXJpID09PSBcInN0cmluZ1wiKSA/XG4gICAgICAgICAgICAgICAgICAgIGNvcmVfMS5HcmFtbWFyLlVSSVBhcnNlKG9wdGlvbnMucGFyYW1zLnRvVXJpKSA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLnRvVXJpO1xuICAgICAgICAgICAgaWYgKCF0b1VSSSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRvIFVSSTogXCIgKyBvcHRpb25zLnBhcmFtcy50b1VyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogT3B0aW9uc1xuICAgICAgICAqIC0gZXh0cmFIZWFkZXJzXG4gICAgICAgICogLSBwYXJhbXNcbiAgICAgICAgKiAtIGNvbnRlbnRUeXBlXG4gICAgICAgICogLSBib2R5XG4gICAgICAgICovXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMgfHwgT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB2YXIgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwge307XG4gICAgICAgIHZhciBib2R5T2JqO1xuICAgICAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICBib2R5T2JqID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSA/IG9wdGlvbnMuY29udGVudFR5cGUgOiBcImFwcGxpY2F0aW9uL3NkcFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb2JqVG9Db25zdHJ1Y3QuYm9keSA9IGJvZHlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIGlmIChib2R5T2JqKSB7XG4gICAgICAgICAgICBib2R5ID0gVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihib2R5T2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgcmVxdWVzdFxuICAgICAgICBvYmpUb0NvbnN0cnVjdC5yZXF1ZXN0ID0gdWEudXNlckFnZW50Q29yZS5tYWtlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXRob2QsIHRhcmdldCwgZnJvbVVSSSwgdG9VUkksIHBhcmFtcywgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgLyogU2V0IG90aGVyIHByb3BlcnRpZXMgZnJvbSB0aGUgcmVxdWVzdCAqL1xuICAgICAgICBpZiAob2JqVG9Db25zdHJ1Y3QucmVxdWVzdC5mcm9tKSB7XG4gICAgICAgICAgICBvYmpUb0NvbnN0cnVjdC5sb2NhbElkZW50aXR5ID0gb2JqVG9Db25zdHJ1Y3QucmVxdWVzdC5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmpUb0NvbnN0cnVjdC5yZXF1ZXN0LnRvKSB7XG4gICAgICAgICAgICBvYmpUb0NvbnN0cnVjdC5yZW1vdGVJZGVudGl0eSA9IG9ialRvQ29uc3RydWN0LnJlcXVlc3QudG87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsaWVudENvbnRleHQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudWEudXNlckFnZW50Q29yZS5yZXF1ZXN0KHRoaXMucmVxdWVzdCwge1xuICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlIHx8IDA7XG4gICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudWEuYXBwbGljYW50c1t0aGlzLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVhLmFwcGxpY2FudHNbdGhpcy50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYWNjZXB0ZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudWEuYXBwbGljYW50c1t0aGlzLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnVhLmFwcGxpY2FudHNbdGhpcy50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVqZWN0ZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuICAgIENsaWVudENvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCB1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH07XG4gICAgcmV0dXJuIENsaWVudENvbnRleHQ7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5DbGllbnRDb250ZXh0ID0gQ2xpZW50Q29udGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG52YXIgQztcbihmdW5jdGlvbiAoQykge1xuICAgIEMudmVyc2lvbiA9IHZlcnNpb25fMS5MSUJSQVJZX1ZFUlNJT047XG4gICAgQy5VU0VSX0FHRU5UID0gXCJTSVAuanMvXCIgKyB2ZXJzaW9uXzEuTElCUkFSWV9WRVJTSU9OO1xuICAgIC8vIFNJUCBzY2hlbWVcbiAgICBDLlNJUCA9IFwic2lwXCI7XG4gICAgQy5TSVBTID0gXCJzaXBzXCI7XG4gICAgLy8gRW5kIGFuZCBGYWlsdXJlIGNhdXNlc1xuICAgIHZhciBjYXVzZXM7XG4gICAgKGZ1bmN0aW9uIChjYXVzZXMpIHtcbiAgICAgICAgLy8gR2VuZXJpYyBlcnJvciBjYXVzZXNcbiAgICAgICAgY2F1c2VzW1wiQ09OTkVDVElPTl9FUlJPUlwiXSA9IFwiQ29ubmVjdGlvbiBFcnJvclwiO1xuICAgICAgICBjYXVzZXNbXCJJTlRFUk5BTF9FUlJPUlwiXSA9IFwiSW50ZXJuYWwgRXJyb3JcIjtcbiAgICAgICAgY2F1c2VzW1wiUkVRVUVTVF9USU1FT1VUXCJdID0gXCJSZXF1ZXN0IFRpbWVvdXRcIjtcbiAgICAgICAgY2F1c2VzW1wiU0lQX0ZBSUxVUkVfQ09ERVwiXSA9IFwiU0lQIEZhaWx1cmUgQ29kZVwiO1xuICAgICAgICAvLyBTSVAgZXJyb3IgY2F1c2VzXG4gICAgICAgIGNhdXNlc1tcIkFERFJFU1NfSU5DT01QTEVURVwiXSA9IFwiQWRkcmVzcyBJbmNvbXBsZXRlXCI7XG4gICAgICAgIGNhdXNlc1tcIkFVVEhFTlRJQ0FUSU9OX0VSUk9SXCJdID0gXCJBdXRoZW50aWNhdGlvbiBFcnJvclwiO1xuICAgICAgICBjYXVzZXNbXCJCVVNZXCJdID0gXCJCdXN5XCI7XG4gICAgICAgIGNhdXNlc1tcIkRJQUxPR19FUlJPUlwiXSA9IFwiRGlhbG9nIEVycm9yXCI7XG4gICAgICAgIGNhdXNlc1tcIklOQ09NUEFUSUJMRV9TRFBcIl0gPSBcIkluY29tcGF0aWJsZSBTRFBcIjtcbiAgICAgICAgY2F1c2VzW1wiTk9UX0ZPVU5EXCJdID0gXCJOb3QgRm91bmRcIjtcbiAgICAgICAgY2F1c2VzW1wiUkVESVJFQ1RFRFwiXSA9IFwiUmVkaXJlY3RlZFwiO1xuICAgICAgICBjYXVzZXNbXCJSRUpFQ1RFRFwiXSA9IFwiUmVqZWN0ZWRcIjtcbiAgICAgICAgY2F1c2VzW1wiVU5BVkFJTEFCTEVcIl0gPSBcIlVuYXZhaWxhYmxlXCI7XG4gICAgICAgIC8vIFNlc3Npb24gZXJyb3IgY2F1c2VzXG4gICAgICAgIGNhdXNlc1tcIkJBRF9NRURJQV9ERVNDUklQVElPTlwiXSA9IFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCI7XG4gICAgICAgIGNhdXNlc1tcIkNBTkNFTEVEXCJdID0gXCJDYW5jZWxlZFwiO1xuICAgICAgICBjYXVzZXNbXCJFWFBJUkVTXCJdID0gXCJFeHBpcmVzXCI7XG4gICAgICAgIGNhdXNlc1tcIk5PX0FDS1wiXSA9IFwiTm8gQUNLXCI7XG4gICAgICAgIGNhdXNlc1tcIk5PX0FOU1dFUlwiXSA9IFwiTm8gQW5zd2VyXCI7XG4gICAgICAgIGNhdXNlc1tcIk5PX1BSQUNLXCJdID0gXCJObyBQUkFDS1wiO1xuICAgICAgICBjYXVzZXNbXCJSVFBfVElNRU9VVFwiXSA9IFwiUlRQIFRpbWVvdXRcIjtcbiAgICAgICAgY2F1c2VzW1wiVVNFUl9ERU5JRURfTUVESUFfQUNDRVNTXCJdID0gXCJVc2VyIERlbmllZCBNZWRpYSBBY2Nlc3NcIjtcbiAgICAgICAgY2F1c2VzW1wiV0VCUlRDX0VSUk9SXCJdID0gXCJXZWJSVEMgRXJyb3JcIjtcbiAgICAgICAgY2F1c2VzW1wiV0VCUlRDX05PVF9TVVBQT1JURURcIl0gPSBcIldlYlJUQyBOb3QgU3VwcG9ydGVkXCI7XG4gICAgfSkoY2F1c2VzID0gQy5jYXVzZXMgfHwgKEMuY2F1c2VzID0ge30pKTtcbiAgICB2YXIgc3VwcG9ydGVkO1xuICAgIChmdW5jdGlvbiAoc3VwcG9ydGVkKSB7XG4gICAgICAgIHN1cHBvcnRlZFtcIlJFUVVJUkVEXCJdID0gXCJyZXF1aXJlZFwiO1xuICAgICAgICBzdXBwb3J0ZWRbXCJTVVBQT1JURURcIl0gPSBcInN1cHBvcnRlZFwiO1xuICAgICAgICBzdXBwb3J0ZWRbXCJVTlNVUFBPUlRFRFwiXSA9IFwibm9uZVwiO1xuICAgIH0pKHN1cHBvcnRlZCA9IEMuc3VwcG9ydGVkIHx8IChDLnN1cHBvcnRlZCA9IHt9KSk7XG4gICAgQy5TSVBfRVJST1JfQ0FVU0VTID0ge1xuICAgICAgICBBRERSRVNTX0lOQ09NUExFVEU6IFs0ODRdLFxuICAgICAgICBBVVRIRU5USUNBVElPTl9FUlJPUjogWzQwMSwgNDA3XSxcbiAgICAgICAgQlVTWTogWzQ4NiwgNjAwXSxcbiAgICAgICAgSU5DT01QQVRJQkxFX1NEUDogWzQ4OCwgNjA2XSxcbiAgICAgICAgTk9UX0ZPVU5EOiBbNDA0LCA2MDRdLFxuICAgICAgICBSRURJUkVDVEVEOiBbMzAwLCAzMDEsIDMwMiwgMzA1LCAzODBdLFxuICAgICAgICBSRUpFQ1RFRDogWzQwMywgNjAzXSxcbiAgICAgICAgVU5BVkFJTEFCTEU6IFs0ODAsIDQxMCwgNDA4LCA0MzBdXG4gICAgfTtcbiAgICAvLyBTSVAgTWV0aG9kc1xuICAgIEMuQUNLID0gXCJBQ0tcIjtcbiAgICBDLkJZRSA9IFwiQllFXCI7XG4gICAgQy5DQU5DRUwgPSBcIkNBTkNFTFwiO1xuICAgIEMuSU5GTyA9IFwiSU5GT1wiO1xuICAgIEMuSU5WSVRFID0gXCJJTlZJVEVcIjtcbiAgICBDLk1FU1NBR0UgPSBcIk1FU1NBR0VcIjtcbiAgICBDLk5PVElGWSA9IFwiTk9USUZZXCI7XG4gICAgQy5PUFRJT05TID0gXCJPUFRJT05TXCI7XG4gICAgQy5SRUdJU1RFUiA9IFwiUkVHSVNURVJcIjtcbiAgICBDLlVQREFURSA9IFwiVVBEQVRFXCI7XG4gICAgQy5TVUJTQ1JJQkUgPSBcIlNVQlNDUklCRVwiO1xuICAgIEMuUFVCTElTSCA9IFwiUFVCTElTSFwiO1xuICAgIEMuUkVGRVIgPSBcIlJFRkVSXCI7XG4gICAgQy5QUkFDSyA9IFwiUFJBQ0tcIjtcbiAgICAvKiBTSVAgUmVzcG9uc2UgUmVhc29uc1xuICAgICAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVyc1xuICAgICAqIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvT3ZlclNJUC9ibG9iL21hc3Rlci9saWIvb3ZlcnNpcC9zaXAvY29uc3RhbnRzLnJiI0w3XG4gICAgICovXG4gICAgQy5SRUFTT05fUEhSQVNFID0ge1xuICAgICAgICAxMDA6IFwiVHJ5aW5nXCIsXG4gICAgICAgIDE4MDogXCJSaW5naW5nXCIsXG4gICAgICAgIDE4MTogXCJDYWxsIElzIEJlaW5nIEZvcndhcmRlZFwiLFxuICAgICAgICAxODI6IFwiUXVldWVkXCIsXG4gICAgICAgIDE4MzogXCJTZXNzaW9uIFByb2dyZXNzXCIsXG4gICAgICAgIDE5OTogXCJFYXJseSBEaWFsb2cgVGVybWluYXRlZFwiLFxuICAgICAgICAyMDA6IFwiT0tcIixcbiAgICAgICAgMjAyOiBcIkFjY2VwdGVkXCIsXG4gICAgICAgIDIwNDogXCJObyBOb3RpZmljYXRpb25cIixcbiAgICAgICAgMzAwOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgICAgICAgMzAxOiBcIk1vdmVkIFBlcm1hbmVudGx5XCIsXG4gICAgICAgIDMwMjogXCJNb3ZlZCBUZW1wb3JhcmlseVwiLFxuICAgICAgICAzMDU6IFwiVXNlIFByb3h5XCIsXG4gICAgICAgIDM4MDogXCJBbHRlcm5hdGl2ZSBTZXJ2aWNlXCIsXG4gICAgICAgIDQwMDogXCJCYWQgUmVxdWVzdFwiLFxuICAgICAgICA0MDE6IFwiVW5hdXRob3JpemVkXCIsXG4gICAgICAgIDQwMjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gICAgICAgIDQwMzogXCJGb3JiaWRkZW5cIixcbiAgICAgICAgNDA0OiBcIk5vdCBGb3VuZFwiLFxuICAgICAgICA0MDU6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgICAgIDQwNjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICAgICAgICA0MDc6IFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIixcbiAgICAgICAgNDA4OiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICAgICAgICA0MTA6IFwiR29uZVwiLFxuICAgICAgICA0MTI6IFwiQ29uZGl0aW9uYWwgUmVxdWVzdCBGYWlsZWRcIixcbiAgICAgICAgNDEzOiBcIlJlcXVlc3QgRW50aXR5IFRvbyBMYXJnZVwiLFxuICAgICAgICA0MTQ6IFwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIixcbiAgICAgICAgNDE1OiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgICAgICAgNDE2OiBcIlVuc3VwcG9ydGVkIFVSSSBTY2hlbWVcIixcbiAgICAgICAgNDE3OiBcIlVua25vd24gUmVzb3VyY2UtUHJpb3JpdHlcIixcbiAgICAgICAgNDIwOiBcIkJhZCBFeHRlbnNpb25cIixcbiAgICAgICAgNDIxOiBcIkV4dGVuc2lvbiBSZXF1aXJlZFwiLFxuICAgICAgICA0MjI6IFwiU2Vzc2lvbiBJbnRlcnZhbCBUb28gU21hbGxcIixcbiAgICAgICAgNDIzOiBcIkludGVydmFsIFRvbyBCcmllZlwiLFxuICAgICAgICA0Mjg6IFwiVXNlIElkZW50aXR5IEhlYWRlclwiLFxuICAgICAgICA0Mjk6IFwiUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eVwiLFxuICAgICAgICA0MzA6IFwiRmxvdyBGYWlsZWRcIixcbiAgICAgICAgNDMzOiBcIkFub255bWl0eSBEaXNhbGxvd2VkXCIsXG4gICAgICAgIDQzNjogXCJCYWQgSWRlbnRpdHktSW5mb1wiLFxuICAgICAgICA0Mzc6IFwiVW5zdXBwb3J0ZWQgQ2VydGlmaWNhdGVcIixcbiAgICAgICAgNDM4OiBcIkludmFsaWQgSWRlbnRpdHkgSGVhZGVyXCIsXG4gICAgICAgIDQzOTogXCJGaXJzdCBIb3AgTGFja3MgT3V0Ym91bmQgU3VwcG9ydFwiLFxuICAgICAgICA0NDA6IFwiTWF4LUJyZWFkdGggRXhjZWVkZWRcIixcbiAgICAgICAgNDY5OiBcIkJhZCBJbmZvIFBhY2thZ2VcIixcbiAgICAgICAgNDcwOiBcIkNvbnNlbnQgTmVlZGVkXCIsXG4gICAgICAgIDQ3ODogXCJVbnJlc29sdmFibGUgRGVzdGluYXRpb25cIixcbiAgICAgICAgNDgwOiBcIlRlbXBvcmFyaWx5IFVuYXZhaWxhYmxlXCIsXG4gICAgICAgIDQ4MTogXCJDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0XCIsXG4gICAgICAgIDQ4MjogXCJMb29wIERldGVjdGVkXCIsXG4gICAgICAgIDQ4MzogXCJUb28gTWFueSBIb3BzXCIsXG4gICAgICAgIDQ4NDogXCJBZGRyZXNzIEluY29tcGxldGVcIixcbiAgICAgICAgNDg1OiBcIkFtYmlndW91c1wiLFxuICAgICAgICA0ODY6IFwiQnVzeSBIZXJlXCIsXG4gICAgICAgIDQ4NzogXCJSZXF1ZXN0IFRlcm1pbmF0ZWRcIixcbiAgICAgICAgNDg4OiBcIk5vdCBBY2NlcHRhYmxlIEhlcmVcIixcbiAgICAgICAgNDg5OiBcIkJhZCBFdmVudFwiLFxuICAgICAgICA0OTE6IFwiUmVxdWVzdCBQZW5kaW5nXCIsXG4gICAgICAgIDQ5MzogXCJVbmRlY2lwaGVyYWJsZVwiLFxuICAgICAgICA0OTQ6IFwiU2VjdXJpdHkgQWdyZWVtZW50IFJlcXVpcmVkXCIsXG4gICAgICAgIDUwMDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgICAgICAgNTAxOiBcIk5vdCBJbXBsZW1lbnRlZFwiLFxuICAgICAgICA1MDI6IFwiQmFkIEdhdGV3YXlcIixcbiAgICAgICAgNTAzOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgICAgICAgNTA0OiBcIlNlcnZlciBUaW1lLW91dFwiLFxuICAgICAgICA1MDU6IFwiVmVyc2lvbiBOb3QgU3VwcG9ydGVkXCIsXG4gICAgICAgIDUxMzogXCJNZXNzYWdlIFRvbyBMYXJnZVwiLFxuICAgICAgICA1ODA6IFwiUHJlY29uZGl0aW9uIEZhaWx1cmVcIixcbiAgICAgICAgNjAwOiBcIkJ1c3kgRXZlcnl3aGVyZVwiLFxuICAgICAgICA2MDM6IFwiRGVjbGluZVwiLFxuICAgICAgICA2MDQ6IFwiRG9lcyBOb3QgRXhpc3QgQW55d2hlcmVcIixcbiAgICAgICAgNjA2OiBcIk5vdCBBY2NlcHRhYmxlXCJcbiAgICB9O1xuICAgIC8qIFNJUCBPcHRpb24gVGFnc1xuICAgICAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVycy9zaXAtcGFyYW1ldGVycy54aHRtbCNzaXAtcGFyYW1ldGVycy00XG4gICAgICovXG4gICAgQy5PUFRJT05fVEFHUyA9IHtcbiAgICAgICAgXCIxMDByZWxcIjogdHJ1ZSxcbiAgICAgICAgXCIxOTlcIjogdHJ1ZSxcbiAgICAgICAgXCJhbnN3ZXJtb2RlXCI6IHRydWUsXG4gICAgICAgIFwiZWFybHktc2Vzc2lvblwiOiB0cnVlLFxuICAgICAgICBcImV2ZW50bGlzdFwiOiB0cnVlLFxuICAgICAgICBcImV4cGxpY2l0c3ViXCI6IHRydWUsXG4gICAgICAgIFwiZnJvbS1jaGFuZ2VcIjogdHJ1ZSxcbiAgICAgICAgXCJnZW9sb2NhdGlvbi1odHRwXCI6IHRydWUsXG4gICAgICAgIFwiZ2VvbG9jYXRpb24tc2lwXCI6IHRydWUsXG4gICAgICAgIFwiZ2luXCI6IHRydWUsXG4gICAgICAgIFwiZ3J1dVwiOiB0cnVlLFxuICAgICAgICBcImhpc3RpbmZvXCI6IHRydWUsXG4gICAgICAgIFwiaWNlXCI6IHRydWUsXG4gICAgICAgIFwiam9pblwiOiB0cnVlLFxuICAgICAgICBcIm11bHRpcGxlLXJlZmVyXCI6IHRydWUsXG4gICAgICAgIFwibm9yZWZlcnN1YlwiOiB0cnVlLFxuICAgICAgICBcIm5vc3ViXCI6IHRydWUsXG4gICAgICAgIFwib3V0Ym91bmRcIjogdHJ1ZSxcbiAgICAgICAgXCJwYXRoXCI6IHRydWUsXG4gICAgICAgIFwicG9saWN5XCI6IHRydWUsXG4gICAgICAgIFwicHJlY29uZGl0aW9uXCI6IHRydWUsXG4gICAgICAgIFwicHJlZlwiOiB0cnVlLFxuICAgICAgICBcInByaXZhY3lcIjogdHJ1ZSxcbiAgICAgICAgXCJyZWNpcGllbnQtbGlzdC1pbnZpdGVcIjogdHJ1ZSxcbiAgICAgICAgXCJyZWNpcGllbnQtbGlzdC1tZXNzYWdlXCI6IHRydWUsXG4gICAgICAgIFwicmVjaXBpZW50LWxpc3Qtc3Vic2NyaWJlXCI6IHRydWUsXG4gICAgICAgIFwicmVwbGFjZXNcIjogdHJ1ZSxcbiAgICAgICAgXCJyZXNvdXJjZS1wcmlvcml0eVwiOiB0cnVlLFxuICAgICAgICBcInNkcC1hbmF0XCI6IHRydWUsXG4gICAgICAgIFwic2VjLWFncmVlXCI6IHRydWUsXG4gICAgICAgIFwidGRpYWxvZ1wiOiB0cnVlLFxuICAgICAgICBcInRpbWVyXCI6IHRydWUsXG4gICAgICAgIFwidXVpXCI6IHRydWUgLy8gUkZDIDc0MzNcbiAgICB9O1xuICAgIHZhciBkdG1mVHlwZTtcbiAgICAoZnVuY3Rpb24gKGR0bWZUeXBlKSB7XG4gICAgICAgIGR0bWZUeXBlW1wiSU5GT1wiXSA9IFwiaW5mb1wiO1xuICAgICAgICBkdG1mVHlwZVtcIlJUUFwiXSA9IFwicnRwXCI7XG4gICAgfSkoZHRtZlR5cGUgPSBDLmR0bWZUeXBlIHx8IChDLmR0bWZUeXBlID0ge30pKTtcbn0pKEMgPSBleHBvcnRzLkMgfHwgKGV4cG9ydHMuQyA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8vIGVudW1zIGNhbid0IHJlYWxseSBiZSBkZWNsYXJlZCwgc28gdGhleSBhcmUgc2V0IGhlcmUuXG4vLyBwdWxsZWQgb3V0IG9mIGluZGl2aWR1YWwgZmlsZXMgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGlhbG9nU3RhdHVzO1xuKGZ1bmN0aW9uIChEaWFsb2dTdGF0dXMpIHtcbiAgICBEaWFsb2dTdGF0dXNbRGlhbG9nU3RhdHVzW1wiU1RBVFVTX0VBUkxZXCJdID0gMV0gPSBcIlNUQVRVU19FQVJMWVwiO1xuICAgIERpYWxvZ1N0YXR1c1tEaWFsb2dTdGF0dXNbXCJTVEFUVVNfQ09ORklSTUVEXCJdID0gMl0gPSBcIlNUQVRVU19DT05GSVJNRURcIjtcbn0pKERpYWxvZ1N0YXR1cyA9IGV4cG9ydHMuRGlhbG9nU3RhdHVzIHx8IChleHBvcnRzLkRpYWxvZ1N0YXR1cyA9IHt9KSk7XG52YXIgU2Vzc2lvblN0YXR1cztcbihmdW5jdGlvbiAoU2Vzc2lvblN0YXR1cykge1xuICAgIC8vIFNlc3Npb24gc3RhdGVzXG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX05VTExcIl0gPSAwXSA9IFwiU1RBVFVTX05VTExcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfSU5WSVRFX1NFTlRcIl0gPSAxXSA9IFwiU1RBVFVTX0lOVklURV9TRU5UXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTXzFYWF9SRUNFSVZFRFwiXSA9IDJdID0gXCJTVEFUVVNfMVhYX1JFQ0VJVkVEXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX0lOVklURV9SRUNFSVZFRFwiXSA9IDNdID0gXCJTVEFUVVNfSU5WSVRFX1JFQ0VJVkVEXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUlwiXSA9IDRdID0gXCJTVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX0FOU1dFUkVEXCJdID0gNV0gPSBcIlNUQVRVU19BTlNXRVJFRFwiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDS1wiXSA9IDZdID0gXCJTVEFUVVNfV0FJVElOR19GT1JfUFJBQ0tcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfV0FJVElOR19GT1JfQUNLXCJdID0gN10gPSBcIlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0tcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfQ0FOQ0VMRURcIl0gPSA4XSA9IFwiU1RBVFVTX0NBTkNFTEVEXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX1RFUk1JTkFURURcIl0gPSA5XSA9IFwiU1RBVFVTX1RFUk1JTkFURURcIjtcbiAgICBTZXNzaW9uU3RhdHVzW1Nlc3Npb25TdGF0dXNbXCJTVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0tcIl0gPSAxMF0gPSBcIlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDS1wiO1xuICAgIFNlc3Npb25TdGF0dXNbU2Vzc2lvblN0YXR1c1tcIlNUQVRVU19FQVJMWV9NRURJQVwiXSA9IDExXSA9IFwiU1RBVFVTX0VBUkxZX01FRElBXCI7XG4gICAgU2Vzc2lvblN0YXR1c1tTZXNzaW9uU3RhdHVzW1wiU1RBVFVTX0NPTkZJUk1FRFwiXSA9IDEyXSA9IFwiU1RBVFVTX0NPTkZJUk1FRFwiO1xufSkoU2Vzc2lvblN0YXR1cyA9IGV4cG9ydHMuU2Vzc2lvblN0YXR1cyB8fCAoZXhwb3J0cy5TZXNzaW9uU3RhdHVzID0ge30pKTtcbnZhciBUeXBlU3RyaW5ncztcbihmdW5jdGlvbiAoVHlwZVN0cmluZ3MpIHtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIkNsaWVudENvbnRleHRcIl0gPSAwXSA9IFwiQ2xpZW50Q29udGV4dFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiQ29uZmlndXJhdGlvbkVycm9yXCJdID0gMV0gPSBcIkNvbmZpZ3VyYXRpb25FcnJvclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiRGlhbG9nXCJdID0gMl0gPSBcIkRpYWxvZ1wiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiRGlnZXN0QXV0aGVudGljYXRpb25cIl0gPSAzXSA9IFwiRGlnZXN0QXV0aGVudGljYXRpb25cIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIkRUTUZcIl0gPSA0XSA9IFwiRFRNRlwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiSW5jb21pbmdNZXNzYWdlXCJdID0gNV0gPSBcIkluY29taW5nTWVzc2FnZVwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiSW5jb21pbmdSZXF1ZXN0XCJdID0gNl0gPSBcIkluY29taW5nUmVxdWVzdFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiSW5jb21pbmdSZXNwb25zZVwiXSA9IDddID0gXCJJbmNvbWluZ1Jlc3BvbnNlXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbnZhbGlkU3RhdGVFcnJvclwiXSA9IDhdID0gXCJJbnZhbGlkU3RhdGVFcnJvclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiSW52aXRlQ2xpZW50Q29udGV4dFwiXSA9IDldID0gXCJJbnZpdGVDbGllbnRDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJJbnZpdGVTZXJ2ZXJDb250ZXh0XCJdID0gMTBdID0gXCJJbnZpdGVTZXJ2ZXJDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJMb2dnZXJcIl0gPSAxMV0gPSBcIkxvZ2dlclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiTG9nZ2VyRmFjdG9yeVwiXSA9IDEyXSA9IFwiTG9nZ2VyRmFjdG9yeVwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiTWV0aG9kUGFyYW1ldGVyRXJyb3JcIl0gPSAxM10gPSBcIk1ldGhvZFBhcmFtZXRlckVycm9yXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJOYW1lQWRkckhlYWRlclwiXSA9IDE0XSA9IFwiTmFtZUFkZHJIZWFkZXJcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIk5vdFN1cHBvcnRlZEVycm9yXCJdID0gMTVdID0gXCJOb3RTdXBwb3J0ZWRFcnJvclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiT3V0Z29pbmdSZXF1ZXN0XCJdID0gMTZdID0gXCJPdXRnb2luZ1JlcXVlc3RcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlBhcmFtZXRlcnNcIl0gPSAxN10gPSBcIlBhcmFtZXRlcnNcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlB1Ymxpc2hDb250ZXh0XCJdID0gMThdID0gXCJQdWJsaXNoQ29udGV4dFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUmVmZXJDbGllbnRDb250ZXh0XCJdID0gMTldID0gXCJSZWZlckNsaWVudENvbnRleHRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlJlZmVyU2VydmVyQ29udGV4dFwiXSA9IDIwXSA9IFwiUmVmZXJTZXJ2ZXJDb250ZXh0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJSZWdpc3RlckNvbnRleHRcIl0gPSAyMV0gPSBcIlJlZ2lzdGVyQ29udGV4dFwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiUmVuZWdvdGlhdGlvbkVycm9yXCJdID0gMjJdID0gXCJSZW5lZ290aWF0aW9uRXJyb3JcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlJlcXVlc3RTZW5kZXJcIl0gPSAyM10gPSBcIlJlcXVlc3RTZW5kZXJcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlNlcnZlckNvbnRleHRcIl0gPSAyNF0gPSBcIlNlcnZlckNvbnRleHRcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlNlc3Npb25cIl0gPSAyNV0gPSBcIlNlc3Npb25cIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcIl0gPSAyNl0gPSBcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvclwiXSA9IDI3XSA9IFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yXCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXJcIl0gPSAyOF0gPSBcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlclwiO1xuICAgIFR5cGVTdHJpbmdzW1R5cGVTdHJpbmdzW1wiU3Vic2NyaXB0aW9uXCJdID0gMjldID0gXCJTdWJzY3JpcHRpb25cIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlRyYW5zcG9ydFwiXSA9IDMwXSA9IFwiVHJhbnNwb3J0XCI7XG4gICAgVHlwZVN0cmluZ3NbVHlwZVN0cmluZ3NbXCJVQVwiXSA9IDMxXSA9IFwiVUFcIjtcbiAgICBUeXBlU3RyaW5nc1tUeXBlU3RyaW5nc1tcIlVSSVwiXSA9IDMyXSA9IFwiVVJJXCI7XG59KShUeXBlU3RyaW5ncyA9IGV4cG9ydHMuVHlwZVN0cmluZ3MgfHwgKGV4cG9ydHMuVHlwZVN0cmluZ3MgPSB7fSkpO1xuLy8gVUEgc3RhdHVzIGNvZGVzXG52YXIgVUFTdGF0dXM7XG4oZnVuY3Rpb24gKFVBU3RhdHVzKSB7XG4gICAgVUFTdGF0dXNbVUFTdGF0dXNbXCJTVEFUVVNfSU5JVFwiXSA9IDBdID0gXCJTVEFUVVNfSU5JVFwiO1xuICAgIFVBU3RhdHVzW1VBU3RhdHVzW1wiU1RBVFVTX1NUQVJUSU5HXCJdID0gMV0gPSBcIlNUQVRVU19TVEFSVElOR1wiO1xuICAgIFVBU3RhdHVzW1VBU3RhdHVzW1wiU1RBVFVTX1JFQURZXCJdID0gMl0gPSBcIlNUQVRVU19SRUFEWVwiO1xuICAgIFVBU3RhdHVzW1VBU3RhdHVzW1wiU1RBVFVTX1VTRVJfQ0xPU0VEXCJdID0gM10gPSBcIlNUQVRVU19VU0VSX0NMT1NFRFwiO1xuICAgIFVBU3RhdHVzW1VBU3RhdHVzW1wiU1RBVFVTX05PVF9SRUFEWVwiXSA9IDRdID0gXCJTVEFUVVNfTk9UX1JFQURZXCI7XG59KShVQVN0YXR1cyA9IGV4cG9ydHMuVUFTdGF0dXMgfHwgKGV4cG9ydHMuVUFTdGF0dXMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG52YXIgRXhjZXB0aW9ucztcbihmdW5jdGlvbiAoRXhjZXB0aW9ucykge1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGhhcyBjbG9zZWQuXG4gICAgICogT2NjdXJzIHdoZW4gZ2V0RGVzY3JpcHRpb24oKSBvciBzZXREZXNjcmlwdGlvbigpIGFyZSBjYWxsZWQgYWZ0ZXIgY2xvc2UoKSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICogT2NjdXJzIHdoZW4gY2xvc2UoKSBpcyBjYWxsZWQgd2hpbGUgZ2V0RGVzY3JpcHRpb24oKSBvciBzZXREZXNjcmlwdGlvbigpIGFyZSBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICB2YXIgQ2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgaGFzIGNsb3NlZC5cIikgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xuICAgIH0oY29yZV8xLkV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuQ2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yID0gQ2xvc2VkU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgc2Vzc2lvbiB0ZXJtaW5hdGVkIGJlZm9yZSB0aGUgYWN0aW9uIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICB2YXIgVGVybWluYXRlZFNlc3Npb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoVGVybWluYXRlZFNlc3Npb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVGVybWluYXRlZFNlc3Npb25FcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlRoZSBzZXNzaW9uIGhhcyB0ZXJtaW5hdGVkLlwiKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUZXJtaW5hdGVkU2Vzc2lvbkVycm9yO1xuICAgIH0oY29yZV8xLkV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuVGVybWluYXRlZFNlc3Npb25FcnJvciA9IFRlcm1pbmF0ZWRTZXNzaW9uRXJyb3I7XG4gICAgLyoqXG4gICAgICogVW5zdXBwb3J0ZWQgc2Vzc2lvbiBkZXNjcmlwdGlvbiBjb250ZW50IHR5cGUuXG4gICAgICovXG4gICAgdmFyIFVuc3VwcG9ydGVkU2Vzc2lvbkRlc2NyaXB0aW9uQ29udGVudFR5cGVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVbnN1cHBvcnRlZFNlc3Npb25EZXNjcmlwdGlvbkNvbnRlbnRUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJVbnN1cHBvcnRlZCBzZXNzaW9uIGRlc2NyaXB0aW9uIGNvbnRlbnQgdHlwZS5cIikgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yO1xuICAgIH0oY29yZV8xLkV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yID0gVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yO1xufSkoRXhjZXB0aW9ucyA9IGV4cG9ydHMuRXhjZXB0aW9ucyB8fCAoZXhwb3J0cy5FeGNlcHRpb25zID0ge30pKTtcbi8qKlxuICogREVQUkVDQVRFRDogVGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIG9mIGV4Y2VwdGlvbnMgaW4gdGhpcyBsaWJyYXJ5IGF0dGVtcHRlZCB0b1xuICogZGVhbCB3aXRoIHRoZSBsYWNrIG9mIHR5cGUgY2hlY2tpbmcgaW4gSmF2YVNjcmlwdCBieSBhZGRpbmcgYSBcInR5cGVcIiBhdHRyaWJ1dGVcbiAqIHRvIG9iamVjdHMgYW5kIHVzaW5nIHRoYXQgdG8gZGlzY3JpbWluYXRlLiBPbiB0b3Agb2YgdGhhdCBpdCBsYXllcmVkIGFsbGNvYXRlZFxuICogXCJjb2RlXCIgbnVtYmVycyBhbmQgY29uc3RhbnQgXCJuYW1lXCIgc3RyaW5ncy4gQWxsIG9mIHRoYXQgaXMgdW5uZWNlc3Nhcnkgd2hlbiB1c2luZ1xuICogVHlwZVNjcmlwdCwgaW5oZXJpdGluZyBmcm9tIEVycm9yIGFuZCBwcm9wZXJseSBzZXR0aW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uLi5cbiAqL1xudmFyIExlZ2FjeUV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhMZWdhY3lFeGNlcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVnYWN5RXhjZXB0aW9uKGNvZGUsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIF90aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGVnYWN5RXhjZXB0aW9uO1xufShjb3JlXzEuRXhjZXB0aW9uKSk7XG4oZnVuY3Rpb24gKEV4Y2VwdGlvbnMpIHtcbiAgICB2YXIgQ29uZmlndXJhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25maWd1cmF0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAxLCBcIkNPTkZJR1VSQVRJT05fRVJST1JcIiwgKCF2YWx1ZSkgPyBcIk1pc3NpbmcgcGFyYW1ldGVyOiBcIiArIHBhcmFtZXRlciA6XG4gICAgICAgICAgICAgICAgXCJJbnZhbGlkIHZhbHVlIFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIgZm9yIHBhcmFtZXRlciAnXCIgKyBwYXJhbWV0ZXIgKyBcIidcIikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLkNvbmZpZ3VyYXRpb25FcnJvcjtcbiAgICAgICAgICAgIF90aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbmZpZ3VyYXRpb25FcnJvcjtcbiAgICB9KExlZ2FjeUV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yID0gQ29uZmlndXJhdGlvbkVycm9yO1xuICAgIHZhciBJbnZhbGlkU3RhdGVFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52YWxpZFN0YXRlRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEludmFsaWRTdGF0ZUVycm9yKHN0YXR1cykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgMiwgXCJJTlZBTElEX1NUQVRFX0VSUk9SXCIsIFwiSW52YWxpZCBzdGF0dXM6IFwiICsgc3RhdHVzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuSW52YWxpZFN0YXRlRXJyb3I7XG4gICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yO1xuICAgIH0oTGVnYWN5RXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvciA9IEludmFsaWRTdGF0ZUVycm9yO1xuICAgIHZhciBOb3RTdXBwb3J0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoTm90U3VwcG9ydGVkRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5vdFN1cHBvcnRlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDMsIFwiTk9UX1NVUFBPUlRFRF9FUlJPUlwiLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuTm90U3VwcG9ydGVkRXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5vdFN1cHBvcnRlZEVycm9yO1xuICAgIH0oTGVnYWN5RXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFcnJvciA9IE5vdFN1cHBvcnRlZEVycm9yO1xuICAgIC8vIDQgd2FzIEdldERlc2NyaXB0aW9uRXJyb3IsIHdoaWNoIHdhcyBkZXByZWNhdGVkIGFuZCBub3cgcmVtb3ZlZFxuICAgIHZhciBSZW5lZ290aWF0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKFJlbmVnb3RpYXRpb25FcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gUmVuZWdvdGlhdGlvbkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDUsIFwiUkVORUdPVElBVElPTl9FUlJPUlwiLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuUmVuZWdvdGlhdGlvbkVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZW5lZ290aWF0aW9uRXJyb3I7XG4gICAgfShMZWdhY3lFeGNlcHRpb24pKTtcbiAgICBFeGNlcHRpb25zLlJlbmVnb3RpYXRpb25FcnJvciA9IFJlbmVnb3RpYXRpb25FcnJvcjtcbiAgICB2YXIgTWV0aG9kUGFyYW1ldGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKE1ldGhvZFBhcmFtZXRlckVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBNZXRob2RQYXJhbWV0ZXJFcnJvcihtZXRob2QsIHBhcmFtZXRlciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIDYsIFwiTUVUSE9EX1BBUkFNRVRFUl9FUlJPUlwiLCAoIXZhbHVlKSA/XG4gICAgICAgICAgICAgICAgXCJNaXNzaW5nIHBhcmFtZXRlcjogXCIgKyBwYXJhbWV0ZXIgOlxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCB2YWx1ZSBcIiArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFwiIGZvciBwYXJhbWV0ZXIgJ1wiICsgcGFyYW1ldGVyICsgXCInXCIpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5NZXRob2RQYXJhbWV0ZXJFcnJvcjtcbiAgICAgICAgICAgIF90aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgIF90aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1ldGhvZFBhcmFtZXRlckVycm9yO1xuICAgIH0oTGVnYWN5RXhjZXB0aW9uKSk7XG4gICAgRXhjZXB0aW9ucy5NZXRob2RQYXJhbWV0ZXJFcnJvciA9IE1ldGhvZFBhcmFtZXRlckVycm9yO1xuICAgIC8vIDcgd2FzIFRyYW5zcG9ydEVycm9yLCB3aGljaCB3YXMgcmVwbGFjZWRcbiAgICB2YXIgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihtZXRob2QsIGVycm9yLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCA4LCBcIlNFU1NJT05fREVTQ1JJUFRJT05fSEFORExFUl9FUlJPUlwiLCBtZXNzYWdlIHx8IFwiRXJyb3Igd2l0aCBTZXNzaW9uIERlc2NyaXB0aW9uIEhhbmRsZXJcIikgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcjtcbiAgICAgICAgICAgIF90aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcjtcbiAgICB9KExlZ2FjeUV4Y2VwdGlvbikpO1xuICAgIEV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yID0gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xufSkoRXhjZXB0aW9ucyA9IGV4cG9ydHMuRXhjZXB0aW9ucyB8fCAoZXhwb3J0cy5FeGNlcHRpb25zID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ2xpZW50Q29udGV4dF8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29udGV4dFwiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25zXCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1wiKTtcbi8qKlxuICogU0lQIFB1Ymxpc2ggKFNJUCBFeHRlbnNpb24gZm9yIEV2ZW50IFN0YXRlIFB1YmxpY2F0aW9uIFJGQzM5MDMpXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgUHVibGlzaENvbnRleHQuXG4gKi9cbnZhciBQdWJsaXNoQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQdWJsaXNoQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdWJsaXNoQ29udGV4dCh1YSwgdGFyZ2V0LCBldmVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgb3B0aW9ucy5jb250ZW50VHlwZSA9IChvcHRpb25zLmNvbnRlbnRUeXBlIHx8IFwidGV4dC9wbGFpblwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4cGlyZXMgIT09IFwibnVtYmVyXCIgfHwgKG9wdGlvbnMuZXhwaXJlcyAlIDEpICE9PSAwKSB7XG4gICAgICAgICAgICBvcHRpb25zLmV4cGlyZXMgPSAzNjAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucy5leHBpcmVzID0gTnVtYmVyKG9wdGlvbnMuZXhwaXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAob3B0aW9ucy51bnB1Ymxpc2hPbkNsb3NlKSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudW5wdWJsaXNoT25DbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5NZXRob2RQYXJhbWV0ZXJFcnJvcihcIlB1Ymxpc2hcIiwgXCJUYXJnZXRcIiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLk1ldGhvZFBhcmFtZXRlckVycm9yKFwiUHVibGlzaFwiLCBcIlRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdWEsIENvbnN0YW50c18xLkMuUFVCTElTSCwgdGFyZ2V0LCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5QdWJsaXNoQ29udGV4dDtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgaWYgKGV2ZW50ID09PSB1bmRlZmluZWQgfHwgZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5NZXRob2RQYXJhbWV0ZXJFcnJvcihcIlB1Ymxpc2hcIiwgXCJFdmVudFwiLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcihcInNpcC5wdWJsaXNoXCIpO1xuICAgICAgICBfdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IF90aGlzLm9wdGlvbnMuZXhwaXJlcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdWJsaXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IEV2ZW50IGJvZHkgdG8gcHVibGlzaCwgb3B0aW9uYWxcbiAgICAgKi9cbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSB0aGUgcnVuXG4gICAgICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzIEluaXRhbCBvciBNb2RpZnkgcmVxdWVzdFxuICAgICAgICB0aGlzLm9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB0aGlzLm9wdGlvbnMuYm9keTtcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgSW5pdGlhbCByZXF1ZXN0IGFmdGVyIHVucHVibGlzaFxuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IHRoaXMub3B0aW9ucy5leHBpcmVzO1xuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0aGlzLnVhLnB1Ymxpc2hlcnNbdGhpcy50YXJnZXQudG9TdHJpbmcoKSArIFwiOlwiICsgdGhpcy5ldmVudF0pKSB7XG4gICAgICAgICAgICB0aGlzLnVhLnB1Ymxpc2hlcnNbdGhpcy50YXJnZXQudG9TdHJpbmcoKSArIFwiOlwiICsgdGhpcy5ldmVudF0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFB1Ymxpc2hSZXF1ZXN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnB1Ymxpc2hcbiAgICAgKi9cbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUudW5wdWJsaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDbGVhbiB1cCBiZWZvcmUgdGhlIHJ1blxuICAgICAgICBpZiAodGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucHVibGlzaFJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1YlJlcXVlc3RCb2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV0YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kUHVibGlzaFJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2VcbiAgICAgKi9cbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNlbmQgdW5wdWJsaXNoLCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51bnB1Ymxpc2hPbkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLnVucHVibGlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVibGlzaFJlZnJlc2hUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlZnJlc2hUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV0YWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudWEucHVibGlzaGVyc1t0aGlzLnRhcmdldC50b1N0cmluZygpICsgXCI6XCIgKyB0aGlzLmV2ZW50XSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudWEucHVibGlzaGVyc1t0aGlzLnRhcmdldC50b1N0cmluZygpICsgXCI6XCIgKyB0aGlzLmV2ZW50XTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVibGlzaENvbnRleHQucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ1bnB1Ymxpc2hlZFwiLCB1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZW1pdChcInVucHVibGlzaGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAwO1xuICAgICAgICB2YXIgY2F1c2UgPSBVdGlsc18xLlV0aWxzLmdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlKTtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlLnRvU3RyaW5nKCkpOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInByb2dyZXNzXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlLnRvU3RyaW5nKCkpOlxuICAgICAgICAgICAgICAgIC8vIFNldCBTSVAtRXRhZ1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oYXNIZWFkZXIoXCJTSVAtRVRhZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFdGFnID0gcmVzcG9uc2UuZ2V0SGVhZGVyKFwiU0lQLUVUYWdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiU0lQLUVUYWcgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gUFVCTElTSFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEV4cGlyZVxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oYXNIZWFkZXIoXCJFeHBpcmVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBpcmVzID0gTnVtYmVyKHJlc3BvbnNlLmdldEhlYWRlcihcIkV4cGlyZXNcIikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyZXMgPT09IFwibnVtYmVyXCIgJiYgZXhwaXJlcyA+PSAwICYmIGV4cGlyZXMgPD0gdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXhwaXJlcyA9IGV4cGlyZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQmFkIEV4cGlyZXMgaGVhZGVyIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFBVQkxJU0hcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFeHBpcmVzIGhlYWRlciBtaXNzaW5nIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFBVQkxJU0hcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIHJlZnJlc2hcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5yZWZyZXNoUmVxdWVzdCgpOyB9LCB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICogOTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicHVibGlzaGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1bnB1Ymxpc2hlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL140MTIkLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgLy8gNDEyIGNvZGUgbWVhbnMgbm8gbWF0Y2hpbmcgRVRhZyAtIHBvc3NpYmx5IHRoZSBQVUJMSVNIIGV4cGlyZWRcbiAgICAgICAgICAgICAgICAvLyBSZXN1Ym1pdCBhcyBuZXcgcmVxdWVzdCwgaWYgdGhlIGN1cnJlbnQgcmVxdWVzdCBpcyBub3QgYSBcInJlbW92ZVwiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV0YWcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCI0MTIgcmVzcG9uc2UgdG8gUFVCTElTSCwgcmVjb3ZlcmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaXNoKHRoaXMub3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCI0MTIgcmVzcG9uc2UgdG8gUFVCTElTSCwgcmVjb3ZlcnkgZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVucHVibGlzaGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjQyMyQvLnRlc3Qoc3RhdHVzQ29kZS50b1N0cmluZygpKTpcbiAgICAgICAgICAgICAgICAvLyA0MjMgY29kZSBtZWFucyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgRXhwaXJlcyBpbnRlcnZhbCB1cFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFeHBpcmVzICE9PSAwICYmIHJlc3BvbnNlLmhhc0hlYWRlcihcIk1pbi1FeHBpcmVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5FeHBpcmVzID0gTnVtYmVyKHJlc3BvbnNlLmdldEhlYWRlcihcIk1pbi1FeHBpcmVzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtaW5FeHBpcmVzID09PSBcIm51bWJlclwiIHx8IG1pbkV4cGlyZXMgPiB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiNDIzIGNvZGUgaW4gcmVzcG9uc2UgdG8gUFVCTElTSCwgYWRqdXN0aW5nIHRoZSBFeHBpcmVzIHZhbHVlIGFuZCB0cnlpbmcgdG8gcmVjb3ZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSBtaW5FeHBpcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaCh0aGlzLm9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQmFkIDQyMyByZXNwb25zZSBNaW4tRXhwaXJlcyBoZWFkZXIgcmVjZWl2ZWQgZm9yIFBVQkxJU0hcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5wdWJsaXNoZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIjQyMyByZXNwb25zZSB0byBQVUJMSVNILCByZWNvdmVyeSBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidW5wdWJsaXNoZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVucHVibGlzaGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gdGhlIGNsZWFudXBcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV4cGlyZXMgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnB1YlJlcXVlc3RCb2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wdWJSZXF1ZXN0RXRhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVibGlzaENvbnRleHQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudWEudXNlckFnZW50Q29yZS5wdWJsaXNoKHRoaXMucmVxdWVzdCwge1xuICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQdWJsaXNoQ29udGV4dC5wcm90b3R5cGUucmVmcmVzaFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENsZWFuIHVwIGJlZm9yZSB0aGUgcnVuXG4gICAgICAgIGlmICh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnB1Ymxpc2hSZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgUmVmcmVzaCByZXF1ZXN0XG4gICAgICAgIHRoaXMucHViUmVxdWVzdEJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFdGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3Qgbm90IHZhbGlkXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuTWV0aG9kUGFyYW1ldGVyRXJyb3IoXCJQdWJsaXNoXCIsIFwiQm9keVwiLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RFeHBpcmVzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IG5vdCB2YWxpZFxuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLk1ldGhvZFBhcmFtZXRlckVycm9yKFwiUHVibGlzaFwiLCBcIkV4cGlyZVwiLCB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRQdWJsaXNoUmVxdWVzdCgpO1xuICAgIH07XG4gICAgUHVibGlzaENvbnRleHQucHJvdG90eXBlLnNlbmRQdWJsaXNoUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcU9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHRoaXMub3B0aW9ucyB8fCBPYmplY3QucHJvdG90eXBlKTtcbiAgICAgICAgcmVxT3B0aW9ucy5leHRyYUhlYWRlcnMgPSAodGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgcmVxT3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV2ZW50OiBcIiArIHRoaXMuZXZlbnQpO1xuICAgICAgICByZXFPcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKFwiRXhwaXJlczogXCIgKyB0aGlzLnB1YlJlcXVlc3RFeHBpcmVzKTtcbiAgICAgICAgaWYgKHRoaXMucHViUmVxdWVzdEV0YWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxT3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIlNJUC1JZi1NYXRjaDogXCIgKyB0aGlzLnB1YlJlcXVlc3RFdGFnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVyaSA9IHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgY29yZV8xLlVSSSA/IHRoaXMudGFyZ2V0IDogdGhpcy51YS5ub3JtYWxpemVUYXJnZXQodGhpcy50YXJnZXQpO1xuICAgICAgICBpZiAoIXJ1cmkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJ1cmkgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgdmFyIGJvZHlPYmo7XG4gICAgICAgIGlmICh0aGlzLnB1YlJlcXVlc3RCb2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJvZHlPYmogPSB7XG4gICAgICAgICAgICAgICAgYm9keTogdGhpcy5wdWJSZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5O1xuICAgICAgICBpZiAoYm9keU9iaikge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzXzEuVXRpbHMuZnJvbUJvZHlPYmooYm9keU9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy51YS51c2VyQWdlbnRDb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKENvbnN0YW50c18xLkMuUFVCTElTSCwgcnVyaSwgcGFyYW1zLmZyb21VcmkgPyBwYXJhbXMuZnJvbVVyaSA6IHRoaXMudWEudXNlckFnZW50Q29yZS5jb25maWd1cmF0aW9uLmFvciwgcGFyYW1zLnRvVXJpID8gcGFyYW1zLnRvVXJpIDogdGhpcy50YXJnZXQsIHBhcmFtcywgcmVxT3B0aW9ucy5leHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICB9O1xuICAgIHJldHVybiBQdWJsaXNoQ29udGV4dDtcbn0oQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQpKTtcbmV4cG9ydHMuUHVibGlzaENvbnRleHQgPSBQdWJsaXNoQ29udGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgQ2xpZW50Q29udGV4dF8xID0gcmVxdWlyZShcIi4vQ2xpZW50Q29udGV4dFwiKTtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi9FbnVtc1wiKTtcbnZhciBFeGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25zXCIpO1xudmFyIFNlcnZlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1NlcnZlckNvbnRleHRcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbnZhciBSZWZlckNsaWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVmZXJDbGllbnRDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmVyQ2xpZW50Q29udGV4dCh1YSwgYXBwbGljYW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHVhID09PSB1bmRlZmluZWQgfHwgYXBwbGljYW50ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVhLCBDb25zdGFudHNfMS5DLlJFRkVSLCBhcHBsaWNhbnQucmVtb3RlSWRlbnRpdHkudXJpLnRvU3RyaW5nKCksIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlJlZmVyQ2xpZW50Q29udGV4dDtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIF90aGlzLmV4dHJhSGVhZGVycyA9IChfdGhpcy5vcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgX3RoaXMuYXBwbGljYW50ID0gYXBwbGljYW50O1xuICAgICAgICBfdGhpcy50YXJnZXQgPSBfdGhpcy5pbml0UmVmZXJUbyh0YXJnZXQpO1xuICAgICAgICBpZiAoX3RoaXMudWEpIHtcbiAgICAgICAgICAgIF90aGlzLmV4dHJhSGVhZGVycy5wdXNoKFwiUmVmZXJyZWQtQnk6IDxcIiArIF90aGlzLnVhLmNvbmZpZ3VyYXRpb24udXJpICsgXCI+XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IENoZWNrIHRoYXQgdGhpcyBpcyBjb3JyZWN0IGlzYy9pY2NcbiAgICAgICAgX3RoaXMuZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIGFwcGxpY2FudC5jb250YWN0KTtcbiAgICAgICAgLy8gdGhpcyBpcyBVQS5DLkFMTE9XRURfTUVUSE9EUywgcmVtb3ZlZCB0byBnZXQgYXJvdW5kIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgX3RoaXMuZXh0cmFIZWFkZXJzLnB1c2goXCJBbGxvdzogXCIgKyBbXG4gICAgICAgICAgICBcIkFDS1wiLFxuICAgICAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgICAgICBcIk1FU1NBR0VcIixcbiAgICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICAgIFwiSU5GT1wiLFxuICAgICAgICAgICAgXCJOT1RJRllcIixcbiAgICAgICAgICAgIFwiUkVGRVJcIlxuICAgICAgICBdLnRvU3RyaW5nKCkpO1xuICAgICAgICBfdGhpcy5leHRyYUhlYWRlcnMucHVzaChcIlJlZmVyLVRvOiBcIiArIF90aGlzLnRhcmdldCk7XG4gICAgICAgIF90aGlzLmVycm9yTGlzdGVuZXIgPSBfdGhpcy5vblRyYW5zcG9ydEVycm9yLmJpbmQoX3RoaXMpO1xuICAgICAgICBpZiAodWEudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB1YS50cmFuc3BvcnQub24oXCJ0cmFuc3BvcnRFcnJvclwiLCBfdGhpcy5lcnJvckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZmVyQ2xpZW50Q29udGV4dC5wcm90b3R5cGUucmVmZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKHRoaXMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5jb25jYXQob3B0aW9ucy5leHRyYUhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbGljYW50LnNlbmRSZXF1ZXN0KENvbnN0YW50c18xLkMuUkVGRVIsIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5leHRyYUhlYWRlcnMsXG4gICAgICAgICAgICByZWNlaXZlUmVzcG9uc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA/IHJlc3BvbnNlLnN0YXR1c0NvZGUudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKC9eMVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmZXJSZXF1ZXN0UHJvZ3Jlc3NcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvXjJbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZmVyUmVxdWVzdEFjY2VwdGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL15bNC02XVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVmZXJSZXF1ZXN0UmVqZWN0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVmZXJDbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlTm90aWZ5ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuIGNvcnJlY3RseSBoYW5kbGUgdGhpcywgdGhlbiB3ZSBuZWVkIHRvIHNlbmQgYSAyMDAgT0shXG4gICAgICAgIHZhciBjb250ZW50VHlwZSA9IHJlcXVlc3QubWVzc2FnZS5oYXNIZWFkZXIoXCJDb250ZW50LVR5cGVcIikgP1xuICAgICAgICAgICAgcmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLnNlYXJjaCgvXm1lc3NhZ2VcXC9zaXBmcmFnLykgIT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZUJvZHkgPSBjb3JlXzEuR3JhbW1hci5wYXJzZShyZXF1ZXN0Lm1lc3NhZ2UuYm9keSwgXCJzaXBmcmFnXCIpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VCb2R5ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDg5LFxuICAgICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQmFkIEV2ZW50XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICgvXjFbMC05XXsyfSQvLnRlc3QobWVzc2FnZUJvZHkuc3RhdHVzX2NvZGUpKTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJQcm9ncmVzc1wiLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAoL14yWzAtOV17Mn0kLy50ZXN0KG1lc3NhZ2VCb2R5LnN0YXR1c19jb2RlKSk6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInJlZmVyQWNjZXB0ZWRcIiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFjdGl2ZUFmdGVyVHJhbnNmZXIgJiYgdGhpcy5hcHBsaWNhbnQudGVybWluYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2FudC50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWZlclJlamVjdGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJub3RpZnlcIiwgcmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnJlamVjdCh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0ODksXG4gICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQmFkIEV2ZW50XCJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWZlckNsaWVudENvbnRleHQucHJvdG90eXBlLmluaXRSZWZlclRvID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB2YXIgc3RyaW5nT3JVUkk7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBSRUZFUiB3aXRob3V0IFJlcGxhY2VzIChCbGluZCBUcmFuc2ZlcilcbiAgICAgICAgICAgIHZhciB0YXJnZXRTdHJpbmcgPSBjb3JlXzEuR3JhbW1hci5wYXJzZSh0YXJnZXQsIFwiUmVmZXJfVG9cIik7XG4gICAgICAgICAgICBzdHJpbmdPclVSSSA9IHRhcmdldFN0cmluZyAmJiB0YXJnZXRTdHJpbmcudXJpID8gdGFyZ2V0U3RyaW5nLnVyaSA6IHRhcmdldDtcbiAgICAgICAgICAgIC8vIENoZWNrIHRhcmdldCB2YWxpZGl0eVxuICAgICAgICAgICAgdmFyIHRhcmdldFVyaSA9IHRoaXMudWEubm9ybWFsaXplVGFyZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFVyaSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRhcmdldDogXCIgKyB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nT3JVUkkgPSB0YXJnZXRVcmk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSRUZFUiB3aXRoIFJlcGxhY2VzIChBdHRlbmRlZCBUcmFuc2ZlcilcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0YXJnZXQucmVtb3RlSWRlbnRpdHkuZnJpZW5kbHlOYW1lO1xuICAgICAgICAgICAgdmFyIHJlbW90ZVRhcmdldCA9IHRhcmdldC5zZXNzaW9uLnJlbW90ZVRhcmdldC50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGNhbGxJZCA9IHRhcmdldC5zZXNzaW9uLmNhbGxJZDtcbiAgICAgICAgICAgIHZhciByZW1vdGVUYWcgPSB0YXJnZXQuc2Vzc2lvbi5yZW1vdGVUYWc7XG4gICAgICAgICAgICB2YXIgbG9jYWxUYWcgPSB0YXJnZXQuc2Vzc2lvbi5sb2NhbFRhZztcbiAgICAgICAgICAgIHZhciByZXBsYWNlcyA9IGVuY29kZVVSSUNvbXBvbmVudChjYWxsSWQgKyBcIjt0by10YWc9XCIgKyByZW1vdGVUYWcgKyBcIjtmcm9tLXRhZz1cIiArIGxvY2FsVGFnKTtcbiAgICAgICAgICAgIHN0cmluZ09yVVJJID0gXCJcXFwiXCIgKyBkaXNwbGF5TmFtZSArIFwiXFxcIiA8XCIgKyByZW1vdGVUYXJnZXQgKyBcIj9SZXBsYWNlcz1cIiArIHJlcGxhY2VzICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ09yVVJJO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZmVyQ2xpZW50Q29udGV4dDtcbn0oQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQpKTtcbmV4cG9ydHMuUmVmZXJDbGllbnRDb250ZXh0ID0gUmVmZXJDbGllbnRDb250ZXh0O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1jbGFzc2VzLXBlci1maWxlXG52YXIgUmVmZXJTZXJ2ZXJDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlZmVyU2VydmVyQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZlclNlcnZlckNvbnRleHQodWEsIGluY29taW5nUmVxdWVzdCwgc2Vzc2lvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1YSwgaW5jb21pbmdSZXF1ZXN0KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuUmVmZXJTZXJ2ZXJDb250ZXh0O1xuICAgICAgICBfdGhpcy51YSA9IHVhO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0lOVklURV9SRUNFSVZFRDtcbiAgICAgICAgX3RoaXMuZnJvbVRhZyA9IF90aGlzLnJlcXVlc3QuZnJvbVRhZztcbiAgICAgICAgX3RoaXMuaWQgPSBfdGhpcy5yZXF1ZXN0LmNhbGxJZCArIF90aGlzLmZyb21UYWc7XG4gICAgICAgIF90aGlzLmNvbnRhY3QgPSBfdGhpcy51YS5jb250YWN0LnRvU3RyaW5nKCk7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcihcInNpcC5yZWZlcnNlcnZlcmNvbnRleHRcIiwgX3RoaXMuaWQpO1xuICAgICAgICAvLyBOZWVkZWQgdG8gc2VuZCB0aGUgTk9USUZZJ3NcbiAgICAgICAgX3RoaXMuY3NlcSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgICAgX3RoaXMuY2FsbElkID0gX3RoaXMucmVxdWVzdC5jYWxsSWQ7XG4gICAgICAgIF90aGlzLmZyb21VcmkgPSBfdGhpcy5yZXF1ZXN0LnRvLnVyaTtcbiAgICAgICAgX3RoaXMuZnJvbVRhZyA9IF90aGlzLnJlcXVlc3QudG8ucGFyYW1ldGVycy50YWc7XG4gICAgICAgIF90aGlzLnJlbW90ZVRhcmdldCA9IF90aGlzLnJlcXVlc3QuaGVhZGVycy5Db250YWN0WzBdLnBhcnNlZC51cmk7XG4gICAgICAgIF90aGlzLnRvVXJpID0gX3RoaXMucmVxdWVzdC5mcm9tLnVyaTtcbiAgICAgICAgX3RoaXMudG9UYWcgPSBfdGhpcy5yZXF1ZXN0LmZyb21UYWc7XG4gICAgICAgIF90aGlzLnJvdXRlU2V0ID0gX3RoaXMucmVxdWVzdC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpO1xuICAgICAgICAvLyBSRkMgMzUxNSAyLjQuMVxuICAgICAgICBpZiAoIV90aGlzLnJlcXVlc3QuaGFzSGVhZGVyKFwicmVmZXItdG9cIikpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiSW52YWxpZCBSRUZFUiBwYWNrZXQuIEEgcmVmZXItdG8gaGVhZGVyIGlzIHJlcXVpcmVkLiBSZWplY3RpbmcgcmVmZXIuXCIpO1xuICAgICAgICAgICAgX3RoaXMucmVqZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMucmVmZXJUbyA9IF90aGlzLnJlcXVlc3QucGFyc2VIZWFkZXIoXCJyZWZlci10b1wiKTtcbiAgICAgICAgLy8gVE9ETzogTXVzdCBzZXQgZXhwaXJhdGlvbiB0aW1lciBhbmQgc2VuZCAyMDIgaWYgdGhlcmUgaXMgbm8gcmVzcG9uc2UgYnkgdGhlblxuICAgICAgICBfdGhpcy5yZWZlcnJlZFNlc3Npb24gPSBfdGhpcy51YS5maW5kU2Vzc2lvbihfdGhpcy5yZXF1ZXN0KTtcbiAgICAgICAgaWYgKF90aGlzLnJlcXVlc3QuaGFzSGVhZGVyKFwicmVmZXJyZWQtYnlcIikpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZmVycmVkQnkgPSBfdGhpcy5yZXF1ZXN0LmdldEhlYWRlcihcInJlZmVycmVkLWJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5yZWZlclRvLnVyaS5oYXNIZWFkZXIoXCJyZXBsYWNlc1wiKSkge1xuICAgICAgICAgICAgX3RoaXMucmVwbGFjZXMgPSBfdGhpcy5yZWZlclRvLnVyaS5nZXRIZWFkZXIoXCJyZXBsYWNlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5lcnJvckxpc3RlbmVyID0gX3RoaXMub25UcmFuc3BvcnRFcnJvci5iaW5kKF90aGlzKTtcbiAgICAgICAgaWYgKHVhLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdWEudHJhbnNwb3J0Lm9uKFwidHJhbnNwb3J0RXJyb3JcIiwgX3RoaXMuZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVmZXJTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC50cnlpbmcoKTtcbiAgICB9O1xuICAgIFJlZmVyU2VydmVyQ29udGV4dC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiUmVqZWN0aW5nIHJlZmVyXCIpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRDtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWplY3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJSZXF1ZXN0UmVqZWN0ZWRcIiwgdGhpcyk7XG4gICAgfTtcbiAgICBSZWZlclNlcnZlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC5hY2NlcHQoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAyLFxuICAgICAgICAgICAgcmVhc29uUGhyYXNlOiBcIkFjY2VwdGVkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcInJlZmVyUmVxdWVzdEFjY2VwdGVkXCIsIHRoaXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5mb2xsb3dSZWZlcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiQWNjZXB0ZWQgcmVmZXIsIGF0dGVtcHRpbmcgdG8gYXV0b21hdGljYWxseSBmb2xsb3cgaXRcIik7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5yZWZlclRvLnVyaTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnNjaGVtZSB8fCAhdGFyZ2V0LnNjaGVtZS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNJUC5qcyBjYW4gb25seSBhdXRvbWF0aWNhbGx5IGZvbGxvdyBTSVAgcmVmZXIgdGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGludml0ZU9wdGlvbnMgPSBvcHRpb25zLmludml0ZU9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKGludml0ZU9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWNvZGVVUklDb21wb25lbnQgaXMgYSBob2xkb3ZlciBmcm9tIDJjMDg2ZWI0LiBOb3Qgc3VyZSB0aGF0IGl0IGlzIGFjdHVhbGx5IG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVwbGFjZXM6IFwiICsgZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMucmVwbGFjZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVycmVkQnkpIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlZmVycmVkLUJ5OiBcIiArIHRoaXMucmVmZXJyZWRCeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnZpdGVPcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgICAgIHRhcmdldC5jbGVhckhlYWRlcnMoKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2Vzc2lvbiA9IHRoaXMudWEuaW52aXRlKHRhcmdldC50b1N0cmluZygpLCBpbnZpdGVPcHRpb25zLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJJbnZpdGVTZW50XCIsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2Vzc2lvbi5vbmNlKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZSB8fCAxMDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb25QaHJhc2UgPSByZXNwb25zZS5yZWFzb25QaHJhc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmROb3RpZnkoKFwiU0lQLzIuMCBcIiArIHN0YXR1c0NvZGUgKyBcIiBcIiArIHJlYXNvblBocmFzZSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZmVyUHJvZ3Jlc3NcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVmZXJyZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZlcnJlZFNlc3Npb24uZW1pdChcInJlZmVyUHJvZ3Jlc3NcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRTZXNzaW9uLm9uY2UoXCJhY2NlcHRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJTdWNjZXNzZnVsbHkgZm9sbG93ZWQgdGhlIHJlZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kTm90aWZ5KFwiU0lQLzIuMCAyMDAgT0tcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWZlckFjY2VwdGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlZmVycmVkU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVmZXJyZWRTZXNzaW9uLmVtaXQoXCJyZWZlckFjY2VwdGVkXCIsIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciByZWZlckZhaWxlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gTm8gdGhyb3cgaGVyZSBiZWNhdXNlIGl0IGlzIHBvc3NpYmxlIHRoaXMgZ2V0cyBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiUmVmZXIgd2FzIG5vdCBzdWNjZXNzZnVsLiBSZXN1bWluZyBzZXNzaW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiQWxlcnRpbmcgcmVmZXJyZXIgdGhhdCBpZGVudGl0eSBpcyByZXF1aXJlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kTm90aWZ5KFwiU0lQLzIuMCA0MjkgUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kTm90aWZ5KFwiU0lQLzIuMCA2MDMgRGVjbGluZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE11c3QgY2hhbmdlIHRoZSBzdGF0dXMgYWZ0ZXIgc2VuZGluZyB0aGUgZmluYWwgTm90aWZ5IG9yIGl0IHdpbGwgbm90IHNlbmQgZHVlIHRvIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZmVyUmVqZWN0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVmZXJyZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWZlcnJlZFNlc3Npb24uZW1pdChcInJlZmVyUmVqZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2Vzc2lvbi5vbmNlKFwicmVqZWN0ZWRcIiwgcmVmZXJGYWlsZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2Vzc2lvbi5vbmNlKFwiZmFpbGVkXCIsIHJlZmVyRmFpbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkFjY2VwdGVkIHJlZmVyLCBidXQgZGlkIG5vdCBhdXRvbWF0aWNhbGx5IGZvbGxvdyBpdFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE5vdGlmeShcIlNJUC8yLjAgMjAwIE9LXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicmVmZXJBY2NlcHRlZFwiLCB0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlZmVycmVkU2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJyZWRTZXNzaW9uLmVtaXQoXCJyZWZlckFjY2VwdGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWZlclNlcnZlckNvbnRleHQucHJvdG90eXBlLnNlbmROb3RpZnkgPSBmdW5jdGlvbiAoYm9keVN0cikge1xuICAgICAgICAvLyBGSVhNRTogUG9ydGVkIHRoaXMuIENsZWFuIGl0IHVwLiBTZXNzaW9uIGtub3dzIGl0cyBzdGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JlXzEuR3JhbW1hci5wYXJzZShib2R5U3RyLCBcInNpcGZyYWdcIikgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaXBmcmFnIGJvZHkgaXMgcmVxdWlyZWQgdG8gc2VuZCBub3RpZnkgZm9yIHJlZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0ge1xuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBcInJlbmRlclwiLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwibWVzc2FnZS9zaXBmcmFnXCIsXG4gICAgICAgICAgICBjb250ZW50OiBib2R5U3RyXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBzZW50IGluIHNhbWUgZGlhbG9nIGFzIGluIGRpYWxvZyBSRUZFUi5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLm5vdGlmeSh1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJFdmVudDogcmVmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJTdWJzY3JpcHRpb24tU3RhdGU6IHRlcm1pbmF0ZWRcIixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBpbXBsaWNpdCBzdWJzY3JpcHRpb24gY3JlYXRlZCBieSBhIFJFRkVSIGlzIHRoZSBzYW1lIGFzIGFcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGNyZWF0ZWQgd2l0aCBhIFNVQlNDUklCRSByZXF1ZXN0LiAgVGhlIGFnZW50IGlzc3VpbmcgdGhlXG4gICAgICAgIC8vIFJFRkVSIGNhbiB0ZXJtaW5hdGUgdGhpcyBzdWJzY3JpcHRpb24gcHJlbWF0dXJlbHkgYnkgdW5zdWJzY3JpYmluZ1xuICAgICAgICAvLyB1c2luZyB0aGUgbWVjaGFuaXNtcyBkZXNjcmliZWQgaW4gWzJdLiAgVGVybWluYXRpbmcgYSBzdWJzY3JpcHRpb24sXG4gICAgICAgIC8vIGVpdGhlciBieSBleHBsaWNpdGx5IHVuc3Vic2NyaWJpbmcgb3IgcmVqZWN0aW5nIE5PVElGWSwgaXMgbm90IGFuXG4gICAgICAgIC8vIGluZGljYXRpb24gdGhhdCB0aGUgcmVmZXJlbmNlZCByZXF1ZXN0IHNob3VsZCBiZSB3aXRoZHJhd24gb3JcbiAgICAgICAgLy8gYWJhbmRvbmVkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUxNSNzZWN0aW9uLTIuNC40XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBzZW50IGluIG5ldyBkaWFsb2cgZm9yIG91dCBvZiBkaWFsb2cgUkVGRVIuXG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCBiZSBkb25lIGluIGEgc3Vic2NyaWJlIGRpYWxvZyB0byBzYXRpc2Z5IHRoZSBhYm92ZS5cbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLnVhLnVzZXJBZ2VudENvcmUubWFrZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UoQ29uc3RhbnRzXzEuQy5OT1RJRlksIHRoaXMucmVtb3RlVGFyZ2V0LCB0aGlzLmZyb21VcmksIHRoaXMudG9VcmksIHtcbiAgICAgICAgICAgIGNzZXE6IHRoaXMuY3NlcSArPSAxLFxuICAgICAgICAgICAgY2FsbElkOiB0aGlzLmNhbGxJZCxcbiAgICAgICAgICAgIGZyb21UYWc6IHRoaXMuZnJvbVRhZyxcbiAgICAgICAgICAgIHRvVGFnOiB0aGlzLnRvVGFnLFxuICAgICAgICAgICAgcm91dGVTZXQ6IHRoaXMucm91dGVTZXRcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgXCJFdmVudDogcmVmZXJcIixcbiAgICAgICAgICAgIFwiU3Vic2NyaXB0aW9uLVN0YXRlOiB0ZXJtaW5hdGVkXCIsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZTogbWVzc2FnZS9zaXBmcmFnXCJcbiAgICAgICAgXSwgYm9keSk7XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSB0aGlzLnVhLnRyYW5zcG9ydDtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VyID0ge1xuICAgICAgICAgICAgbG9nZ2VyRmFjdG9yeTogdGhpcy51YS5nZXRMb2dnZXJGYWN0b3J5KClcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5pYyA9IG5ldyBjb3JlXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ocmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyKTtcbiAgICB9O1xuICAgIFJlZmVyU2VydmVyQ29udGV4dC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjayk7IH07XG4gICAgcmV0dXJuIFJlZmVyU2VydmVyQ29udGV4dDtcbn0oU2VydmVyQ29udGV4dF8xLlNlcnZlckNvbnRleHQpKTtcbmV4cG9ydHMuUmVmZXJTZXJ2ZXJDb250ZXh0ID0gUmVmZXJTZXJ2ZXJDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBDbGllbnRDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9DbGllbnRDb250ZXh0XCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xudmFyIEV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvbnNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIGxvYWQuXG4gKiBAcHJpdmF0ZVxuICogcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBsb2FkQ29uZmlnKGNvbmZpZ3VyYXRpb24pIHtcbiAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgIGV4cGlyZXM6IDYwMCxcbiAgICAgICAgZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zOiBbXSxcbiAgICAgICAgaW5zdGFuY2VJZDogdW5kZWZpbmVkLFxuICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICByZWdJZDogdW5kZWZpbmVkLFxuICAgICAgICByZWdpc3RyYXI6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHZhciBjb25maWdDaGVjayA9IGdldENvbmZpZ3VyYXRpb25DaGVjaygpO1xuICAgIC8vIENoZWNrIE1hbmRhdG9yeSBwYXJhbWV0ZXJzXG4gICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIGNvbmZpZ0NoZWNrLm1hbmRhdG9yeSkge1xuICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgICAgICAgdmFyIGNoZWNrZWRWYWx1ZSA9IGNvbmZpZ0NoZWNrLm1hbmRhdG9yeVtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjaGVja2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gY29uZmlnQ2hlY2sub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSwgYnV0IHNob3VsZG4ndCBiZSwgYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgaXMgbnVsbCwgZW1wdHkgc3RyaW5nLCBvciB1bmRlZmluZWQgdGhlbiBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBudW1iZXIgd2l0aCBOYU4gdmFsdWUgdGhlbiBhbHNvIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgLy8gTk9URTogSlMgZG9lcyBub3QgYWxsb3cgXCJ2YWx1ZSA9PT0gTmFOXCIsIHRoZSBmb2xsb3dpbmcgZG9lcyB0aGUgd29yazpcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gXCJcIiB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBjb25maWdDaGVjay5vcHRpb25hbFtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjaGVja2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXR0aW5ncztcbn1cbmZ1bmN0aW9uIGdldENvbmZpZ3VyYXRpb25DaGVjaygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYW5kYXRvcnk6IHt9LFxuICAgICAgICBvcHRpb25hbDoge1xuICAgICAgICAgICAgZXhwaXJlczogZnVuY3Rpb24gKGV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwoZXhwaXJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gTnVtYmVyKGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4dHJhQ29udGFjdEhlYWRlclBhcmFtczogZnVuY3Rpb24gKGV4dHJhQ29udGFjdEhlYWRlclBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYUNvbnRhY3RIZWFkZXJQYXJhbXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFDb250YWN0SGVhZGVyUGFyYW1zLmZpbHRlcihmdW5jdGlvbiAoY29udGFjdEhlYWRlclBhcmFtKSB7IHJldHVybiAodHlwZW9mIGNvbnRhY3RIZWFkZXJQYXJhbSA9PT0gXCJzdHJpbmdcIik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnN0YW5jZUlkOiBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoL151dWlkOi9pLnRlc3QoaW5zdGFuY2VJZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQgPSBpbnN0YW5jZUlkLnN1YnN0cig1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvcmVfMS5HcmFtbWFyLnBhcnNlKGluc3RhbmNlSWQsIFwidXVpZFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmFtczogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZ0lkOiBmdW5jdGlvbiAocmVnSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwocmVnSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihyZWdJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0cmFyOiBmdW5jdGlvbiAocmVnaXN0cmFyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWdpc3RyYXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIS9ec2lwOi9pLnRlc3QocmVnaXN0cmFyKSkge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RyYXIgPSBDb25zdGFudHNfMS5DLlNJUCArIFwiOlwiICsgcmVnaXN0cmFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gY29yZV8xLkdyYW1tYXIuVVJJUGFyc2UocmVnaXN0cmFyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBSZWdpc3RlckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVnaXN0ZXJDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZ2lzdGVyQ29udGV4dCh1YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBsb2FkQ29uZmlnKG9wdGlvbnMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MucmVnSWQgJiYgIXNldHRpbmdzLmluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmluc3RhbmNlSWQgPSBVdGlsc18xLlV0aWxzLm5ld1VVSUQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghc2V0dGluZ3MucmVnSWQgJiYgc2V0dGluZ3MuaW5zdGFuY2VJZCkge1xuICAgICAgICAgICAgc2V0dGluZ3MucmVnSWQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLnBhcmFtcy50b1VyaSA9IHNldHRpbmdzLnBhcmFtcy50b1VyaSB8fCB1YS5jb25maWd1cmF0aW9uLnVyaTtcbiAgICAgICAgc2V0dGluZ3MucGFyYW1zLnRvRGlzcGxheU5hbWUgPSBzZXR0aW5ncy5wYXJhbXMudG9EaXNwbGF5TmFtZSB8fCB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lO1xuICAgICAgICBzZXR0aW5ncy5wYXJhbXMuY2FsbElkID0gc2V0dGluZ3MucGFyYW1zLmNhbGxJZCB8fCBVdGlsc18xLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDIyKTtcbiAgICAgICAgc2V0dGluZ3MucGFyYW1zLmNzZXEgPSBzZXR0aW5ncy5wYXJhbXMuY3NlcSB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgICAgIC8qIElmIG5vICdyZWdpc3RyYXJTZXJ2ZXInIGlzIHNldCB1c2UgdGhlICd1cmknIHZhbHVlIHdpdGhvdXQgdXNlciBwb3J0aW9uLiAqL1xuICAgICAgICBpZiAoIXNldHRpbmdzLnJlZ2lzdHJhcikge1xuICAgICAgICAgICAgdmFyIHJlZ2lzdHJhclNlcnZlciA9IHt9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1YS5jb25maWd1cmF0aW9uLnVyaSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdHJhclNlcnZlciA9IHVhLmNvbmZpZ3VyYXRpb24udXJpLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVnaXN0cmFyU2VydmVyLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWdpc3RyYXJTZXJ2ZXIgPSB1YS5jb25maWd1cmF0aW9uLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLnJlZ2lzdHJhciA9IHJlZ2lzdHJhclNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVhLCBDb25zdGFudHNfMS5DLlJFR0lTVEVSLCBzZXR0aW5ncy5yZWdpc3RyYXIsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5SZWdpc3RlckNvbnRleHQ7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBzZXR0aW5ncztcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLnJlZ2lzdGVyY29udGV4dFwiKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcImNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBmb3IgUmVnaXN0ZXJDb250ZXh0IGFmdGVyIHZhbGlkYXRpb246XCIpO1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIsK3IFwiICsgcGFyYW1ldGVyICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3NbcGFyYW1ldGVyXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ2lzdHJhdGlvbiBleHBpcmVzXG4gICAgICAgIF90aGlzLmV4cGlyZXMgPSBzZXR0aW5ncy5leHBpcmVzO1xuICAgICAgICAvLyBDb250YWN0IGhlYWRlclxuICAgICAgICBfdGhpcy5jb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZygpO1xuICAgICAgICAvLyBTZXQgc3RhdHVzXG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdWEudHJhbnNwb3J0Lm9uKFwiZGlzY29ubmVjdGVkXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uVHJhbnNwb3J0RGlzY29ubmVjdGVkKCk7IH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBIYW5kbGUgT3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKHRoaXMub3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLmdlbmVyYXRlQ29udGFjdEhlYWRlcih0aGlzLmV4cGlyZXMpKTtcbiAgICAgICAgLy8gdGhpcyBpcyBVQS5DLkFMTE9XRURfTUVUSE9EUywgcmVtb3ZlZCB0byBnZXQgYXJvdW5kIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJBbGxvdzogXCIgKyBbXG4gICAgICAgICAgICBcIkFDS1wiLFxuICAgICAgICAgICAgXCJDQU5DRUxcIixcbiAgICAgICAgICAgIFwiSU5WSVRFXCIsXG4gICAgICAgICAgICBcIk1FU1NBR0VcIixcbiAgICAgICAgICAgIFwiQllFXCIsXG4gICAgICAgICAgICBcIk9QVElPTlNcIixcbiAgICAgICAgICAgIFwiSU5GT1wiLFxuICAgICAgICAgICAgXCJOT1RJRllcIixcbiAgICAgICAgICAgIFwiUkVGRVJcIlxuICAgICAgICBdLnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBTYXZlIG9yaWdpbmFsIGV4dHJhSGVhZGVycyB0byBiZSB1c2VkIGluIC5jbG9zZVxuICAgICAgICB0aGlzLmNsb3NlSGVhZGVycyA9IHRoaXMub3B0aW9ucy5jbG9zZVdpdGhIZWFkZXJzID9cbiAgICAgICAgICAgICh0aGlzLm9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpIDogW107XG4gICAgICAgIHRoaXMucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBEaXNjYXJkIHJlc3BvbnNlcyB0byBvbGRlciBSRUdJU1RFUi91bi1SRUdJU1RFUiByZXF1ZXN0cy5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5jc2VxICE9PSBfdGhpcy5yZXF1ZXN0LmNzZXEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciByZWdpc3RyYXRpb24gdGltZXJcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25UaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0dXNDb2RlID0gKHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFjY2VwdGVkXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGlyZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oYXNIZWFkZXIoXCJleHBpcmVzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gTnVtYmVyKHJlc3BvbnNlLmdldEhlYWRlcihcImV4cGlyZXNcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIHRoZSBDb250YWN0IHBvaW50aW5nIHRvIHVzIGFuZCB1cGRhdGUgdGhlIGV4cGlyZXMgdmFsdWUgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0cyA9IHJlc3BvbnNlLmdldEhlYWRlcnMoXCJjb250YWN0XCIpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJubyBDb250YWN0IGhlYWRlciBpbiByZXNwb25zZSB0byBSRUdJU1RFUiwgcmVzcG9uc2UgaWdub3JlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY29udGFjdHMtLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdCA9IHJlc3BvbnNlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiLCBjb250YWN0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdC51cmkudXNlciA9PT0gX3RoaXMudWEuY29udGFjdC51cmkudXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSBjb250YWN0LmdldFBhcmFtKFwiZXhwaXJlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIm5vIENvbnRhY3QgaGVhZGVyIHBvaW50aW5nIHRvIHVzLCByZXNwb25zZSBpZ25vcmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9IF90aGlzLmV4cGlyZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtUmVnaXN0ZXIgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGludGVydmFsIGhhcyBlbGFwc2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhhdCwgZGVjcmVhc2UgdGhlIGV4cGlyZXMgdmFsdWUuIGllOiAzIHNlY29uZHNcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0ZXIoX3RoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIChleHBpcmVzICogMTAwMCkgLSAzMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcInJlZ2lzdHJhdGlvbiBleHBpcmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51bnJlZ2lzdGVyZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZXhwaXJlcyAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIGdydXUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0Lmhhc1BhcmFtKFwidGVtcC1ncnV1XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51YS5jb250YWN0LnRlbXBHcnV1ID0gY29yZV8xLkdyYW1tYXIuVVJJUGFyc2UoY29udGFjdC5nZXRQYXJhbShcInRlbXAtZ3J1dVwiKS5yZXBsYWNlKC9cIi9nLCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuaGFzUGFyYW0oXCJwdWItZ3J1dVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudWEuY29udGFjdC5wdWJHcnV1ID0gY29yZV8xLkdyYW1tYXIuVVJJUGFyc2UoY29udGFjdC5nZXRQYXJhbShcInB1Yi1ncnV1XCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZ2lzdGVyZWRcIiwgcmVzcG9uc2UgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gSW50ZXJ2YWwgdG9vIGJyaWVmIFJGQzMyNjEgMTAuMi44XG4gICAgICAgICAgICAgICAgY2FzZSAvXjQyMyQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5oYXNIZWFkZXIoXCJtaW4tZXhwaXJlc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jcmVhc2Ugb3VyIHJlZ2lzdHJhdGlvbiBpbnRlcnZhbCB0byB0aGUgc3VnZ2VzdGVkIG1pbmltdW1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV4cGlyZXMgPSBOdW1iZXIocmVzcG9uc2UuZ2V0SGVhZGVyKFwibWluLWV4cGlyZXNcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0aGUgcmVnaXN0cmF0aW9uIGFnYWluIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RlcihfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gVGhpcyByZXNwb25zZSBNVVNUIGNvbnRhaW4gYSBNaW4tRXhwaXJlcyBoZWFkZXIgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiNDIzIHJlc3BvbnNlIHJlY2VpdmVkIGZvciBSRUdJU1RFUiB3aXRob3V0IE1pbi1FeHBpcmVzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuU0lQX0ZBSUxVUkVfQ09ERSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uRmFpbHVyZShyZXNwb25zZSwgVXRpbHNfMS5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25GYWlsdXJlKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uRmFpbHVyZSh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3QuY3NlcSsrO1xuICAgICAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKFwiY3NlcVwiLCB0aGlzLnJlcXVlc3QuY3NlcSArIFwiIFJFR0lTVEVSXCIpO1xuICAgICAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhSGVhZGVyczogdGhpcy5jbG9zZUhlYWRlcnNcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkQmVmb3JlID0gdGhpcy5yZWdpc3RlcmVkO1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkICYmICFvcHRpb25zLmFsbCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFscmVhZHkgdW5yZWdpc3RlcmVkLCBidXQgc2VuZGluZyBhbiB1bnJlZ2lzdGVyIGFueXdheXMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvLyBDbGVhciB0aGUgcmVnaXN0cmF0aW9uIHRpbWVyLlxuICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25UaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWdpc3RyYXRpb25UaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiAqXCIpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJFeHBpcmVzOiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuZ2VuZXJhdGVDb250YWN0SGVhZGVyKDApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSAocmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSkgPyByZXNwb25zZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYWNjZXB0ZWRcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZWdpc3RyYXRpb25FeHBpcmVkVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXJlZChyZXNwb25zZSwgVXRpbHNfMS5VdGlscy5zaXBFcnJvckNhdXNlKHJlc3BvbnNlLnN0YXR1c0NvZGUgfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBOb3QgYWN0dWFsbHkgdW5yZWdpc3RlcmVkLi4uXG4gICAgICAgICAgICAvLyB0aGlzLnVucmVnaXN0ZXJlZCh1bmRlZmluZWQsIFNJUC5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3QuY3NlcSsrO1xuICAgICAgICB0aGlzLnJlcXVlc3Quc2V0SGVhZGVyKFwiY3NlcVwiLCB0aGlzLnJlcXVlc3QuY3NlcSArIFwiIFJFR0lTVEVSXCIpO1xuICAgICAgICB0aGlzLnJlcXVlc3QuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUudW5yZWdpc3RlcmVkID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KFwidW5yZWdpc3RlcmVkXCIsIHJlc3BvbnNlIHx8IHVuZGVmaW5lZCwgY2F1c2UgfHwgdW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIFJlZ2lzdGVyQ29udGV4dC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51YS51c2VyQWdlbnRDb3JlLnJlZ2lzdGVyKHRoaXMucmVxdWVzdCwge1xuICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZS5tZXNzYWdlKTsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSZWdpc3RlckNvbnRleHQucHJvdG90eXBlLnJlZ2lzdHJhdGlvbkZhaWx1cmUgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSB8fCB1bmRlZmluZWQsIGNhdXNlIHx8IHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBSZWdpc3RlckNvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RGlzY29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRCZWZvcmUgPSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvblRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVnaXN0cmF0aW9uRXhwaXJlZFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbkV4cGlyZWRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXJlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgRnVuY3Rpb24gdG8gZ2VuZXJhdGUgQ29udGFjdCBIZWFkZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBSZWdpc3RlckNvbnRleHQucHJvdG90eXBlLmdlbmVyYXRlQ29udGFjdEhlYWRlciA9IGZ1bmN0aW9uIChleHBpcmVzKSB7XG4gICAgICAgIGlmIChleHBpcmVzID09PSB2b2lkIDApIHsgZXhwaXJlcyA9IDA7IH1cbiAgICAgICAgdmFyIGNvbnRhY3QgPSB0aGlzLmNvbnRhY3Q7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVnSWQgJiYgdGhpcy5vcHRpb25zLmluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIGNvbnRhY3QgKz0gXCI7cmVnLWlkPVwiICsgdGhpcy5vcHRpb25zLnJlZ0lkO1xuICAgICAgICAgICAgY29udGFjdCArPSAnOytzaXAuaW5zdGFuY2U9XCI8dXJuOnV1aWQ6JyArIHRoaXMub3B0aW9ucy5pbnN0YW5jZUlkICsgJz5cIic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYUNvbnRhY3RIZWFkZXJQYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRyYUNvbnRhY3RIZWFkZXJQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFjdCArPSBcIjtcIiArIGhlYWRlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRhY3QgKz0gXCI7ZXhwaXJlcz1cIiArIGV4cGlyZXM7XG4gICAgICAgIHJldHVybiBjb250YWN0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlZ2lzdGVyQ29udGV4dDtcbn0oQ2xpZW50Q29udGV4dF8xLkNsaWVudENvbnRleHQpKTtcbmV4cG9ydHMuUmVnaXN0ZXJDb250ZXh0ID0gUmVnaXN0ZXJDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xudmFyIFNlcnZlckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2VydmVyQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXJ2ZXJDb250ZXh0KHVhLCBpbmNvbWluZ1JlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5jb21pbmdSZXF1ZXN0ID0gaW5jb21pbmdSZXF1ZXN0O1xuICAgICAgICBfdGhpcy5kYXRhID0ge307XG4gICAgICAgIFNlcnZlckNvbnRleHQuaW5pdGlhbGl6ZXIoX3RoaXMsIHVhLCBpbmNvbWluZ1JlcXVlc3QpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8vIGhhY2sgdG8gZ2V0IGFyb3VuZCBvdXIgbXVsdGlwbGUgaW5oZXJpdGFuY2UgaXNzdWVzXG4gICAgU2VydmVyQ29udGV4dC5pbml0aWFsaXplciA9IGZ1bmN0aW9uIChvYmplY3RUb0NvbnN0cnVjdCwgdWEsIGluY29taW5nUmVxdWVzdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IGluY29taW5nUmVxdWVzdC5tZXNzYWdlO1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXJ2ZXJDb250ZXh0O1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC51YSA9IHVhO1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoXCJzaXAuc2VydmVyY29udGV4dFwiKTtcbiAgICAgICAgb2JqZWN0VG9Db25zdHJ1Y3QucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIGlmIChyZXF1ZXN0LmJvZHkpIHtcbiAgICAgICAgICAgIG9iamVjdFRvQ29uc3RydWN0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaGFzSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC5jb250ZW50VHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFRvQ29uc3RydWN0Lm1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgICAgICBvYmplY3RUb0NvbnN0cnVjdC5sb2NhbElkZW50aXR5ID0gcmVxdWVzdC50bztcbiAgICAgICAgb2JqZWN0VG9Db25zdHJ1Y3QucmVtb3RlSWRlbnRpdHkgPSByZXF1ZXN0LmZyb207XG4gICAgICAgIHZhciBoYXNBc3NlcnRlZElkZW50aXR5ID0gcmVxdWVzdC5oYXNIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpO1xuICAgICAgICBpZiAoaGFzQXNzZXJ0ZWRJZGVudGl0eSkge1xuICAgICAgICAgICAgdmFyIGFzc2VydGVkSWRlbnRpdHkgPSByZXF1ZXN0LmdldEhlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIik7XG4gICAgICAgICAgICBpZiAoYXNzZXJ0ZWRJZGVudGl0eSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFRvQ29uc3RydWN0LmFzc2VydGVkSWRlbnRpdHkgPSBjb3JlXzEuR3JhbW1hci5uYW1lQWRkckhlYWRlclBhcnNlKGFzc2VydGVkSWRlbnRpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5wcm9ncmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODA7XG4gICAgICAgIG9wdGlvbnMubWluQ29kZSA9IDEwMDtcbiAgICAgICAgb3B0aW9ucy5tYXhDb2RlID0gMTk5O1xuICAgICAgICBvcHRpb25zLmV2ZW50cyA9IFtcInByb2dyZXNzXCJdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlcnZlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAyMDA7XG4gICAgICAgIG9wdGlvbnMubWluQ29kZSA9IDIwMDtcbiAgICAgICAgb3B0aW9ucy5tYXhDb2RlID0gMjk5O1xuICAgICAgICBvcHRpb25zLmV2ZW50cyA9IFtcImFjY2VwdGVkXCJdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCA0ODA7XG4gICAgICAgIG9wdGlvbnMubWluQ29kZSA9IDMwMDtcbiAgICAgICAgb3B0aW9ucy5tYXhDb2RlID0gNjk5O1xuICAgICAgICBvcHRpb25zLmV2ZW50cyA9IFtcInJlamVjdGVkXCIsIFwiZmFpbGVkXCJdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGUgfHwgMTAwO1xuICAgICAgICB2YXIgbWluQ29kZSA9IG9wdGlvbnMubWluQ29kZSB8fCAxMDA7XG4gICAgICAgIHZhciBtYXhDb2RlID0gb3B0aW9ucy5tYXhDb2RlIHx8IDY5OTtcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUsIG9wdGlvbnMucmVhc29uUGhyYXNlKTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSA/IGNvcmVfMS5mcm9tQm9keUxlZ2FjeShvcHRpb25zLmJvZHkpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZXZlbnRzID0gb3B0aW9ucy5ldmVudHMgfHwgW107XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgbWluQ29kZSB8fCBzdGF0dXNDb2RlID4gbWF4Q29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2VPcHRpb25zID0ge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIHJlYXNvblBocmFzZTogcmVhc29uUGhyYXNlLFxuICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGVTdHJpbmcgPSBzdGF0dXNDb2RlLnRvU3RyaW5nKCk7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgY2FzZSAvXjEwMCQvLnRlc3Qoc3RhdHVzQ29kZVN0cmluZyk6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmluY29taW5nUmVxdWVzdC50cnlpbmcocmVzcG9uc2VPcHRpb25zKS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjFbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZVN0cmluZyk6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmluY29taW5nUmVxdWVzdC5wcm9ncmVzcyhyZXNwb25zZU9wdGlvbnMpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlU3RyaW5nKTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LmFjY2VwdChyZXNwb25zZU9wdGlvbnMpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eM1swLTldezJ9JC8udGVzdChzdGF0dXNDb2RlU3RyaW5nKTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlZGlyZWN0KFtdLCByZXNwb25zZU9wdGlvbnMpLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eWzQtNl1bMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZVN0cmluZyk6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmluY29taW5nUmVxdWVzdC5yZWplY3QocmVzcG9uc2VPcHRpb25zKS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXR1cyBjb2RlIFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LCByZXNwb25zZSwgcmVhc29uUGhyYXNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU2VydmVyQ29udGV4dC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICB9O1xuICAgIFNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCB1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLkNPTk5FQ1RJT05fRVJST1IpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlcnZlckNvbnRleHQ7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5TZXJ2ZXJDb250ZXh0ID0gU2VydmVyQ29udGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIENsaWVudENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NsaWVudENvbnRleHRcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uc1wiKTtcbnZhciBSZWZlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1JlZmVyQ29udGV4dFwiKTtcbnZhciBTZXJ2ZXJDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9TZXJ2ZXJDb250ZXh0XCIpO1xudmFyIERUTUZfMSA9IHJlcXVpcmUoXCIuL1Nlc3Npb24vRFRNRlwiKTtcbnZhciBEVE1GVmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi9TZXNzaW9uL0RUTUZWYWxpZGF0b3JcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuLypcbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyfSBbc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnldXG4gKiAgICAgICAgKFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5IGFyZ3VtZW50IG9mIHRoZSBVQSBjb25zdHJ1Y3Rvci4pXG4gKi9cbnZhciBTZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNlc3Npb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbihzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0ge307XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb247XG4gICAgICAgIGlmICghc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJBIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBpcyByZXF1aXJlZCBmb3IgdGhlIHNlc3Npb24gdG8gZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc3RhdHVzID0gU2Vzc2lvbi5DLlNUQVRVU19OVUxMO1xuICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkgPSBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeTtcbiAgICAgICAgX3RoaXMuaGFzT2ZmZXIgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaGFzQW5zd2VyID0gZmFsc2U7XG4gICAgICAgIC8vIFNlc3Npb24gVGltZXJzXG4gICAgICAgIF90aGlzLnRpbWVycyA9IHtcbiAgICAgICAgICAgIGFja1RpbWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBleHBpcmVzVGltZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGludml0ZTJ4eFRpbWVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2VyTm9BbnN3ZXJUaW1lcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVsMXh4VGltZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByYWNrVGltZXI6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICAvLyBTZXNzaW9uIGluZm9cbiAgICAgICAgX3RoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5lbmRUaW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy50b25lcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gSG9sZCBzdGF0ZVxuICAgICAgICBfdGhpcy5sb2NhbEhvbGQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuZWFybHlTZHAgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnJlbDEwMCA9IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNlc3Npb24ucHJvdG90eXBlLmR0bWYgPSBmdW5jdGlvbiAodG9uZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCAmJiB0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcih0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdG9uZXMnIHZhbGlkaXR5XG4gICAgICAgIERUTUZWYWxpZGF0b3JfMS5EVE1GVmFsaWRhdG9yLnZhbGlkYXRlKHRvbmVzKTtcbiAgICAgICAgdmFyIHNlbmREVE1GID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEIHx8ICFfdGhpcy50b25lcyB8fCBfdGhpcy50b25lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIHNlbmRpbmcgRFRNRlxuICAgICAgICAgICAgICAgIF90aGlzLnRvbmVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkdG1mID0gX3RoaXMudG9uZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICAgICAgaWYgKGR0bWYudG9uZSA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMjAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGR0bWYub24oXCJmYWlsZWRcIiwgZnVuY3Rpb24gKCkgeyBfdGhpcy50b25lcyA9IHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgICAgICAgZHRtZi5zZW5kKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBkdG1mLmR1cmF0aW9uICsgZHRtZi5pbnRlclRvbmVHYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGltZW91dCBmb3IgdGhlIG5leHQgdG9uZVxuICAgICAgICAgICAgc2V0VGltZW91dChzZW5kRFRNRiwgdGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICAgIHRvbmVzID0gdG9uZXMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGR0bWZUeXBlID0gdGhpcy51YS5jb25maWd1cmF0aW9uLmR0bWZUeXBlO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyICYmIGR0bWZUeXBlID09PSBDb25zdGFudHNfMS5DLmR0bWZUeXBlLlJUUCkge1xuICAgICAgICAgICAgdmFyIHNlbnQgPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuc2VuZER0bWYodG9uZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFzZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkF0dGVtcHQgdG8gdXNlIGR0bWZUeXBlICdSVFAnIGhhcyBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBJTkZPIHBhY2tldCBtZXRob2RcIik7XG4gICAgICAgICAgICAgICAgZHRtZlR5cGUgPSBDb25zdGFudHNfMS5DLmR0bWZUeXBlLklORk87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR0bWZUeXBlID09PSBDb25zdGFudHNfMS5DLmR0bWZUeXBlLklORk8pIHtcbiAgICAgICAgICAgIHZhciBkdG1mcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRvbmVzQXJyYXkgPSB0b25lcy5zcGxpdChcIlwiKTtcbiAgICAgICAgICAgIHdoaWxlICh0b25lc0FycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBkdG1mcy5wdXNoKG5ldyBEVE1GXzEuRFRNRih0aGlzLCB0b25lc0FycmF5LnNoaWZ0KCksIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudG9uZXMpICYmIHRoaXMudG9uZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9uZXMgYXJlIGFscmVhZHkgcXVldWVkLCBqdXN0IGFkZCB0byB0aGUgcXVldWVcbiAgICAgICAgICAgICAgICB0aGlzLnRvbmVzID0gdGhpcy50b25lcy5jb25jYXQoZHRtZnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b25lcyA9IGR0bWZzO1xuICAgICAgICAgICAgc2VuZERUTUYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmJ5ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yOiBBdHRlbXB0ZWQgdG8gc2VuZCBCWUUgaW4gYSB0ZXJtaW5hdGVkIHNlc3Npb24uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidGVybWluYXRpbmcgU2Vzc2lvblwiKTtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlICYmIChzdGF0dXNDb2RlIDwgMjAwIHx8IHN0YXR1c0NvZGUgPj0gNzAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3QoQ29uc3RhbnRzXzEuQy5CWUUsIG9wdGlvbnMpLnRlcm1pbmF0ZWQoKTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlZmVyID0gZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBDaGVjayBTZXNzaW9uIFN0YXR1c1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmZXJDb250ZXh0ID0gbmV3IFJlZmVyQ29udGV4dF8xLlJlZmVyQ2xpZW50Q29udGV4dCh0aGlzLnVhLCB0aGlzLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXQoXCJyZWZlclJlcXVlc3RlZFwiLCB0aGlzLnJlZmVyQ29udGV4dCk7XG4gICAgICAgIHRoaXMucmVmZXJDb250ZXh0LnJlZmVyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZlckNvbnRleHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBpbiBkaWFsb2cgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIFJlcXVlc3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnNlbmRSZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgYW55IFwiYm9keVwiIG9wdGlvbiB0byBhIEJvZHkuXG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IFV0aWxzXzEuVXRpbHMuZnJvbUJvZHlPYmoob3B0aW9ucy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IGFueSBcInJlY2VpdmVSZXNwb25zZVwiIGNhbGxiYWNrIG9wdGlvbiBwYXNzZWQgdG8gYW4gT3V0Z29pbmdSZXF1ZXN0RGVsZWdhdGUuXG4gICAgICAgIHZhciBkZWxlZ2F0ZTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9ucy5yZWNlaXZlUmVzcG9uc2U7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gY2FsbGJhY2socmVzcG9uc2UubWVzc2FnZSk7IH0sXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBjYWxsYmFjayhyZXNwb25zZS5tZXNzYWdlKTsgfSxcbiAgICAgICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIGNhbGxiYWNrKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIGNhbGxiYWNrKHJlc3BvbnNlLm1lc3NhZ2UpOyB9LFxuICAgICAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIGNhbGxiYWNrKHJlc3BvbnNlLm1lc3NhZ2UpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0O1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLkJZRTpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zZXNzaW9uLmJ5ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLklOVklURTpcbiAgICAgICAgICAgICAgICByZXF1ZXN0ID0gdGhpcy5zZXNzaW9uLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLk1FU1NBR0U6XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc2Vzc2lvbi5tZXNzYWdlKGRlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuUkVGRVI6XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuc2Vzc2lvbi5yZWZlcihkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFwiICsgbWV0aG9kICsgXCIuIE1ldGhvZCBub3QgaW1wbGVtZW50ZWQgYnkgdXNlciBhZ2VudCBjb3JlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3J0ZWQgLSBFbWl0IHRoZSByZXF1ZXN0IGV2ZW50XG4gICAgICAgIHRoaXMuZW1pdChtZXRob2QudG9Mb3dlckNhc2UoKSwgcmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImNsb3NpbmcgSU5WSVRFIHNlc3Npb24gXCIgKyB0aGlzLmlkKTtcbiAgICAgICAgLy8gMXN0IFN0ZXAuIFRlcm1pbmF0ZSBtZWRpYS5cbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMm5kIFN0ZXAuIFRlcm1pbmF0ZSBzaWduYWxpbmcuXG4gICAgICAgIC8vIENsZWFyIHNlc3Npb24gdGltZXJzXG4gICAgICAgIGZvciAodmFyIHRpbWVyIGluIHRoaXMudGltZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lcnNbdGltZXJdKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzW3RpbWVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQ7XG4gICAgICAgIGlmICh0aGlzLnVhLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy51YS50cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJ0cmFuc3BvcnRFcnJvclwiLCB0aGlzLmVycm9yTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmhvbGQgPSBmdW5jdGlvbiAob3B0aW9ucywgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBbXTsgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLICYmIHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24gaXMgYWxyZWFkeSBvbiBob2xkLCBjYW5ub3QgcHV0IGl0IG9uIGhvbGQgYWdhaW5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubW9kaWZpZXJzLnB1c2godGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmhvbGRNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhbEhvbGQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlbmRSZWludml0ZShvcHRpb25zKTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnVuaG9sZCA9IGZ1bmN0aW9uIChvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0sgJiYgdGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5sb2NhbEhvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24gaXMgbm90IG9uIGhvbGQsIGNhbm5vdCB1bmhvbGQgaXRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIHRoaXMubG9jYWxIb2xkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVpbnZpdGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbW9kaWZpZXJzKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBbXTsgfVxuICAgICAgICBvcHRpb25zLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlaW52aXRlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gaGVyZSBmb3IgdHlwZXMgYW5kIHRvIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEICYmIHRoaXMuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQ09OTkVDVElPTl9FUlJPUik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uUmVxdWVzdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLlJFUVVFU1RfVElNRU9VVCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5SRVFVRVNUX1RJTUVPVVQpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25EaWFsb2dFcnJvciA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsZWQocmVzcG9uc2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkRJQUxPR19FUlJPUik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25BY2sgPSBmdW5jdGlvbiAoaW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maXJtU2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lcnMuYWNrVGltZXIpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVycy5pbnZpdGUyeHhUaW1lcik7XG4gICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRDtcbiAgICAgICAgICAgIHZhciBjb250ZW50RGlzcCA9IGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gICAgICAgICAgICBpZiAoY29udGVudERpc3AgJiYgY29udGVudERpc3AudHlwZSA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmJvZHkgPSBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5ib2R5O1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcnR5cGUgPSBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiY29uZmlybWVkXCIsIGluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5oYXNEZXNjcmlwdGlvbihpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5nZXRIZWFkZXIoXCJDb250ZW50LVR5cGVcIikgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0Fuc3dlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnNldERlc2NyaXB0aW9uKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmJvZHksIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IFwiNDg4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpcm1TZXNzaW9uKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlybVNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAoaW5jb21pbmdSZXF1ZXN0KSB7XG4gICAgICAgIHN3aXRjaCAoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UubWV0aG9kKSB7IC8vIFRPRE86IFRoaXMgbmVlZHMgYSBkZWZhdWx0IGNhc2VcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5CWUU6XG4gICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYnllXCIsIGluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLkJZRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLklOVklURTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlLUlOVklURSByZWNlaXZlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlUmVpbnZpdGUoaW5jb21pbmdSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuSU5GTzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEIHx8IHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uSW5mbyhpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvZHRtZi1yZWxheS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuYm9keS5zcGxpdChcIlxcclxcblwiLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9uZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdUb25lID0gL14oU2lnbmFsXFxzKj89XFxzKj8pKFswLTlBLUQjKl17MX0pKFxccyk/LiovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZ1RvbmUudGVzdChib2R5WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvbmUgPSBib2R5WzBdLnJlcGxhY2UocmVnVG9uZSwgXCIkMlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdEdXJhdGlvbiA9IC9eKER1cmF0aW9uXFxzPz1cXHM/KShbMC05XXsxLDR9KShcXHMpPy4qLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdEdXJhdGlvbi50ZXN0KGJvZHlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBwYXJzZUludChib2R5WzFdLnJlcGxhY2UocmVnRHVyYXRpb24sIFwiJDJcIiksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b25lICYmIGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERUTUZfMS5EVE1GKHRoaXMsIHRvbmUsIHsgZHVyYXRpb246IGR1cmF0aW9uIH0pLmluaXRfaW5jb21pbmcoaW5jb21pbmdSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5yZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW1wiQWNjZXB0OiBhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCJdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuUkVGRVI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJSRUZFUiByZWNlaXZlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlckNvbnRleHQgPSBuZXcgUmVmZXJDb250ZXh0XzEuUmVmZXJTZXJ2ZXJDb250ZXh0KHRoaXMudWEsIGluY29taW5nUmVxdWVzdCwgdGhpcy5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKFwicmVmZXJSZXF1ZXN0ZWRcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWZlclJlcXVlc3RlZFwiLCB0aGlzLnJlZmVyQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJObyByZWZlclJlcXVlc3RlZCBsaXN0ZW5lcnMsIGF1dG9tYXRpY2FsbHkgYWNjZXB0aW5nIGFuZCBmb2xsb3dpbmcgdGhlIHJlZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGZvbGxvd1JlZmVyOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXNzZWRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbnZpdGVPcHRpb25zID0gdGhpcy5wYXNzZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlckNvbnRleHQuYWNjZXB0KG9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5OT1RJRlk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVmZXJDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmZXJDb250ZXh0LnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuUmVmZXJDbGllbnRDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmhhc0hlYWRlcihcImV2ZW50XCIpICYmXG4gICAgICAgICAgICAgICAgICAgIC9ecmVmZXIoOy4qKT8kLy50ZXN0KGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcImV2ZW50XCIpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyQ29udGV4dC5yZWNlaXZlTm90aWZ5KGluY29taW5nUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5vdGlmeVwiLCBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuTUVTU0FHRTpcbiAgICAgICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEluIGRpYWxvZyBJTlZJVEUgUmVjZXB0aW9uXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVjZWl2ZVJlaW52aXRlID0gZnVuY3Rpb24gKGluY29taW5nUmVxdWVzdCkge1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgcHJvYmFibHkgY2hlY2sgc3RhdGUgb2YgdGhlIHNlc3Npb25cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0KFwicmVpbnZpdGVcIiwgdGhpcywgaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICBpZiAoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRlZElkZW50aXR5ID1cbiAgICAgICAgICAgICAgICBjb3JlXzEuR3JhbW1hci5uYW1lQWRkckhlYWRlclBhcnNlKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgdG8gcmVpbnZpdGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgIWluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSkgeyAvLyBJbnZpdGUgdy9vIFNEUFxuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5nZXREZXNjcmlwdGlvbih0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmhhc0Rlc2NyaXB0aW9uKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgLy8gSW52aXRlIHcvIFNEUFxuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5zZXREZXNjcmlwdGlvbihpbmNvbWluZ1JlcXVlc3QubWVzc2FnZS5ib2R5LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycykudGhlbih0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuZ2V0RGVzY3JpcHRpb24uYmluZCh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIsIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIHRoaXMubW9kaWZpZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIEJhZCBQYWNrZXQgKHNob3VsZCBuZXZlciBnZXQgaGl0KVxuICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQxNSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJlaW52aXRlRmFpbGVkXCIsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2UuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXNDb2RlO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlJlbmVnb3RpYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZW5lZ290aWF0aW9uRXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlID0gNDg4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSA0ODg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmNvbWluZ1JlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSB9KTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWludml0ZUZhaWxlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGJldHRlclxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXCJDb250YWN0OiBcIiArIF90aGlzLmNvbnRhY3RdO1xuICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCh7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IFV0aWxzXzEuVXRpbHMuZnJvbUJvZHlPYmooZGVzY3JpcHRpb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlaW52aXRlQWNjZXB0ZWRcIiwgX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnNlbmRSZWludml0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZWludml0ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlJlaW52aXRlIGluIHByb2dyZXNzLiBQbGVhc2Ugd2FpdCB1bnRpbCBjb21wbGV0ZSwgdGhlbiB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciwgY2FuJ3QgcmVpbnZpdGUuLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdSZWludml0ZSA9IHRydWU7XG4gICAgICAgIG9wdGlvbnMubW9kaWZpZXJzID0gb3B0aW9ucy5tb2RpZmllcnMgfHwgW107XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLmNvbnRhY3QpO1xuICAgICAgICAvLyB0aGlzIGlzIFVBLkMuQUxMT1dFRF9NRVRIT0RTLCByZW1vdmVkIHRvIGdldCBhcm91bmQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkFsbG93OiBcIiArIFtcbiAgICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICAgIFwiTUVTU0FHRVwiLFxuICAgICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgICAgICAgXCJJTkZPXCIsXG4gICAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgICAgXCJSRUZFUlwiXG4gICAgICAgIF0udG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5nZXREZXNjcmlwdGlvbihvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBvcHRpb25zLm1vZGlmaWVycylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgIG9uQWNjZXB0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJSZWNlaXZlZCByZWludml0ZSByZXNwb25zZSwgYnV0IGluIFNUQVRVU19URVJNSU5BVEVEXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBzZW5kIGEgU0lQIHJlc3BvbnNlP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucGVuZGluZ1JlaW52aXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJSZWNlaXZlZCByZWludml0ZSByZXNwb25zZSwgYnV0IGhhdmUgbm8gcGVuZGluZyByZWludml0ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gc2VuZCBhIFNJUCByZXNwb25zZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogV2h5IGlzIHRoaXMgc2V0IGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgICAgICAgICAvLyAxNy4xLjEuMSAtIEZvciBlYWNoIGZpbmFsIHJlc3BvbnNlIHRoYXQgaXMgcmVjZWl2ZWQgYXQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBzZW5kcyBhbiBBQ0ssXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJhY2tcIiwgcmVzcG9uc2UuYWNrKCkpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQWxsIG9mIHRoZXNlIHRpbWVycyBzaG91bGQgbW92ZSBpbnRvIHRoZSBUcmFuc2FjdGlvbiBsYXllclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXJzLmludml0ZTJ4eFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5oYXNEZXNjcmlwdGlvbihyZXNwb25zZS5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiMlhYIHJlc3BvbnNlIHJlY2VpdmVkIHRvIHJlLWludml0ZSBidXQgZGlkIG5vdCBoYXZlIGEgZGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVpbnZpdGVGYWlsZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlbmVnb3RpYXRpb25FcnJvclwiLCBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuUmVuZWdvdGlhdGlvbkVycm9yKFwiMlhYIHJlc3BvbnNlIHJlY2VpdmVkIHRvIHJlLWludml0ZSBidXQgZGlkIG5vdCBoYXZlIGEgZGVzY3JpcHRpb25cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5tZXNzYWdlLmJvZHksIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBfdGhpcy5tb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkNvdWxkIG5vdCBzZXQgdGhlIGRlc2NyaXB0aW9uIGluIDJYWCByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWludml0ZUZhaWxlZFwiLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVuZWdvdGlhdGlvbkVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZFJlcXVlc3QoQ29uc3RhbnRzXzEuQy5CWUUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFtcIlJlYXNvbjogXCIgKyBVdGlsc18xLlV0aWxzLmdldFJlYXNvbkhlYWRlclZhbHVlKDQ4OCwgXCJOb3QgQWNjZXB0YWJsZSBIZXJlXCIpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuSU5DT01QQVRJQkxFX1NEUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlaW52aXRlQWNjZXB0ZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblJlZGlyZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IERvZXMgQUNLIG5lZWQgdG8gYmUgc2VudD9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSZWNlaXZlZCBhIG5vbiAxWFggb3IgMlhYIHJlc3BvbnNlIHRvIGEgcmUtaW52aXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVpbnZpdGVGYWlsZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVuZWdvdGlhdGlvbkVycm9yXCIsIG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5SZW5lZ290aWF0aW9uRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHRvIGEgcmUtaW52aXRlXCIpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IERvZXMgQUNLIG5lZWQgdG8gYmUgc2VudD9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSZWNlaXZlZCBhIG5vbiAxWFggb3IgMlhYIHJlc3BvbnNlIHRvIGEgcmUtaW52aXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVpbnZpdGVGYWlsZWRcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVuZWdvdGlhdGlvbkVycm9yXCIsIG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5SZW5lZ290aWF0aW9uRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHRvIGEgcmUtaW52aXRlXCIpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uVHJ5aW5nOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihkZXNjcmlwdGlvbilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfdGhpcy5zZXNzaW9uLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5SZW5lZ290aWF0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwicmVuZWdvdGlhdGlvbkVycm9yXCIsIGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiUmVuZWdvdGlhdGlvbiBFcnJvclwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGVycm9yXCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5mYWlsZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGNhdXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5yZWplY3RlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgY2F1c2UpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVqZWN0ZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5jYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiY2FuY2VsXCIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmFjY2VwdGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBjYXVzZSkge1xuICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIGNhdXNlID0gVXRpbHNfMS5VdGlscy5nZXRSZWFzb25QaHJhc2UoKHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUpIHx8IDAsIGNhdXNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLnJlcGxhY2VlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VlLmVtaXQoXCJyZXBsYWNlZFwiLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZWUudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiYWNjZXB0ZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS50ZXJtaW5hdGVkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdChcInRlcm1pbmF0ZWRcIiwgbWVzc2FnZSwgY2F1c2UpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmNvbm5lY3RpbmcgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW5nXCIsIHsgcmVxdWVzdDogcmVxdWVzdCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTZXNzaW9uLkMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXM7XG4gICAgcmV0dXJuIFNlc3Npb247XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5TZXNzaW9uID0gU2Vzc2lvbjtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxudmFyIEludml0ZVNlcnZlckNvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52aXRlU2VydmVyQ29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZpdGVTZXJ2ZXJDb250ZXh0KHVhLCBpbmNvbWluZ0ludml0ZVJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1YS5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICB1YS5sb2dnZXIud2FybihcIkNhbid0IGJ1aWxkIElTQyB3aXRob3V0IFNESCBGYWN0b3J5XCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSVNDIENvbnN0cnVjdG9yIEZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yc2VxID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICAgICAgICBfdGhpcy5pbmNvbWluZ1JlcXVlc3QgPSBpbmNvbWluZ0ludml0ZVJlcXVlc3Q7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gaW5jb21pbmdJbnZpdGVSZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgIFNlcnZlckNvbnRleHRfMS5TZXJ2ZXJDb250ZXh0LmluaXRpYWxpemVyKF90aGlzLCB1YSwgaW5jb21pbmdJbnZpdGVSZXF1ZXN0KTtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuSW52aXRlU2VydmVyQ29udGV4dDtcbiAgICAgICAgdmFyIGNvbnRlbnREaXNwID0gcmVxdWVzdC5wYXJzZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gICAgICAgIGlmIChjb250ZW50RGlzcCAmJiBjb250ZW50RGlzcC50eXBlID09PSBcInJlbmRlclwiKSB7XG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJib2R5ID0gcmVxdWVzdC5ib2R5O1xuICAgICAgICAgICAgX3RoaXMucmVuZGVydHlwZSA9IHJlcXVlc3QuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfSU5WSVRFX1JFQ0VJVkVEO1xuICAgICAgICBfdGhpcy5mcm9tVGFnID0gcmVxdWVzdC5mcm9tVGFnO1xuICAgICAgICBfdGhpcy5pZCA9IHJlcXVlc3QuY2FsbElkICsgX3RoaXMuZnJvbVRhZztcbiAgICAgICAgX3RoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIF90aGlzLmNvbnRhY3QgPSBfdGhpcy51YS5jb250YWN0LnRvU3RyaW5nKCk7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IHVhLmdldExvZ2dlcihcInNpcC5pbnZpdGVzZXJ2ZXJjb250ZXh0XCIsIF90aGlzLmlkKTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICAgICAgICBfdGhpcy51YS5zZXNzaW9uc1tfdGhpcy5pZF0gPSBfdGhpcztcbiAgICAgICAgLy8gU2V0IDEwMHJlbCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHNldDEwMHJlbCA9IGZ1bmN0aW9uIChoZWFkZXIsIHJlbFNldHRpbmcpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Lmhhc0hlYWRlcihoZWFkZXIpICYmIHJlcXVlc3QuZ2V0SGVhZGVyKGhlYWRlcikudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiMTAwcmVsXCIpID49IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWwxMDAgPSByZWxTZXR0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXQxMDByZWwoXCJyZXF1aXJlXCIsIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEKTtcbiAgICAgICAgc2V0MTAwcmVsKFwic3VwcG9ydGVkXCIsIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCk7XG4gICAgICAgIC8vIFNldCB0aGUgdG9UYWcgb24gdGhlIGluY29taW5nIHJlcXVlc3QgdG8gdGhlIHRvVGFnIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgYmUgdXNlZCBpbiB0aGUgcmVzcG9uc2UgdG8gdGhlIGluY29taW5nIHJlcXVlc3QhISFcbiAgICAgICAgLy8gRklYTUU6IEhBQ0s6IFRoaXMgaXMgYSBoYWNrIHRvIHBvcnQgYW4gZXhpc3RpbmcgYmVoYXZpb3IuXG4gICAgICAgIC8vIFRoZSBiZWhhdmlvciBiZWluZyBwb3J0ZWQgYXBwZWFycyB0byBiZSBhIGhhY2sgaXRzZWxmLFxuICAgICAgICAvLyBzbyB0aGlzIGlzIGEgaGFjayB0byBwb3J0IGEgaGFjay4gQXQgbGVhc3Qgb25lIHRlc3Qgc3BlY1xuICAgICAgICAvLyByZWxpZXMgb24gaXQgKHdoaWNoIGlzIHlldCBhbm90aGVyIGhhY2spLlxuICAgICAgICBfdGhpcy5yZXF1ZXN0LnRvVGFnID0gaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnRvVGFnO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjtcbiAgICAgICAgLy8gU2V0IHVzZXJOb0Fuc3dlclRpbWVyXG4gICAgICAgIF90aGlzLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5jb21pbmdJbnZpdGVSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQwOCB9KTtcbiAgICAgICAgICAgIF90aGlzLmZhaWxlZChyZXF1ZXN0LCBDb25zdGFudHNfMS5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZChyZXF1ZXN0LCBDb25zdGFudHNfMS5DLmNhdXNlcy5OT19BTlNXRVIpO1xuICAgICAgICB9LCBfdGhpcy51YS5jb25maWd1cmF0aW9uLm5vQW5zd2VyVGltZW91dCB8fCA2MCk7XG4gICAgICAgIC8qIFNldCBleHBpcmVzVGltZXJcbiAgICAgICAgKiBSRkMzMjYxIDEzLjMuMVxuICAgICAgICAqL1xuICAgICAgICAvLyBHZXQgdGhlIEV4cGlyZXMgaGVhZGVyIHZhbHVlIGlmIGV4aXN0c1xuICAgICAgICBpZiAocmVxdWVzdC5oYXNIZWFkZXIoXCJleHBpcmVzXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXhwaXJlcyA9IE51bWJlcihyZXF1ZXN0LmdldEhlYWRlcihcImV4cGlyZXNcIikgfHwgMCkgKiAxMDAwO1xuICAgICAgICAgICAgX3RoaXMudGltZXJzLmV4cGlyZXNUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nSW52aXRlUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODcgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZChyZXF1ZXN0LCBDb25zdGFudHNfMS5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZChyZXF1ZXN0LCBDb25zdGFudHNfMS5DLmNhdXNlcy5FWFBJUkVTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBleHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5lcnJvckxpc3RlbmVyID0gX3RoaXMub25UcmFuc3BvcnRFcnJvci5iaW5kKF90aGlzKTtcbiAgICAgICAgaWYgKHVhLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdWEudHJhbnNwb3J0Lm9uKFwidHJhbnNwb3J0RXJyb3JcIiwgX3RoaXMuZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUsIFwiYXV0b1NlbmRBbkluaXRpYWxQcm92aXNpb25hbFJlc3BvbnNlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIGEgZmlyc3QgcHJvdmlzaW9uYWwgcmVzcG9uc2UgYWZ0ZXIgdGhlIDEwMCBUcnlpbmdcbiAgICAgICAgICogd2lsbCBiZSBzZW50IGF1dG9tYXRpY2FsbHkuIFRoaXMgaXMgZmFsc2UgaXQgdGhlIFVBQyByZXF1aXJlZFxuICAgICAgICAgKiByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgKDEwMHJlbCBpbiBSZXF1aXJlIGhlYWRlciksXG4gICAgICAgICAqIG90aGVyd2lzZSBpdCBpcyB0cnVlLiBUaGUgcHJvdmlzaW9uYWwgaXMgc2VudCBieSBjYWxsaW5nXG4gICAgICAgICAqIGBwcm9ncmVzcygpYCB3aXRob3V0IGFueSBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBGSVhNRTogVE9ETzogSXQgc2VlbXMgcmVhc29uYWJsZSB0aGF0IHRoZSBJU0MgdXNlciBzaG91bGRcbiAgICAgICAgICogYmUgYWJsZSB0byBvcHRpb25hbGx5IGRpc2FibGUgdGhpcyBiZWhhdmlvci4gQXMgdGhlIHByb3Zpc2lvbmFsXG4gICAgICAgICAqIGlzIHNlbnQgcHJpb3IgdG8gdGhlIFwiaW52aXRlXCIgZXZlbnQgYmVpbmcgZW1pdHRlZCwgaXQncyBhIGtub3duXG4gICAgICAgICAqIGlzc3VlIHRoYXQgdGhlIElTQyB1c2VyIGNhbm5vdCByZWdpc3RlciBsaXN0ZW5lcnMgb3IgZG8gYW55IG90aGVyXG4gICAgICAgICAqIHNldHVwIHByaW9yIHRvIHRoZSBjYWxsIHRvIGBwcm9ncmVzcygpYC4gQXMgYW4gZXhhbXBsZSB3aHkgdGhpcyBpc1xuICAgICAgICAgKiBhbiBpc3N1ZSwgc2V0dGluZyBgdWEuY29uZmlndXJhdGlvbi5yZWwxMDBgIHRvIFJFUVVJUkVEIHdpbGwgcmVzdWx0XG4gICAgICAgICAqIGluIGFuIGF0dGVtcHQgYnkgYHByb2dyZXNzKClgIHRvIHNlbmQgYSAxODMgd2l0aCBTRFAgcHJvZHVjZWQgYnlcbiAgICAgICAgICogY2FsbGluZyBgZ2V0RGVzY3JpcHRpb24oKWAgb24gYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIsIGJ1dFxuICAgICAgICAgKiB0aGUgSVNDIHVzZXIgY2Fubm90IHBlcmZvcm0gYW55IHBvdGVudGlhbGx5IHJlcXVpcmVkIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICAgICAgICogaGFuZGxlciBpbml0aWFsaXphdGlvbiAodGh1cyBwcmV2ZW50aW5nIHRoZSB1dGlsaXphdGlvbiBvZiBzZXR0aW5nXG4gICAgICAgICAqIGB1YS5jb25maWd1cmF0aW9uLnJlbDEwMGAgdG8gUkVRVUlSRUQpLiBUaGF0IGJlZ3MgdGhlIHF1ZXN0aW9uIG9mXG4gICAgICAgICAqIHdoeSB0aGlzIGJlaGF2aW9yIGlzIGRpc2FibGVkIHdoZW4gdGhlIFVBQyByZXF1aXJlcyAxMDByZWwgYnV0IG5vdFxuICAgICAgICAgKiB3aGVuIHRoZSBVQVMgcmVxdWlyZXMgMTAwcmVsPyBCdXQgaWdub3JpbmcgdGhhdCwgaXQncyBqdXN0IG9uZSBleGFtcGxlXG4gICAgICAgICAqIG9mIGEgY2xhc3Mgb2YgY2FzZXMgd2hlcmUgdGhlIElTQyB1c2VyIG5lZWRzIHRvIGRvIHNvbWV0aGluZyBwcmlvclxuICAgICAgICAgKiB0byB0aGUgZmlyc3QgY2FsbCB0byBgcHJvZ3Jlc3MoKWAgYW5kIGlzIHVuYWJsZSB0byBkbyBzby5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gdHlwZSBoYWNrIGZvciBzZXJ2ZXJjb250ZXh0IGludGVyZmFjZVxuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlcGx5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyB0eXBpbmcgbm90ZTogdGhpcyB3YXMgdGhlIG9ubHkgZnVuY3Rpb24gdXNpbmcgaXRzIHN1cGVyIGluIFNlcnZlckNvbnRleHRcbiAgICAvLyBzbyB0aGUgYm90dG9tIGhhbGYgb2YgdGhpcyBmdW5jdGlvbiBpcyBjb3BpZWQgYW5kIHBhaXJlZCBkb3duIGZyb20gdGhhdFxuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlamVjdGluZyBSVENTZXNzaW9uXCIpO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCA0ODA7XG4gICAgICAgIHZhciByZWFzb25QaHJhc2UgPSBVdGlsc18xLlV0aWxzLmdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlLCBvcHRpb25zLnJlYXNvblBocmFzZSk7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSA/IGNvcmVfMS5mcm9tQm9keUxlZ2FjeShvcHRpb25zLmJvZHkpIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBGSVhNRTogTmVlZCB0byByZWRpcmVjdCB0byBzb21lcGxhZVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBzdGF0dXNDb2RlIDwgNDAwID9cbiAgICAgICAgICAgIHRoaXMuaW5jb21pbmdSZXF1ZXN0LnJlZGlyZWN0KFtdLCB7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZTogcmVhc29uUGhyYXNlLCBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycywgYm9keTogYm9keSB9KSA6XG4gICAgICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7XG4gICAgICAgIChbXCJyZWplY3RlZFwiLCBcImZhaWxlZFwiXSkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoZXZlbnQsIHJlc3BvbnNlLm1lc3NhZ2UsIHJlYXNvblBocmFzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtaW5hdGVkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY2NlcHQgdGhlIGluY29taW5nIElOVklURSByZXF1ZXN0IHRvIHN0YXJ0IGEgU2Vzc2lvbi5cbiAgICAgKiBSZXBsaWVzIHRvIHRoZSBJTlZJVEUgcmVxdWVzdCB3aXRoIGEgMjAwIE9rIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIEZJWE1FOiBOZWVkIGd1YXJkIGFnYWluc3QgY2FsbGluZyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fYWNjZXB0KG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gX2EubWVzc2FnZSwgc2Vzc2lvbiA9IF9hLnNlc3Npb247XG4gICAgICAgICAgICBzZXNzaW9uLmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgIG9uQWNrOiBmdW5jdGlvbiAoYWNrUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMub25BY2soYWNrUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgb25BY2tUaW1lb3V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkFja1RpbWVvdXQoKTsgfSxcbiAgICAgICAgICAgICAgICBvbkJ5ZTogZnVuY3Rpb24gKGJ5ZVJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KGJ5ZVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgIG9uSW5mbzogZnVuY3Rpb24gKGluZm9SZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChpbmZvUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgb25JbnZpdGU6IGZ1bmN0aW9uIChpbnZpdGVSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChpbnZpdGVSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QobWVzc2FnZVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgIG9uTm90aWZ5OiBmdW5jdGlvbiAobm90aWZ5UmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3Qobm90aWZ5UmVxdWVzdCk7IH0sXG4gICAgICAgICAgICAgICAgb25QcmFjazogZnVuY3Rpb24gKHByYWNrUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QocHJhY2tSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICBvblJlZmVyOiBmdW5jdGlvbiAocmVmZXJSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChyZWZlclJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BQ0s7XG4gICAgICAgICAgICBfdGhpcy5hY2NlcHRlZChtZXNzYWdlLCBVdGlsc18xLlV0aWxzLmdldFJlYXNvblBocmFzZSgyMDApKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQ29udGV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBBc3N1bWluZyBlcnJvciBkdWUgdG8gYXN5bmMgcmFjZSBvbiBDQU5DRUwgYW5kIGVhdGluZyBlcnJvci5cbiAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcG9ydCBwcm9ncmVzcyB0byB0aGUgdGhlIGNhbGxlci5cbiAgICAgKiBSZXBsaWVzIHRvIHRoZSBJTlZJVEUgcmVxdWVzdCB3aXRoIGEgMXh4IHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gUG9ydGVkXG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MDtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDE5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3J0ZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVbmV4cGVjdGVkIGNhbGwgZm9yIHByb2dyZXNzIHdoaWxlIHRlcm1pbmF0ZWQsIGlnbm9yaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkZWRcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5leHBlY3RlZCBjYWxsIGZvciBwcm9ncmVzcyB3aGlsZSBhbnN3ZXJlZCwgaWdub3JpbmdcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGRlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRURfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVbmV4cGVjdGVkIGNhbGwgZm9yIHByb2dyZXNzIHdoaWxlIGFuc3dlcmVkICh3YWl0aW5nIGZvciBwcmFjayksIGlnbm9yaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGZvciBhIHJlcXVlc3QgaGFzIGJlZW5cbiAgICAgICAgLy8gYWNrbm93bGVkZ2VkLCB0aGUgVUFTIE1BWSBzZW5kIGFkZGl0aW9uYWwgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gcmVzcG9uc2VzLiAgVGhlIFVBUyBNVVNUIE5PVCBzZW5kIGEgc2Vjb25kIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vIHJlc3BvbnNlIHVudGlsIHRoZSBmaXJzdCBpcyBhY2tub3dsZWRnZWQuICBBZnRlciB0aGUgZmlyc3QsIGl0IGlzXG4gICAgICAgIC8vIFJFQ09NTUVOREVEIHRoYXQgdGhlIFVBUyBub3Qgc2VuZCBhbiBhZGRpdGlvbmFsIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgIC8vIHJlc3BvbnNlIHVudGlsIHRoZSBwcmV2aW91cyBpcyBhY2tub3dsZWRnZWQuICBUaGUgZmlyc3QgcmVsaWFibGVcbiAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgcmVjZWl2ZXMgc3BlY2lhbCB0cmVhdG1lbnQgYmVjYXVzZSBpdCBjb252ZXlzXG4gICAgICAgIC8vIHRoZSBpbml0aWFsIHNlcXVlbmNlIG51bWJlci4gIElmIGFkZGl0aW9uYWwgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gcmVzcG9uc2VzIHdlcmUgc2VudCBiZWZvcmUgdGhlIGZpcnN0IHdhcyBhY2tub3dsZWRnZWQsIHRoZSBVQVMgY291bGRcbiAgICAgICAgLy8gbm90IGJlIGNlcnRhaW4gdGhlc2Ugd2VyZSByZWNlaXZlZCBpbiBvcmRlci5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVuZXhwZWN0ZWQgY2FsbCBmb3IgcHJvZ3Jlc3Mgd2hpbGUgd2FpdGluZyBmb3IgcHJhY2ssIGlnbm9yaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9ydGVkXG4gICAgICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC50cnlpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db250ZXh0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBBc3N1bWluZyBlcnJvciBkdWUgdG8gYXN5bmMgcmFjZSBvbiBDQU5DRUwgYW5kIGVhdGluZyBlcnJvci5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YW5kYXJkIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgICAgICBpZiAoISh0aGlzLnJlbDEwMCA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpICYmXG4gICAgICAgICAgICAhKHRoaXMucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQgJiYgb3B0aW9ucy5yZWwxMDApICYmXG4gICAgICAgICAgICAhKHRoaXMucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5TVVBQT1JURUQgJiYgdGhpcy51YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyhvcHRpb25zKVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNvbnRleHRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEFzc3VtaW5nIGVycm9yIGR1ZSB0byBhc3luYyByYWNlIG9uIENBTkNFTCBhbmQgZWF0aW5nIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgIHRoaXMuX3JlbGlhYmxlUHJvZ3Jlc3NXYWl0Rm9yUHJhY2sob3B0aW9ucylcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQ29udGV4dEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBBc3N1bWluZyBlcnJvciBkdWUgdG8gYXN5bmMgcmFjZSBvbiBDQU5DRUwgYW5kIGVhdGluZyBlcnJvci5cbiAgICAgICAgICAgIGlmICghX3RoaXMuX2NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlamVjdCBhbiB1bmFjY2VwdGVkIGluY29taW5nIElOVklURSByZXF1ZXN0IG9yIHNlbmQgQllFIGlmIGVzdGFibGlzaGVkIHNlc3Npb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuIEZJWE1FOiBUaGlzIG9wdGlvbnMgYnVja2V0IG5lZWRzIHRvIGJlIHR5cGVkLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLFxuICAgICAgICAvLyBhbmQgdGhlIGNhbGxlZSdzIFVBIE1BWSBzZW5kIGEgQllFIG9uIGNvbmZpcm1lZCBkaWFsb2dzLCBidXQgTVVTVCBOT1RcbiAgICAgICAgLy8gc2VuZCBhIEJZRSBvbiBlYXJseSBkaWFsb2dzLiBIb3dldmVyLCB0aGUgY2FsbGVlJ3MgVUEgTVVTVCBOT1Qgc2VuZCBhXG4gICAgICAgIC8vIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2cgdW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eFxuICAgICAgICAvLyByZXNwb25zZSBvciB1bnRpbCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBXZSBkb24ndCB5ZXQgaGF2ZSBhIGRpYWxvZywgc28gcmVqZWN0IHJlcXVlc3QuXG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXNzaW9uLnNlc3Npb25TdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuRWFybHk6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3Qob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuQWNrV2FpdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gQUNLIHNob3dzIHVwLCBzYXkgQllFLlxuICAgICAgICAgICAgICAgICAgICBvbkFjazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZFJlcXVlc3QoQ29uc3RhbnRzXzEuQy5CWUUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBPciB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIHRpbWVzIG91dCBiZWZvcmUgdGhlIEFDSyBhcnJpdmVzLlxuICAgICAgICAgICAgICAgICAgICBvbkFja1RpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmRSZXF1ZXN0KENvbnN0YW50c18xLkMuQllFLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gUG9ydGVkXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYnllXCIsIHRoaXMucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuQ29uZmlybWVkOlxuICAgICAgICAgICAgICAgIHRoaXMuYnllKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vbkNhbmNlbCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9BTlNXRVIgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUEgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ0FOQ0VMRUQ7XG4gICAgICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODcgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGVkKCk7XG4gICAgICAgICAgICB0aGlzLnJlamVjdGVkKG1lc3NhZ2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKG1lc3NhZ2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkNBTkNFTEVEKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZChtZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5DQU5DRUxFRCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24gKGluY29taW5nUmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBDb25zdGFudHNfMS5DLlBSQUNLOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci1jcmVhdGVkXCIsIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmhhc0Rlc2NyaXB0aW9uKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuc2V0RGVzY3JpcHRpb24oaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UuYm9keSwgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgdGhpcy5tb2RpZmllcnMpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVycy5wcmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IFwiNDg4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZChpbmNvbWluZ1JlcXVlc3QubWVzc2FnZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVybWluYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogXCI0ODhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uUGhyYXNlOiBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsZWQoaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKGluY29taW5nUmVxdWVzdC5tZXNzYWdlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJzLnJlbDF4eFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVycy5wcmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19FQVJMWV9NRURJQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nUmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QuY2FsbCh0aGlzLCBpbmNvbWluZ1JlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJbnRlcm5hbCBGdW5jdGlvbiB0byBzZXR1cCB0aGUgaGFuZGxlciBjb25zaXN0ZW50bHlcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5zZXR1cFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkodGhpcywgdGhpcy51YS5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9ucyk7XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBjb3JlXzEuZ2V0Qm9keSh0aGlzLmluY29taW5nUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghYm9keSB8fCBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiAhPT0gXCJzZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZlcihvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE9mZmVyQW5kR2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPZmZlcihvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gbyAgT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZlciwgaXQgTVVTVCBOT1QgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gYW55IHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgaW5pdGlhbCBJTlZJVEUuICBUaGlzIG1lYW5zIHRoYXQgYSBVQVMgYmFzZWQgb24gdGhpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgICAgICAgICAgICAgICAvLyBjb21wbGV0aW9uIG9mIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbi5vZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBvZmZlciB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIodGhpcy5zZXNzaW9uLm9mZmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5oYW5kbGVQcmFja09mZmVyQW5zd2VyID0gZnVuY3Rpb24gKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgUFJBQ0sgZG9lc24ndCBoYXZlIGFuIG9mZmVyL2Fuc3dlciwgbm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICB2YXIgYm9keSA9IGNvcmVfMS5nZXRCb2R5KHJlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgIGlmICghYm9keSB8fCBib2R5LmNvbnRlbnREaXNwb3NpdGlvbiAhPT0gXCJzZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgVUFDIHJlY2VpdmVzIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhbiBvZmZlclxuICAgICAgICAvLyAodGhpcyB3b3VsZCBvY2N1ciBpZiB0aGUgVUFDIHNlbnQgYW4gSU5WSVRFIHdpdGhvdXQgYW4gb2ZmZXIsIGluXG4gICAgICAgIC8vIHdoaWNoIGNhc2UgdGhlIGZpcnN0IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpbGwgY29udGFpbiB0aGVcbiAgICAgICAgLy8gb2ZmZXIpLCBpdCBNVVNUIGdlbmVyYXRlIGFuIGFuc3dlciBpbiB0aGUgUFJBQ0suICBJZiB0aGUgVUFDIHJlY2VpdmVzXG4gICAgICAgIC8vIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2l0aCBhbiBhbnN3ZXIsIGl0IE1BWSBnZW5lcmF0ZSBhblxuICAgICAgICAvLyBhZGRpdGlvbmFsIG9mZmVyIGluIHRoZSBQUkFDSy4gIElmIHRoZSBVQVMgcmVjZWl2ZXMgYSBQUkFDSyB3aXRoIGFuXG4gICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIHBsYWNlIHRoZSBhbnN3ZXIgaW4gdGhlIDJ4eCB0byB0aGUgUFJBQ0suXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBhcyBmaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBtdXN0IGhhdmUgYW5zd2VyL29mZmVyLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgICAgICAgIC8vIFJlY2V2ZWQgYW5zd2VyLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldEFuc3dlcihib2R5LCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBhcyBsb2NhbCBvZmZlciB3b3VsZCBiZSBhbnN3ZXJlZCBieSB0aGlzIFBSQUNLXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLnNlc3Npb24uc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgICAgICAgLy8gUmVjZXZlZCBvZmZlciwgZ2VuZXJhdGUgYW5zd2VyLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE9mZmVyQW5kR2V0QW5zd2VyKGJvZHksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5zZXNzaW9uLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIHRoaXMuc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gc2Vzc2lvbiBjYW5jZWxlZC5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5jYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYW5jZWxlZC5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gc2Vzc2lvbiB0ZXJtaW5hdGVkLlxuICAgICAqIFVzaW5nIGl0IGhlcmUganVzdCBmb3IgdGhlIFBSQUNLIHRpbWVvdXQuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUudGVybWluYXRlZCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjYXVzZSkge1xuICAgICAgICB0aGlzLnByYWNrTmV2ZXJBcnJpdmVkKCk7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRlcm1pbmF0ZWQuY2FsbCh0aGlzLCBtZXNzYWdlLCBjYXVzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHZlcnNpb24gb2YgYGFjY2VwdGAgd2hpY2ggcmVzb2x2ZXMgYSBzZXNzaW9uIHdoZW4gdGhlIDIwMCBPayByZXNwb25zZSBpcyBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqIEB0aHJvd3Mge0Nsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcn0gVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBjbG9zZWQgYmVmb3JlIG1ldGhvZCBjb21wbGV0ZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNhY3Rpb25TdGF0ZUVycm9yfSBUaGUgdHJhbnNhY3Rpb24gc3RhdGUgZG9lcyBub3QgYWxsb3cgZm9yIGBhY2NlcHQoKWAgdG8gYmUgY2FsbGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBjYW4gY2hhbmdlIHdoaWxlIHRoaXMgY2FsbCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5fYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gRklYTUU6IFBvcnRlZCAtIGNhbGxiYWNrIGZvciBpbiBkaWFsb2cgSU5GTyByZXF1ZXN0cy5cbiAgICAgICAgLy8gVHVybnMgb3V0IGFjY2VwdCgpIGNhbiBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UgaWYgd2UgYXJlIHdhaXRpbmdcbiAgICAgICAgLy8gZm9yIGEgUFJBQ0sgaW4gd2hpY2ggY2FzZSBcIm9wdGlvbnNcIiBnZXQgY29tcGxldGVseSB0b3NzZWQgYXdheS5cbiAgICAgICAgLy8gU28gdGhpcyBpcyBicm9rZW4gaW4gdGhhdCBjYXNlIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgdXNlcyBvZiBvcHRpb25zKS5cbiAgICAgICAgLy8gVGVtcHRlZCB0byBqdXN0IHRyeSB0byBmaXggaXQgbm93LCBidXQgbGVhdmluZyBpdCBicm9rZW4gZm9yIHRoZSBtb21lbnQuXG4gICAgICAgIHRoaXMub25JbmZvID0gb3B0aW9ucy5vbkluZm87XG4gICAgICAgIC8vIFRoZSBVQVMgTUFZIHNlbmQgYSBmaW5hbCByZXNwb25zZSB0byB0aGUgaW5pdGlhbCByZXF1ZXN0IGJlZm9yZVxuICAgICAgICAvLyBoYXZpbmcgcmVjZWl2ZWQgUFJBQ0tzIGZvciBhbGwgdW5hY2tub3dsZWRnZWQgcmVsaWFibGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gcmVzcG9uc2VzLCB1bmxlc3MgdGhlIGZpbmFsIHJlc3BvbnNlIGlzIDJ4eCBhbmQgYW55IG9mIHRoZVxuICAgICAgICAvLyB1bmFja25vd2xlZGdlZCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgY29udGFpbmVkIGEgc2Vzc2lvblxuICAgICAgICAvLyBkZXNjcmlwdGlvbi4gIEluIHRoYXQgY2FzZSwgaXQgTVVTVCBOT1Qgc2VuZCBhIGZpbmFsIHJlc3BvbnNlIHVudGlsXG4gICAgICAgIC8vIHRob3NlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBhcmUgYWNrbm93bGVkZ2VkLiAgSWYgdGhlIFVBUyBkb2VzIHNlbmQgYVxuICAgICAgICAvLyBmaW5hbCByZXNwb25zZSB3aGVuIHJlbGlhYmxlIHJlc3BvbnNlcyBhcmUgc3RpbGwgdW5hY2tub3dsZWRnZWQsIGl0XG4gICAgICAgIC8vIFNIT1VMRCBOT1QgY29udGludWUgdG8gcmV0cmFuc21pdCB0aGUgdW5hY2tub3dsZWRnZWQgcmVsaWFibGVcbiAgICAgICAgLy8gcHJvdmlzaW9uYWwgcmVzcG9uc2VzLCBidXQgaXQgTVVTVCBiZSBwcmVwYXJlZCB0byBwcm9jZXNzIFBSQUNLXG4gICAgICAgIC8vIHJlcXVlc3RzIGZvciB0aG9zZSBvdXRzdGFuZGluZyByZXNwb25zZXMuICBBIFVBUyBNVVNUIE5PVCBzZW5kIG5ld1xuICAgICAgICAvLyByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMgKGFzIG9wcG9zZWQgdG8gcmV0cmFuc21pc3Npb25zIG9mXG4gICAgICAgIC8vIHVuYWNrbm93bGVkZ2VkIG9uZXMpIGFmdGVyIHNlbmRpbmcgYSBmaW5hbCByZXNwb25zZSB0byBhIHJlcXVlc3QuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tM1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfUFJBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19BTlNXRVJFRF9XQUlUSU5HX0ZPUl9QUkFDSztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JBcnJpdmFsT2ZQcmFjaygpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQ7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVycy51c2VyTm9BbnN3ZXJUaW1lcik7IC8vIFBvcnRlZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIob3B0aW9ucyk7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJvZHkpIHsgcmV0dXJuIF90aGlzLmluY29taW5nUmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IGJvZHkgfSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcnRlZFxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQU5TV0VSKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQU5TV0VSRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMuc3RhdHVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0FOU1dFUkVEO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcnMudXNlck5vQW5zd2VyVGltZXIpOyAvLyBQb3J0ZWRcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VyKG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gX3RoaXMuaW5jb21pbmdSZXF1ZXN0LmFjY2VwdCh7IHN0YXR1c0NvZGU6IDIwMCwgYm9keTogYm9keSB9KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHZlcnNpb24gb2YgYHByb2dyZXNzYCB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSBpcyBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqIEB0aHJvd3Mge0Nsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcn0gVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBjbG9zZWQgYmVmb3JlIG1ldGhvZCBjb21wbGV0ZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNhY3Rpb25TdGF0ZUVycm9yfSBUaGUgdHJhbnNhY3Rpb24gc3RhdGUgZG9lcyBub3QgYWxsb3cgZm9yIGBwcm9ncmVzcygpYCB0byBiZSBjYWxsZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIGNhbiBjaGFuZ2Ugd2hpbGUgdGhpcyBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLl9wcm9ncmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIFBvcnRlZFxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODA7XG4gICAgICAgIHZhciByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgPyBjb3JlXzEuZnJvbUJvZHlMZWdhY3kob3B0aW9ucy5ib2R5KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gVGhlIDE4MyAoU2Vzc2lvbiBQcm9ncmVzcykgcmVzcG9uc2UgaXMgdXNlZCB0byBjb252ZXkgaW5mb3JtYXRpb25cbiAgICAgICAgLy8gYWJvdXQgdGhlIHByb2dyZXNzIG9mIHRoZSBjYWxsIHRoYXQgaXMgbm90IG90aGVyd2lzZSBjbGFzc2lmaWVkLiAgVGhlXG4gICAgICAgIC8vIFJlYXNvbi1QaHJhc2UsIGhlYWRlciBmaWVsZHMsIG9yIG1lc3NhZ2UgYm9keSBNQVkgYmUgdXNlZCB0byBjb252ZXlcbiAgICAgICAgLy8gbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBjYWxsIHByb2dyZXNzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIxLjEuNVxuICAgICAgICAvLyBJdCBpcyB0aGUgZGUgZmFjdG8gaW5kdXN0cnkgc3RhbmRhcmQgdG8gdXRpbGl6ZSAxODMgd2l0aCBTRFAgdG8gcHJvdmlkZSBcImVhcmx5IG1lZGlhXCIuXG4gICAgICAgIC8vIFdoaWxlIGl0IGlzIHVubGlrZWx5IHNvbWVvbmUgd291bGQgd2FudCB0byBzZW5kIGEgMTgzIHdpdGhvdXQgU0RQLCBzbyBpdCBzaG91bGQgYmUgYW4gb3B0aW9uLlxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gMTgzICYmICFib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3NXaXRoU0RQKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NSZXNwb25zZSA9IHRoaXMuaW5jb21pbmdSZXF1ZXN0LnByb2dyZXNzKHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcHJvZ3Jlc3NSZXNwb25zZS5tZXNzYWdlLCByZWFzb25QaHJhc2UpOyAvLyBQb3J0ZWRcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHByb2dyZXNzUmVzcG9uc2Uuc2Vzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvZ3Jlc3NSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHZlcnNpb24gb2YgYHByb2dyZXNzYCB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIHNkcCBpcyBzZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgYnVja2V0LlxuICAgICAqIEB0aHJvd3Mge0Nsb3NlZFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcn0gVGhlIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBjbG9zZWQgYmVmb3JlIG1ldGhvZCBjb21wbGV0ZWQuXG4gICAgICogQHRocm93cyB7VHJhbnNhY3Rpb25TdGF0ZUVycm9yfSBUaGUgdHJhbnNhY3Rpb24gc3RhdGUgZG9lcyBub3QgYWxsb3cgZm9yIGBwcm9ncmVzcygpYCB0byBiZSBjYWxsZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIGNhbiBjaGFuZ2Ugd2hpbGUgdGhpcyBjYWxsIGlzIGluIHByb2dyZXNzLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLl9wcm9ncmVzc1dpdGhTRFAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZSB8fCAxODM7XG4gICAgICAgIHZhciByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgLy8gR2V0IGFuIG9mZmVyL2Fuc3dlciBhbmQgc2VuZCBhIHJlcGx5LlxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7IHJldHVybiBfdGhpcy5pbmNvbWluZ1JlcXVlc3QucHJvZ3Jlc3MoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2U6IHJlYXNvblBocmFzZSwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMsIGJvZHk6IGJvZHkgfSk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJvZ3Jlc3NSZXNwb25zZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInByb2dyZXNzXCIsIHByb2dyZXNzUmVzcG9uc2UubWVzc2FnZSwgcmVhc29uUGhyYXNlKTsgLy8gUG9ydGVkXG4gICAgICAgICAgICBfdGhpcy5zZXNzaW9uID0gcHJvZ3Jlc3NSZXNwb25zZS5zZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzUmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSB2ZXJzaW9uIG9mIGBwcm9ncmVzc2Agd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgc2VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAdGhyb3dzIHtDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3J9IFRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgY2xvc2VkIGJlZm9yZSBtZXRob2QgY29tcGxldGVkLlxuICAgICAqIEB0aHJvd3Mge1RyYW5zYWN0aW9uU3RhdGVFcnJvcn0gVGhlIHRyYW5zYWN0aW9uIHN0YXRlIGRvZXMgbm90IGFsbG93IGZvciBgcHJvZ3Jlc3MoKWAgdG8gYmUgY2FsbGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBjYW4gY2hhbmdlIHdoaWxlIHRoaXMgY2FsbCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5fcmVsaWFibGVQcm9ncmVzcyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MztcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IDEwMHJlbFwiKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSU2VxOiBcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSk7XG4gICAgICAgIC8vIEdldCBhbiBvZmZlci9hbnN3ZXIgYW5kIHNlbmQgYSByZXBseS5cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VyKG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keSkgeyByZXR1cm4gX3RoaXMuaW5jb21pbmdSZXF1ZXN0LnByb2dyZXNzKHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByb2dyZXNzUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCBwcm9ncmVzc1Jlc3BvbnNlLm1lc3NhZ2UsIHJlYXNvblBocmFzZSk7IC8vIFBvcnRlZFxuICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbiA9IHByb2dyZXNzUmVzcG9uc2Uuc2Vzc2lvbjtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmVzc1Jlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgdmVyc2lvbiBvZiBgcHJvZ3Jlc3NgIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIGFja25vd2xlZGdlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAdGhyb3dzIHtDbG9zZWRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3J9IFRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgY2xvc2VkIGJlZm9yZSBtZXRob2QgY29tcGxldGVkLlxuICAgICAqIEB0aHJvd3Mge1RyYW5zYWN0aW9uU3RhdGVFcnJvcn0gVGhlIHRyYW5zYWN0aW9uIHN0YXRlIGRvZXMgbm90IGFsbG93IGZvciBgcHJvZ3Jlc3MoKWAgdG8gYmUgY2FsbGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90ZSB0aGF0IHRoZSB0cmFuc2FjdGlvbiBzdGF0ZSBjYW4gY2hhbmdlIHdoaWxlIHRoaXMgY2FsbCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5fcmVsaWFibGVQcm9ncmVzc1dhaXRGb3JQcmFjayA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDE4MztcbiAgICAgICAgdmFyIHJlYXNvblBocmFzZSA9IG9wdGlvbnMucmVhc29uUGhyYXNlO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IDEwMHJlbFwiKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSU2VxOiBcIiArIHRoaXMucnNlcSsrKTtcbiAgICAgICAgdmFyIGJvZHk7XG4gICAgICAgIC8vIFBvcnRlZCAtIHNldCBzdGF0dXMuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19XQUlUSU5HX0ZPUl9QUkFDSztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB3YWl0aW5nRm9yUHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlcihvcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZlckFuc3dlcikge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBvZmZlckFuc3dlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW5jb21pbmdSZXF1ZXN0LnByb2dyZXNzKHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocHJvZ3Jlc3NSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCBwcm9ncmVzc1Jlc3BvbnNlLm1lc3NhZ2UsIHJlYXNvblBocmFzZSk7IC8vIFBvcnRlZFxuICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb24gPSBwcm9ncmVzc1Jlc3BvbnNlLnNlc3Npb247XG4gICAgICAgICAgICAgICAgdmFyIHByYWNrUmVxdWVzdDtcbiAgICAgICAgICAgICAgICB2YXIgcHJhY2tSZXNwb25zZTtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc1Jlc3BvbnNlLnNlc3Npb24uZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUHJhY2s6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmFja1JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByYWNrV2FpdFRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb25UaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhaXRpbmdGb3JQcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JQcmFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUHJhY2tPZmZlckFuc3dlcihwcmFja1JlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHByYWNrUmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJhY2tSZXNwb25zZSA9IHByYWNrUmVxdWVzdC5hY2NlcHQoeyBzdGF0dXNDb2RlOiAyMDAsIGJvZHk6IHByYWNrUmVzcG9uc2VCb2R5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3J0ZWQgLSBzZXQgc3RhdHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX1BSQUNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FOU1dFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmFja0Fycml2ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHByYWNrUmVxdWVzdDogcHJhY2tSZXF1ZXN0LCBwcmFja1Jlc3BvbnNlOiBwcmFja1Jlc3BvbnNlLCBwcm9ncmVzc1Jlc3BvbnNlOiBwcm9ncmVzc1Jlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgICAgICAgICAgdmFyIHByYWNrV2FpdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghd2FpdGluZ0ZvclByYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0ZvclByYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiTm8gUFJBQ0sgcmVjZWl2ZWQsIHJlamVjdGluZyBJTlZJVEUuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVsMXh4UmV0cmFuc21pc3Npb25UaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbmNvbWluZ1JlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNTA0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLk5PX1BSQUNLKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuVGVybWluYXRlZFNlc3Npb25FcnJvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBwcmFja1dhaXRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KHByYWNrV2FpdFRpbWVvdXQsIGNvcmVfMS5UaW1lcnMuVDEgKiA2NCk7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi0zXG4gICAgICAgICAgICAgICAgdmFyIHJlbDF4eFJldHJhbnNtaXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5jb21pbmdSZXF1ZXN0LnByb2dyZXNzKHsgc3RhdHVzQ29kZTogc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlOiByZWFzb25QaHJhc2UsIGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdGluZ0ZvclByYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlbDF4eFJldHJhbnNtaXNzaW9uVGltZXIgPSBzZXRUaW1lb3V0KHJlbDF4eFJldHJhbnNtaXNzaW9uLCB0aW1lb3V0ICo9IDIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBjb3JlXzEuVGltZXJzLlQxO1xuICAgICAgICAgICAgICAgIHZhciByZWwxeHhSZXRyYW5zbWlzc2lvblRpbWVyID0gc2V0VGltZW91dChyZWwxeHhSZXRyYW5zbWlzc2lvbiwgdGltZW91dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3Igd2hlbiBBQ0sgZm9yIGEgMnh4IHJlc3BvbnNlIGlzIG5ldmVyIHJlY2VpdmVkLlxuICAgICAqIEBwYXJhbSBzZXNzaW9uIFNlc3Npb24gdGhlIEFDSyBuZXZlciBhcnJpdmVkIGZvclxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLm9uQWNrVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwibm8gQUNLIHJlY2VpdmVkIGZvciBhbiBleHRlbmRlZCBwZXJpb2Qgb2YgdGltZSwgdGVybWluYXRpbmcgdGhlIGNhbGxcIik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5ieWUoKTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLk5PX0FDSyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZJWE1FOiBUT0RPOiBUaGUgY3VycmVudCBsaWJyYXJ5IGludGVyZmFjZSBwcmVzZW50cyBhc3luYyBtZXRob2RzIHdpdGhvdXQgYVxuICAgICAqIHByb3BlciBhc3luYyBlcnJvciBoYW5kbGluZyBtZWNoYW5pc20uIEFyZ3VhYmx5IGEgcHJvbWlzZSBiYXNlZCBpbnRlcmZhY2VcbiAgICAgKiB3b3VsZCBiZSBhbiBpbXByb3ZlbWVudCBvdmVyIHRoZSBwYXR0ZXJuIG9mIHJldHVybmluZyBgdGhpc2AuIFRoZSBhcHByb2FjaCBoYXNcbiAgICAgKiBiZWVuIGdlbmVyYWxseSBhbG9uZyB0aGUgbGluZXMgb2YgbG9nIGEgZXJyb3IgYW5kIHRlcm1pbmF0ZS5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5vbkNvbnRleHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IDQ4MDtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgY29yZV8xLkV4Y2VwdGlvbikgeyAvLyBUaGVyZSBtaWdodCBiZSBpbnRlcmVzdCBpbiBjYXRjaGluZyB0aGVzZSBFeGNlcHRpb25zLlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlRlcm1pbmF0ZWRTZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBQUkFDSyBuZXZlciBhcnJpdmVkLCBzbyB3ZSB0aW1lZCBvdXQgd2FpdGluZyBmb3IgaXQuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkluY29taW5nIHNlc3Npb24gdGVybWluYXRlZCB3aGlsZSB3YWl0aW5nIGZvciBQUkFDSy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlVuc3VwcG9ydGVkU2Vzc2lvbkRlc2NyaXB0aW9uQ29udGVudFR5cGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSA0MTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIGNvcmVfMS5FeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7IC8vIE90aGVyIEVycm9ycyBob3VsZCBnbyB1bmNhdWdodC5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkga25vdyB3aGF0IGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGltcGxlbWVudGF0aW9uIG1pZ2h0IHRocm93XG4gICAgICAgICAgICAvLyBvdXIgd2F5LCBzbyBhcyBhIGxhc3QgcmVzb3J0LCBqdXN0IGFzc3VtZSB3ZSBhcmUgZ2V0dGluZyBhbiBcImFueVwiIGFuZCBsb2cgaXQuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIuXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluY29taW5nUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlIH0pOyAvLyBcIlRlbXBvcmFyaWx5IFVuYXZhaWxhYmxlXCJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKHRoaXMuaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkKHRoaXMuaW5jb21pbmdSZXF1ZXN0Lm1lc3NhZ2UsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5wcmFja0Fycml2ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLndhaXRpbmdGb3JQcmFja1Jlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFja1JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnByYWNrTmV2ZXJBcnJpdmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53YWl0aW5nRm9yUHJhY2tSZWplY3QpIHtcbiAgICAgICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUmVqZWN0KG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5UZXJtaW5hdGVkU2Vzc2lvbkVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFja1JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0V4Y2VwdGlvbnMuVGVybWluYXRlZFNlc3Npb25FcnJvcn0gVGhlIHNlc3Npb24gdGVybWluYXRlZCBiZWZvcmUgYmVpbmcgYWNjZXB0ZWQgKGkuZS4gY2FuY2VsIGFycml2ZWQpLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLndhaXRGb3JBcnJpdmFsT2ZQcmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMud2FpdGluZ0ZvclByYWNrUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWxyZWFkeSB3YWl0aW5nIGZvciBQUkFDS1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRpbmdGb3JQcmFja1Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy53YWl0aW5nRm9yUHJhY2tSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLndhaXRpbmdGb3JQcmFja1JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLndhaXRpbmdGb3JQcmFja1Byb21pc2U7XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5nZXRPZmZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICB2YXIgc2RoID0gdGhpcy5nZXRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIHJldHVybiBzZGhcbiAgICAgICAgICAgIC5nZXREZXNjcmlwdGlvbihvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBvcHRpb25zLm1vZGlmaWVycylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5T2JqKSB7IHJldHVybiBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKGJvZHlPYmopOyB9KTtcbiAgICB9O1xuICAgIEludml0ZVNlcnZlckNvbnRleHQucHJvdG90eXBlLnNldEFuc3dlciA9IGZ1bmN0aW9uIChhbnN3ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICB2YXIgc2RoID0gdGhpcy5nZXRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIGlmICghc2RoLmhhc0Rlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZGhcbiAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihhbnN3ZXIuY29udGVudCwgb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgb3B0aW9ucy5tb2RpZmllcnMpO1xuICAgIH07XG4gICAgSW52aXRlU2VydmVyQ29udGV4dC5wcm90b3R5cGUuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIgPSBmdW5jdGlvbiAob2ZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5oYXNPZmZlciA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuZ2V0U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgICAgICBpZiAoIXNkaC5oYXNEZXNjcmlwdGlvbihvZmZlci5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuVW5zdXBwb3J0ZWRTZXNzaW9uRGVzY3JpcHRpb25Db250ZW50VHlwZUVycm9yKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZGhcbiAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihvZmZlci5jb250ZW50LCBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBvcHRpb25zLm1vZGlmaWVycylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNkaC5nZXREZXNjcmlwdGlvbihvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCBvcHRpb25zLm1vZGlmaWVycyk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keU9iaikgeyByZXR1cm4gVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaihib2R5T2JqKTsgfSk7XG4gICAgfTtcbiAgICBJbnZpdGVTZXJ2ZXJDb250ZXh0LnByb3RvdHlwZS5nZXRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDcmVhdGUgb3VyIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBpZiBub3QgYWxyZWFkeSBkb25lIHNvLi4uXG4gICAgICAgIHZhciBzZGggPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgICAgICAvLyBGSVhNRTogUG9ydGVkIC0gdGhpcyBjYW4gZ2V0IGVtaXR0ZWQgbXVsdGlwbGUgdGltZXMgZXZlbiB3aGVuIG9ubHkgY3JlYXRlZCBvbmNlLi4uIGRvbid0IHdlIGNhcmU/XG4gICAgICAgIHRoaXMuZW1pdChcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXItY3JlYXRlZFwiLCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpO1xuICAgICAgICAvLyBSZXR1cm4uXG4gICAgICAgIHJldHVybiBzZGg7XG4gICAgfTtcbiAgICByZXR1cm4gSW52aXRlU2VydmVyQ29udGV4dDtcbn0oU2Vzc2lvbikpO1xuZXhwb3J0cy5JbnZpdGVTZXJ2ZXJDb250ZXh0ID0gSW52aXRlU2VydmVyQ29udGV4dDtcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxudmFyIEludml0ZUNsaWVudENvbnRleHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52aXRlQ2xpZW50Q29udGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZpdGVDbGllbnRDb250ZXh0KHVhLCB0YXJnZXQsIG9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAobW9kaWZpZXJzID09PSB2b2lkIDApIHsgbW9kaWZpZXJzID0gW107IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1YS5jb25maWd1cmF0aW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KSB7XG4gICAgICAgICAgICB1YS5sb2dnZXIud2FybihcIkNhbid0IGJ1aWxkIElTQyB3aXRob3V0IFNESCBGYWN0b3J5XCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSUNDIENvbnN0cnVjdG9yIEZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgYW5vbnltb3VzID0gb3B0aW9ucy5hbm9ueW1vdXMgfHwgZmFsc2U7XG4gICAgICAgIHZhciBmcm9tVGFnID0gVXRpbHNfMS5VdGlscy5uZXdUYWcoKTtcbiAgICAgICAgb3B0aW9ucy5wYXJhbXMuZnJvbVRhZyA9IGZyb21UYWc7XG4gICAgICAgIC8qIERvIG5vdCBhZGQgO29iIGluIGluaXRpYWwgZm9ybWluZyBkaWFsb2cgcmVxdWVzdHMgaWYgdGhlIHJlZ2lzdHJhdGlvbiBvdmVyXG4gICAgICAgICogIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gZ290IGEgR1JVVSBVUkkuXG4gICAgICAgICovXG4gICAgICAgIHZhciBjb250YWN0ID0gdWEuY29udGFjdC50b1N0cmluZyh7XG4gICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcbiAgICAgICAgICAgIG91dGJvdW5kOiBhbm9ueW1vdXMgPyAhdWEuY29udGFjdC50ZW1wR3J1dSA6ICF1YS5jb250YWN0LnB1YkdydXVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSAob3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGlmIChhbm9ueW1vdXMgJiYgdWEuY29uZmlndXJhdGlvbi51cmkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyYW1zLmZyb21EaXNwbGF5TmFtZSA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgICAgICBvcHRpb25zLnBhcmFtcy5mcm9tVXJpID0gXCJzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkXCI7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlAtUHJlZmVycmVkLUlkZW50aXR5OiBcIiArIHVhLmNvbmZpZ3VyYXRpb24udXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJQcml2YWN5OiBpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgY29udGFjdCk7XG4gICAgICAgIC8vIHRoaXMgaXMgVUEuQy5BTExPV0VEX01FVEhPRFMsIHJlbW92ZWQgdG8gZ2V0IGFyb3VuZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgW1xuICAgICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgICAgXCJNRVNTQUdFXCIsXG4gICAgICAgICAgICBcIkJZRVwiLFxuICAgICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgICBcIklORk9cIixcbiAgICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgICBcIlJFRkVSXCJcbiAgICAgICAgXS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZXF1aXJlOiAxMDByZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEKSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcXVpcmU6IHJlcGxhY2VzXCIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gZXh0cmFIZWFkZXJzO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkpIHx8IHRoaXM7XG4gICAgICAgIENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0LmluaXRpYWxpemVyKF90aGlzLCB1YSwgQ29uc3RhbnRzXzEuQy5JTlZJVEUsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuSW52aXRlQ2xpZW50Q29udGV4dDtcbiAgICAgICAgX3RoaXMucGFzc2VkT3B0aW9ucyA9IG9wdGlvbnM7IC8vIFNhdmUgZm9yIGxhdGVyIHRvIHVzZSB3aXRoIHJlZmVyXG4gICAgICAgIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgX3RoaXMubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICAgICAgICBfdGhpcy5pbnZpdGVXaXRob3V0U2RwID0gb3B0aW9ucy5pbnZpdGVXaXRob3V0U2RwIHx8IGZhbHNlO1xuICAgICAgICAvLyBTZXQgYW5vbnltb3VzIHByb3BlcnR5XG4gICAgICAgIF90aGlzLmFub255bW91cyA9IG9wdGlvbnMuYW5vbnltb3VzIHx8IGZhbHNlO1xuICAgICAgICAvLyBDdXN0b20gZGF0YSB0byBiZSBzZW50IGVpdGhlciBpbiBJTlZJVEUgb3IgaW4gQUNLXG4gICAgICAgIF90aGlzLnJlbmRlcmJvZHkgPSBvcHRpb25zLnJlbmRlcmJvZHkgfHwgdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5yZW5kZXJ0eXBlID0gb3B0aW9ucy5yZW5kZXJ0eXBlIHx8IFwidGV4dC9wbGFpblwiO1xuICAgICAgICAvLyBTZXNzaW9uIHBhcmFtZXRlciBpbml0aWFsaXphdGlvblxuICAgICAgICBfdGhpcy5mcm9tVGFnID0gZnJvbVRhZztcbiAgICAgICAgX3RoaXMuY29udGFjdCA9IGNvbnRhY3Q7XG4gICAgICAgIC8vIENoZWNrIFNlc3Npb24gU3RhdHVzXG4gICAgICAgIGlmIChfdGhpcy5zdGF0dXMgIT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfTlVMTCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKF90aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3V0Z29pbmdTZXNzaW9uIHNwZWNpZmljIHBhcmFtZXRlcnNcbiAgICAgICAgX3RoaXMuaXNDYW5jZWxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZWNlaXZlZDEwMCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBDb25zdGFudHNfMS5DLklOVklURTtcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gdWEuZ2V0TG9nZ2VyKFwic2lwLmludml0ZWNsaWVudGNvbnRleHRcIik7XG4gICAgICAgIHVhLmFwcGxpY2FudHNbX3RoaXMudG9TdHJpbmcoKV0gPSBfdGhpcztcbiAgICAgICAgX3RoaXMuaWQgPSBfdGhpcy5yZXF1ZXN0LmNhbGxJZCArIF90aGlzLmZyb21UYWc7XG4gICAgICAgIF90aGlzLm9uSW5mbyA9IG9wdGlvbnMub25JbmZvO1xuICAgICAgICBfdGhpcy5lcnJvckxpc3RlbmVyID0gX3RoaXMub25UcmFuc3BvcnRFcnJvci5iaW5kKF90aGlzKTtcbiAgICAgICAgaWYgKHVhLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdWEudHJhbnNwb3J0Lm9uKFwidHJhbnNwb3J0RXJyb3JcIiwgX3RoaXMuZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZC5cIik7XG4gICAgfTtcbiAgICAvLyBoYWNrIGZvciBnZXR0aW5nIGFyb3VuZCBDbGllbnRDb250ZXh0IGludGVyZmFjZVxuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VuZEludml0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLmludml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gU2F2ZSB0aGUgc2Vzc2lvbiBpbnRvIHRoZSB1YSBzZXNzaW9ucyBjb2xsZWN0aW9uLlxuICAgICAgICAvLyBOb3RlOiBwbGFjaW5nIGluIGNvbnN0cnVjdG9yIGJyZWFrcyBjYWxsIHRvIHJlcXVlc3QuY2FuY2VsIG9uIGNsb3NlLi4uIFVzZXIgZG9lcyBub3QgbmVlZCB0aGlzIGFueXdheVxuICAgICAgICB0aGlzLnVhLnNlc3Npb25zW3RoaXMuaWRdID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYWxsb3cgdGhlIGZ1bmN0aW9uIHRvIHJldHVybiBzbyB0aGF0IGxpc3RlbmVycyBjYW4gYmUgc2V0IHVwIGZvciB0aGVzZSBldmVudHNcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVGhlcmUgaXMgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBjYW5jZWwgKG9yIHRlcm1pbmF0ZSkgY2FuIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyIGludml0ZS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0NhbmNlbGVkIHx8IF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmludml0ZVdpdGhvdXRTZHApIHtcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHNlbmQgYW4gaW52aXRlIHdpdGggbm8gc2RwLi4uXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlbmRlcmJvZHkgJiYgX3RoaXMucmVuZGVydHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0LmJvZHkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBfdGhpcy5yZW5kZXJib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IF90aGlzLnJlbmRlcnR5cGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19JTlZJVEVfU0VOVDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIE1lZGlhIFNlc3Npb25cbiAgICAgICAgICAgICAgICBfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkoX3RoaXMsIF90aGlzLnVhLmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci1jcmVhdGVkXCIsIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuZ2V0RGVzY3JpcHRpb24oX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIF90aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBUaGVyZSBpcyBhIHJhY2UgY29uZGl0aW9uIHdoZXJlIGNhbmNlbCAob3IgdGVybWluYXRlKSBjYW4gYmUgY2FsbGVkIChhKXN5bmNocm9ub3VzbHkgYWZ0ZXIgaW52aXRlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDYW5jZWxlZCB8fCBfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdC5ib2R5ID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfSU5WSVRFX1NFTlQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmQoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coZXJyLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mYWlsZWQodW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5XRUJSVENfRVJST1IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZXJtaW5hdGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gQ2hlY2sgU2Vzc2lvbiBTdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1RFUk1JTkFURUQgfHwgdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuSW52YWxpZFN0YXRlRXJyb3IodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5JbnZhbGlkU3RhdGVFcnJvcihFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NBTkNFTEVEKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJDYW5jZWxpbmcgc2Vzc2lvblwiKTtcbiAgICAgICAgdmFyIGNhbmNlbFJlYXNvbiA9IFV0aWxzXzEuVXRpbHMuZ2V0Q2FuY2VsUmVhc29uKG9wdGlvbnMuc3RhdHVzQ29kZSwgb3B0aW9ucy5yZWFzb25QaHJhc2UpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgaWYgKHRoaXMub3V0Z29pbmdJbnZpdGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQ2FuY2VsaW5nIHNlc3Npb24gYmVmb3JlIGl0IHdhcyBjcmVhdGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5vdXRnb2luZ0ludml0ZVJlcXVlc3QuY2FuY2VsKGNhbmNlbFJlYXNvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsZWQoKTtcbiAgICB9O1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfV0FJVElOR19GT1JfQUNLIHx8IHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0NPTkZJUk1FRCkge1xuICAgICAgICAgICAgdGhpcy5ieWUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDEzLjIuMSBDcmVhdGluZyB0aGUgSW5pdGlhbCBJTlZJVEVcbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZSBpbml0aWFsIElOVklURSByZXByZXNlbnRzIGEgcmVxdWVzdCBvdXRzaWRlIG9mIGEgZGlhbG9nLFxuICAgICAqIGl0cyBjb25zdHJ1Y3Rpb24gZm9sbG93cyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDguMS4xLiAgQWRkaXRpb25hbFxuICAgICAqIHByb2Nlc3NpbmcgaXMgcmVxdWlyZWQgZm9yIHRoZSBzcGVjaWZpYyBjYXNlIG9mIElOVklURS5cbiAgICAgKlxuICAgICAqIEFuIEFsbG93IGhlYWRlciBmaWVsZCAoU2VjdGlvbiAyMC41KSBTSE9VTEQgYmUgcHJlc2VudCBpbiB0aGUgSU5WSVRFLlxuICAgICAqIEl0IGluZGljYXRlcyB3aGF0IG1ldGhvZHMgY2FuIGJlIGludm9rZWQgd2l0aGluIGEgZGlhbG9nLCBvbiB0aGUgVUFcbiAgICAgKiBzZW5kaW5nIHRoZSBJTlZJVEUsIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRpYWxvZy4gIEZvciBleGFtcGxlLCBhXG4gICAgICogVUEgY2FwYWJsZSBvZiByZWNlaXZpbmcgSU5GTyByZXF1ZXN0cyB3aXRoaW4gYSBkaWFsb2cgWzM0XSBTSE9VTERcbiAgICAgKiBpbmNsdWRlIGFuIEFsbG93IGhlYWRlciBmaWVsZCBsaXN0aW5nIHRoZSBJTkZPIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEEgU3VwcG9ydGVkIGhlYWRlciBmaWVsZCAoU2VjdGlvbiAyMC4zNykgU0hPVUxEIGJlIHByZXNlbnQgaW4gdGhlXG4gICAgICogSU5WSVRFLiAgSXQgZW51bWVyYXRlcyBhbGwgdGhlIGV4dGVuc2lvbnMgdW5kZXJzdG9vZCBieSB0aGUgVUFDLlxuICAgICAqXG4gICAgICogQW4gQWNjZXB0IChTZWN0aW9uIDIwLjEpIGhlYWRlciBmaWVsZCBNQVkgYmUgcHJlc2VudCBpbiB0aGUgSU5WSVRFLlxuICAgICAqIEl0IGluZGljYXRlcyB3aGljaCBDb250ZW50LVR5cGVzIGFyZSBhY2NlcHRhYmxlIHRvIHRoZSBVQSwgaW4gYm90aFxuICAgICAqIHRoZSByZXNwb25zZSByZWNlaXZlZCBieSBpdCwgYW5kIGluIGFueSBzdWJzZXF1ZW50IHJlcXVlc3RzIHNlbnQgdG9cbiAgICAgKiBpdCB3aXRoaW4gZGlhbG9ncyBlc3RhYmxpc2hlZCBieSB0aGUgSU5WSVRFLiAgVGhlIEFjY2VwdCBoZWFkZXIgZmllbGRcbiAgICAgKiBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgaW5kaWNhdGluZyBzdXBwb3J0IG9mIHZhcmlvdXMgc2Vzc2lvblxuICAgICAqIGRlc2NyaXB0aW9uIGZvcm1hdHMuXG4gICAgICpcbiAgICAgKiBUaGUgVUFDIE1BWSBhZGQgYW4gRXhwaXJlcyBoZWFkZXIgZmllbGQgKFNlY3Rpb24gMjAuMTkpIHRvIGxpbWl0IHRoZVxuICAgICAqIHZhbGlkaXR5IG9mIHRoZSBpbnZpdGF0aW9uLiAgSWYgdGhlIHRpbWUgaW5kaWNhdGVkIGluIHRoZSBFeHBpcmVzXG4gICAgICogaGVhZGVyIGZpZWxkIGlzIHJlYWNoZWQgYW5kIG5vIGZpbmFsIGFuc3dlciBmb3IgdGhlIElOVklURSBoYXMgYmVlblxuICAgICAqIHJlY2VpdmVkLCB0aGUgVUFDIGNvcmUgU0hPVUxEIGdlbmVyYXRlIGEgQ0FOQ0VMIHJlcXVlc3QgZm9yIHRoZVxuICAgICAqIElOVklURSwgYXMgcGVyIFNlY3Rpb24gOS5cbiAgICAgKlxuICAgICAqIEEgVUFDIE1BWSBhbHNvIGZpbmQgaXQgdXNlZnVsIHRvIGFkZCwgYW1vbmcgb3RoZXJzLCBTdWJqZWN0IChTZWN0aW9uXG4gICAgICogMjAuMzYpLCBPcmdhbml6YXRpb24gKFNlY3Rpb24gMjAuMjUpIGFuZCBVc2VyLUFnZW50IChTZWN0aW9uIDIwLjQxKVxuICAgICAqIGhlYWRlciBmaWVsZHMuICBUaGV5IGFsbCBjb250YWluIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIElOVklURS5cbiAgICAgKlxuICAgICAqIFRoZSBVQUMgTUFZIGNob29zZSB0byBhZGQgYSBtZXNzYWdlIGJvZHkgdG8gdGhlIElOVklURS4gIFNlY3Rpb25cbiAgICAgKiA4LjEuMS4xMCBkZWFscyB3aXRoIGhvdyB0byBjb25zdHJ1Y3QgdGhlIGhlYWRlciBmaWVsZHMgLS0gQ29udGVudC1cbiAgICAgKiBUeXBlIGFtb25nIG90aGVycyAtLSBuZWVkZWQgdG8gZGVzY3JpYmUgdGhlIG1lc3NhZ2UgYm9keS5cbiAgICAgKlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc2VuZEludml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgVGhlcmUgYXJlIHNwZWNpYWwgcnVsZXMgZm9yIG1lc3NhZ2UgYm9kaWVzIHRoYXQgY29udGFpbiBhIHNlc3Npb25cbiAgICAgICAgLy8gICAgZGVzY3JpcHRpb24gLSB0aGVpciBjb3JyZXNwb25kaW5nIENvbnRlbnQtRGlzcG9zaXRpb24gaXMgXCJzZXNzaW9uXCIuXG4gICAgICAgIC8vICAgIFNJUCB1c2VzIGFuIG9mZmVyL2Fuc3dlciBtb2RlbCB3aGVyZSBvbmUgVUEgc2VuZHMgYSBzZXNzaW9uXG4gICAgICAgIC8vICAgIGRlc2NyaXB0aW9uLCBjYWxsZWQgdGhlIG9mZmVyLCB3aGljaCBjb250YWlucyBhIHByb3Bvc2VkIGRlc2NyaXB0aW9uXG4gICAgICAgIC8vICAgIG9mIHRoZSBzZXNzaW9uLiAgVGhlIG9mZmVyIGluZGljYXRlcyB0aGUgZGVzaXJlZCBjb21tdW5pY2F0aW9ucyBtZWFuc1xuICAgICAgICAvLyAgICAoYXVkaW8sIHZpZGVvLCBnYW1lcyksIHBhcmFtZXRlcnMgb2YgdGhvc2UgbWVhbnMgKHN1Y2ggYXMgY29kZWNcbiAgICAgICAgLy8gICAgdHlwZXMpIGFuZCBhZGRyZXNzZXMgZm9yIHJlY2VpdmluZyBtZWRpYSBmcm9tIHRoZSBhbnN3ZXJlci4gIFRoZVxuICAgICAgICAvLyAgICBvdGhlciBVQSByZXNwb25kcyB3aXRoIGFub3RoZXIgc2Vzc2lvbiBkZXNjcmlwdGlvbiwgY2FsbGVkIHRoZVxuICAgICAgICAvLyAgICBhbnN3ZXIsIHdoaWNoIGluZGljYXRlcyB3aGljaCBjb21tdW5pY2F0aW9ucyBtZWFucyBhcmUgYWNjZXB0ZWQsIHRoZVxuICAgICAgICAvLyAgICBwYXJhbWV0ZXJzIHRoYXQgYXBwbHkgdG8gdGhvc2UgbWVhbnMsIGFuZCBhZGRyZXNzZXMgZm9yIHJlY2VpdmluZ1xuICAgICAgICAvLyAgICBtZWRpYSBmcm9tIHRoZSBvZmZlcmVyLiBBbiBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UgaXMgd2l0aGluIHRoZVxuICAgICAgICAvLyAgICBjb250ZXh0IG9mIGEgZGlhbG9nLCBzbyB0aGF0IGlmIGEgU0lQIElOVklURSByZXN1bHRzIGluIG11bHRpcGxlXG4gICAgICAgIC8vICAgIGRpYWxvZ3MsIGVhY2ggaXMgYSBzZXBhcmF0ZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UuICBUaGUgb2ZmZXIvYW5zd2VyXG4gICAgICAgIC8vICAgIG1vZGVsIGRlZmluZXMgcmVzdHJpY3Rpb25zIG9uIHdoZW4gb2ZmZXJzIGFuZCBhbnN3ZXJzIGNhbiBiZSBtYWRlXG4gICAgICAgIC8vICAgIChmb3IgZXhhbXBsZSwgeW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcykuXG4gICAgICAgIC8vICAgIFRoaXMgcmVzdWx0cyBpbiByZXN0cmljdGlvbnMgb24gd2hlcmUgdGhlIG9mZmVycyBhbmQgYW5zd2VycyBjYW5cbiAgICAgICAgLy8gICAgYXBwZWFyIGluIFNJUCBtZXNzYWdlcy4gIEluIHRoaXMgc3BlY2lmaWNhdGlvbiwgb2ZmZXJzIGFuZCBhbnN3ZXJzXG4gICAgICAgIC8vICAgIGNhbiBvbmx5IGFwcGVhciBpbiBJTlZJVEUgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcywgYW5kIEFDSy4gIFRoZSB1c2FnZVxuICAgICAgICAvLyAgICBvZiBvZmZlcnMgYW5kIGFuc3dlcnMgaXMgZnVydGhlciByZXN0cmljdGVkLiAgRm9yIHRoZSBpbml0aWFsIElOVklURVxuICAgICAgICAvLyAgICB0cmFuc2FjdGlvbiwgdGhlIHJ1bGVzIGFyZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgbyAgVGhlIGluaXRpYWwgb2ZmZXIgTVVTVCBiZSBpbiBlaXRoZXIgYW4gSU5WSVRFIG9yLCBpZiBub3QgdGhlcmUsXG4gICAgICAgIC8vICAgICAgICAgIGluIHRoZSBmaXJzdCByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gdGhlIFVBUyBiYWNrIHRvXG4gICAgICAgIC8vICAgICAgICAgIHRoZSBVQUMuICBJbiB0aGlzIHNwZWNpZmljYXRpb24sIHRoYXQgaXMgdGhlIGZpbmFsIDJ4eFxuICAgICAgICAvLyAgICAgICAgICByZXNwb25zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgbyAgSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gYVxuICAgICAgICAvLyAgICAgICAgICByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gVUFTIGJhY2sgdG8gVUFDIHdoaWNoIGlzXG4gICAgICAgIC8vICAgICAgICAgIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAgICAgIC8vICAgICAgICAgIG9ubHkgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURS4gIFRoYXQgc2FtZSBleGFjdFxuICAgICAgICAvLyAgICAgICAgICBhbnN3ZXIgTUFZIGFsc28gYmUgcGxhY2VkIGluIGFueSBwcm92aXNpb25hbCByZXNwb25zZXMgc2VudFxuICAgICAgICAvLyAgICAgICAgICBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAgICAgIC8vICAgICAgICAgIGRlc2NyaXB0aW9uIGl0IHJlY2VpdmVzIGFzIHRoZSBhbnN3ZXIsIGFuZCBNVVNUIGlnbm9yZSBhbnlcbiAgICAgICAgLy8gICAgICAgICAgc2Vzc2lvbiBkZXNjcmlwdGlvbnMgaW4gc3Vic2VxdWVudCByZXNwb25zZXMgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgLy8gICAgICAgICAgSU5WSVRFLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICBvICBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiB0aGUgZmlyc3QgcmVsaWFibGUgbm9uLWZhaWx1cmVcbiAgICAgICAgLy8gICAgICAgICAgbWVzc2FnZSBmcm9tIHRoZSBVQVMgYmFjayB0byBVQUMsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiB0aGVcbiAgICAgICAgLy8gICAgICAgICAgYWNrbm93bGVkZ2VtZW50IGZvciB0aGF0IG1lc3NhZ2UgKGluIHRoaXMgc3BlY2lmaWNhdGlvbiwgQUNLXG4gICAgICAgIC8vICAgICAgICAgIGZvciBhIDJ4eCByZXNwb25zZSkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgIG8gIEFmdGVyIGhhdmluZyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgZmlyc3Qgb2ZmZXIsIHRoZVxuICAgICAgICAvLyAgICAgICAgICBVQUMgTUFZIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIGluIHJlcXVlc3RzIGJhc2VkIG9uIHJ1bGVzXG4gICAgICAgIC8vICAgICAgICAgIHNwZWNpZmllZCBmb3IgdGhhdCBtZXRob2QsIGJ1dCBvbmx5IGlmIGl0IGhhcyByZWNlaXZlZCBhbnN3ZXJzXG4gICAgICAgIC8vICAgICAgICAgIHRvIGFueSBwcmV2aW91cyBvZmZlcnMsIGFuZCBoYXMgbm90IHNlbnQgYW55IG9mZmVycyB0byB3aGljaCBpdFxuICAgICAgICAvLyAgICAgICAgICBoYXNuJ3QgZ290dGVuIGFuIGFuc3dlci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgbyAgT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgICAvLyAgICAgICAgICBvZmZlciwgaXQgTVVTVCBOT1QgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gYW55IHJlc3BvbnNlc1xuICAgICAgICAvLyAgICAgICAgICB0byB0aGUgaW5pdGlhbCBJTlZJVEUuICBUaGlzIG1lYW5zIHRoYXQgYSBVQVMgYmFzZWQgb24gdGhpc1xuICAgICAgICAvLyAgICAgICAgICBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgICAvLyAgICAgICAgICBjb21wbGV0aW9uIG9mIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyA1IFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgYW5kIFBSQUNLXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFJGQyAzMjYxIGRlc2NyaWJlcyBndWlkZWxpbmVzIGZvciB0aGUgc2V0cyBvZiBtZXNzYWdlcyBpbiB3aGljaFxuICAgICAgICAvLyAgICBvZmZlcnMgYW5kIGFuc3dlcnMgWzNdIGNhbiBhcHBlYXIuICBCYXNlZCBvbiB0aG9zZSBndWlkZWxpbmVzLCB0aGlzXG4gICAgICAgIC8vICAgIGV4dGVuc2lvbiBwcm92aWRlcyBhZGRpdGlvbmFsIG9wcG9ydHVuaXRpZXMgZm9yIG9mZmVyL2Fuc3dlclxuICAgICAgICAvLyAgICBleGNoYW5nZXMuXG4gICAgICAgIC8vICAgIElmIHRoZSBJTlZJVEUgY29udGFpbmVkIGFuIG9mZmVyLCB0aGUgVUFTIE1BWSBnZW5lcmF0ZSBhbiBhbnN3ZXIgaW4gYVxuICAgICAgICAvLyAgICByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSAoYXNzdW1pbmcgdGhlc2UgYXJlIHN1cHBvcnRlZCBieSB0aGVcbiAgICAgICAgLy8gICAgVUFDKS4gIFRoYXQgcmVzdWx0cyBpbiB0aGUgZXN0YWJsaXNobWVudCBvZiB0aGUgc2Vzc2lvbiBiZWZvcmVcbiAgICAgICAgLy8gICAgY29tcGxldGlvbiBvZiB0aGUgY2FsbC4gIFNpbWlsYXJseSwgaWYgYSByZWxpYWJsZSBwcm92aXNpb25hbFxuICAgICAgICAvLyAgICByZXNwb25zZSBpcyB0aGUgZmlyc3QgcmVsaWFibGUgbWVzc2FnZSBzZW50IGJhY2sgdG8gdGhlIFVBQywgYW5kIHRoZVxuICAgICAgICAvLyAgICBJTlZJVEUgZGlkIG5vdCBjb250YWluIGFuIG9mZmVyLCBvbmUgTVVTVCBhcHBlYXIgaW4gdGhhdCByZWxpYWJsZVxuICAgICAgICAvLyAgICBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICAgICAgLy8gICAgSWYgdGhlIFVBQyByZWNlaXZlcyBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYW4gb2ZmZXJcbiAgICAgICAgLy8gICAgKHRoaXMgd291bGQgb2NjdXIgaWYgdGhlIFVBQyBzZW50IGFuIElOVklURSB3aXRob3V0IGFuIG9mZmVyLCBpblxuICAgICAgICAvLyAgICB3aGljaCBjYXNlIHRoZSBmaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSB3aWxsIGNvbnRhaW4gdGhlXG4gICAgICAgIC8vICAgIG9mZmVyKSwgaXQgTVVTVCBnZW5lcmF0ZSBhbiBhbnN3ZXIgaW4gdGhlIFBSQUNLLiAgSWYgdGhlIFVBQyByZWNlaXZlc1xuICAgICAgICAvLyAgICBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHdpdGggYW4gYW5zd2VyLCBpdCBNQVkgZ2VuZXJhdGUgYW5cbiAgICAgICAgLy8gICAgYWRkaXRpb25hbCBvZmZlciBpbiB0aGUgUFJBQ0suICBJZiB0aGUgVUFTIHJlY2VpdmVzIGEgUFJBQ0sgd2l0aCBhblxuICAgICAgICAvLyAgICBvZmZlciwgaXQgTVVTVCBwbGFjZSB0aGUgYW5zd2VyIGluIHRoZSAyeHggdG8gdGhlIFBSQUNLLlxuICAgICAgICAvLyAgICBPbmNlIGFuIGFuc3dlciBoYXMgYmVlbiBzZW50IG9yIHJlY2VpdmVkLCB0aGUgVUEgU0hPVUxEIGVzdGFibGlzaCB0aGVcbiAgICAgICAgLy8gICAgc2Vzc2lvbiBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBvZiB0aGUgb2ZmZXIgYW5kIGFuc3dlciwgZXZlbiBpZiB0aGVcbiAgICAgICAgLy8gICAgb3JpZ2luYWwgSU5WSVRFIGl0c2VsZiBoYXMgbm90IGJlZW4gcmVzcG9uZGVkIHRvLlxuICAgICAgICAvLyAgICBJZiB0aGUgVUFTIGhhZCBwbGFjZWQgYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGluIGFueSByZWxpYWJsZVxuICAgICAgICAvLyAgICBwcm92aXNpb25hbCByZXNwb25zZSB0aGF0IGlzIHVuYWNrbm93bGVkZ2VkIHdoZW4gdGhlIElOVklURSBpc1xuICAgICAgICAvLyAgICBhY2NlcHRlZCwgdGhlIFVBUyBNVVNUIGRlbGF5IHNlbmRpbmcgdGhlIDJ4eCB1bnRpbCB0aGUgcHJvdmlzaW9uYWxcbiAgICAgICAgLy8gICAgcmVzcG9uc2UgaXMgYWNrbm93bGVkZ2VkLiAgT3RoZXJ3aXNlLCB0aGUgcmVsaWFiaWxpdHkgb2YgdGhlIDF4eFxuICAgICAgICAvLyAgICBjYW5ub3QgYmUgZ3VhcmFudGVlZCwgYW5kIHJlbGlhYmlsaXR5IGlzIG5lZWRlZCBmb3IgcHJvcGVyIG9wZXJhdGlvblxuICAgICAgICAvLyAgICBvZiB0aGUgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLlxuICAgICAgICAvLyAgICBBbGwgdXNlciBhZ2VudHMgdGhhdCBzdXBwb3J0IHRoaXMgZXh0ZW5zaW9uIE1VU1Qgc3VwcG9ydCBhbGxcbiAgICAgICAgLy8gICAgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlcyB0aGF0IGFyZSBwb3NzaWJsZSBiYXNlZCBvbiB0aGUgcnVsZXMgaW5cbiAgICAgICAgLy8gICAgU2VjdGlvbiAxMy4yIG9mIFJGQyAzMjYxLCBiYXNlZCBvbiB0aGUgZXhpc3RlbmNlIG9mIElOVklURSBhbmQgUFJBQ0tcbiAgICAgICAgLy8gICAgYXMgcmVxdWVzdHMsIGFuZCAyeHggYW5kIHJlbGlhYmxlIDF4eCBhcyBub24tZmFpbHVyZSByZWxpYWJsZVxuICAgICAgICAvLyAgICByZXNwb25zZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYyI3NlY3Rpb24tNVxuICAgICAgICAvLy8vXG4gICAgICAgIC8vIFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgSW1wbGVtZW50YXRpb25cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIG9mZmVyL2Fuc3dlciBtb2RlbCBpcyBzdHJhaWdodCBmb3J3YXJkLCBidXQgb25lIE1VU1QgUkVBRCB0aGUgc3BlY2lmaWNhdGlvbnMuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMTMuMi4xIENyZWF0aW5nIHRoZSBJbml0aWFsIElOVklURSAocGFyYWdyYXBoIDggaW4gcGFydGljdWxhcilcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gNSBUaGUgT2ZmZXIvQW5zd2VyIE1vZGVsIGFuZCBQUkFDS1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2Vzc2lvbiBJbml0aWF0aW9uIFByb3RvY29sIChTSVApIFVzYWdlIG9mIHRoZSBPZmZlci9BbnN3ZXIgTW9kZWxcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzMzdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKioqIElNUE9SVEFOVCBJTVBMRU1FTlRBVElPTiBDSE9JQ0VTICoqKlxuICAgICAgICAvL1xuICAgICAgICAvLyBUTERSLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAxKSBPbmx5IG9uZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UgcGVybWl0dGVkIGR1cmluZyBpbml0aWFsIElOVklURS5cbiAgICAgICAgLy8gIDIpIE5vIFwiZWFybHkgbWVkaWFcIiBpZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEpIEluaXRpYWwgT2ZmZXIvQW5zd2VyIFJlc3RyaWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBPdXIgaW1wbGVtZW50YXRpb24gcmVwbGFjZXMgdGhlIGZvbGxvd2luZyBidWxsZXQgcG9pbnQuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbyAgQWZ0ZXIgaGF2aW5nIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBmaXJzdCBvZmZlciwgdGhlXG4gICAgICAgIC8vICAgIFVBQyBNQVkgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gcmVxdWVzdHMgYmFzZWQgb24gcnVsZXNcbiAgICAgICAgLy8gICAgc3BlY2lmaWVkIGZvciB0aGF0IG1ldGhvZCwgYnV0IG9ubHkgaWYgaXQgaGFzIHJlY2VpdmVkIGFuc3dlcnNcbiAgICAgICAgLy8gICAgdG8gYW55IHByZXZpb3VzIG9mZmVycywgYW5kIGhhcyBub3Qgc2VudCBhbnkgb2ZmZXJzIHRvIHdoaWNoIGl0XG4gICAgICAgIC8vICAgIGhhc24ndCBnb3R0ZW4gYW4gYW5zd2VyLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAvL1xuICAgICAgICAvLyAuLi53aXRoLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG8gIEFmdGVyIGhhdmluZyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgZmlyc3Qgb2ZmZXIsIHRoZVxuICAgICAgICAvLyAgICBVQUMgTVVTVCBOT1QgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gcmVxdWVzdHMgYmFzZWQgb24gcnVsZXNcbiAgICAgICAgLy8gICAgc3BlY2lmaWVkIGZvciB0aGF0IG1ldGhvZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gLi4ud2hpY2ggaW4gY29tYmluYXRpb24gd2l0aCB0aGlzIGJ1bGxldCBwb2ludC4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBvICBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgIC8vICAgIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgIC8vICAgIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgIC8vICAgIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgIC8vICAgIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC4uLmVuc3VyZXMgdGhhdCBFWEFDVExZIE9ORSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2Ugd2lsbCBvY2N1clxuICAgICAgICAvLyBkdXJpbmcgYW4gaW5pdGlhbCBvdXQgb2YgZGlhbG9nIElOVklURSByZXF1ZXN0IG1hZGUgYnkgb3VyIFVBQy5cbiAgICAgICAgLy9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMikgRWFybHkgTWVkaWEgUmVzdHJpY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdoaWxlIG91ciBpbXBsZW1lbnRhdGlvbiBhZGhlcmVzIHRvIHRoZSBmb2xsb3dpbmcgYnVsbGV0IHBvaW50Li4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIG8gIElmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIGFuIElOVklURSwgdGhlIGFuc3dlciBNVVNUIGJlIGluIGFcbiAgICAgICAgLy8gICAgcmVsaWFibGUgbm9uLWZhaWx1cmUgbWVzc2FnZSBmcm9tIFVBUyBiYWNrIHRvIFVBQyB3aGljaCBpc1xuICAgICAgICAvLyAgICBjb3JyZWxhdGVkIHRvIHRoYXQgSU5WSVRFLiAgRm9yIHRoaXMgc3BlY2lmaWNhdGlvbiwgdGhhdCBpc1xuICAgICAgICAvLyAgICBvbmx5IHRoZSBmaW5hbCAyeHggcmVzcG9uc2UgdG8gdGhhdCBJTlZJVEUuICBUaGF0IHNhbWUgZXhhY3RcbiAgICAgICAgLy8gICAgYW5zd2VyIE1BWSBhbHNvIGJlIHBsYWNlZCBpbiBhbnkgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIHNlbnRcbiAgICAgICAgLy8gICAgcHJpb3IgdG8gdGhlIGFuc3dlci4gIFRoZSBVQUMgTVVTVCB0cmVhdCB0aGUgZmlyc3Qgc2Vzc2lvblxuICAgICAgICAvLyAgICBkZXNjcmlwdGlvbiBpdCByZWNlaXZlcyBhcyB0aGUgYW5zd2VyLCBhbmQgTVVTVCBpZ25vcmUgYW55XG4gICAgICAgIC8vICAgIHNlc3Npb24gZGVzY3JpcHRpb25zIGluIHN1YnNlcXVlbnQgcmVzcG9uc2VzIHRvIHRoZSBpbml0aWFsXG4gICAgICAgIC8vICAgIElOVklURS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgaGF2ZSBtYWRlIHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb24gZGVjaXNpb24gd2l0aCByZWdhcmQgdG8gZWFybHkgbWVkaWEuLi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gbyAgSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gdGhlIElOVklURSwgdGhlIGFuc3dlciBmcm9tIHRoZVxuICAgICAgICAvLyAgICBVQVMgYmFjayB0byB0aGUgVUFDIHdpbGwgZXN0YWJsaXNoIGEgbWVkaWEgc2Vzc2lvbiBvbmx5XG4gICAgICAgIC8vICAgIG9ubHkgYWZ0ZXIgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURSBpcyByZWNlaXZlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3IgdGhpcyBkZWNpc2lvbiBpcyByb290ZWQgaW4gYSByZXN0cmljdGlvbiBjdXJyZW50bHlcbiAgICAgICAgLy8gaW5oZXJlbnQgaW4gV2ViUlRDLiBTcGVjaWZpY2FsbHksIHdoaWxlIGEgU0lQIElOVklURSByZXF1ZXN0IHdpdGggYW5cbiAgICAgICAgLy8gaW5pdGlhbCBvZmZlciBtYXkgZm9yayByZXN1bHRpbmcgaW4gbW9yZSB0aGFuIG9uZSBwcm92aXNpb25hbCBhbnN3ZXIsXG4gICAgICAgIC8vIHRoZXJlIGlzIGN1cnJlbnRseSBubyBlYXN5L2dvb2Qgd2F5IHRvIHRvIFwiZm9ya1wiIGFuIG9mZmVyIGdlbmVyYXRlZFxuICAgICAgICAvLyBieSBhIHBlZXIgY29ubmVjdGlvbi4gSW4gcGFydGljdWxhciwgYSBXZWJSVEMgb2ZmZXIgY3VycmVudGx5IG1heSBvbmx5XG4gICAgICAgIC8vIGJlIG1hdGNoZWQgd2l0aCBvbmUgYW5zd2VyIGFuZCB3ZSBoYXZlIG5vIGdvb2Qgd2F5IHRvIGtub3cgd2hpY2hcbiAgICAgICAgLy8gXCJwcm92aXNpb25hbCBhbnN3ZXJcIiBpcyBnb2luZyB0byBiZSB0aGUgXCJmaW5hbCBhbnN3ZXJcIi4gU28gd2UgaGF2ZVxuICAgICAgICAvLyBkZWNpZGVkIHRvIHB1bnQgYW5kIG5vdCBjcmVhdGUgYW55IFwiZWFybHkgbWVkaWFcIiBzZXNzaW9ucyBpbiB0aGlzIGNhc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSB1cHNob3QgaXMgdGhhdCBpZiB5b3Ugd2FudCBcImVhcmx5IG1lZGlhXCIsIHlvdSBtdXN0IG5vdCBwdXQgdGhlXG4gICAgICAgIC8vIGluaXRpYWwgb2ZmZXIgaW4gdGhlIElOVklURS4gSW5zdGVhZCwgZm9yY2UgdGhlIFVBUyB0byBwcm92aWRlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIG9mZmVyIGJ5IHNlbmRpbmcgYW4gSU5WSVRFIHdpdGhvdXQgYW4gb2ZmZXIuIEluIHRoZSBXZWJSVENcbiAgICAgICAgLy8gY2FzZSB0aGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSB1bmlxdWUgcGVlciBjb25uZWN0aW9uIHdpdGggYSB1bmlxdWVcbiAgICAgICAgLy8gYW5zd2VyIGZvciBldmVyeSBwcm92aXNpb25hbCBvZmZlciB3aXRoIFwiZWFybHkgbWVkaWFcIiBvbiBhbGwgb2YgdGhlbS5cbiAgICAgICAgLy8vL1xuICAgICAgICAvLy8vXG4gICAgICAgIC8vIFJPQURNQVA6IFRoZSBPZmZlci9BbnN3ZXIgTW9kZWwgSW1wbGVtZW50YXRpb25cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIFwibm8gZWFybHkgbWVkaWEgaWYgb2ZmZXIgaW4gSU5WSVRFXCIgaW1wbGVtZW50YXRpb24gaXMgbm90IGFcbiAgICAgICAgLy8gd2VsY29tZSBvbmUuIFRoZSBtYXNzZXMgd2FudCBpdC4gVGhlIHdhbnQgaXQgYW5kIHRoZXkgd2FudCBpdFxuICAgICAgICAvLyB0byB3b3JrIGZvciBXZWJSVEMgKHNvIHRoZXkgd2FudCB0byBoYXZlIHRoZWlyIGNha2UgYW5kIGVhdCB0b28pLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTbyB3aGlsZSB3ZSBjdXJyZW50bHkgY2Fubm90IG1ha2UgdGhlIG9mZmVyIGluIElOVklURStmb3JraW5nK3dlYnJ0Y1xuICAgICAgICAvLyBjYXNlIHdvcmssIHdlIGRlY2lkZWQgdG8gZG8gdGhlIGZvbGxvd2luZy4uLlxuICAgICAgICAvL1xuICAgICAgICAvLyAxKSBtb2RpZnkgU0RIIEZhY3RvcnkgdG8gcHJvdmlkZSBhbiBpbml0aWFsIG9mZmVyIHdpdGhvdXQgZ2l2aW5nIHVzIHRoZSBTREgsIGFuZCB0aGVuLi4uXG4gICAgICAgIC8vIDIpIHN0aWNrIHRoYXQgb2ZmZXIgaW4gdGhlIGluaXRpYWwgSU5WSVRFLCBhbmQgd2hlbiAxODMgd2l0aCBpbml0aWFsIGFuc3dlciBpcyByZWNlaXZlZC4uLlxuICAgICAgICAvLyAzKSBhc2sgU0RIIEZhY3RvcnkgaWYgaXQgc3VwcG9ydHMgXCJlYXJseVJlbW90ZUFuc3dlclwiXG4gICAgICAgIC8vICAgYSkgaWYgdHJ1ZSwgYXNrIFNESCBGYWN0b3J5IHRvIGNyZWF0ZVNESChsb2NhbE9mZmVyKS50aGVuKChzZGgpID0+IHNkaC5zZXREZXNjcmlwdGlvbihyZW1vdGVBbnN3ZXIpXG4gICAgICAgIC8vICAgYikgaWYgZmFsc2UsIGRlZmVyIGdldHRpbmcgYSBTREggdW50aWwgMnh4IHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE91ciBzdXBwbGllZCBXZWJSVEMgU0RIIHdpbGwgZGVmYXVsdCB0byBiZWhhdmlvciAzYiB3aGljaCB3b3JrcyBpbiBmb3JraW5nIGVudmlyb25tZW50ICh3aXRob3V0KVxuICAgICAgICAvLyBlYXJseSBtZWRpYSBpZiBpbml0aWFsIG9mZmVyIGlzIGluIHRoZSBJTlZJVEUpLiBXZSB3aWxsLCBob3dldmVyLCBwcm92aWRlIGFuIFwiaW52aXRlV2lsbE5vdEZvcmtcIlxuICAgICAgICAvLyBvcHRpb24gd2hpY2ggaWYgc2V0IHRvIFwidHJ1ZVwiIHdpbGwgaGF2ZSBvdXIgc3VwcGxpZWQgV2ViUlRDIFNESCBiZWhhdmUgaW4gdGhlIDNhIG1hbm5lci5cbiAgICAgICAgLy8gVGhhdCB3aWxsIHJlc3VsdCBpblxuICAgICAgICAvLyAgLSBlYXJseSBtZWRpYSB3b3JraW5nIHdpdGggaW5pdGlhbCBvZmZlciBpbiB0aGUgSU5WSVRFLCBhbmQuLi5cbiAgICAgICAgLy8gIC0gaWYgdGhlIElOVklURSBmb3JrcywgdGhlIHNlc3Npb24gdGVybWluYXRpbmcgd2l0aCBhbiBFUlJPUiB0aGF0IHJlYWRzIGxpa2VcbiAgICAgICAgLy8gICAgXCJZb3Ugc2V0ICdpbnZpdGVXaWxsTm90Rm9yaycgdG8gdHJ1ZSBidXQgdGhlIElOVklURSBmb3JrZWQuIFlvdSBjYW4ndCBlYXQgeW91ciBjYWtlLCBhbmQgaGF2ZSBpdCB0b28uXCJcbiAgICAgICAgLy8gIC0gZnVydGhlcm1vcmUsIHdlIGFjY2VwdCB0aGF0IHVzZXJzIHdpbGwgcmVwb3J0IHRoYXQgZXJyb3IgdG8gdXMgYXMgXCJidWdcIiByZWdhcmRsZXNzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNvLCBTREggRmFjdG9yeSBpcyBnb2luZyB0byBlbmQgdXAgd2l0aCBhIG5ldyBpbnRlcmZhY2UgYWxvbmcgdGhlIGxpbmVzIG9mLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGludGVyZmFjZSBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSB7XG4gICAgICAgIC8vICAgbWFrZUxvY2FsT2ZmZXIoKTogUHJvbWlzZTxDb250ZW50VHlwZUFuZEJvZHk+O1xuICAgICAgICAvLyAgIG1ha2VTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKFxuICAgICAgICAvLyAgICAgaW5pdGlhbE9mZmVyOiBDb250ZW50VHlwZUFuZEJvZHksIG9mZmVyVHlwZTogXCJsb2NhbFwiIHwgXCJyZW1vdGVcIlxuICAgICAgICAvLyAgICk6IFByb21pc2U8U2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcj47XG4gICAgICAgIC8vICAgc3VwcG9ydHNFYXJseVJlbW90ZUFuc3dlcjogYm9vbGVhbjtcbiAgICAgICAgLy8gICBzdXBwb3J0c0NvbnRlbnRUeXBlKGNvbnRlbnRUeXBlOiBzdHJpbmcpOiBib29sZWFuO1xuICAgICAgICAvLyAgIGdldERlc2NyaXB0aW9uKGRlc2NyaXB0aW9uOiBDb250ZW50VHlwZUFuZEJvZHkpOiBQcm9taXNlPENvbnRlbnRUeXBlQW5kQm9keT5cbiAgICAgICAgLy8gICBzZXREZXNjcmlwdGlvbihkZXNjcmlwdGlvbjogQ29udGVudFR5cGVBbmRCb2R5KTogUHJvbWlzZTx2b2lkPlxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgYWxsIHRoZSBoYXNPZmZlci9oYXNBbnN3ZXIgdHJhY2tpbmcgY29kZSBhbmQgb3RoZXJ3aXNlIGNvZGVcbiAgICAgICAgLy8gaXQgdXAgdG8gdGhlIHNhbWUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgU0RIIEZhY3RvcnkgYW5kIFNESCByZWdhcmRsZXNzIG9mIHNpZ25hbGluZyBzY2VuYXJpby5cbiAgICAgICAgLy8vL1xuICAgICAgICAvLyBTZW5kIHRoZSBJTlZJVEUgcmVxdWVzdC5cbiAgICAgICAgdGhpcy5vdXRnb2luZ0ludml0ZVJlcXVlc3QgPSB0aGlzLnVhLnVzZXJBZ2VudENvcmUuaW52aXRlKHRoaXMucmVxdWVzdCwge1xuICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25BY2NlcHQoaW52aXRlUmVzcG9uc2UpOyB9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vblByb2dyZXNzKGludml0ZVJlc3BvbnNlKTsgfSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25SZWRpcmVjdChpbnZpdGVSZXNwb25zZSk7IH0sXG4gICAgICAgICAgICBvblJlamVjdDogZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vblJlamVjdChpbnZpdGVSZXNwb25zZSk7IH0sXG4gICAgICAgICAgICBvblRyeWluZzogZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vblRyeWluZyhpbnZpdGVSZXNwb25zZSk7IH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5hY2tBbmRCeWUgPSBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UsIHNlc3Npb24sIHN0YXR1c0NvZGUsIHJlYXNvblBocmFzZSkge1xuICAgICAgICBpZiAoIXRoaXMudWEudXNlckFnZW50Q29yZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIHJlcXVpcmVzIHVzZXIgYWdlbnQgY29yZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWFzb246IFwiICsgVXRpbHNfMS5VdGlscy5nZXRSZWFzb25IZWFkZXJWYWx1ZShzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0Z29pbmdBY2tSZXF1ZXN0ID0gaW52aXRlUmVzcG9uc2UuYWNrKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImFja1wiLCBvdXRnb2luZ0Fja1JlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgIHZhciBvdXRnb2luZ0J5ZVJlcXVlc3QgPSBzZXNzaW9uLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImJ5ZVwiLCBvdXRnb2luZ0J5ZVJlcXVlc3QubWVzc2FnZSk7XG4gICAgfTtcbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5kaXNwb3NlRWFybHlNZWRpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVhcmx5TWVkaWFTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWFybHkgbWVkaWEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVycyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZmluYWwgcmVzcG9uc2UgdG8gaW5pdGlhbCBJTlZJVEUuXG4gICAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIDJ4eCByZXNwb25zZS5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRDb250ZXh0LnByb3RvdHlwZS5vbkFjY2VwdCA9IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYXJseSBtZWRpYSBzZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXJzIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gaW52aXRlUmVzcG9uc2UubWVzc2FnZTtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBpbnZpdGVSZXNwb25zZS5zZXNzaW9uO1xuICAgICAgICAvLyBPdXIgdHJhbnNhY3Rpb24gbGF5ZXIgaXMgXCJub24tc3RhbmRhcmRcIiBpbiB0aGF0IGl0IHdpbGwgb25seVxuICAgICAgICAvLyBwYXNzIHVzIGEgMnh4IHJlc3BvbnNlIG9uY2UgcGVyIGJyYW5jaCwgc28gdGhlcmUgaXMgbm8gbmVlZCB0b1xuICAgICAgICAvLyB3b3JyeSBhYm91dCBkZWFsaW5nIHdpdGggMnh4IHJldHJhbnNtaXNzaW9ucy4gSG93ZXZlciwgd2UgY2FuXG4gICAgICAgIC8vIGFuZCBkbyBzdGlsbCBnZXQgMnh4IHJlc3BvbnNlcyBmb3IgbXVsdGlwbGUgYnJhbmNoZXMgKHdoZW4gYW5cbiAgICAgICAgLy8gSU5WSVRFIGlzIGZvcmtlZCkgd2hpY2ggbWF5IGNyZWF0ZSBtdWx0aXBsZSBjb25maXJtZWQgZGlhbG9ncy5cbiAgICAgICAgLy8gSGVyZWluIHdlIGFyZSBhY2tpbmcgYW5kIHNlbmRpbmcgYSBieWUgdG8gYW55IGNvbmZpcm1lZCBkaWFsb2dzXG4gICAgICAgIC8vIHdoaWNoIGFycml2ZSBiZXlvbmQgdGhlIGZpcnN0IG9uZS4gVGhpcyBpcyB0aGUgZGVzaXJlZCBiZWhhdmlvclxuICAgICAgICAvLyBmb3IgbW9zdCBhcHBsaWNhdGlvbnMgKGJ1dCBjZXJ0YWlubHkgbm90IGFsbCkuXG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgcmVjZWl2ZWQgYSBjb25maXJtZWQgZGlhbG9nLCBhY2sgJiBieWUgdGhpcyBzZXNzaW9uLlxuICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgcmVxdWVzdGVkIGNhbmNlbGxhdGlvbiwgYWNrICYgYnllIHRoaXMgc2Vzc2lvbi5cbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tBbmRCeWUoaW52aXRlUmVzcG9uc2UsIHNlc3Npb24pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiYnllXCIsIHRoaXMucmVxdWVzdCk7IC8vIEZJWE1FOiBQb3J0ZWQgdGhpcyBvZGQgc2Vjb25kIFwiYnllXCIgZW1pdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcnRlZCBiZWhhdmlvci5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhhc0hlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIikpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0ZWRJZGVudGl0eSA9IGNvcmVfMS5HcmFtbWFyLm5hbWVBZGRySGVhZGVyUGFyc2UocmVzcG9uc2UuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBhIGNvbmZpcm1lZCBkaWFsb2cuXG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgIG9uQWNrOiBmdW5jdGlvbiAoYWNrUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMub25BY2soYWNrUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICBvbkJ5ZTogZnVuY3Rpb24gKGJ5ZVJlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KGJ5ZVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgb25JbmZvOiBmdW5jdGlvbiAoaW5mb1JlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KGluZm9SZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgIG9uSW52aXRlOiBmdW5jdGlvbiAoaW52aXRlUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QoaW52aXRlUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlUmVxdWVzdCkgeyByZXR1cm4gX3RoaXMucmVjZWl2ZVJlcXVlc3QobWVzc2FnZVJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgb25Ob3RpZnk6IGZ1bmN0aW9uIChub3RpZnlSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChub3RpZnlSZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgIG9uUHJhY2s6IGZ1bmN0aW9uIChwcmFja1JlcXVlc3QpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXF1ZXN0KHByYWNrUmVxdWVzdCk7IH0sXG4gICAgICAgICAgICBvblJlZmVyOiBmdW5jdGlvbiAocmVmZXJSZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5yZWNlaXZlUmVxdWVzdChyZWZlclJlcXVlc3QpOyB9LFxuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKHNlc3Npb24uc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgLy8gSU5WSVRFIHdpdGhvdXQgT2ZmZXIsIHNvIE1VU1QgaGF2ZSBPZmZlciBhdCB0aGlzIHBvaW50LCBzbyBpbnZhbGlkIHN0YXRlLlxuICAgICAgICAgICAgICAgIHRoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uLCA0MDAsIFwiTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBDb25zdGFudHNfMS5DLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgICAgICAgLy8gSU5WSVRFIHdpdGggT2ZmZXIsIHNvIE1VU1QgaGF2ZSBBbnN3ZXIgYXQgdGhpcyBwb2ludCwgc28gaW52YWxpZCBzdGF0ZS5cbiAgICAgICAgICAgICAgICB0aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbiwgNDAwLCBcIk1pc3Npbmcgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICAgICAgICAvLyBJTlZJVEUgd2l0aG91dCBPZmZlciwgcmVjZWl2ZWQgb2ZmZXIgaW4gMnh4LCBzbyBNVVNUIHNlbmQgQW5zd2VyIGluIEFDSy5cbiAgICAgICAgICAgICAgICB2YXIgc2RoXzEgPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KHRoaXMsIHRoaXMudWEuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IHNkaF8xO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXItY3JlYXRlZFwiLCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGlmICghc2RoXzEuaGFzRGVzY3JpcHRpb24ocmVzcG9uc2UuZ2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIpIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrQW5kQnllKGludml0ZVJlc3BvbnNlLCBzZXNzaW9uLCA0MDAsIFwiTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFzT2ZmZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNkaF8xXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2RoXzEuZ2V0RGVzY3JpcHRpb24oX3RoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsIF90aGlzLm1vZGlmaWVycyk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDYW5jZWxlZCB8fCBfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogXCJzZXNzaW9uXCIsIGNvbnRlbnRUeXBlOiBkZXNjcmlwdGlvbi5jb250ZW50VHlwZSwgY29udGVudDogZGVzY3JpcHRpb24uYm9keVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNrUmVxdWVzdCA9IGludml0ZVJlc3BvbnNlLmFjayh7IGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJhY2tcIiwgYWNrUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJpbnZhbGlkIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbWVzc2FnZSBpcyBpbmNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbiwgNDg4LCBcIkludmFsaWQgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZChyZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuQkFEX01FRElBX0RFU0NSSVBUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNlc3Npb24gaGFzIGNvbXBsZXRlZCBhbiBpbml0aWFsIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4uLlxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zXzE7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyYm9keSAmJiB0aGlzLnJlbmRlcnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc18xID0geyBib2R5OiB7IGNvbnRlbnREaXNwb3NpdGlvbjogXCJyZW5kZXJcIiwgY29udGVudFR5cGU6IHRoaXMucmVuZGVydHlwZSwgY29udGVudDogdGhpcy5yZW5kZXJib2R5IH0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgSU5WSVRFIHdpdGggT2ZmZXIgYW5kIHdlIGhhdmUgYmVlbiB3YWl0aW5nIHRpbGwgbm93IHRvIGFwcGx5IHRoZSBhbnN3ZXIuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT2ZmZXIgJiYgIXRoaXMuaGFzQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyID0gc2Vzc2lvbi5hbnN3ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbnN3ZXIgaXMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihhbnN3ZXIuY29udGVudCwgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgdGhpcy5tb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWNrUmVxdWVzdCA9IGludml0ZVJlc3BvbnNlLmFjayhvcHRpb25zXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFja1wiLCBhY2tSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjZXB0ZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFja0FuZEJ5ZShpbnZpdGVSZXNwb25zZSwgc2Vzc2lvbiwgNDg4LCBcIk5vdCBBY2NlcHRhYmxlIEhlcmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5mYWlsZWQocmVzcG9uc2UsIENvbnN0YW50c18xLkMuY2F1c2VzLkJBRF9NRURJQV9ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSU1FOiBET04nVCBFQVQgVU5IQU5ETEVEIEVSUk9SUyFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgSU5WSVRFIHdpdGggb3Igd2l0aG91dCBPZmZlciBhbmQgd2UgaGF2ZSBhbHJlYWR5IGNvbXBsZXRlZCB0aGUgaW5pdGlhbCBleGNoYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuZ2V0KHNlc3Npb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMuZGVsZXRlKHNlc3Npb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc09mZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNBbnN3ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfQ09ORklSTUVEO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWNrUmVxdWVzdCA9IGludml0ZVJlc3BvbnNlLmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJhY2tcIiwgYWNrUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2NlcHRlZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgIC8vIERpYWxvZyBoYXMgdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZXNzaW9uIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlRWFybHlNZWRpYSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgICAqIEBwYXJhbSBpbnZpdGVSZXNwb25zZSAxeHggcmVzcG9uc2UuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUub25Qcm9ncmVzcyA9IGZ1bmN0aW9uIChpbnZpdGVSZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBQb3J0ZWQgLSBVc2VyIHJlcXVlc3RlZCBjYW5jZWxsYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3V0Z29pbmdJbnZpdGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXRnb2luZyBJTlZJVEUgcmVxdWVzdCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5lYXJseU1lZGlhU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVhcmx5IG1lZGlhIHNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlcnMgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSBpbnZpdGVSZXNwb25zZS5tZXNzYWdlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGludml0ZVJlc3BvbnNlLnNlc3Npb247XG4gICAgICAgIC8vIFBvcnRlZCAtIFNldCBzdGF0dXMuXG4gICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU18xWFhfUkVDRUlWRUQ7XG4gICAgICAgIC8vIFBvcnRlZCAtIFNldCBhc3NlcnRlZElkZW50aXR5LlxuICAgICAgICBpZiAocmVzcG9uc2UuaGFzSGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRlZElkZW50aXR5ID0gY29yZV8xLkdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShyZXNwb25zZS5nZXRIZWFkZXIoXCJQLUFzc2VydGVkLUlkZW50aXR5XCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTVVTVCBlc3RhYmxpc2ggYSBkaWFsb2cgaWYgb25lIGlzIG5vdCB5ZXQgY3JlYXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi00XG4gICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgLy8gQSByZXNwb25zZSB3aXRoIGEgdG8gdGFnIE1VU1QgY3JlYXRlIGEgc2Vzc2lvbiAoc2hvdWxkIG5ldmVyIGdldCBoZXJlKS5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlc3Npb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZvciBhbiBpbml0aWFsIHJlcXVlc3QsIGFuZFxuICAgICAgICAvLyB0aGF0IHJlc3BvbnNlIGNvbnRhaW5zIGEgUmVxdWlyZSBoZWFkZXIgZmllbGQgY29udGFpbmluZyB0aGUgb3B0aW9uXG4gICAgICAgIC8vIHRhZyAxMDByZWwsIHRoZSByZXNwb25zZSBpcyB0byBiZSBzZW50IHJlbGlhYmx5LiAgSWYgdGhlIHJlc3BvbnNlIGlzXG4gICAgICAgIC8vIGEgMTAwIChUcnlpbmcpIChhcyBvcHBvc2VkIHRvIDEwMSB0byAxOTkpLCB0aGlzIG9wdGlvbiB0YWcgTVVTVCBiZVxuICAgICAgICAvLyBpZ25vcmVkLCBhbmQgdGhlIHByb2NlZHVyZXMgYmVsb3cgTVVTVCBOT1QgYmUgdXNlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi00XG4gICAgICAgIHZhciByZXF1aXJlSGVhZGVyID0gcmVzcG9uc2UuZ2V0SGVhZGVyKFwicmVxdWlyZVwiKTtcbiAgICAgICAgdmFyIHJzZXFIZWFkZXIgPSByZXNwb25zZS5nZXRIZWFkZXIoXCJyc2VxXCIpO1xuICAgICAgICB2YXIgcnNlcSA9IHJlcXVpcmVIZWFkZXIgJiYgcmVxdWlyZUhlYWRlci5pbmNsdWRlcyhcIjEwMHJlbFwiKSAmJiByc2VxSGVhZGVyID8gTnVtYmVyKHJzZXFIZWFkZXIpIDogdW5kZWZpbmVkO1xuICAgICAgICB2YXIgcmVzcG9uc2VSZWxpYWJsZSA9ICEhcnNlcTtcbiAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtdO1xuICAgICAgICBpZiAocmVzcG9uc2VSZWxpYWJsZSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSQWNrOiBcIiArIHJlc3BvbnNlLmdldEhlYWRlcihcInJzZXFcIikgKyBcIiBcIiArIHJlc3BvbnNlLmdldEhlYWRlcihcImNzZXFcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElOVklURSB3aXRob3V0IE9mZmVyIGFuZCBzZXNzaW9uIHN0aWxsIGhhcyBubyBvZmZlciAoYW5kIG5vIGFuc3dlcikuXG4gICAgICAgIGlmIChzZXNzaW9uLnNpZ25hbGluZ1N0YXRlID09PSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbCkge1xuICAgICAgICAgICAgLy8gU2ltaWxhcmx5LCBpZiBhIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgICAgICAvLyByZXNwb25zZSBpcyB0aGUgZmlyc3QgcmVsaWFibGUgbWVzc2FnZSBzZW50IGJhY2sgdG8gdGhlIFVBQywgYW5kIHRoZVxuICAgICAgICAgICAgLy8gSU5WSVRFIGRpZCBub3QgY29udGFpbiBhbiBvZmZlciwgb25lIE1VU1QgYXBwZWFyIGluIHRoYXQgcmVsaWFibGVcbiAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjIjc2VjdGlvbi01XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VSZWxpYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJGaXJzdCByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSByZWNlaXZlZCBNVVNUIGNvbnRhaW4gYW4gb2ZmZXIgd2hlbiBJTlZJVEUgZG9lcyBub3QgY29udGFpbiBhbiBvZmZlci5cIik7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEtub3duIHBvcHVsYXIgVUEncyBjdXJyZW50bHkgZW5kIHVwIGhlcmUuLi5cbiAgICAgICAgICAgICAgICBpbnZpdGVSZXNwb25zZS5wcmFjayh7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElOVklURSB3aXRoIE9mZmVyIGFuZCBzZXNzaW9uIG9ubHkgaGFzIHRoYXQgaW5pdGlhbCBsb2NhbCBvZmZlci5cbiAgICAgICAgaWYgKHNlc3Npb24uc2lnbmFsaW5nU3RhdGUgPT09IGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcikge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUmVsaWFibGUpIHtcbiAgICAgICAgICAgICAgICBpbnZpdGVSZXNwb25zZS5wcmFjayh7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElOVklURSB3aXRob3V0IE9mZmVyIGFuZCByZWNlaXZlZCBpbml0aWFsIG9mZmVyIGluIHByb3Zpc2lvbmFsIHJlc3BvbnNlXG4gICAgICAgIGlmIChzZXNzaW9uLnNpZ25hbGluZ1N0YXRlID09PSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyKSB7XG4gICAgICAgICAgICAvLyBUaGUgaW5pdGlhbCBvZmZlciBNVVNUIGJlIGluIGVpdGhlciBhbiBJTlZJVEUgb3IsIGlmIG5vdCB0aGVyZSxcbiAgICAgICAgICAgIC8vIGluIHRoZSBmaXJzdCByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gdGhlIFVBUyBiYWNrIHRvXG4gICAgICAgICAgICAvLyB0aGUgVUFDLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBTZWN0aW9uIDEzLjIuMSBvZiBbUkZDMzI2MV0sICdUaGUgZmlyc3QgcmVsaWFibGVcbiAgICAgICAgICAgIC8vIG5vbi1mYWlsdXJlIG1lc3NhZ2UnIG11c3QgaGF2ZSBhbiBvZmZlciBpZiB0aGVyZSBpcyBubyBvZmZlciBpbiB0aGVcbiAgICAgICAgICAgIC8vIElOVklURSByZXF1ZXN0LiAgVGhpcyBtZWFucyB0aGF0IHRoZSBVc2VyIEFnZW50IChVQSkgdGhhdCByZWNlaXZlc1xuICAgICAgICAgICAgLy8gdGhlIElOVklURSByZXF1ZXN0IHdpdGhvdXQgYW4gb2ZmZXIgbXVzdCBpbmNsdWRlIGFuIG9mZmVyIGluIHRoZVxuICAgICAgICAgICAgLy8gZmlyc3QgcmVsaWFibGUgcmVzcG9uc2Ugd2l0aCAxMDByZWwgZXh0ZW5zaW9uLiAgSWYgbm8gcmVsaWFibGVcbiAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGhhcyBiZWVuIHNlbnQsIHRoZSBVc2VyIEFnZW50IFNlcnZlciAoVUFTKSBtdXN0XG4gICAgICAgICAgICAvLyBpbmNsdWRlIGFuIG9mZmVyIHdoZW4gc2VuZGluZyAyeHggcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjMzNyNzZWN0aW9uLTIuMlxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVJlbGlhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vbi1yZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZSBNVVNUIE5PVCBjb250YWluIGFuIGluaXRpYWwgb2ZmZXIsIGRpc2NhcmRpbmcgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIG9mZmVyIGlzIGluIHRoZSBmaXJzdCByZWxpYWJsZSBub24tZmFpbHVyZVxuICAgICAgICAgICAgLy8gbWVzc2FnZSBmcm9tIHRoZSBVQVMgYmFjayB0byBVQUMsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiB0aGVcbiAgICAgICAgICAgIC8vIGFja25vd2xlZGdlbWVudCBmb3IgdGhhdCBtZXNzYWdlXG4gICAgICAgICAgICB2YXIgc2RoXzIgPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KHRoaXMsIHRoaXMudWEuY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMgfHwge30pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci1jcmVhdGVkXCIsIHNkaF8yKTtcbiAgICAgICAgICAgIHRoaXMuZWFybHlNZWRpYVNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJzLnNldChzZXNzaW9uLmlkLCBzZGhfMik7XG4gICAgICAgICAgICBzZGhfMlxuICAgICAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBzZGhfMi5nZXREZXNjcmlwdGlvbihfdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucywgX3RoaXMubW9kaWZpZXJzKTsgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBcInNlc3Npb25cIiwgY29udGVudFR5cGU6IGRlc2NyaXB0aW9uLmNvbnRlbnRUeXBlLCBjb250ZW50OiBkZXNjcmlwdGlvbi5ib2R5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpbnZpdGVSZXNwb25zZS5wcmFjayh7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzLCBib2R5OiBib2R5IH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcInByb2dyZXNzXCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfVEVSTUlOQVRFRCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmZhaWxlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIHNlc3Npb24gaGFzIGNvbXBsZXRlZCBhbiBpbml0aWFsIG9mZmVyL2Fuc3dlciBleGNoYW5nZSwgc28uLi5cbiAgICAgICAgLy8gLSBJTlZJVEUgd2l0aCBTRFAgYW5kIHRoaXMgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTUFZIGJlIHJlbGlhYmxlXG4gICAgICAgIC8vIC0gSU5WSVRFIHdpdGhvdXQgU0RQIGFuZCB0aGlzIHByb3Zpc2lvbmFsIHJlc3BvbnNlIE1BWSBiZSByZWxpYWJsZVxuICAgICAgICBpZiAoc2Vzc2lvbi5zaWduYWxpbmdTdGF0ZSA9PT0gY29yZV8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlUmVsaWFibGUpIHtcbiAgICAgICAgICAgICAgICBpbnZpdGVSZXNwb25zZS5wcmFjayh7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogQXMgZG9jdW1lbnRlZCwgbm8gZWFybHkgbWVkaWEgaWYgb2ZmZXIgd2FzIGluIElOVklURSwgc28gbm90aGluZyB0byBiZSBkb25lLlxuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IEFkZCBhIGZsYWcvaGFjayB0byBhbGxvdyBlYXJseSBtZWRpYSBpbiB0aGlzIGNhc2UuIFRoZXJlIGFyZSBwZW9wbGVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICBpbiBub24tZm9ya2luZyBlbnZpcm9ubWVudHMgKHRoaW5rIHN0cmFpZ2h0IHRvIEZyZWVTV0lUQ0gpIHdobyB3YW50XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgZWFybHkgbWVkaWEgb24gYSAxODMuIE5vdCBzdXJlIGhvdyB0byBhY3R1YWxseSBtYWtlIGl0IHdvcmssIGJhc2ljYWxseVxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgIHNvbWV0aGluZyBsaWtlLi4uXG4gICAgICAgICAgICBpZiAoMCAvKiBmbGFnICovICYmIHRoaXMuaGFzT2ZmZXIgJiYgIXRoaXMuaGFzQW5zd2VyICYmIHRoaXMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzQW5zd2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cy5TVEFUVVNfRUFSTFlfTUVESUE7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgIC5zZXREZXNjcmlwdGlvbihyZXNwb25zZS5ib2R5LCB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLCB0aGlzLm1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX0VBUkxZX01FRElBO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmFpbGVkKHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuV0VCUlRDX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVybWluYXRlZCh1bmRlZmluZWQsIENvbnN0YW50c18xLkMuY2F1c2VzLldFQlJUQ19FUlJPUik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmaW5hbCByZXNwb25zZSB0byBpbml0aWFsIElOVklURS5cbiAgICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgM3h4IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLm9uUmVkaXJlY3QgPSBmdW5jdGlvbiAoaW52aXRlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlRWFybHlNZWRpYSgpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBpbnZpdGVSZXNwb25zZS5tZXNzYWdlO1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuc2lwRXJyb3JDYXVzZShzdGF0dXNDb2RlIHx8IDApO1xuICAgICAgICB0aGlzLnJlamVjdGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMuZmFpbGVkKHJlc3BvbnNlLCBjYXVzZSk7XG4gICAgICAgIHRoaXMudGVybWluYXRlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGZpbmFsIHJlc3BvbnNlIHRvIGluaXRpYWwgSU5WSVRFLlxuICAgICAqIEBwYXJhbSBpbnZpdGVSZXNwb25zZSA0eHgsIDV4eCwgb3IgNnh4IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLm9uUmVqZWN0ID0gZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUVhcmx5TWVkaWEoKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gaW52aXRlUmVzcG9uc2UubWVzc2FnZTtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICB2YXIgY2F1c2UgPSBVdGlsc18xLlV0aWxzLnNpcEVycm9yQ2F1c2Uoc3RhdHVzQ29kZSB8fCAwKTtcbiAgICAgICAgdGhpcy5yZWplY3RlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLmZhaWxlZChyZXNwb25zZSwgY2F1c2UpO1xuICAgICAgICB0aGlzLnRlcm1pbmF0ZWQocmVzcG9uc2UsIGNhdXNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBmaW5hbCByZXNwb25zZSB0byBpbml0aWFsIElOVklURS5cbiAgICAgKiBAcGFyYW0gaW52aXRlUmVzcG9uc2UgMTAwIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudENvbnRleHQucHJvdG90eXBlLm9uVHJ5aW5nID0gZnVuY3Rpb24gKGludml0ZVJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQxMDAgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJwcm9ncmVzc1wiLCBpbnZpdGVSZXNwb25zZS5tZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBJbnZpdGVDbGllbnRDb250ZXh0O1xufShTZXNzaW9uKSk7XG5leHBvcnRzLkludml0ZUNsaWVudENvbnRleHQgPSBJbnZpdGVDbGllbnRDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vQ29uc3RhbnRzXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbnNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9VdGlsc1wiKTtcbnZhciBEVE1GVmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi9EVE1GVmFsaWRhdG9yXCIpO1xuLyoqXG4gKiBAY2xhc3MgRFRNRlxuICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICovXG52YXIgRFRNRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEVE1GLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERUTUYoc2Vzc2lvbiwgdG9uZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5DID0ge1xuICAgICAgICAgICAgTUlOX0RVUkFUSU9OOiA3MCxcbiAgICAgICAgICAgIE1BWF9EVVJBVElPTjogNjAwMCxcbiAgICAgICAgICAgIERFRkFVTFRfRFVSQVRJT046IDEwMCxcbiAgICAgICAgICAgIE1JTl9JTlRFUl9UT05FX0dBUDogNTAsXG4gICAgICAgICAgICBERUZBVUxUX0lOVEVSX1RPTkVfR0FQOiA1MDBcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuRFRNRjtcbiAgICAgICAgaWYgKHRvbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IHNlc3Npb24udWEuZ2V0TG9nZ2VyKFwic2lwLmludml0ZWNvbnRleHQuZHRtZlwiLCBzZXNzaW9uLmlkKTtcbiAgICAgICAgX3RoaXMub3duZXIgPSBzZXNzaW9uO1xuICAgICAgICB2YXIgbW9yZVRoYW5PbmVUb25lID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHRvbmUgaXMgaW52YWxpZCwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgdG9uZSBpbiB0aGUgY29ycmVjdCBmb3JtYXQuXG4gICAgICAgIF90aGlzLnRvbmUgPSBEVE1GVmFsaWRhdG9yXzEuRFRNRlZhbGlkYXRvci52YWxpZGF0ZSh0b25lLCBtb3JlVGhhbk9uZVRvbmUpO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICB2YXIgaW50ZXJUb25lR2FwID0gb3B0aW9ucy5pbnRlclRvbmVHYXA7XG4gICAgICAgIC8vIENoZWNrIGR1cmF0aW9uXG4gICAgICAgIGlmIChkdXJhdGlvbiAmJiAhVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB0b25lIGR1cmF0aW9uOiBcIiArIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMuQy5ERUZBVUxUX0RVUkFUSU9OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR1cmF0aW9uIDwgX3RoaXMuQy5NSU5fRFVSQVRJT04pIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiJ2R1cmF0aW9uJyB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBtaW5pbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gXCIgK1xuICAgICAgICAgICAgICAgIF90aGlzLkMuTUlOX0RVUkFUSU9OICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfdGhpcy5DLk1JTl9EVVJBVElPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkdXJhdGlvbiA+IF90aGlzLkMuTUFYX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIidkdXJhdGlvbicgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQsIHNldHRpbmcgaXQgdG8gXCIgK1xuICAgICAgICAgICAgICAgIF90aGlzLkMuTUFYX0RVUkFUSU9OICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfdGhpcy5DLk1BWF9EVVJBVElPTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gTWF0aC5hYnMoZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIC8vIENoZWNrIGludGVyVG9uZUdhcFxuICAgICAgICBpZiAoaW50ZXJUb25lR2FwICYmICFVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChpbnRlclRvbmVHYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBpbnRlclRvbmVHYXA6IFwiICsgaW50ZXJUb25lR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW50ZXJUb25lR2FwKSB7XG4gICAgICAgICAgICBpbnRlclRvbmVHYXAgPSBfdGhpcy5DLkRFRkFVTFRfSU5URVJfVE9ORV9HQVA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW50ZXJUb25lR2FwIDwgX3RoaXMuQy5NSU5fSU5URVJfVE9ORV9HQVApIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci53YXJuKFwiJ2ludGVyVG9uZUdhcCcgdmFsdWUgaXMgbG93ZXIgdGhhbiB0aGUgbWluaW11bSBhbGxvd2VkLCBzZXR0aW5nIGl0IHRvIFwiICtcbiAgICAgICAgICAgICAgICBfdGhpcy5DLk1JTl9JTlRFUl9UT05FX0dBUCArIFwiIG1pbGxpc2Vjb25kc1wiKTtcbiAgICAgICAgICAgIGludGVyVG9uZUdhcCA9IF90aGlzLkMuTUlOX0lOVEVSX1RPTkVfR0FQO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJUb25lR2FwID0gTWF0aC5hYnMoaW50ZXJUb25lR2FwKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pbnRlclRvbmVHYXAgPSBpbnRlclRvbmVHYXA7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRFRNRi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIC8vIENoZWNrIFJUQ1Nlc3Npb24gU3RhdHVzXG4gICAgICAgIGlmICh0aGlzLm93bmVyLnN0YXR1cyAhPT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19DT05GSVJNRUQgJiZcbiAgICAgICAgICAgIHRoaXMub3duZXIuc3RhdHVzICE9PSBFbnVtc18xLlNlc3Npb25TdGF0dXMuU1RBVFVTX1dBSVRJTkdfRk9SX0FDSykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkludmFsaWRTdGF0ZUVycm9yKHRoaXMub3duZXIuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgRFRNRiBvcHRpb25zXG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyA/IG9wdGlvbnMuZXh0cmFIZWFkZXJzLnNsaWNlKCkgOiBbXTtcbiAgICAgICAgdmFyIGJvZHkgPSB7XG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9kdG1mLXJlbGF5XCIsXG4gICAgICAgICAgICBib2R5OiBcIlNpZ25hbD0gXCIgKyB0aGlzLnRvbmUgKyBcIlxcclxcbkR1cmF0aW9uPSBcIiArIHRoaXMuZHVyYXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3duZXIuc2Vzc2lvbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLm93bmVyLnNlc3Npb24uaW5mbyh1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBVdGlsc18xLlV0aWxzLmZyb21Cb2R5T2JqKGJvZHkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMub3duZXIuZW1pdChcImR0bWZcIiwgcmVxdWVzdC5tZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRFRNRi5wcm90b3R5cGUuaW5pdF9pbmNvbWluZyA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIGlmICghdGhpcy50b25lIHx8ICF0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiaW52YWxpZCBJTkZPIERUTUYgcmVjZWl2ZWQsIGRpc2NhcmRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIuZW1pdChcImR0bWZcIiwgcmVxdWVzdC5tZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRFRNRi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2UgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA/IHJlc3BvbnNlLnN0YXR1c0NvZGUgOiAwO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUudG9TdHJpbmcoKSk6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwic3VjY2VlZGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYXRvcjogXCJyZW1vdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuc2lwRXJyb3JDYXVzZShzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgRFRNRi5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZmFpbGVkXCIsIHVuZGVmaW5lZCwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuUkVRVUVTVF9USU1FT1VUKTtcbiAgICAgICAgdGhpcy5vd25lci5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBEVE1GLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJmYWlsZWRcIiwgdW5kZWZpbmVkLCBDb25zdGFudHNfMS5DLmNhdXNlcy5DT05ORUNUSU9OX0VSUk9SKTtcbiAgICAgICAgdGhpcy5vd25lci5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgfTtcbiAgICBEVE1GLnByb3RvdHlwZS5vbkRpYWxvZ0Vycm9yID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZSwgQ29uc3RhbnRzXzEuQy5jYXVzZXMuRElBTE9HX0VSUk9SKTtcbiAgICAgICAgdGhpcy5vd25lci5vbkRpYWxvZ0Vycm9yKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHJldHVybiBEVE1GO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuRFRNRiA9IERUTUY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEVE1GVmFsaWRhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERUTUZWYWxpZGF0b3IoKSB7XG4gICAgfVxuICAgIERUTUZWYWxpZGF0b3IudmFsaWRhdGUgPSBmdW5jdGlvbiAodG9uZSwgbW9yZVRoYW5PbmVUb25lKSB7XG4gICAgICAgIGlmIChtb3JlVGhhbk9uZVRvbmUgPT09IHZvaWQgMCkgeyBtb3JlVGhhbk9uZVRvbmUgPSB0cnVlOyB9XG4gICAgICAgIC8vIENoZWNrIHRvbmUgdHlwZVxuICAgICAgICBpZiAodHlwZW9mIHRvbmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRvbmUgPSB0b25lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRvbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRvbmUgPSB0b25lLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBEVE1GVmFsaWRhdG9yLmdlbmVyYXRlSW52YWxpZFRvbmVFcnJvcih0b25lKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnZXggPSBtb3JlVGhhbk9uZVRvbmUgPyAvXlswLTlBLUQjKixdKyQvaSA6IC9eWzAtOUEtRCMqXSQvaTtcbiAgICAgICAgLy8gQ2hlY2sgdG9uZSB2YWx1ZVxuICAgICAgICBpZiAoIXRvbmUubWF0Y2gocmVnZXgpKSB7XG4gICAgICAgICAgICBEVE1GVmFsaWRhdG9yLmdlbmVyYXRlSW52YWxpZFRvbmVFcnJvcih0b25lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9uZTtcbiAgICB9O1xuICAgIERUTUZWYWxpZGF0b3IuZ2VuZXJhdGVJbnZhbGlkVG9uZUVycm9yID0gZnVuY3Rpb24gKHRvbmUpIHtcbiAgICAgICAgdmFyIHRvbmVGb3JNc2cgPSAoISF0b25lICYmIHR5cGVvZiB0b25lICE9PSBcImJvb2xlYW5cIiA/IHRvbmUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpIDogdG9uZSk7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHRvbmUocyk6IFwiICsgdG9uZUZvck1zZyk7XG4gICAgfTtcbiAgICByZXR1cm4gRFRNRlZhbGlkYXRvcjtcbn0oKSk7XG5leHBvcnRzLkRUTUZWYWxpZGF0b3IgPSBEVE1GVmFsaWRhdG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbnZhciBhbGxvd2VkX21ldGhvZHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdXNlci1hZ2VudC1jb3JlL2FsbG93ZWQtbWV0aG9kc1wiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4vRW51bXNcIik7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuLyoqXG4gKiBXaGlsZSB0aGlzIGNsYXNzIGlzIG5hbWVkIGBTdWJzY3JpcHRpb25gLCBpdCBpcyBjbG9zZXIgdG9cbiAqIGFuIGltcGxlbWVudGF0aW9uIG9mIGEgXCJzdWJzY3JpYmVyXCIgYXMgZGVmaW5lZCBpbiBSRkMgNjY2NVxuICogXCJTSVAtU3BlY2lmaWMgRXZlbnQgTm90aWZpY2F0aW9uc1wiLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjVcbiAqIEBjbGFzcyBDbGFzcyBjcmVhdGluZyBhIFNJUCBTdWJzY3JpYmVyLlxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gdWEgVXNlciBhZ2VudC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFN1YnNjcmlwdGlvbiB0YXJnZXQuXG4gICAgICogQHBhcmFtIGV2ZW50IFN1YnNjcmlwdGlvbiBldmVudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odWEsIHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF0YSA9IHt9O1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBDb25zdGFudHNfMS5DLlNVQlNDUklCRTtcbiAgICAgICAgX3RoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2xpZW50Q29udGV4dCBpbnRlcmZhY2VcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuU3Vic2NyaXB0aW9uO1xuICAgICAgICBfdGhpcy51YSA9IHVhO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSB1YS5nZXRMb2dnZXIoXCJzaXAuc3Vic2NyaXB0aW9uXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICBfdGhpcy5ib2R5ID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSA/IG9wdGlvbnMuY29udGVudFR5cGUgOiBcImFwcGxpY2F0aW9uL3NkcFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRhcmdldCBVUklcbiAgICAgICAgdmFyIHVyaSA9IHVhLm5vcm1hbGl6ZVRhcmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXVyaSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFyZ2V0OiBcIiArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMudXJpID0gdXJpO1xuICAgICAgICAvLyBTdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgICAgX3RoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIGV4cGlyZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZXhwaXJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpcy5leHBpcmVzID0gMzYwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5leHBpcmVzICE9PSBcIm51bWJlclwiKSB7IC8vIHByZS10eXBlc2NyaXB0IHR5cGUgZ3VhcmRcbiAgICAgICAgICAgIHVhLmxvZ2dlci53YXJuKFwiT3B0aW9uIFxcXCJleHBpcmVzXFxcIiBtdXN0IGJlIGEgbnVtYmVyLiBVc2luZyBkZWZhdWx0IG9mIDM2MDAuXCIpO1xuICAgICAgICAgICAgX3RoaXMuZXhwaXJlcyA9IDM2MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5leHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1YnNjcmlwdGlvbiBleHRyYSBoZWFkZXJzXG4gICAgICAgIF90aGlzLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgLy8gU3Vic2NyaXB0aW9uIGNvbnRleHQuXG4gICAgICAgIF90aGlzLmNvbnRleHQgPSBfdGhpcy5pbml0Q29udGV4dCgpO1xuICAgICAgICBfdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBDbGllbnRDb250ZXh0IGludGVyZmFjZVxuICAgICAgICBfdGhpcy5yZXF1ZXN0ID0gX3RoaXMuY29udGV4dC5tZXNzYWdlO1xuICAgICAgICBpZiAoIV90aGlzLnJlcXVlc3QuZnJvbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMucmVxdWVzdC50bykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmxvY2FsSWRlbnRpdHkgPSBfdGhpcy5yZXF1ZXN0LmZyb207XG4gICAgICAgIF90aGlzLnJlbW90ZUlkZW50aXR5ID0gX3RoaXMucmVxdWVzdC50bztcbiAgICAgICAgLy8gQWRkIHRvIFVBJ3MgY29sbGVjdGlvblxuICAgICAgICBfdGhpcy5pZCA9IF90aGlzLnJlcXVlc3QuY2FsbElkICsgX3RoaXMucmVxdWVzdC5mcm9tLnBhcmFtZXRlcnMudGFnICsgX3RoaXMuZXZlbnQ7XG4gICAgICAgIF90aGlzLnVhLnN1YnNjcmlwdGlvbnNbX3RoaXMuaWRdID0gX3RoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmV0cnlBZnRlclRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXRyeUFmdGVyVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeUFmdGVyVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIFVBJ3MgY29sbGVjdGlvblxuICAgICAgICBkZWxldGUgdGhpcy51YS5zdWJzY3JpcHRpb25zW3RoaXMuaWRdO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5lbWl0LmFwcGx5KHRoaXMsIHRzbGliXzEuX19zcHJlYWRBcnJheXMoW2V2ZW50XSwgYXJncykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR3JhY2VmdWxseSB0ZXJtaW5hdGUuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRleHQuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlOlxuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZS1TVUJTQ1JJQkUgcmVxdWVzdCBpZiB0aGVyZSBpcyBhbiBcImFjdGl2ZVwiIHN1YnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250ZXh0LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5zdWJzY3JpcHRpb24ucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25BY2NlcHQ6IChmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uQWNjZXB0ZWQocmVzcG9uc2UpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVkaXJlY3Q6IChmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLm9uRmFpbGVkKHJlc3BvbnNlKTsgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlamVjdDogKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25GYWlsZWQocmVzcG9uc2UpOyB9KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBpbml0aWFsIFNVQlNDUklCRSByZXF1ZXN0IGlmIG5vIHN1YnNjcmlwdGlvbi5cbiAgICAgKiBTZW5kIGEgcmUtU1VCU0NSSUJFIHJlcXVlc3QgaWYgdGhlcmUgaXMgYW4gXCJhY3RpdmVcIiBzdWJzY3JpcHRpb24uXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb250ZXh0LnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdWJzY3JpYmUoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3Muc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uID0gcmVzdWx0LnN1Y2Nlc3Muc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbi5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Ob3RpZnk6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7IHJldHVybiBfdGhpcy5vbk5vdGlmeShyZXF1ZXN0KTsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWZyZXNoOiBmdW5jdGlvbiAocmVxdWVzdCkgeyByZXR1cm4gX3RoaXMub25SZWZyZXNoKHJlcXVlc3QpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRlcm1pbmF0ZWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlKCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Ob3RpZnkocmVzdWx0LnN1Y2Nlc3MucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRmFpbGVkKHJlc3VsdC5mYWlsdXJlLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZS1TVUJTQ1JJQkUgcmVxdWVzdCBpZiB0aGVyZSBpcyBhIFwicGVuZGluZ1wiIG9yIFwiYWN0aXZlXCIgc3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29udGV4dC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZXMgaW50ZW50aW9uYWxseSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZXMgaW50ZW50aW9uYWxseSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUub25BY2NlcHRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA/IHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA6IDA7XG4gICAgICAgIHZhciBjYXVzZSA9IFV0aWxzXzEuVXRpbHMuZ2V0UmVhc29uUGhyYXNlKHN0YXR1c0NvZGUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJhY2NlcHRlZFwiLCByZXNwb25zZS5tZXNzYWdlLCBjYXVzZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLm9uRmFpbGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA/IHJlc3BvbnNlLm1lc3NhZ2Uuc3RhdHVzQ29kZSA6IDA7XG4gICAgICAgICAgICB2YXIgY2F1c2UgPSBVdGlsc18xLlV0aWxzLmdldFJlYXNvblBocmFzZShzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImZhaWxlZFwiLCByZXNwb25zZS5tZXNzYWdlLCBjYXVzZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZWplY3RlZFwiLCByZXNwb25zZS5tZXNzYWdlLCBjYXVzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUub25Ob3RpZnkgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0LmFjY2VwdCgpOyAvLyBTZW5kIDIwMCByZXNwb25zZS5cbiAgICAgICAgdGhpcy5lbWl0KFwibm90aWZ5XCIsIHsgcmVxdWVzdDogcmVxdWVzdC5tZXNzYWdlIH0pO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBzZXQgc3RhdGUgdG8gZG9uZSwgbm8gZnVydGhlciBwcm9jZXNzaW5nIHNob3VsZCB0YWtlIHBsYWNlXG4gICAgICAgIC8vIGFuZCB3ZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIGNsZWFuaW5nIHVwIGFmdGVyIHRoZSBhcHByb3ByaWF0ZSBOT1RJRlkuXG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFwidGVybWluYXRlZFwiLCB0aGUgc3Vic2NyaWJlclxuICAgICAgICAvLyAgTVVTVCBjb25zaWRlciB0aGUgc3Vic2NyaXB0aW9uIHRlcm1pbmF0ZWQuICBUaGUgXCJleHBpcmVzXCIgcGFyYW1ldGVyXG4gICAgICAgIC8vICBoYXMgbm8gc2VtYW50aWNzIGZvciBcInRlcm1pbmF0ZWRcIiAtLSBub3RpZmllcnMgU0hPVUxEIE5PVCBpbmNsdWRlIGFuXG4gICAgICAgIC8vICBcImV4cGlyZXNcIiBwYXJhbWV0ZXIgb24gYSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZCB3aXRoIGFcbiAgICAgICAgLy8gIHZhbHVlIG9mIFwidGVybWluYXRlZFwiLCBhbmQgc3Vic2NyaWJlcnMgTVVTVCBpZ25vcmUgYW55IHN1Y2hcbiAgICAgICAgLy8gIHBhcmFtZXRlciwgaWYgcHJlc2VudC4gIElmIGEgcmVhc29uIGNvZGUgaXMgcHJlc2VudCwgdGhlIGNsaWVudFxuICAgICAgICAvLyAgc2hvdWxkIGJlaGF2ZSBhcyBkZXNjcmliZWQgYmVsb3cuICBJZiBubyByZWFzb24gY29kZSBvciBhbiB1bmtub3duXG4gICAgICAgIC8vICByZWFzb24gY29kZSBpcyBwcmVzZW50LCB0aGUgY2xpZW50IE1BWSBhdHRlbXB0IHRvIHJlLXN1YnNjcmliZSBhdCBhbnlcbiAgICAgICAgLy8gIHRpbWUgKHVubGVzcyBhIFwicmV0cnktYWZ0ZXJcIiBwYXJhbWV0ZXIgaXMgcHJlc2VudCwgaW4gd2hpY2ggY2FzZSB0aGVcbiAgICAgICAgLy8gIGNsaWVudCBTSE9VTEQgTk9UIGF0dGVtcHQgcmUtc3Vic2NyaXB0aW9uIHVudGlsIGFmdGVyIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgLy8gIHNlY29uZHMgc3BlY2lmaWVkIGJ5IHRoZSBcInJldHJ5LWFmdGVyXCIgcGFyYW1ldGVyKS4gIFRoZSByZWFzb24gY29kZXNcbiAgICAgICAgLy8gIGRlZmluZWQgYnkgdGhpcyBkb2N1bWVudCBhcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvblN0YXRlID0gcmVxdWVzdC5tZXNzYWdlLnBhcnNlSGVhZGVyKFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUgJiYgc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdGUucmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJUZXJtaW5hdGVkIHN1YnNjcmlwdGlvbiB3aXRoIHJlYXNvbiBcIiArIHN1YnNjcmlwdGlvblN0YXRlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvblN0YXRlLnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkZWFjdGl2YXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lb3V0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwcm9iYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2l2ZXVwXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXRlLnBhcmFtcyAmJiBzdWJzY3JpcHRpb25TdGF0ZS5wYXJhbXNbXCJyZXRyeS1hZnRlclwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXRyeUFmdGVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnN1YnNjcmliZSgpOyB9LCBzdWJzY3JpcHRpb25TdGF0ZS5wYXJhbXNbXCJyZXRyeS1hZnRlclwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwibm9yZXNvdXJjZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnZhcmlhbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5vblJlZnJlc2ggPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXF1ZXN0LmRlbGVnYXRlID0ge1xuICAgICAgICAgICAgb25BY2NlcHQ6IGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gX3RoaXMub25BY2NlcHRlZChyZXNwb25zZSk7IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUub25UZXJtaW5hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJ0ZXJtaW5hdGVkXCIpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5pbml0Q29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnM6IHRoaXMuZXh0cmFIZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogdGhpcy5ib2R5ID8gVXRpbHNfMS5VdGlscy5mcm9tQm9keU9iaih0aGlzLmJvZHkpIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG5ldyBTdWJzY3JpYmVDbGllbnRDb250ZXh0KHRoaXMudWEudXNlckFnZW50Q29yZSwgdGhpcy51cmksIHRoaXMuZXZlbnQsIHRoaXMuZXhwaXJlcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgIG9uQWNjZXB0OiAoZnVuY3Rpb24gKHJlc3BvbnNlKSB7IHJldHVybiBfdGhpcy5vbkFjY2VwdGVkKHJlc3BvbnNlKTsgfSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbnZhciBTdWJzY3JpYmVDbGllbnRDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmliZUNsaWVudENvbnRleHQoY29yZSwgdGFyZ2V0LCBldmVudCwgZXhwaXJlcywgb3B0aW9ucywgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy5leHBpcmVzID0gZXhwaXJlcztcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29yZS5sb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcC5zdWJzY3JpcHRpb25cIik7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdmFyIGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW10pLnNsaWNlKCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKGFsbG93SGVhZGVyKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJFdmVudDogXCIgKyB0aGlzLmV2ZW50KTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJFeHBpcmVzOiBcIiArIHRoaXMuZXhwaXJlcyk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQ29udGFjdDogXCIgKyB0aGlzLmNvcmUuY29uZmlndXJhdGlvbi5jb250YWN0LnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgYm9keSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ib2R5O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBjb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKENvbnN0YW50c18xLkMuU1VCU0NSSUJFLCB0aGlzLnRhcmdldCwgdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uYW9yLCB0aGlzLnRhcmdldCwge30sIGV4dHJhSGVhZGVycywgYm9keSk7XG4gICAgfVxuICAgIC8qKiBEZXN0cnVjdG9yLiAqL1xuICAgIFN1YnNjcmliZUNsaWVudENvbnRleHQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC53YWl0Tm90aWZ5U3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmliZUNsaWVudENvbnRleHQucHJvdG90eXBlLCBcInN0YXRlXCIsIHtcbiAgICAgICAgLyoqIFN1YnNjcmlwdGlvbiBzdGF0ZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29yZV8xLlN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaCBzdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU3Vic2NyaWJlQ2xpZW50Q29udGV4dC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiTm90IGluIGluaXRpYWwgc3RhdGUuIERpZCB5b3UgY2FsbCBzdWJzY3JpYmUgbW9yZSB0aGFuIG9uY2U/XCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMucmVxdWVzdCA9IF90aGlzLmNvcmUuc3Vic2NyaWJlKF90aGlzLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFNVQlNDUklCRSByZXF1ZXN0IHdpbGwgYmUgY29uZmlybWVkIHdpdGggYSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyAyMDAtY2xhc3MgcmVzcG9uc2VzIGluZGljYXRlIHRoYXQgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBhY2NlcHRlZFxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGF0IGEgTk9USUZZIHJlcXVlc3Qgd2lsbCBiZSBzZW50IGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMVxuICAgICAgICAgICAgICAgIG9uQWNjZXB0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIER1ZSB0byB0aGUgcG90ZW50aWFsIGZvciBvdXQtb2Ytb3JkZXIgbWVzc2FnZXMsIHBhY2tldCBsb3NzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyBmb3JraW5nLCB0aGUgc3Vic2NyaWJlciBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgTk9USUZZIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSBTVUJTQ1JJQkUgdHJhbnNhY3Rpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjRcbiAgICAgICAgICAgICAgICBvbk5vdGlmeTogZnVuY3Rpb24gKHJlcXVlc3RXaXRoU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbiA9IHJlcXVlc3RXaXRoU3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uLmF1dG9SZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc3VjY2VzczogcmVxdWVzdFdpdGhTdWJzY3JpcHRpb24gfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIFRpbWVyIE4gZXhwaXJlcyBwcmlvciB0byB0aGUgcmVjZWlwdCBvZiBhIE5PVElGWSByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWJzY3JpYmVyIGNvbnNpZGVycyB0aGUgc3Vic2NyaXB0aW9uIGZhaWxlZCwgYW5kIGNsZWFucyB1cFxuICAgICAgICAgICAgICAgIC8vIGFueSBzdGF0ZSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YnNjcmlwdGlvbiBhdHRlbXB0LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuNFxuICAgICAgICAgICAgICAgIG9uTm90aWZ5VGltZW91dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgZmFpbHVyZToge30gfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIFNVQlNDUklCRSByZXF1ZXN0IHdpbGwgYmUgY29uZmlybWVkIHdpdGggYSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBOb24tMjAwLWNsYXNzIGZpbmFsIHJlc3BvbnNlcyBpbmRpY2F0ZSB0aGF0IG5vIHN1YnNjcmlwdGlvbiBvciBuZXdcbiAgICAgICAgICAgICAgICAvLyBkaWFsb2cgdXNhZ2UgaGFzIGJlZW4gY3JlYXRlZCwgYW5kIG5vIHN1YnNlcXVlbnQgTk9USUZZIHJlcXVlc3Qgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHNlbnQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgICAgICAgICAgb25SZWRpcmVjdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoeyBmYWlsdXJlOiB7IHJlc3BvbnNlOiByZXNwb25zZSB9IH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBTVUJTQ1JJQkUgcmVxdWVzdCB3aWxsIGJlIGNvbmZpcm1lZCB3aXRoIGEgZmluYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgLy8gTm9uLTIwMC1jbGFzcyBmaW5hbCByZXNwb25zZXMgaW5kaWNhdGUgdGhhdCBubyBzdWJzY3JpcHRpb24gb3IgbmV3XG4gICAgICAgICAgICAgICAgLy8gZGlhbG9nIHVzYWdlIGhhcyBiZWVuIGNyZWF0ZWQsIGFuZCBubyBzdWJzZXF1ZW50IE5PVElGWSByZXF1ZXN0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyBiZSBzZW50LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMVxuICAgICAgICAgICAgICAgIG9uUmVqZWN0OiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGZhaWx1cmU6IHsgcmVzcG9uc2U6IHJlc3BvbnNlIH0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZUNsaWVudENvbnRleHQ7XG59KCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4vKipcbiAqIExlZ2FjeSBUcmFuc3BvcnQuXG4gKiBAcmVtYXJrc1xuICogQWJzdHJhY3QgdHJhbnNwb3J0IGxheWVyIGJhc2UgY2xhc3MuXG4gKiBAcHVibGljXG4gKi9cbnZhciBUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIGxvZ2dlciAtIExvZ2dlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LiBEZXByZWNhdGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc3BvcnQucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcm90b2NvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlbWFya3NcbiAgICAgICAgICogRm9ybWF0dGVkIGFzIGRlZmluZWQgZm9yIHRoZSBWaWEgaGVhZGVyIHNlbnQtcHJvdG9jb2wgdHJhbnNwb3J0LlxuICAgICAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIwLjQyXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlciAmJiB0aGlzLnNlcnZlci5zY2hlbWUgPyB0aGlzLnNlcnZlci5zY2hlbWUgOiBcIldTU1wiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9taXNlIGRlc2lnbmF0ZWQgYnkgdGhlIGNoaWxkIGxheWVyIHRoZW4gZW1pdHMgYSBjb25uZWN0ZWQgZXZlbnQuXG4gICAgICogQXV0b21hdGljYWxseSBlbWl0cyBhbiBldmVudCB1cG9uIHJlc29sdXRpb24sIHVubGVzcyBvdmVycmlkZUV2ZW50IGlzIHNldC4gSWYgeW91XG4gICAgICogb3ZlcnJpZGUgdGhlIGV2ZW50IGluIHRoaXMgZmFzaGlvbiwgeW91IHNob3VsZCBlbWl0IGl0IGluIHlvdXIgaW1wbGVtZW50YXRpb24gb2YgY29ubmVjdFByb21pc2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghZGF0YS5vdmVycmlkZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UgdGhlbiBlbWl0cyBhICdtZXNzYWdlU2VudCcgZXZlbnQuIEF1dG9tYXRpY2FsbHkgZW1pdHMgYW5cbiAgICAgKiBldmVudCB1cG9uIHJlc29sdXRpb24sIHVubGVzcyBkYXRhLm92ZXJyaWRlRXZlbnQgaXMgc2V0LiBJZiB5b3Ugb3ZlcnJpZGVcbiAgICAgKiB0aGUgZXZlbnQgaW4gdGhpcyBmYXNoaW9uLCB5b3Ugc2hvdWxkIGVtaXQgaXQgaW4geW91ciBpbXBsZW1lbnRhdGlvbiBvZiBzZW5kUHJvbWlzZVxuICAgICAqIFJlamVjdHMgd2l0aCBhbiBFcnJvciBpZiBtZXNzYWdlIGZhaWxzIHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBNZXNzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gRXJyb3IgaGFuZGxpbmcgaXMgaW5kZXBlbmRlbnQgb2Ygd2hldGhlciB0aGUgbWVzc2FnZSB3YXMgYSByZXF1ZXN0IG9yXG4gICAgICAgIC8vIHJlc3BvbnNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IHVzZXIgYXNrcyBmb3IgYSBtZXNzYWdlIHRvIGJlIHNlbnQgb3ZlciBhblxuICAgICAgICAvLyB1bnJlbGlhYmxlIHRyYW5zcG9ydCwgYW5kIHRoZSByZXN1bHQgaXMgYW4gSUNNUCBlcnJvciwgdGhlIGJlaGF2aW9yXG4gICAgICAgIC8vIGRlcGVuZHMgb24gdGhlIHR5cGUgb2YgSUNNUCBlcnJvci4gIEhvc3QsIG5ldHdvcmssIHBvcnQgb3IgcHJvdG9jb2xcbiAgICAgICAgLy8gdW5yZWFjaGFibGUgZXJyb3JzLCBvciBwYXJhbWV0ZXIgcHJvYmxlbSBlcnJvcnMgU0hPVUxEIGNhdXNlIHRoZVxuICAgICAgICAvLyB0cmFuc3BvcnQgbGF5ZXIgdG8gaW5mb3JtIHRoZSB0cmFuc3BvcnQgdXNlciBvZiBhIGZhaWx1cmUgaW4gc2VuZGluZy5cbiAgICAgICAgLy8gU291cmNlIHF1ZW5jaCBhbmQgVFRMIGV4Y2VlZGVkIElDTVAgZXJyb3JzIFNIT1VMRCBiZSBpZ25vcmVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IHVzZXIgYXNrcyBmb3IgYSByZXF1ZXN0IHRvIGJlIHNlbnQgb3ZlciBhIHJlbGlhYmxlXG4gICAgICAgIC8vIHRyYW5zcG9ydCwgYW5kIHRoZSByZXN1bHQgaXMgYSBjb25uZWN0aW9uIGZhaWx1cmUsIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgLy8gbGF5ZXIgU0hPVUxEIGluZm9ybSB0aGUgdHJhbnNwb3J0IHVzZXIgb2YgYSBmYWlsdXJlIGluIHNlbmRpbmcuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTguNFxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUHJvbWlzZShtZXNzYWdlKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0Lm92ZXJyaWRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibWVzc2FnZVNlbnRcIiwgcmVzdWx0Lm1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvbWlzZSBkZXNpZ25hdGVkIGJ5IHRoZSBjaGlsZCBsYXllciB0aGVuIGVtaXRzIGFcbiAgICAgKiBkaXNjb25uZWN0ZWQgZXZlbnQuIEF1dG9tYXRpY2FsbHkgZW1pdHMgYW4gZXZlbnQgdXBvbiByZXNvbHV0aW9uLFxuICAgICAqIHVubGVzcyBvdmVycmlkZUV2ZW50IGlzIHNldC4gSWYgeW91IG92ZXJyaWRlIHRoZSBldmVudCBpbiB0aGlzIGZhc2hpb24sXG4gICAgICogeW91IHNob3VsZCBlbWl0IGl0IGluIHlvdXIgaW1wbGVtZW50YXRpb24gb2YgZGlzY29ubmVjdFByb21pc2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdFByb21pc2Uob3B0aW9ucykudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFkYXRhLm92ZXJyaWRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuYWZ0ZXJDb25uZWN0ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZShcImNvbm5lY3RlZFwiLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIG9uY2UgdGhlIFVBIGlzIGNvbm5lY3RlZC4gREVQUkVDQVRJT04gV0FSTklORzoganVzdCB1c2UgYWZ0ZXJDb25uZWN0ZWQoKVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUud2FpdEZvckNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFwiREVQUkVDQVRJT04gV0FSTklORyBUcmFuc3BvcnQud2FpdEZvckNvbm5lY3RlZCgpOiB1c2UgYWZ0ZXJDb25uZWN0ZWQoKSBpbnN0ZWFkXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF90aGlzLmFmdGVyQ29ubmVjdGVkKHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnQ7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBDbGllbnRDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9DbGllbnRDb250ZXh0XCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xudmFyIEV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvbnNcIik7XG52YXIgUHVibGlzaENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1B1Ymxpc2hDb250ZXh0XCIpO1xudmFyIFJlZmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUmVmZXJDb250ZXh0XCIpO1xudmFyIFJlZ2lzdGVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUmVnaXN0ZXJDb250ZXh0XCIpO1xudmFyIFNlcnZlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1NlcnZlckNvbnRleHRcIik7XG52YXIgU2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vU2Vzc2lvblwiKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N1YnNjcmlwdGlvblwiKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4vVXRpbHNcIik7XG52YXIgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vV2ViL1Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcIik7XG52YXIgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9XZWIvVHJhbnNwb3J0XCIpO1xuLyoqXG4gKiBAY2xhc3MgQ2xhc3MgY3JlYXRpbmcgYSBTSVAgVXNlciBBZ2VudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24gcmV0dXJuaW5nIFNJUC5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyfSBbY29uZmlndXJhdGlvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeV1cbiAqICBBIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBieSBlYWNoIG9mIHRoZSBVQSdzIFNlc3Npb25zIHRvIGJ1aWxkIHRoZSBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyIGZvciB0aGF0IFNlc3Npb24uXG4gKiAgSWYgbm8gKG9yIGEgZmFsc3kpIHZhbHVlIGlzIHByb3ZpZGVkLCBlYWNoIFNlc3Npb24gd2lsbCB1c2UgYSBkZWZhdWx0IChXZWJSVEMpIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuXG4gKi9cbnZhciBVQSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhVQSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVQShjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKiBVbmxvYWQgbGlzdGVuZXIuICovXG4gICAgICAgIF90aGlzLnVubG9hZExpc3RlbmVyID0gKGZ1bmN0aW9uICgpIHsgX3RoaXMuc3RvcCgpOyB9KTtcbiAgICAgICAgX3RoaXMudHlwZSA9IEVudW1zXzEuVHlwZVN0cmluZ3MuVUE7XG4gICAgICAgIF90aGlzLmxvZyA9IG5ldyBjb3JlXzEuTG9nZ2VyRmFjdG9yeSgpO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBfdGhpcy5nZXRMb2dnZXIoXCJzaXAudWFcIik7XG4gICAgICAgIF90aGlzLmNvbmZpZ3VyYXRpb24gPSB7fTtcbiAgICAgICAgLy8gVXNlciBhY3Rpb25zIG91dHNpZGUgYW55IHNlc3Npb24vZGlhbG9nIChNRVNTQUdFKVxuICAgICAgICBfdGhpcy5hcHBsaWNhbnRzID0ge307XG4gICAgICAgIF90aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgX3RoaXMuc2Vzc2lvbnMgPSB7fTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgICBfdGhpcy5wdWJsaXNoZXJzID0ge307XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX0lOSVQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHRocm93cyB7U0lQLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yfVxuICAgICAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbmZpZ3VyYXRpb24gPT09IFwic3RyaW5nXCIgfHwgY29uZmlndXJhdGlvbiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwbHkgbG9nIGNvbmZpZ3VyYXRpb24gaWYgcHJlc2VudFxuICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5sb2cpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZy5idWlsdGluRW5hYmxlZCA9IGNvbmZpZ3VyYXRpb24ubG9nLmJ1aWx0aW5FbmFibGVkO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24ubG9nLmhhc093blByb3BlcnR5KFwiY29ubmVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nLmNvbm5lY3RvciA9IGNvbmZpZ3VyYXRpb24ubG9nLmNvbm5lY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmxvZy5oYXNPd25Qcm9wZXJ0eShcImxldmVsXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxldmVsID0gY29uZmlndXJhdGlvbi5sb2cubGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ3YXJuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGNvcmVfMS5MZXZlbHMud2FybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy5sb2c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy5kZWJ1ZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy53YXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjb3JlXzEuTGV2ZWxzLmxvZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY29yZV8xLkxldmVscy5kZWJ1ZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXZvaWQgc2V0dGluZyBsZXZlbCB3aGVuIGludmFsaWQsIHVzZSBkZWZhdWx0IGxldmVsIGluc3RlYWRcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkludmFsaWQgXFxcImxldmVsXFxcIiBwYXJhbWV0ZXIgdmFsdWU6IFwiICsgSlNPTi5zdHJpbmdpZnkobGV2ZWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZy5sZXZlbCA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBkZXByZWNhdGVkTWVzc2FnZSA9IFwiVGhlIFVBIGNsYXNzIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIGF2YWlsYWJsZSBzdGFydGluZyB3aXRoIFNJUC5qcyByZWxlYXNlIDAuMTYuMC4gXCIgK1xuICAgICAgICAgICAgXCJUaGUgVUEgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIFVzZXJBZ2VudCBjbGFzcy4gUGxlYXNlIHVwZGF0ZSBhY2NvcmRpbmdseS5cIjtcbiAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oZGVwcmVjYXRlZE1lc3NhZ2UpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX3RoaXMubG9hZENvbmZpZyhjb25maWd1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfTk9UX1JFQURZO1xuICAgICAgICAgICAgX3RoaXMuZXJyb3IgPSBVQS5DLkNPTkZJR1VSQVRJT05fRVJST1I7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMuY29uZmlndXJhdGlvbi50cmFuc3BvcnRDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5UcmFuc3BvcnRFcnJvcihcIlRyYW5zcG9ydCBjb25zdHJ1Y3RvciBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydCA9IG5ldyBfdGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcG9ydENvbnN0cnVjdG9yKF90aGlzLmdldExvZ2dlcihcInNpcC50cmFuc3BvcnRcIiksIF90aGlzLmNvbmZpZ3VyYXRpb24udHJhbnNwb3J0T3B0aW9ucyk7XG4gICAgICAgIHZhciB1c2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbiA9IG1ha2VVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbkZyb21VQShfdGhpcyk7XG4gICAgICAgIC8vIFRoZSBSZXBsYWNlcyBoZWFkZXIgY29udGFpbnMgaW5mb3JtYXRpb24gdXNlZCB0byBtYXRjaCBhbiBleGlzdGluZ1xuICAgICAgICAvLyBTSVAgZGlhbG9nIChjYWxsLWlkLCB0by10YWcsIGFuZCBmcm9tLXRhZykuICBVcG9uIHJlY2VpdmluZyBhbiBJTlZJVEVcbiAgICAgICAgLy8gd2l0aCBhIFJlcGxhY2VzIGhlYWRlciwgdGhlIFVzZXIgQWdlbnQgKFVBKSBhdHRlbXB0cyB0byBtYXRjaCB0aGlzXG4gICAgICAgIC8vIGluZm9ybWF0aW9uIHdpdGggYSBjb25maXJtZWQgb3IgZWFybHkgZGlhbG9nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzg5MSNzZWN0aW9uLTNcbiAgICAgICAgdmFyIGhhbmRsZUludml0ZVdpdGhSZXBsYWNlc0hlYWRlciA9IGZ1bmN0aW9uIChjb250ZXh0LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY29uZmlndXJhdGlvbi5yZXBsYWNlcyAhPT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuVU5TVVBQT1JURUQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZXMgPSByZXF1ZXN0LnBhcnNlSGVhZGVyKFwicmVwbGFjZXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTZXNzaW9uID0gX3RoaXMuc2Vzc2lvbnNbcmVwbGFjZXMuY2FsbF9pZCArIHJlcGxhY2VzLnJlcGxhY2VzX2Zyb21fdGFnXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Vzc2lvbnNbcmVwbGFjZXMuY2FsbF9pZCArIHJlcGxhY2VzLnJlcGxhY2VzX3RvX3RhZ10gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKHJlcXVlc3QsIHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTZXNzaW9uLnN0YXR1cyA9PT0gRW51bXNfMS5TZXNzaW9uU3RhdHVzLlNUQVRVU19URVJNSU5BVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKHJlcXVlc3QsIHsgc3RhdHVzQ29kZTogNjAzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXREaWFsb2dJZCA9IHJlcGxhY2VzLmNhbGxfaWQgKyByZXBsYWNlcy5yZXBsYWNlc190b190YWcgKyByZXBsYWNlcy5yZXBsYWNlc19mcm9tX3RhZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldERpYWxvZyA9IF90aGlzLnVzZXJBZ2VudENvcmUuZGlhbG9ncy5nZXQodGFyZ2V0RGlhbG9nSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldERpYWxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXNlckFnZW50Q29yZS5yZXBseVN0YXRlbGVzcyhyZXF1ZXN0LCB7IHN0YXR1c0NvZGU6IDQ4MSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldERpYWxvZy5lYXJseSAmJiByZXBsYWNlcy5lYXJseV9vbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyQWdlbnRDb3JlLnJlcGx5U3RhdGVsZXNzKHJlcXVlc3QsIHsgc3RhdHVzQ29kZTogNDg2IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVwbGFjZWUgPSB0YXJnZXRTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHVzZXJBZ2VudENvcmVEZWxlZ2F0ZSA9IHtcbiAgICAgICAgICAgIG9uSW52aXRlOiBmdW5jdGlvbiAoaW5jb21pbmdJbnZpdGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFBvcnRlZCAtIDEwMCBUcnlpbmcgc2VuZCBzaG91bGQgYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcmVxdWlyZWQgaWYgVFUgd2lsbCBub3QgcmVzcG9uZCBpbiAyMDBtcy5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICAgICAgICAgIGluY29taW5nSW52aXRlUmVxdWVzdC50cnlpbmcoKTtcbiAgICAgICAgICAgICAgICBpbmNvbWluZ0ludml0ZVJlcXVlc3QuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbiAoY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uQ2FuY2VsKGNhbmNlbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uVHJhbnNwb3J0RXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblRyYW5zcG9ydEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbmV3IFNlc3Npb25fMS5JbnZpdGVTZXJ2ZXJDb250ZXh0KF90aGlzLCBpbmNvbWluZ0ludml0ZVJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIC8vIFBvcnRlZCAtIGhhbmRsaW5nIG9mIG91dCBvZiBkaWFsb2cgSU5WSVRFIHdpdGggUmVwbGFjZXMuXG4gICAgICAgICAgICAgICAgaGFuZGxlSW52aXRlV2l0aFJlcGxhY2VzSGVhZGVyKGNvbnRleHQsIGluY29taW5nSW52aXRlUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBQb3J0ZWQgLSBtYWtlIHRoZSBmaXJzdCBjYWxsIHRvIHByb2dyZXNzIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuYXV0b1NlbmRBbkluaXRpYWxQcm92aXNpb25hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQucHJvZ3Jlc3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImludml0ZVwiLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uIChpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gUG9ydGVkIC0gaGFuZGxpbmcgb2Ygb3V0IG9mIGRpYWxvZyBNRVNTQUdFLlxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDb250ZXh0ID0gbmV3IFNlcnZlckNvbnRleHRfMS5TZXJ2ZXJDb250ZXh0KF90aGlzLCBpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb250ZXh0LmJvZHkgPSBpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2UuYm9keTtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDb250ZXh0LmNvbnRlbnRUeXBlID0gaW5jb21pbmdNZXNzYWdlUmVxdWVzdC5tZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKSB8fCBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgICAgICAgICBpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJtZXNzYWdlXCIsIHNlcnZlckNvbnRleHQpOyAvLyBUT0RPOiBSZXZpZXcuIFdoeSBpcyBhIFwiU2VydmVyQ29udGV4dFwiIGVtaXR0ZWQ/IFdoYXQgdXNlIGl0IGlzP1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uTm90aWZ5OiBmdW5jdGlvbiAoaW5jb21pbmdOb3RpZnlSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gREVQUkVDQVRFRDogT3V0IG9mIGRpYWxvZyBOT1RJRlkgaXMgYW4gb2Jzb2xldGUgdXNhZ2UuXG4gICAgICAgICAgICAgICAgLy8gUG9ydGVkIC0gaGFuZGxpbmcgb2Ygb3V0IG9mIGRpYWxvZyBOT1RJRlkuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbmZpZ3VyYXRpb24uYWxsb3dMZWdhY3lOb3RpZmljYXRpb25zICYmIF90aGlzLmxpc3RlbmVycyhcIm5vdGlmeVwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY29taW5nTm90aWZ5UmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm5vdGlmeVwiLCB7IHJlcXVlc3Q6IGluY29taW5nTm90aWZ5UmVxdWVzdC5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdOb3RpZnlSZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4MSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWZlcjogZnVuY3Rpb24gKGluY29taW5nUmVmZXJSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gUG9ydGVkIC0gaGFuZGxpbmcgb2Ygb3V0IG9mIGRpYWxvZyBSRUZFUi5cbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiUmVjZWl2ZWQgYW4gb3V0IG9mIGRpYWxvZyByZWZlclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmNvbmZpZ3VyYXRpb24uYWxsb3dPdXRPZkRpYWxvZ1JlZmVycykge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZ1JlZmVyUmVxdWVzdC5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJBbGxvdyBvdXQgb2YgZGlhbG9nIHJlZmVycyBpcyBlbmFibGVkIG9uIHRoZSBVQVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmZXJDb250ZXh0ID0gbmV3IFJlZmVyQ29udGV4dF8xLlJlZmVyU2VydmVyQ29udGV4dChfdGhpcywgaW5jb21pbmdSZWZlclJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5saXN0ZW5lcnMoXCJvdXRPZkRpYWxvZ1JlZmVyUmVxdWVzdGVkXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwib3V0T2ZEaWFsb2dSZWZlclJlcXVlc3RlZFwiLCByZWZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIk5vIG91dE9mRGlhbG9nUmVmZXJSZXF1ZXN0IGxpc3RlbmVycywgYXV0b21hdGljYWxseSBhY2NlcHRpbmcgYW5kIGZvbGxvd2luZyB0aGUgb3V0IG9mIGRpYWxvZyByZWZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJDb250ZXh0LmFjY2VwdCh7IGZvbGxvd1JlZmVyOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblN1YnNjcmliZTogZnVuY3Rpb24gKGluY29taW5nU3Vic2NyaWJlUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJzdWJzY3JpYmVcIiwgaW5jb21pbmdTdWJzY3JpYmVSZXF1ZXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnVzZXJBZ2VudENvcmUgPSBuZXcgY29yZV8xLlVzZXJBZ2VudENvcmUodXNlckFnZW50Q29yZUNvbmZpZ3VyYXRpb24sIHVzZXJBZ2VudENvcmVEZWxlZ2F0ZSk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgcmVnaXN0ZXJDb250ZXh0XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyQ29udGV4dCA9IG5ldyBSZWdpc3RlckNvbnRleHRfMS5SZWdpc3RlckNvbnRleHQoX3RoaXMsIGNvbmZpZ3VyYXRpb24ucmVnaXN0ZXJPcHRpb25zKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKFwiZmFpbGVkXCIsIF90aGlzLmVtaXQuYmluZChfdGhpcywgXCJyZWdpc3RyYXRpb25GYWlsZWRcIikpO1xuICAgICAgICBfdGhpcy5yZWdpc3RlckNvbnRleHQub24oXCJyZWdpc3RlcmVkXCIsIF90aGlzLmVtaXQuYmluZChfdGhpcywgXCJyZWdpc3RlcmVkXCIpKTtcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJDb250ZXh0Lm9uKFwidW5yZWdpc3RlcmVkXCIsIF90aGlzLmVtaXQuYmluZChfdGhpcywgXCJ1bnJlZ2lzdGVyZWRcIikpO1xuICAgICAgICBpZiAoX3RoaXMuY29uZmlndXJhdGlvbi5hdXRvc3RhcnQpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIC8vICBIaWdoIExldmVsIEFQSVxuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgVUEucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5yZWdpc3RlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbF0gdW5yZWdpc3RlciBhbGwgdXNlciBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLnJlZ2lzdGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmFmdGVyQ29ubmVjdGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdGVyQ29udGV4dC51bnJlZ2lzdGVyKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUuaXNSZWdpc3RlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlckNvbnRleHQucmVnaXN0ZXJlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1ha2UgYW4gb3V0Z29pbmcgY2FsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmlld3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWVkaWFdIGdldHMgcGFzc2VkIHRvIFNJUC5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmdldERlc2NyaXB0aW9uIGFzIG1lZGlhSGludFxuICAgICAqXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICAqXG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLmludml0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMsIG1vZGlmaWVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ldyBTZXNzaW9uXzEuSW52aXRlQ2xpZW50Q29udGV4dCh0aGlzLCB0YXJnZXQsIG9wdGlvbnMsIG1vZGlmaWVycyk7XG4gICAgICAgIC8vIERlbGF5IHNlbmRpbmcgYWN0dWFsIGludml0ZSB1bnRpbCB0aGUgbmV4dCAndGljaycgaWYgd2UgYXJlIGFscmVhZHlcbiAgICAgICAgLy8gY29ubmVjdGVkLCBzbyB0aGF0IEFQSSBjb25zdW1lcnMgY2FuIHJlZ2lzdGVyIHRvIGV2ZW50cyBmaXJlZCBieSB0aGVcbiAgICAgICAgLy8gdGhlIHNlc3Npb24uXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmFmdGVyQ29ubmVjdGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW52aXRlKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiaW52aXRlU2VudFwiLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG4gICAgVUEucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKHRoaXMsIHRhcmdldCwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5hZnRlckNvbm5lY3RlZChmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIuc3Vic2NyaWJlKCk7IH0pO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBQVUJMSVNIIEV2ZW50IFN0YXRlIFB1YmxpY2F0aW9uIChSRkMzOTAzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqXG4gICAgICogQHRocm93cyB7U0lQLkV4Y2VwdGlvbnMuTWV0aG9kUGFyYW1ldGVyRXJyb3J9XG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcHViID0gbmV3IFB1Ymxpc2hDb250ZXh0XzEuUHVibGlzaENvbnRleHQodGhpcywgdGFyZ2V0LCBldmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmFmdGVyQ29ubmVjdGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHB1Yi5wdWJsaXNoKGJvZHkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHB1YjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhcmdldFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBib2R5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAqXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfVxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24gKHRhcmdldCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoYm9keSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gTWVzc2FnZSBtb2R1bGUsIHNvIGl0IGlzIG9rYXkgdGhhdCB0aGUgVUEgaGFuZGxlcyBkZWZhdWx0cyBoZXJlLlxuICAgICAgICBvcHRpb25zLmNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZSB8fCBcInRleHQvcGxhaW5cIjtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChDb25zdGFudHNfMS5DLk1FU1NBR0UsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxID0gbmV3IENsaWVudENvbnRleHRfMS5DbGllbnRDb250ZXh0KHRoaXMsIG1ldGhvZCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYWZ0ZXJDb25uZWN0ZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxLnNlbmQoKTsgfSk7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlLlxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJ1c2VyIHJlcXVlc3RlZCBjbG9zdXJlLi4uXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1VTRVJfQ0xPU0VEKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVUEgYWxyZWFkeSBjbG9zZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBDbG9zZSByZWdpc3RlckNvbnRleHRcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY2xvc2luZyByZWdpc3RlckNvbnRleHRcIik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb250ZXh0LmNsb3NlKCk7XG4gICAgICAgIC8vIFJ1biB0ZXJtaW5hdGUgb24gZXZlcnkgU2Vzc2lvblxuICAgICAgICBmb3IgKHZhciBzZXNzaW9uIGluIHRoaXMuc2Vzc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb25zW3Nlc3Npb25dKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiY2xvc2luZyBzZXNzaW9uIFwiICsgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uc1tzZXNzaW9uXS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gdW5zdWJzY3JpYmUgb24gZXZlcnkgU3Vic2NyaXB0aW9uXG4gICAgICAgIGZvciAodmFyIHN1YnNjcmlwdGlvbiBpbiB0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInVuc3Vic2NyaWJlIFwiICsgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbc3Vic2NyaXB0aW9uXS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biBjbG9zZSBvbiBldmVyeSBQdWJsaXNoZXJcbiAgICAgICAgZm9yICh2YXIgcHVibGlzaGVyIGluIHRoaXMucHVibGlzaGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMucHVibGlzaGVyc1twdWJsaXNoZXJdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidW5wdWJsaXNoIFwiICsgcHVibGlzaGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hlcnNbcHVibGlzaGVyXS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biBjbG9zZSBvbiBldmVyeSBhcHBsaWNhbnRcbiAgICAgICAgZm9yICh2YXIgYXBwbGljYW50IGluIHRoaXMuYXBwbGljYW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGljYW50c1thcHBsaWNhbnRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBsaWNhbnRzW2FwcGxpY2FudF0uY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1VTRVJfQ0xPU0VEO1xuICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgYW5kIHJlc2V0IHVzZXIgYWdlbnQgY29yZVxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmF1dG9zdG9wKSB7XG4gICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lIFBhY2thZ2VkIEFwcHMgZG9uJ3QgYWxsb3cgJ3VubG9hZCcgbGlzdGVuZXJzOiB1bmxvYWQgaXMgbm90IGF2YWlsYWJsZSBpbiBwYWNrYWdlZCBhcHBzXG4gICAgICAgICAgICB2YXIgZ29vZ2xlQ2hyb21lUGFja2FnZWRBcHAgPSB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZS5hcHAgJiYgY2hyb21lLmFwcC5ydW50aW1lID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICFnb29nbGVDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIHRoaXMudW5sb2FkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgV1Mgc2VydmVyIGlmIHN0YXR1cyA9IFNUQVRVU19JTklULlxuICAgICAqIFJlc3VtZSBVQSBhZnRlciBiZWluZyBjbG9zZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInVzZXIgcmVxdWVzdGVkIHN0YXJ0dXAuLi5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfSU5JVCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19TVEFSVElORztcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnRDcmVhdGVkXCIsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfVVNFUl9DTE9TRUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlc3VtaW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19SRUFEWTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfU1RBUlRJTkcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlVBIGlzIGluIFNUQVJUSU5HIHN0YXR1cywgbm90IG9wZW5pbmcgbmV3IGNvbm5lY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0dXMgPT09IEVudW1zXzEuVUFTdGF0dXMuU1RBVFVTX1JFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJVQSBpcyBpbiBSRUFEWSBzdGF0dXMsIG5vdCByZXN1bWluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiQ29ubmVjdGlvbiBpcyBkb3duLiBBdXRvLVJlY292ZXJ5IHN5c3RlbSBpcyB0cnlpbmcgdG8gY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLmF1dG9zdG9wKSB7XG4gICAgICAgICAgICAvLyBHb29nbGUgQ2hyb21lIFBhY2thZ2VkIEFwcHMgZG9uJ3QgYWxsb3cgJ3VubG9hZCcgbGlzdGVuZXJzOiB1bmxvYWQgaXMgbm90IGF2YWlsYWJsZSBpbiBwYWNrYWdlZCBhcHBzXG4gICAgICAgICAgICB2YXIgZ29vZ2xlQ2hyb21lUGFja2FnZWRBcHAgPSB0eXBlb2YgY2hyb21lICE9PSBcInVuZGVmaW5lZFwiICYmIGNocm9tZS5hcHAgJiYgY2hyb21lLmFwcC5ydW50aW1lID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgICAgICFnb29nbGVDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsIHRoaXMudW5sb2FkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGEgc3RyaW5nIGludG8gYSB2YWxpZCBTSVAgcmVxdWVzdCBVUklcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YXJnZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTSVAuVVJJfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUubm9ybWFsaXplVGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gVXRpbHNfMS5VdGlscy5ub3JtYWxpemVUYXJnZXQodGFyZ2V0LCB0aGlzLmNvbmZpZ3VyYXRpb24uaG9zdHBvcnRQYXJhbXMpO1xuICAgIH07XG4gICAgVUEucHJvdG90eXBlLmdldExvZ2dlciA9IGZ1bmN0aW9uIChjYXRlZ29yeSwgbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nLmdldExvZ2dlcihjYXRlZ29yeSwgbGFiZWwpO1xuICAgIH07XG4gICAgVUEucHJvdG90eXBlLmdldExvZ2dlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvZztcbiAgICB9O1xuICAgIFVBLnByb3RvdHlwZS5nZXRTdXBwb3J0ZWRSZXNwb25zZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25UYWdzID0gW107XG4gICAgICAgIGlmICh0aGlzLmNvbnRhY3QucHViR3J1dSB8fCB0aGlzLmNvbnRhY3QudGVtcEdydXUpIHtcbiAgICAgICAgICAgIG9wdGlvblRhZ3MucHVzaChcImdydXVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5yZWwxMDAgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICAgICAgb3B0aW9uVGFncy5wdXNoKFwiMTAwcmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICAgICAgb3B0aW9uVGFncy5wdXNoKFwicmVwbGFjZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uVGFncy5wdXNoKFwib3V0Ym91bmRcIik7XG4gICAgICAgIG9wdGlvblRhZ3MgPSBvcHRpb25UYWdzLmNvbmNhdCh0aGlzLmNvbmZpZ3VyYXRpb24uZXh0cmFTdXBwb3J0ZWQgfHwgW10pO1xuICAgICAgICB2YXIgYWxsb3dVbnJlZ2lzdGVyZWQgPSB0aGlzLmNvbmZpZ3VyYXRpb24uaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncyB8fCBmYWxzZTtcbiAgICAgICAgdmFyIG9wdGlvblRhZ1NldCA9IHt9O1xuICAgICAgICBvcHRpb25UYWdzID0gb3B0aW9uVGFncy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvblRhZykge1xuICAgICAgICAgICAgdmFyIHJlZ2lzdGVyZWQgPSBDb25zdGFudHNfMS5DLk9QVElPTl9UQUdTW29wdGlvblRhZ107XG4gICAgICAgICAgICB2YXIgdW5pcXVlID0gIW9wdGlvblRhZ1NldFtvcHRpb25UYWddO1xuICAgICAgICAgICAgb3B0aW9uVGFnU2V0W29wdGlvblRhZ10gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIChyZWdpc3RlcmVkIHx8IGFsbG93VW5yZWdpc3RlcmVkKSAmJiB1bmlxdWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2Vzc2lvbiB0byB3aGljaCB0aGUgcmVxdWVzdCBiZWxvbmdzIHRvLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtTSVAuSW5jb21pbmdSZXF1ZXN0fSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtTSVAuT3V0Z29pbmdTZXNzaW9ufFNJUC5JbmNvbWluZ1Nlc3Npb258dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5maW5kU2Vzc2lvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb25zW3JlcXVlc3QuY2FsbElkICsgcmVxdWVzdC5mcm9tVGFnXSB8fFxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uc1tyZXF1ZXN0LmNhbGxJZCArIHJlcXVlc3QudG9UYWddIHx8XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBVQS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjayk7IH07XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxlcnNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBVQS5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBFbnVtc18xLlVBU3RhdHVzLlNUQVRVU19VU0VSX0NMT1NFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5lcnJvciB8fCB0aGlzLmVycm9yICE9PSBVQS5DLk5FVFdPUktfRVJST1IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfTk9UX1JFQURZO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFVBLkMuTkVUV09SS19FUlJPUjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uLiBTZXRzIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUuc2V0VHJhbnNwb3J0TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcImNvbm5lY3RlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vblRyYW5zcG9ydENvbm5lY3RlZCgpOyB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5vblRyYW5zcG9ydFJlY2VpdmVNc2cobWVzc2FnZSk7IH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInRyYW5zcG9ydEVycm9yXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uVHJhbnNwb3J0RXJyb3IoKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgY29ubmVjdGlvbiBldmVudC5cbiAgICAgKiBAZXZlbnRcbiAgICAgKiBAcGFyYW0ge1NJUC5UcmFuc3BvcnR9IHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBVQS5wcm90b3R5cGUub25UcmFuc3BvcnRDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZ3VyYXRpb24ucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIC8vIEluIGFuIGVmZm9yIHRvIG1haW50YWluIGJlaGF2aW9yIGZyb20gd2hlbiB3ZSBcImluaXRpYWxpemVkXCIgYW5cbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGZhY3RvcnksIHRoaXMgaXMgaW4gYSBQcm9taXNlLnRoZW5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVnaXN0ZXJDb250ZXh0LnJlZ2lzdGVyKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgU0lQIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSB0aGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlU3RyaW5nIFRoZSBtZXNzYWdlLlxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5vblRyYW5zcG9ydFJlY2VpdmVNc2cgPSBmdW5jdGlvbiAobWVzc2FnZVN0cmluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGNvcmVfMS5QYXJzZXIucGFyc2VNZXNzYWdlKG1lc3NhZ2VTdHJpbmcsIHRoaXMuZ2V0TG9nZ2VyKFwic2lwLnBhcnNlclwiKSk7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVBIGZhaWxlZCB0byBwYXJzZSBpbmNvbWluZyBTSVAgbWVzc2FnZSAtIGRpc2NhcmRpbmcuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gRW51bXNfMS5VQVN0YXR1cy5TVEFUVVNfVVNFUl9DTE9TRUQgJiYgbWVzc2FnZSBpbnN0YW5jZW9mIGNvcmVfMS5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVUEgcmVjZWl2ZWQgbWVzc2FnZSB3aGVuIHN0YXR1cyA9IFVTRVJfQ0xPU0VEIC0gYWJvcnRpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSB2YWxpZCBTSVAgcmVxdWVzdCBmb3JtdWxhdGVkIGJ5IGEgVUFDIE1VU1QsIGF0IGEgbWluaW11bSwgY29udGFpblxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIGhlYWRlciBmaWVsZHM6IFRvLCBGcm9tLCBDU2VxLCBDYWxsLUlELCBNYXgtRm9yd2FyZHMsXG4gICAgICAgIC8vIGFuZCBWaWE7IGFsbCBvZiB0aGVzZSBoZWFkZXIgZmllbGRzIGFyZSBtYW5kYXRvcnkgaW4gYWxsIFNJUFxuICAgICAgICAvLyByZXF1ZXN0cy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMVxuICAgICAgICB2YXIgaGFzTWluaW11bUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFuZGF0b3J5SGVhZGVycyA9IFtcImZyb21cIiwgXCJ0b1wiLCBcImNhbGxfaWRcIiwgXCJjc2VxXCIsIFwidmlhXCJdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYW5kYXRvcnlIZWFkZXJzXzEgPSBtYW5kYXRvcnlIZWFkZXJzOyBfaSA8IG1hbmRhdG9yeUhlYWRlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gbWFuZGF0b3J5SGVhZGVyc18xW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzSGVhZGVyKGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJNaXNzaW5nIG1hbmRhdG9yeSBoZWFkZXIgZmllbGQgOiBcIiArIGhlYWRlciArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXF1ZXN0IENoZWNrc1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIGNvcmVfMS5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2subWluaW11bUhlYWRlcnMoKS5cbiAgICAgICAgICAgIGlmICghaGFzTWluaW11bUhlYWRlcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJSZXF1ZXN0IG1pc3NpbmcgbWFuZGF0b3J5IGhlYWRlciBmaWVsZC4gRHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIGlzIG5vbi1zdGFuZGFyZCBhbmQgc2hvdWxkIGJlIGEgY29uZmlncnVhYmxlIGJlaGF2aW9yIChkZXNpcmFibGUgcmVnYXJkbGVzcykuXG4gICAgICAgICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIHJlamVjdCByZXF1ZXN0IGZyb20gb3Vyc2VsZiAodGhpcyBpbnN0YW5jZSBvZiBTSVAuanMpLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLnJmYzMyNjFfMTZfM180KCkuXG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2UudG9UYWcgJiYgbWVzc2FnZS5jYWxsSWQuc3Vic3RyKDAsIDUpID09PSB0aGlzLmNvbmZpZ3VyYXRpb24uc2lwanNJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckFnZW50Q29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4MiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGSVhNRTogVGhpcyBzaG91bGQgYmUgVHJhbnNwb3J0IGNoZWNrIGJlZm9yZSB3ZSBnZXQgaGVyZSAoU2VjdGlvbiAxOCkuXG4gICAgICAgICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIHJlamVjdCByZXF1ZXN0cyBpZiBib2R5IGxlbmd0aCB3cm9uZy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcG9ydCBvZiBTYW5pdHlDaGVjay5yZmMzMjYxXzE4XzNfcmVxdWVzdCgpLlxuICAgICAgICAgICAgdmFyIGxlbiA9IFV0aWxzXzEuVXRpbHMuc3RyX3V0ZjhfbGVuZ3RoKG1lc3NhZ2UuYm9keSk7XG4gICAgICAgICAgICB2YXIgY29udGVudExlbmd0aCA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCAmJiBsZW4gPCBOdW1iZXIoY29udGVudExlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJBZ2VudENvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlcG9uc2UgQ2hlY2tzXG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgY29yZV8xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2subWluaW11bUhlYWRlcnMoKS5cbiAgICAgICAgICAgIGlmICghaGFzTWluaW11bUhlYWRlcnMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJSZXNwb25zZSBtaXNzaW5nIG1hbmRhdG9yeSBoZWFkZXIgZmllbGQuIERyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDdXN0b20gU0lQLmpzIGNoZWNrIHRvIGRyb3AgcmVzcG9uc2VzIGlmIG11bHRpcGxlIFZpYSBoZWFkZXJzLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3J0IG9mIFNhbml0eUNoZWNrLnJmYzMyNjFfOF8xXzNfMygpLlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ2V0SGVhZGVycyhcInZpYVwiKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk1vcmUgdGhhbiBvbmUgVmlhIGhlYWRlciBmaWVsZCBwcmVzZW50IGluIHRoZSByZXNwb25zZS4gRHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBiZSBUcmFuc3BvcnQgY2hlY2sgYmVmb3JlIHdlIGdldCBoZXJlIChTZWN0aW9uIDE4KS5cbiAgICAgICAgICAgIC8vIEN1c3RvbSBTSVAuanMgY2hlY2sgdG8gZHJvcCByZXNwb25zZXMgaWYgYmFkIFZpYSBoZWFkZXIuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2sucmZjMzI2MV8xOF8xXzIoKS5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZpYS5ob3N0ICE9PSB0aGlzLmNvbmZpZ3VyYXRpb24udmlhSG9zdCB8fCBtZXNzYWdlLnZpYS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVmlhIHNlbnQtYnkgaW4gdGhlIHJlc3BvbnNlIGRvZXMgbm90IG1hdGNoIFVBIFZpYSBob3N0IHZhbHVlLiBEcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgc2hvdWxkIGJlIFRyYW5zcG9ydCBjaGVjayBiZWZvcmUgd2UgZ2V0IGhlcmUgKFNlY3Rpb24gMTgpLlxuICAgICAgICAgICAgLy8gQ3VzdG9tIFNJUC5qcyBjaGVjayB0byByZWplY3QgcmVxdWVzdHMgaWYgYm9keSBsZW5ndGggd3JvbmcuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHBvcnQgb2YgU2FuaXR5Q2hlY2sucmZjMzI2MV8xOF8zX3Jlc3BvbnNlKCkuXG4gICAgICAgICAgICB2YXIgbGVuID0gVXRpbHNfMS5VdGlscy5zdHJfdXRmOF9sZW5ndGgobWVzc2FnZS5ib2R5KTtcbiAgICAgICAgICAgIHZhciBjb250ZW50TGVuZ3RoID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICYmIGxlbiA8IE51bWJlcihjb250ZW50TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJNZXNzYWdlIGJvZHkgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIHZhbHVlIGluIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZC4gRHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgUmVxdWVzdFxuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIGNvcmVfMS5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJBZ2VudENvcmUucmVjZWl2ZUluY29taW5nUmVxdWVzdEZyb21UcmFuc3BvcnQobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIFJlc3BvbnNlXG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgY29yZV8xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJBZ2VudENvcmUucmVjZWl2ZUluY29taW5nUmVzcG9uc2VGcm9tVHJhbnNwb3J0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbWVzc2FnZSB0eXBlLlwiKTtcbiAgICB9O1xuICAgIC8vID09PT09PT09PT09PT09PT09XG4gICAgLy8gVXRpbHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PVxuICAgIFVBLnByb3RvdHlwZS5jaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeSA9IGZ1bmN0aW9uIChhdXRoZW50aWNhdGlvbkZhY3RvcnkpIHtcbiAgICAgICAgaWYgKCEoYXV0aGVudGljYXRpb25GYWN0b3J5IGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdXRoZW50aWNhdGlvbkZhY3RvcnkuaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5LmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aGVudGljYXRpb25GYWN0b3J5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBsb2FkLlxuICAgICAqIHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgVUEucHJvdG90eXBlLmxvYWRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBTZXR0aW5ncyBhbmQgZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgLyogSG9zdCBhZGRyZXNzXG4gICAgICAgICAgICAgKiBWYWx1ZSB0byBiZSBzZXQgaW4gVmlhIHNlbnRfYnkgYW5kIGhvc3QgcGFydCBvZiBDb250YWN0IEZRRE5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmlhSG9zdDogVXRpbHNfMS5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbigxMikgKyBcIi5pbnZhbGlkXCIsXG4gICAgICAgICAgICB1cmk6IG5ldyBjb3JlXzEuVVJJKFwic2lwXCIsIFwiYW5vbnltb3VzLlwiICsgVXRpbHNfMS5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig2KSwgXCJhbm9ueW1vdXMuaW52YWxpZFwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAvLyBDdXN0b20gQ29uZmlndXJhdGlvbiBTZXR0aW5nc1xuICAgICAgICAgICAgY3VzdG9tOiB7fSxcbiAgICAgICAgICAgIC8vIERpc3BsYXkgbmFtZVxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IFwiXCIsXG4gICAgICAgICAgICAvLyBQYXNzd29yZFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlZ2lzdGVyOiB0cnVlLFxuICAgICAgICAgICAgLy8gUmVnaXN0cmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczoge30sXG4gICAgICAgICAgICAvLyBUcmFuc3BvcnQgcmVsYXRlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICB0cmFuc3BvcnRDb25zdHJ1Y3RvcjogVHJhbnNwb3J0XzEuVHJhbnNwb3J0LFxuICAgICAgICAgICAgdHJhbnNwb3J0T3B0aW9uczoge30sXG4gICAgICAgICAgICB1c2VQcmVsb2FkZWRSb3V0ZTogZmFsc2UsXG4gICAgICAgICAgICAvLyBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgaW50byBVc2VyLUFnZW50IHJlcXVlc3QgaGVhZGVyXG4gICAgICAgICAgICB1c2VyQWdlbnRTdHJpbmc6IENvbnN0YW50c18xLkMuVVNFUl9BR0VOVCxcbiAgICAgICAgICAgIC8vIFNlc3Npb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgbm9BbnN3ZXJUaW1lb3V0OiA2MCxcbiAgICAgICAgICAgIC8vIEhhY2tzXG4gICAgICAgICAgICBoYWNrVmlhVGNwOiBmYWxzZSxcbiAgICAgICAgICAgIGhhY2tJcEluQ29udGFjdDogZmFsc2UsXG4gICAgICAgICAgICBoYWNrV3NzSW5UcmFuc3BvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFnczogZmFsc2UsXG4gICAgICAgICAgICAvLyBTZXNzaW9uIERlc2NyaXB0aW9uIEhhbmRsZXIgT3B0aW9uc1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IHt9LFxuICAgICAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uT3B0aW9uczoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRyYVN1cHBvcnRlZDogW10sXG4gICAgICAgICAgICBjb250YWN0TmFtZTogVXRpbHNfMS5VdGlscy5jcmVhdGVSYW5kb21Ub2tlbig4KSxcbiAgICAgICAgICAgIGNvbnRhY3RUcmFuc3BvcnQ6IFwid3NcIixcbiAgICAgICAgICAgIGZvcmNlUnBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgLy8gYXV0b3N0YXJ0aW5nXG4gICAgICAgICAgICBhdXRvc3RhcnQ6IHRydWUsXG4gICAgICAgICAgICBhdXRvc3RvcDogdHJ1ZSxcbiAgICAgICAgICAgIC8vIFJlbGlhYmxlIFByb3Zpc2lvbmFsIFJlc3BvbnNlc1xuICAgICAgICAgICAgcmVsMTAwOiBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5VTlNVUFBPUlRFRCxcbiAgICAgICAgICAgIC8vIERUTUYgdHlwZTogJ2luZm8nIG9yICdydHAnIChSRkMgNDczMylcbiAgICAgICAgICAgIC8vIFJUUCBQYXlsb2FkIFNwZWM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NzMzXG4gICAgICAgICAgICAvLyBXZWJSVEMgQXVkaW8gU3BlYzogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4NzRcbiAgICAgICAgICAgIGR0bWZUeXBlOiBDb25zdGFudHNfMS5DLmR0bWZUeXBlLklORk8sXG4gICAgICAgICAgICAvLyBSZXBsYWNlcyBoZWFkZXIgKFJGQyAzODkxKVxuICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzg5MVxuICAgICAgICAgICAgcmVwbGFjZXM6IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVELFxuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3Rvcnk6IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJfMS5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmRlZmF1bHRGYWN0b3J5LFxuICAgICAgICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiB0aGlzLmNoZWNrQXV0aGVudGljYXRpb25GYWN0b3J5KGZ1bmN0aW9uICh1YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLkRpZ2VzdEF1dGhlbnRpY2F0aW9uKHVhLmdldExvZ2dlckZhY3RvcnkoKSwgX3RoaXMuY29uZmlndXJhdGlvbi5hdXRob3JpemF0aW9uVXNlciwgX3RoaXMuY29uZmlndXJhdGlvbi5wYXNzd29yZCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFsbG93TGVnYWN5Tm90aWZpY2F0aW9uczogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd091dE9mRGlhbG9nUmVmZXJzOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbEZlYXR1cmVzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY29uZmlnQ2hlY2sgPSB0aGlzLmdldENvbmZpZ3VyYXRpb25DaGVjaygpO1xuICAgICAgICAvLyBDaGVjayBNYW5kYXRvcnkgcGFyYW1ldGVyc1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gY29uZmlnQ2hlY2subWFuZGF0b3J5KSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZFZhbHVlID0gY29uZmlnQ2hlY2subWFuZGF0b3J5W3BhcmFtZXRlcl0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1twYXJhbWV0ZXJdID0gY2hlY2tlZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gY29uZmlnQ2hlY2sub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWd1cmF0aW9uW3BhcmFtZXRlcl07XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBlbXB0eSBhcnJheSwgYnV0IHNob3VsZG4ndCBiZSwgYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmFtZXRlciB2YWx1ZSBpcyBudWxsLCBlbXB0eSBzdHJpbmcsIG9yIHVuZGVmaW5lZCB0aGVuIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBudW1iZXIgd2l0aCBOYU4gdmFsdWUgdGhlbiBhbHNvIGFwcGx5IGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IEpTIGRvZXMgbm90IGFsbG93IFwidmFsdWUgPT09IE5hTlwiLCB0aGUgZm9sbG93aW5nIGRvZXMgdGhlIHdvcms6XG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSBcIlwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZFZhbHVlID0gY29uZmlnQ2hlY2sub3B0aW9uYWxbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQb3N0IENvbmZpZ3VyYXRpb24gUHJvY2Vzc1xuICAgICAgICAvLyBBbGxvdyBwYXNzaW5nIDAgbnVtYmVyIGFzIGRpc3BsYXlOYW1lLlxuICAgICAgICBpZiAoc2V0dGluZ3MuZGlzcGxheU5hbWUgPT09IDApIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRpc3BsYXlOYW1lID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lwanNJZCBpbnN0YW5jZSBwYXJhbWV0ZXIuIFN0YXRpYyByYW5kb20gdGFnIG9mIGxlbmd0aCA1XG4gICAgICAgIHNldHRpbmdzLnNpcGpzSWQgPSBVdGlsc18xLlV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDUpO1xuICAgICAgICAvLyBTdHJpbmcgY29udGFpbmluZyBzZXR0aW5ncy51cmkgd2l0aG91dCBzY2hlbWUgYW5kIHVzZXIuXG4gICAgICAgIHZhciBob3N0cG9ydFBhcmFtcyA9IHNldHRpbmdzLnVyaS5jbG9uZSgpO1xuICAgICAgICBob3N0cG9ydFBhcmFtcy51c2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBzZXR0aW5ncy5ob3N0cG9ydFBhcmFtcyA9IGhvc3Rwb3J0UGFyYW1zLnRvUmF3KCkucmVwbGFjZSgvXnNpcDovaSwgXCJcIik7XG4gICAgICAgIC8qIENoZWNrIHdoZXRoZXIgYXV0aG9yaXphdGlvblVzZXIgaXMgZXhwbGljaXRseSBkZWZpbmVkLlxuICAgICAgICAgKiBUYWtlICdzZXR0aW5ncy51cmkudXNlcicgdmFsdWUgaWYgbm90LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFzZXR0aW5ncy5hdXRob3JpemF0aW9uVXNlcikge1xuICAgICAgICAgICAgc2V0dGluZ3MuYXV0aG9yaXphdGlvblVzZXIgPSBzZXR0aW5ncy51cmkudXNlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VyIG5vQW5zd2VyVGltZW91dFxuICAgICAgICBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgPSBzZXR0aW5ncy5ub0Fuc3dlclRpbWVvdXQgKiAxMDAwO1xuICAgICAgICAvLyBWaWEgSG9zdFxuICAgICAgICBpZiAoc2V0dGluZ3MuaGFja0lwSW5Db250YWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmhhY2tJcEluQ29udGFjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gMjU0O1xuICAgICAgICAgICAgICAgIHZhciBvY3RldCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0byAtIGZyb20gKyAxKSArIGZyb20pO1xuICAgICAgICAgICAgICAgIC8vIHJhbmRvbSBUZXN0LU5ldCBJUCAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTczNSlcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy52aWFIb3N0ID0gXCIxOTIuMC4yLlwiICsgb2N0ZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2V0dGluZ3MuaGFja0lwSW5Db250YWN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MudmlhSG9zdCA9IHNldHRpbmdzLmhhY2tJcEluQ29udGFjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb250YWN0IHRyYW5zcG9ydCBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKHNldHRpbmdzLmhhY2tXc3NJblRyYW5zcG9ydCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuY29udGFjdFRyYW5zcG9ydCA9IFwid3NzXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWN0ID0ge1xuICAgICAgICAgICAgcHViR3J1dTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGVtcEdydXU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVyaTogbmV3IGNvcmVfMS5VUkkoXCJzaXBcIiwgc2V0dGluZ3MuY29udGFjdE5hbWUsIHNldHRpbmdzLnZpYUhvc3QsIHVuZGVmaW5lZCwgeyB0cmFuc3BvcnQ6IHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnQgfSksXG4gICAgICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgICAgIHZhciBhbm9ueW1vdXMgPSBvcHRpb25zLmFub255bW91cyB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Ym91bmQgPSBvcHRpb25zLm91dGJvdW5kIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBjb250YWN0ID0gXCI8XCI7XG4gICAgICAgICAgICAgICAgaWYgKGFub255bW91cykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWN0ICs9IChfdGhpcy5jb250YWN0LnRlbXBHcnV1IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJzaXA6YW5vbnltb3VzQGFub255bW91cy5pbnZhbGlkO3RyYW5zcG9ydD1cIiArIHNldHRpbmdzLmNvbnRhY3RUcmFuc3BvcnQpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdCArPSAoX3RoaXMuY29udGFjdC5wdWJHcnV1IHx8IF90aGlzLmNvbnRhY3QudXJpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3V0Ym91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdCArPSBcIjtvYlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250YWN0ICs9IFwiPlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2tlbGV0b24gPSB7fTtcbiAgICAgICAgLy8gRmlsbCB0aGUgdmFsdWUgb2YgdGhlIGNvbmZpZ3VyYXRpb25fc2tlbGV0b25cbiAgICAgICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHNrZWxldG9uW3BhcmFtZXRlcl0gPSBzZXR0aW5nc1twYXJhbWV0ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb25maWd1cmF0aW9uLCBza2VsZXRvbik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBhZnRlciB2YWxpZGF0aW9uOlwiKTtcbiAgICAgICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyYW1ldGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCLCtyBcIiArIHBhcmFtZXRlciArIFwiOiBcIiArIHNldHRpbmdzW3BhcmFtZXRlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXNzd29yZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBwYXJhbWV0ZXIgKyBcIjogXCIgKyBcIk5PVCBTSE9XTlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidHJhbnNwb3J0Q29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIsK3IFwiICsgcGFyYW1ldGVyICsgXCI6IFwiICsgc2V0dGluZ3NbcGFyYW1ldGVyXS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiwrcgXCIgKyBwYXJhbWV0ZXIgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShzZXR0aW5nc1twYXJhbWV0ZXJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gY2hlY2tlci5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIFVBLnByb3RvdHlwZS5nZXRDb25maWd1cmF0aW9uQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYW5kYXRvcnk6IHt9LFxuICAgICAgICAgICAgb3B0aW9uYWw6IHtcbiAgICAgICAgICAgICAgICB1cmk6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoL15zaXA6L2kpLnRlc3QodXJpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJpID0gQ29uc3RhbnRzXzEuQy5TSVAgKyBcIjpcIiArIHVyaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gY29yZV8xLkdyYW1tYXIuVVJJUGFyc2UodXJpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZWQgfHwgIXBhcnNlZC51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHRyYW5zcG9ydENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnRDb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNwb3J0Q29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnM6IGZ1bmN0aW9uICh0cmFuc3BvcnRPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNwb3J0T3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25Vc2VyOiBmdW5jdGlvbiAoYXV0aG9yaXphdGlvblVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmVfMS5HcmFtbWFyLnBhcnNlKCdcIicgKyBhdXRob3JpemF0aW9uVXNlciArICdcIicsIFwicXVvdGVkX3N0cmluZ1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uVXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29yZV8xLkdyYW1tYXIucGFyc2UoJ1wiJyArIGRpc3BsYXlOYW1lICsgJ1wiJywgXCJkaXNwbGF5TmFtZVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZHRtZlR5cGU6IGZ1bmN0aW9uIChkdG1mVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGR0bWZUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvbnN0YW50c18xLkMuZHRtZlR5cGUuUlRQOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLmR0bWZUeXBlLlJUUDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29uc3RhbnRzXzEuQy5kdG1mVHlwZS5JTkZPOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLmR0bWZUeXBlLklORk87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhhY2tWaWFUY3A6IGZ1bmN0aW9uIChoYWNrVmlhVGNwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFja1ZpYVRjcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYWNrVmlhVGNwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYWNrSXBJbkNvbnRhY3Q6IGZ1bmN0aW9uIChoYWNrSXBJbkNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYWNrSXBJbkNvbnRhY3QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoYWNrSXBJbkNvbnRhY3QgPT09IFwic3RyaW5nXCIgJiYgY29yZV8xLkdyYW1tYXIucGFyc2UoaGFja0lwSW5Db250YWN0LCBcImhvc3RcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFja0lwSW5Db250YWN0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYWNrV3NzSW5UcmFuc3BvcnQ6IGZ1bmN0aW9uIChoYWNrV3NzSW5UcmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYWNrV3NzSW5UcmFuc3BvcnQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFja1dzc0luVHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYWNrQWxsb3dVbnJlZ2lzdGVyZWRPcHRpb25UYWdzOiBmdW5jdGlvbiAoaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhY2tBbGxvd1VucmVnaXN0ZXJlZE9wdGlvblRhZ3MgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udGFjdFRyYW5zcG9ydDogZnVuY3Rpb24gKGNvbnRhY3RUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250YWN0VHJhbnNwb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdFRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXh0cmFTdXBwb3J0ZWQ6IGZ1bmN0aW9uIChvcHRpb25UYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG9wdGlvblRhZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG9wdGlvblRhZ3NfMSA9IG9wdGlvblRhZ3M7IF9pIDwgb3B0aW9uVGFnc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG9wdGlvblRhZ3NfMVtfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uVGFncztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcmNlUnBvcnQ6IGZ1bmN0aW9uIChmb3JjZVJwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9yY2VScG9ydCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JjZVJwb3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub0Fuc3dlclRpbWVvdXQ6IGZ1bmN0aW9uIChub0Fuc3dlclRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNEZWNpbWFsKG5vQW5zd2VyVGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihub0Fuc3dlclRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbDEwMDogZnVuY3Rpb24gKHJlbDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVsMTAwID09PSBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlJFUVVJUkVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbDEwMCA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXBsYWNlczogZnVuY3Rpb24gKHJlcGxhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlcyA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuUkVRVUlSRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLnN1cHBvcnRlZC5SRVFVSVJFRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlcyA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlVOU1VQUE9SVEVEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKHJlZ2lzdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVnaXN0ZXIgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyT3B0aW9uczogZnVuY3Rpb24gKHJlZ2lzdGVyT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlZ2lzdGVyT3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdXNlUHJlbG9hZGVkUm91dGU6IGZ1bmN0aW9uICh1c2VQcmVsb2FkZWRSb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHVzZVByZWxvYWRlZFJvdXRlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZVByZWxvYWRlZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1c2VyQWdlbnRTdHJpbmc6IGZ1bmN0aW9uICh1c2VyQWdlbnRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1c2VyQWdlbnRTdHJpbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1c2VyQWdlbnRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dG9zdGFydDogZnVuY3Rpb24gKGF1dG9zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF1dG9zdGFydCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dG9zdG9wOiBmdW5jdGlvbiAoYXV0b3N0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRvc3RvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvc3RvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3Rvcnk6IGZ1bmN0aW9uIChzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnkgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF1dGhlbnRpY2F0aW9uRmFjdG9yeTogdGhpcy5jaGVja0F1dGhlbnRpY2F0aW9uRmFjdG9yeSxcbiAgICAgICAgICAgICAgICBhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIChhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhbGxvd0xlZ2FjeU5vdGlmaWNhdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dMZWdhY3lOb3RpZmljYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjdXN0b206IGZ1bmN0aW9uIChjdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b20gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXN0b207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbnRhY3ROYW1lOiBmdW5jdGlvbiAoY29udGFjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250YWN0TmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3ROYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleHBlcmltZW50YWxGZWF0dXJlczogZnVuY3Rpb24gKGV4cGVyaW1lbnRhbEZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwZXJpbWVudGFsRmVhdHVyZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhwZXJpbWVudGFsRmVhdHVyZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgVUEuQyA9IHtcbiAgICAgICAgLy8gVUEgc3RhdHVzIGNvZGVzXG4gICAgICAgIFNUQVRVU19JTklUOiAwLFxuICAgICAgICBTVEFUVVNfU1RBUlRJTkc6IDEsXG4gICAgICAgIFNUQVRVU19SRUFEWTogMixcbiAgICAgICAgU1RBVFVTX1VTRVJfQ0xPU0VEOiAzLFxuICAgICAgICBTVEFUVVNfTk9UX1JFQURZOiA0LFxuICAgICAgICAvLyBVQSBlcnJvciBjb2Rlc1xuICAgICAgICBDT05GSUdVUkFUSU9OX0VSUk9SOiAxLFxuICAgICAgICBORVRXT1JLX0VSUk9SOiAyLFxuICAgICAgICBBTExPV0VEX01FVEhPRFM6IFtcbiAgICAgICAgICAgIFwiQUNLXCIsXG4gICAgICAgICAgICBcIkNBTkNFTFwiLFxuICAgICAgICAgICAgXCJJTlZJVEVcIixcbiAgICAgICAgICAgIFwiTUVTU0FHRVwiLFxuICAgICAgICAgICAgXCJCWUVcIixcbiAgICAgICAgICAgIFwiT1BUSU9OU1wiLFxuICAgICAgICAgICAgXCJJTkZPXCIsXG4gICAgICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICAgICAgXCJSRUZFUlwiXG4gICAgICAgIF0sXG4gICAgICAgIEFDQ0VQVEVEX0JPRFlfVFlQRVM6IFtcbiAgICAgICAgICAgIFwiYXBwbGljYXRpb24vc2RwXCIsXG4gICAgICAgICAgICBcImFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIlxuICAgICAgICBdLFxuICAgICAgICBNQVhfRk9SV0FSRFM6IDcwLFxuICAgICAgICBUQUdfTEVOR1RIOiAxMFxuICAgIH07XG4gICAgcmV0dXJuIFVBO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuVUEgPSBVQTtcbihmdW5jdGlvbiAoVUEpIHtcbiAgICB2YXIgRHRtZlR5cGU7XG4gICAgKGZ1bmN0aW9uIChEdG1mVHlwZSkge1xuICAgICAgICBEdG1mVHlwZVtcIlJUUFwiXSA9IFwicnRwXCI7XG4gICAgICAgIER0bWZUeXBlW1wiSU5GT1wiXSA9IFwiaW5mb1wiO1xuICAgIH0pKER0bWZUeXBlID0gVUEuRHRtZlR5cGUgfHwgKFVBLkR0bWZUeXBlID0ge30pKTtcbn0pKFVBID0gZXhwb3J0cy5VQSB8fCAoZXhwb3J0cy5VQSA9IHt9KSk7XG5leHBvcnRzLlVBID0gVUE7XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY29uZmlndXJhdGlvbiBnaXZlIGEgVUEuXG4gKiBAcGFyYW0gdWEgVUFcbiAqL1xuZnVuY3Rpb24gbWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBKHVhKSB7XG4gICAgLy8gRklYTUU6IENvbmZpZ3VyYXRpb24gVVJJIGlzIGEgYmFkIG1peCBvZiB0eXBlcyBjdXJyZW50bHkuIEl0IGFsc28gbmVlZHMgdG8gZXhpc3QuXG4gICAgaWYgKCEodWEuY29uZmlndXJhdGlvbi51cmkgaW5zdGFuY2VvZiBjb3JlXzEuVVJJKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIFVSSSBub3QgaW5zdGFuY2Ugb2YgVVJJLlwiKTtcbiAgICB9XG4gICAgdmFyIGFvciA9IHVhLmNvbmZpZ3VyYXRpb24udXJpO1xuICAgIHZhciBjb250YWN0ID0gdWEuY29udGFjdDtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB1YS5jb25maWd1cmF0aW9uLmRpc3BsYXlOYW1lID8gdWEuY29uZmlndXJhdGlvbi5kaXNwbGF5TmFtZSA6IFwiXCI7XG4gICAgdmFyIGhhY2tWaWFUY3AgPSB1YS5jb25maWd1cmF0aW9uLmhhY2tWaWFUY3AgPyB0cnVlIDogZmFsc2U7XG4gICAgdmFyIHJvdXRlU2V0ID0gdWEuY29uZmlndXJhdGlvbi51c2VQcmVsb2FkZWRSb3V0ZSAmJiB1YS50cmFuc3BvcnQuc2VydmVyICYmIHVhLnRyYW5zcG9ydC5zZXJ2ZXIuc2lwVXJpID9cbiAgICAgICAgW3VhLnRyYW5zcG9ydC5zZXJ2ZXIuc2lwVXJpXSA6XG4gICAgICAgIFtdO1xuICAgIHZhciBzaXBqc0lkID0gdWEuY29uZmlndXJhdGlvbi5zaXBqc0lkIHx8IFV0aWxzXzEuVXRpbHMuY3JlYXRlUmFuZG9tVG9rZW4oNSk7XG4gICAgdmFyIHN1cHBvcnRlZE9wdGlvblRhZ3MgPSBbXTtcbiAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2goXCJvdXRib3VuZFwiKTsgLy8gVE9ETzogaXMgdGhpcyByZWFsbHkgc3VwcG9ydGVkP1xuICAgIGlmICh1YS5jb25maWd1cmF0aW9uLnJlbDEwMCA9PT0gQ29uc3RhbnRzXzEuQy5zdXBwb3J0ZWQuU1VQUE9SVEVEKSB7XG4gICAgICAgIHN1cHBvcnRlZE9wdGlvblRhZ3MucHVzaChcIjEwMHJlbFwiKTtcbiAgICB9XG4gICAgaWYgKHVhLmNvbmZpZ3VyYXRpb24ucmVwbGFjZXMgPT09IENvbnN0YW50c18xLkMuc3VwcG9ydGVkLlNVUFBPUlRFRCkge1xuICAgICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzLnB1c2goXCJyZXBsYWNlc1wiKTtcbiAgICB9XG4gICAgaWYgKHVhLmNvbmZpZ3VyYXRpb24uZXh0cmFTdXBwb3J0ZWQpIHtcbiAgICAgICAgc3VwcG9ydGVkT3B0aW9uVGFncy5wdXNoLmFwcGx5KHN1cHBvcnRlZE9wdGlvblRhZ3MsIHVhLmNvbmZpZ3VyYXRpb24uZXh0cmFTdXBwb3J0ZWQpO1xuICAgIH1cbiAgICBpZiAoIXVhLmNvbmZpZ3VyYXRpb24uaGFja0FsbG93VW5yZWdpc3RlcmVkT3B0aW9uVGFncykge1xuICAgICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzID0gc3VwcG9ydGVkT3B0aW9uVGFncy5maWx0ZXIoZnVuY3Rpb24gKG9wdGlvblRhZykgeyByZXR1cm4gQ29uc3RhbnRzXzEuQy5PUFRJT05fVEFHU1tvcHRpb25UYWddOyB9KTtcbiAgICB9XG4gICAgc3VwcG9ydGVkT3B0aW9uVGFncyA9IEFycmF5LmZyb20obmV3IFNldChzdXBwb3J0ZWRPcHRpb25UYWdzKSk7IC8vIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXNcbiAgICB2YXIgc3VwcG9ydGVkT3B0aW9uVGFnc1Jlc3BvbnNlID0gdWEuZ2V0U3VwcG9ydGVkUmVzcG9uc2VPcHRpb25zKCk7XG4gICAgdmFyIHVzZXJBZ2VudEhlYWRlckZpZWxkVmFsdWUgPSB1YS5jb25maWd1cmF0aW9uLnVzZXJBZ2VudFN0cmluZyB8fCBcInNpcGpzXCI7XG4gICAgaWYgKCEodWEuY29uZmlndXJhdGlvbi52aWFIb3N0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIHZpYSBob3N0IHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgdmFyIHZpYUZvcmNlUnBvcnQgPSB1YS5jb25maWd1cmF0aW9uLmZvcmNlUnBvcnQgPyB0cnVlIDogZmFsc2U7XG4gICAgdmFyIHZpYUhvc3QgPSB1YS5jb25maWd1cmF0aW9uLnZpYUhvc3Q7XG4gICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG4gICAgICAgIGFvcjogYW9yLFxuICAgICAgICBjb250YWN0OiBjb250YWN0LFxuICAgICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGhhY2tWaWFUY3A6IGhhY2tWaWFUY3AsXG4gICAgICAgIGxvZ2dlckZhY3Rvcnk6IHVhLmdldExvZ2dlckZhY3RvcnkoKSxcbiAgICAgICAgcm91dGVTZXQ6IHJvdXRlU2V0LFxuICAgICAgICBzaXBqc0lkOiBzaXBqc0lkLFxuICAgICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzOiBzdXBwb3J0ZWRPcHRpb25UYWdzLFxuICAgICAgICBzdXBwb3J0ZWRPcHRpb25UYWdzUmVzcG9uc2U6IHN1cHBvcnRlZE9wdGlvblRhZ3NSZXNwb25zZSxcbiAgICAgICAgdXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZTogdXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZSxcbiAgICAgICAgdmlhRm9yY2VScG9ydDogdmlhRm9yY2VScG9ydCxcbiAgICAgICAgdmlhSG9zdDogdmlhSG9zdCxcbiAgICAgICAgYXV0aGVudGljYXRpb25GYWN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodWEuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdWEuY29uZmlndXJhdGlvbi5hdXRoZW50aWNhdGlvbkZhY3RvcnkodWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNwb3J0QWNjZXNzb3I6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVhLnRyYW5zcG9ydDsgfVxuICAgIH07XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb247XG59XG5leHBvcnRzLm1ha2VVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbkZyb21VQSA9IG1ha2VVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbkZyb21VQTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIGdyYW1tYXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbWVzc2FnZXMvZ3JhbW1hclwiKTtcbnZhciB1cmlfMSA9IHJlcXVpcmUoXCIuL2NvcmUvbWVzc2FnZXMvdXJpXCIpO1xudmFyIFV0aWxzO1xuKGZ1bmN0aW9uIChVdGlscykge1xuICAgIGZ1bmN0aW9uIGRlZmVyKCkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB7fTtcbiAgICAgICAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH1cbiAgICBVdGlscy5kZWZlciA9IGRlZmVyO1xuICAgIGZ1bmN0aW9uIHJlZHVjZVByb21pc2VzKGFyciwgdmFsKSB7XG4gICAgICAgIHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGZuKSB7XG4gICAgICAgICAgICBhY2MgPSBhY2MudGhlbihmbik7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUodmFsKSk7XG4gICAgfVxuICAgIFV0aWxzLnJlZHVjZVByb21pc2VzID0gcmVkdWNlUHJvbWlzZXM7XG4gICAgZnVuY3Rpb24gc3RyX3V0ZjhfbGVuZ3RoKHN0cikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJVtBLUZcXGRdezJ9L2csIFwiVVwiKS5sZW5ndGg7XG4gICAgfVxuICAgIFV0aWxzLnN0cl91dGY4X2xlbmd0aCA9IHN0cl91dGY4X2xlbmd0aDtcbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUZha2VTRFAoYm9keSkge1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBib2R5LmluZGV4T2YoXCJvPVwiKTtcbiAgICAgICAgdmFyIGVuZCA9IGJvZHkuaW5kZXhPZihcIlxcclxcblwiLCBzdGFydCk7XG4gICAgICAgIHJldHVybiBcInY9MFxcclxcblwiICsgYm9keS5zbGljZShzdGFydCwgZW5kKSArIFwiXFxyXFxucz0tXFxyXFxudD0wIDBcXHJcXG5jPUlOIElQNCAwLjAuMC4wXCI7XG4gICAgfVxuICAgIFV0aWxzLmdlbmVyYXRlRmFrZVNEUCA9IGdlbmVyYXRlRmFrZVNEUDtcbiAgICBmdW5jdGlvbiBpc0RlY2ltYWwobnVtKSB7XG4gICAgICAgIHZhciBudW1Bc051bSA9IHBhcnNlSW50KG51bSwgMTApO1xuICAgICAgICByZXR1cm4gIWlzTmFOKG51bUFzTnVtKSAmJiAocGFyc2VGbG9hdChudW0pID09PSBudW1Bc051bSk7XG4gICAgfVxuICAgIFV0aWxzLmlzRGVjaW1hbCA9IGlzRGVjaW1hbDtcbiAgICBmdW5jdGlvbiBjcmVhdGVSYW5kb21Ub2tlbihzaXplLCBiYXNlKSB7XG4gICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHsgYmFzZSA9IDMyOyB9XG4gICAgICAgIHZhciB0b2tlbiA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJhc2UpO1xuICAgICAgICAgICAgdG9rZW4gKz0gci50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIFV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuID0gY3JlYXRlUmFuZG9tVG9rZW47XG4gICAgZnVuY3Rpb24gbmV3VGFnKCkge1xuICAgICAgICAvLyB1c2VkIHRvIHVzZSB0aGUgY29uc3RhbnQgaW4gVUFcbiAgICAgICAgcmV0dXJuIFV0aWxzLmNyZWF0ZVJhbmRvbVRva2VuKDEwKTtcbiAgICB9XG4gICAgVXRpbHMubmV3VGFnID0gbmV3VGFnO1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS91c2Vycy8xMDk1MzgvYnJvb2ZhXG4gICAgZnVuY3Rpb24gbmV3VVVJRCgpIHtcbiAgICAgICAgdmFyIFVVSUQgPSBcInh4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTYpO1xuICAgICAgICAgICAgdmFyIHYgPSBjID09PSBcInhcIiA/IHIgOiAociAlIDQgKyA4KTtcbiAgICAgICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBVVUlEO1xuICAgIH1cbiAgICBVdGlscy5uZXdVVUlEID0gbmV3VVVJRDtcbiAgICAvKlxuICAgICAqIE5vcm1hbGl6ZSBTSVAgVVJJLlxuICAgICAqIE5PVEU6IEl0IGRvZXMgbm90IGFsbG93IGEgU0lQIFVSSSB3aXRob3V0IHVzZXJuYW1lLlxuICAgICAqIEFjY2VwdHMgJ3NpcCcsICdzaXBzJyBhbmQgJ3RlbCcgVVJJcyBhbmQgY29udmVydCB0aGVtIGludG8gJ3NpcCcuXG4gICAgICogRGV0ZWN0cyB0aGUgZG9tYWluIHBhcnQgKGlmIGdpdmVuKSBhbmQgcHJvcGVybHkgaGV4LWVzY2FwZXMgdGhlIHVzZXIgcG9ydGlvbi5cbiAgICAgKiBJZiB0aGUgdXNlciBwb3J0aW9uIGhhcyBvbmx5ICd0ZWwnIG51bWJlciBzeW1ib2xzIHRoZSB1c2VyIHBvcnRpb24gaXMgY2xlYW4gb2YgJ3RlbCcgdmlzdWFsIHNlcGFyYXRvcnMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkb21haW5dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVGFyZ2V0KHRhcmdldCwgZG9tYWluKSB7XG4gICAgICAgIC8vIElmIG5vIHRhcmdldCBpcyBnaXZlbiB0aGVuIHJhaXNlIGFuIGVycm9yLlxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gSWYgYSBTSVAuVVJJIGluc3RhbmNlIGlzIGdpdmVuIHRoZW4gcmV0dXJuIGl0LlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCBpbnN0YW5jZW9mIHVyaV8xLlVSSSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIHNwbGl0IGl0IGJ5ICdAJzpcbiAgICAgICAgICAgIC8vIC0gTGFzdCBmcmFnbWVudCBpcyB0aGUgZGVzaXJlZCBkb21haW4uXG4gICAgICAgICAgICAvLyAtIE90aGVyd2lzZSBhcHBlbmQgdGhlIGdpdmVuIGRvbWFpbiBhcmd1bWVudC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0QXJyYXkgPSB0YXJnZXQuc3BsaXQoXCJAXCIpO1xuICAgICAgICAgICAgdmFyIHRhcmdldFVzZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgc3dpdGNoICh0YXJnZXRBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXNlciA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVzZXIgPSB0YXJnZXRBcnJheVswXTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RG9tYWluID0gdGFyZ2V0QXJyYXlbMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFVzZXIgPSB0YXJnZXRBcnJheS5zbGljZSgwLCB0YXJnZXRBcnJheS5sZW5ndGggLSAxKS5qb2luKFwiQFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RG9tYWluID0gdGFyZ2V0QXJyYXlbdGFyZ2V0QXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIFVSSSBzY2hlbWUgKGlmIHByZXNlbnQpLlxuICAgICAgICAgICAgdGFyZ2V0VXNlciA9IHRhcmdldFVzZXIucmVwbGFjZSgvXihzaXBzP3x0ZWwpOi9pLCBcIlwiKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSAndGVsJyB2aXN1YWwgc2VwYXJhdG9ycyBpZiB0aGUgdXNlciBwb3J0aW9uIGp1c3QgY29udGFpbnMgJ3RlbCcgbnVtYmVyIHN5bWJvbHMuXG4gICAgICAgICAgICBpZiAoL15bXFwtXFwuXFwoXFwpXSpcXCs/WzAtOVxcLVxcLlxcKFxcKV0rJC8udGVzdCh0YXJnZXRVc2VyKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFVzZXIgPSB0YXJnZXRVc2VyLnJlcGxhY2UoL1tcXC1cXC5cXChcXCldL2csIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGNvbXBsZXRlIFNJUCBVUkkuXG4gICAgICAgICAgICB0YXJnZXQgPSBDb25zdGFudHNfMS5DLlNJUCArIFwiOlwiICsgVXRpbHMuZXNjYXBlVXNlcih0YXJnZXRVc2VyKSArIFwiQFwiICsgdGFyZ2V0RG9tYWluO1xuICAgICAgICAgICAgLy8gRmluYWxseSBwYXJzZSB0aGUgcmVzdWx0aW5nIFVSSS5cbiAgICAgICAgICAgIHJldHVybiBncmFtbWFyXzEuR3JhbW1hci5VUklQYXJzZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIFV0aWxzLm5vcm1hbGl6ZVRhcmdldCA9IG5vcm1hbGl6ZVRhcmdldDtcbiAgICAvKlxuICAgICAqIEhleC1lc2NhcGUgYSBTSVAgVVJJIHVzZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVVzZXIodXNlcikge1xuICAgICAgICAvLyBEb24ndCBoZXgtZXNjYXBlICc6JyAoJTNBKSwgJysnICglMkIpLCAnPycgKCUzRlwiKSwgJy8nICglMkYpLlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1c2VyKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lM0EvaWcsIFwiOlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUyQi9pZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNGL2lnLCBcIj9cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lMkYvaWcsIFwiL1wiKTtcbiAgICB9XG4gICAgVXRpbHMuZXNjYXBlVXNlciA9IGVzY2FwZVVzZXI7XG4gICAgZnVuY3Rpb24gaGVhZGVyaXplKHN0cikge1xuICAgICAgICB2YXIgZXhjZXB0aW9ucyA9IHtcbiAgICAgICAgICAgIFwiQ2FsbC1JZFwiOiBcIkNhbGwtSURcIixcbiAgICAgICAgICAgIFwiQ3NlcVwiOiBcIkNTZXFcIixcbiAgICAgICAgICAgIFwiTWluLVNlXCI6IFwiTWluLVNFXCIsXG4gICAgICAgICAgICBcIlJhY2tcIjogXCJSQWNrXCIsXG4gICAgICAgICAgICBcIlJzZXFcIjogXCJSU2VxXCIsXG4gICAgICAgICAgICBcIld3dy1BdXRoZW50aWNhdGVcIjogXCJXV1ctQXV0aGVudGljYXRlXCIsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuYW1lID0gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXy9nLCBcIi1cIikuc3BsaXQoXCItXCIpO1xuICAgICAgICB2YXIgcGFydHMgPSBuYW1lLmxlbmd0aDtcbiAgICAgICAgdmFyIGhuYW1lID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgcGFydCA9IDA7IHBhcnQgPCBwYXJ0czsgcGFydCsrKSB7XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGhuYW1lICs9IFwiLVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG5hbWUgKz0gbmFtZVtwYXJ0XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWVbcGFydF0uc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGNlcHRpb25zW2huYW1lXSkge1xuICAgICAgICAgICAgaG5hbWUgPSBleGNlcHRpb25zW2huYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG5hbWU7XG4gICAgfVxuICAgIFV0aWxzLmhlYWRlcml6ZSA9IGhlYWRlcml6ZTtcbiAgICBmdW5jdGlvbiBzaXBFcnJvckNhdXNlKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgZm9yICh2YXIgY2F1c2UgaW4gQ29uc3RhbnRzXzEuQy5TSVBfRVJST1JfQ0FVU0VTKSB7XG4gICAgICAgICAgICBpZiAoQ29uc3RhbnRzXzEuQy5TSVBfRVJST1JfQ0FVU0VTW2NhdXNlXS5pbmRleE9mKHN0YXR1c0NvZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb25zdGFudHNfMS5DLmNhdXNlc1tjYXVzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnN0YW50c18xLkMuY2F1c2VzLlNJUF9GQUlMVVJFX0NPREU7XG4gICAgfVxuICAgIFV0aWxzLnNpcEVycm9yQ2F1c2UgPSBzaXBFcnJvckNhdXNlO1xuICAgIGZ1bmN0aW9uIGdldFJlYXNvblBocmFzZShjb2RlLCBzcGVjaWZpYykge1xuICAgICAgICByZXR1cm4gc3BlY2lmaWMgfHwgQ29uc3RhbnRzXzEuQy5SRUFTT05fUEhSQVNFW2NvZGVdIHx8IFwiXCI7XG4gICAgfVxuICAgIFV0aWxzLmdldFJlYXNvblBocmFzZSA9IGdldFJlYXNvblBocmFzZTtcbiAgICBmdW5jdGlvbiBnZXRSZWFzb25IZWFkZXJWYWx1ZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgcmVhc29uID0gVXRpbHMuZ2V0UmVhc29uUGhyYXNlKGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHJldHVybiBcIlNJUDtjYXVzZT1cIiArIGNvZGUgKyAnO3RleHQ9XCInICsgcmVhc29uICsgJ1wiJztcbiAgICB9XG4gICAgVXRpbHMuZ2V0UmVhc29uSGVhZGVyVmFsdWUgPSBnZXRSZWFzb25IZWFkZXJWYWx1ZTtcbiAgICBmdW5jdGlvbiBnZXRDYW5jZWxSZWFzb24oY29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmIChjb2RlICYmIGNvZGUgPCAyMDAgfHwgY29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoY29kZSwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBVdGlscy5nZXRDYW5jZWxSZWFzb24gPSBnZXRDYW5jZWxSZWFzb247XG4gICAgZnVuY3Rpb24gYnVpbGRTdGF0dXNMaW5lKGNvZGUsIHJlYXNvbikge1xuICAgICAgICAvLyBWYWxpZGF0ZSBjb2RlIGFuZCByZWFzb24gdmFsdWVzXG4gICAgICAgIGlmICghY29kZSB8fCAoY29kZSA8IDEwMCB8fCBjb2RlID4gNjk5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbiAhPT0gXCJzdHJpbmdcIiAmJiAhKHJlYXNvbiBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHJlYXNvbjogXCIgKyByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJlYXNvbiA9IFV0aWxzLmdldFJlYXNvblBocmFzZShjb2RlLCByZWFzb24pO1xuICAgICAgICByZXR1cm4gXCJTSVAvMi4wIFwiICsgY29kZSArIFwiIFwiICsgcmVhc29uICsgXCJcXHJcXG5cIjtcbiAgICB9XG4gICAgVXRpbHMuYnVpbGRTdGF0dXNMaW5lID0gYnVpbGRTdGF0dXNMaW5lO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJvZHkgZ2l2ZW4gYSBCb2R5T2JqLlxuICAgICAqIEBwYXJhbSBib2R5T2JqIEJvZHkgT2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUJvZHlPYmooYm9keU9iaikge1xuICAgICAgICB2YXIgY29udGVudCA9IGJvZHlPYmouYm9keTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gYm9keU9iai5jb250ZW50VHlwZTtcbiAgICAgICAgdmFyIGNvbnRlbnREaXNwb3NpdGlvbiA9IGNvbnRlbnRUeXBlVG9Db250ZW50RGlzcG9zaXRpb24oY29udGVudFR5cGUpO1xuICAgICAgICB2YXIgYm9keSA9IHsgY29udGVudERpc3Bvc2l0aW9uOiBjb250ZW50RGlzcG9zaXRpb24sIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSwgY29udGVudDogY29udGVudCB9O1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgVXRpbHMuZnJvbUJvZHlPYmogPSBmcm9tQm9keU9iajtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBCb2R5T2JqIGdpdmVuIGEgQm9keS5cbiAgICAgKiBAcGFyYW0gYm9keU9iaiBCb2R5IE9iamVjdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQm9keU9iaihib2R5KSB7XG4gICAgICAgIHZhciBib2R5T2JqID0ge1xuICAgICAgICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGJvZHkuY29udGVudFR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJvZHlPYmo7XG4gICAgfVxuICAgIFV0aWxzLnRvQm9keU9iaiA9IHRvQm9keU9iajtcbiAgICAvLyBJZiB0aGUgQ29udGVudC1EaXNwb3NpdGlvbiBoZWFkZXIgZmllbGQgaXMgbWlzc2luZywgYm9kaWVzIG9mXG4gICAgLy8gQ29udGVudC1UeXBlIGFwcGxpY2F0aW9uL3NkcCBpbXBseSB0aGUgZGlzcG9zaXRpb24gXCJzZXNzaW9uXCIsIHdoaWxlXG4gICAgLy8gb3RoZXIgY29udGVudCB0eXBlcyBpbXBseSBcInJlbmRlclwiLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgZnVuY3Rpb24gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vc2RwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInNlc3Npb25cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcInJlbmRlclwiO1xuICAgICAgICB9XG4gICAgfVxufSkoVXRpbHMgPSBleHBvcnRzLlV0aWxzIHx8IChleHBvcnRzLlV0aWxzID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0cmlwUGF5bG9hZCA9IGZ1bmN0aW9uIChzZHAsIHBheWxvYWQpIHtcbiAgICB2YXIgbWVkaWFEZXNjcyA9IFtdO1xuICAgIHZhciBsaW5lcyA9IHNkcC5zcGxpdCgvXFxyXFxuLyk7XG4gICAgdmFyIGN1cnJlbnRNZWRpYURlc2M7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIGlmICgvXm09KD86YXVkaW98dmlkZW8pLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICBjdXJyZW50TWVkaWFEZXNjID0ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHN0cmlwcGVkOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lZGlhRGVzY3MucHVzaChjdXJyZW50TWVkaWFEZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50TWVkaWFEZXNjKSB7XG4gICAgICAgICAgICB2YXIgcnRwbWFwID0gL15hPXJ0cG1hcDooXFxkKykgKFteL10rKVxcLy8uZXhlYyhsaW5lKTtcbiAgICAgICAgICAgIGlmIChydHBtYXAgJiYgcGF5bG9hZCA9PT0gcnRwbWFwWzJdKSB7XG4gICAgICAgICAgICAgICAgbGluZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNZWRpYURlc2Muc3RyaXBwZWQucHVzaChydHBtYXBbMV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBEb24ndCBpbmNyZW1lbnQgJ2knXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIG1lZGlhRGVzY3NfMSA9IG1lZGlhRGVzY3M7IF9pIDwgbWVkaWFEZXNjc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWVkaWFEZXNjID0gbWVkaWFEZXNjc18xW19pXTtcbiAgICAgICAgdmFyIG1saW5lID0gbGluZXNbbWVkaWFEZXNjLmluZGV4XS5zcGxpdChcIiBcIik7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmlyc3QgMyBwYXJhbWV0ZXJzIG9mIHRoZSBtbGluZS4gVGhlIGNvZGVjIGluZm9ybWF0aW9uIGlzIGFmdGVyIHRoYXRcbiAgICAgICAgZm9yICh2YXIgaiA9IDM7IGogPCBtbGluZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBpZiAobWVkaWFEZXNjLnN0cmlwcGVkLmluZGV4T2YobWxpbmVbal0pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1saW5lLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBsaW5lc1ttZWRpYURlc2MuaW5kZXhdID0gbWxpbmUuam9pbihcIiBcIik7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxyXFxuXCIpO1xufTtcbnZhciBzdHJpcE1lZGlhRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoc2RwLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBkZXNjcmlwdGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJtPVwiICsgZGVzY3JpcHRpb24gKyBcIi4qJFwiLCBcImdtXCIpO1xuICAgIHZhciBncm91cFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeYT1ncm91cDouKiRcIiwgXCJnbVwiKTtcbiAgICBpZiAoZGVzY3JpcHRpb25SZWdFeHAudGVzdChzZHApKSB7XG4gICAgICAgIHZhciBtaWRMaW5lVG9SZW1vdmVfMTtcbiAgICAgICAgc2RwID0gc2RwLnNwbGl0KC9ebT0vZ20pLmZpbHRlcihmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgICAgaWYgKHNlY3Rpb24uc3Vic3RyKDAsIGRlc2NyaXB0aW9uLmxlbmd0aCkgPT09IGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWlkTGluZVRvUmVtb3ZlXzEgPSBzZWN0aW9uLm1hdGNoKC9eYT1taWQ6LiokL2dtKTtcbiAgICAgICAgICAgICAgICBpZiAobWlkTGluZVRvUmVtb3ZlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ZXAgPSBtaWRMaW5lVG9SZW1vdmVfMVswXS5tYXRjaCgvOi4rJC9nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZExpbmVUb1JlbW92ZV8xID0gc3RlcFswXS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pLmpvaW4oXCJtPVwiKTtcbiAgICAgICAgdmFyIGdyb3VwTGluZSA9IHNkcC5tYXRjaChncm91cFJlZ0V4cCk7XG4gICAgICAgIGlmIChncm91cExpbmUgJiYgZ3JvdXBMaW5lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwTGluZVBvcnRpb24gPSBncm91cExpbmVbMF07XG4gICAgICAgICAgICB2YXIgZ3JvdXBSZWdFeHBSZXBsYWNlID0gbmV3IFJlZ0V4cChcIlxcICpcIiArIG1pZExpbmVUb1JlbW92ZV8xICsgXCJbXlxcIF0qXCIsIFwiZ1wiKTtcbiAgICAgICAgICAgIGdyb3VwTGluZVBvcnRpb24gPSBncm91cExpbmVQb3J0aW9uLnJlcGxhY2UoZ3JvdXBSZWdFeHBSZXBsYWNlLCBcIlwiKTtcbiAgICAgICAgICAgIHNkcCA9IHNkcC5zcGxpdChncm91cFJlZ0V4cCkuam9pbihncm91cExpbmVQb3J0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2RwO1xufTtcbmZ1bmN0aW9uIHN0cmlwVGNwQ2FuZGlkYXRlcyhkZXNjcmlwdGlvbikge1xuICAgIGRlc2NyaXB0aW9uLnNkcCA9IChkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIikucmVwbGFjZSgvXmE9Y2FuZGlkYXRlOlxcZCsgXFxkKyB0Y3AgLio/XFxyXFxuL2ltZywgXCJcIik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG59XG5leHBvcnRzLnN0cmlwVGNwQ2FuZGlkYXRlcyA9IHN0cmlwVGNwQ2FuZGlkYXRlcztcbmZ1bmN0aW9uIHN0cmlwVGVsZXBob25lRXZlbnQoZGVzY3JpcHRpb24pIHtcbiAgICBkZXNjcmlwdGlvbi5zZHAgPSBzdHJpcFBheWxvYWQoZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIsIFwidGVsZXBob25lLWV2ZW50XCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5zdHJpcFRlbGVwaG9uZUV2ZW50ID0gc3RyaXBUZWxlcGhvbmVFdmVudDtcbmZ1bmN0aW9uIGNsZWFuSml0c2lTZHBJbWFnZWF0dHIoZGVzY3JpcHRpb24pIHtcbiAgICBkZXNjcmlwdGlvbi5zZHAgPSAoZGVzY3JpcHRpb24uc2RwIHx8IFwiXCIpLnJlcGxhY2UoL14oYT1pbWFnZWF0dHI6Lio/KSh4fHkpPVxcWzAtL2dtLCBcIiQxJDI9WzE6XCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5jbGVhbkppdHNpU2RwSW1hZ2VhdHRyID0gY2xlYW5KaXRzaVNkcEltYWdlYXR0cjtcbmZ1bmN0aW9uIHN0cmlwRzcyMihkZXNjcmlwdGlvbikge1xuICAgIGRlc2NyaXB0aW9uLnNkcCA9IHN0cmlwUGF5bG9hZChkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIiwgXCJHNzIyXCIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5zdHJpcEc3MjIgPSBzdHJpcEc3MjI7XG5mdW5jdGlvbiBzdHJpcFJ0cFBheWxvYWQocGF5bG9hZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gc3RyaXBQYXlsb2FkKGRlc2NyaXB0aW9uLnNkcCB8fCBcIlwiLCBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG4gICAgfTtcbn1cbmV4cG9ydHMuc3RyaXBSdHBQYXlsb2FkID0gc3RyaXBSdHBQYXlsb2FkO1xuZnVuY3Rpb24gc3RyaXBWaWRlbyhkZXNjcmlwdGlvbikge1xuICAgIGRlc2NyaXB0aW9uLnNkcCA9IHN0cmlwTWVkaWFEZXNjcmlwdGlvbihkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIiwgXCJ2aWRlb1wiKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbn1cbmV4cG9ydHMuc3RyaXBWaWRlbyA9IHN0cmlwVmlkZW87XG5mdW5jdGlvbiBhZGRNaWRMaW5lcyhkZXNjcmlwdGlvbikge1xuICAgIHZhciBzZHAgPSBkZXNjcmlwdGlvbi5zZHAgfHwgXCJcIjtcbiAgICBpZiAoc2RwLnNlYXJjaCgvXmE9bWlkLiokL2dtKSA9PT0gLTEpIHtcbiAgICAgICAgdmFyIG1saW5lc18xID0gc2RwLm1hdGNoKC9ebT0uKiQvZ20pO1xuICAgICAgICB2YXIgc2RwQXJyYXlfMSA9IHNkcC5zcGxpdCgvXm09LiokL2dtKTtcbiAgICAgICAgaWYgKG1saW5lc18xKSB7XG4gICAgICAgICAgICBtbGluZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBtbGluZXNfMVtpZHhdID0gZWxlbSArIFwiXFxuYT1taWQ6XCIgKyBpZHg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZHBBcnJheV8xLmZvckVhY2goZnVuY3Rpb24gKGVsZW0sIGlkeCkge1xuICAgICAgICAgICAgaWYgKG1saW5lc18xICYmIG1saW5lc18xW2lkeF0pIHtcbiAgICAgICAgICAgICAgICBzZHBBcnJheV8xW2lkeF0gPSBlbGVtICsgbWxpbmVzXzFbaWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNkcCA9IHNkcEFycmF5XzEuam9pbihcIlwiKTtcbiAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gc2RwO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRlc2NyaXB0aW9uKTtcbn1cbmV4cG9ydHMuYWRkTWlkTGluZXMgPSBhZGRNaWRMaW5lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuLi9hcGkvc2Vzc2lvblwiKTtcbnZhciBFbnVtc18xID0gcmVxdWlyZShcIi4uL0VudW1zXCIpO1xudmFyIEV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9FeGNlcHRpb25zXCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vVXRpbHNcIik7XG52YXIgTW9kaWZpZXJzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vTW9kaWZpZXJzXCIpKTtcbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL1Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlclwiKTtcbi8qIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcbiAqIEBjbGFzcyBQZWVyQ29ubmVjdGlvbiBoZWxwZXIgQ2xhc3MuXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcihsb2dnZXIsIG9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoZSBvcHRpb25zXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIF90aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgICAgIF90aGlzLmR0bWZTZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLnNob3VsZEFjcXVpcmVNZWRpYSA9IHRydWU7XG4gICAgICAgIF90aGlzLkNPTlRFTlRfVFlQRSA9IFwiYXBwbGljYXRpb24vc2RwXCI7XG4gICAgICAgIF90aGlzLkMgPSB7XG4gICAgICAgICAgICBESVJFQ1RJT046IHtcbiAgICAgICAgICAgICAgICBOVUxMOiBudWxsLFxuICAgICAgICAgICAgICAgIFNFTkRSRUNWOiBcInNlbmRyZWN2XCIsXG4gICAgICAgICAgICAgICAgU0VORE9OTFk6IFwic2VuZG9ubHlcIixcbiAgICAgICAgICAgICAgICBSRUNWT05MWTogXCJyZWN2b25seVwiLFxuICAgICAgICAgICAgICAgIElOQUNUSVZFOiBcImluYWN0aXZlXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiBcIiArIEpTT04uc3RyaW5naWZ5KF90aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgX3RoaXMuZGlyZWN0aW9uID0gX3RoaXMuQy5ESVJFQ1RJT04uTlVMTDtcbiAgICAgICAgX3RoaXMubW9kaWZpZXJzID0gX3RoaXMub3B0aW9ucy5tb2RpZmllcnMgfHwgW107XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShfdGhpcy5tb2RpZmllcnMpKSB7XG4gICAgICAgICAgICBfdGhpcy5tb2RpZmllcnMgPSBbX3RoaXMubW9kaWZpZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmluaXRQZWVyQ29ubmVjdGlvbihfdGhpcy5vcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmNvbnN0cmFpbnRzID0gX3RoaXMuY2hlY2tBbmREZWZhdWx0Q29uc3RyYWludHMoX3RoaXMub3B0aW9ucy5jb25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtTSVAuU2Vzc2lvbn0gc2Vzc2lvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgKi9cbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLmRlZmF1bHRGYWN0b3J5ID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IChzZXNzaW9uIGluc3RhbmNlb2Ygc2Vzc2lvbl8xLlNlc3Npb24pID9cbiAgICAgICAgICAgIHNlc3Npb24udXNlckFnZW50LmdldExvZ2dlcihcInNpcC5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyXCIsIHNlc3Npb24uaWQpIDpcbiAgICAgICAgICAgIHNlc3Npb24udWEuZ2V0TG9nZ2VyKFwic2lwLmludml0ZWNvbnRleHQuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiLCBzZXNzaW9uLmlkKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlcl8xLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlcihzZXNzaW9uLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKGxvZ2dlciwgb2JzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLy8gRnVuY3Rpb25zIHRoZSBzZXNzc2lvbiBjYW4gdXNlXG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3RvclxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJjbG9zaW5nIFBlZXJDb25uZWN0aW9uXCIpO1xuICAgICAgICAvLyBoYXZlIHRvIGNoZWNrIHNpZ25hbGluZ1N0YXRlIHNpbmNlIHRoaXMuY2xvc2UoKSBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbiAmJiB0aGlzLnBlZXJDb25uZWN0aW9uLnNpZ25hbGluZ1N0YXRlICE9PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZW5kZXIudHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlci50cmFjay5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJVc2luZyBnZXRMb2NhbFN0cmVhbXMgd2hpY2ggaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmdldExvY2FsU3RyZWFtcygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRSZWNlaXZlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycygpLmZvckVhY2goZnVuY3Rpb24gKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlci50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXIudHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNpbmcgZ2V0UmVtb3RlU3RyZWFtcyB3aGljaCBpcyBkZXByZWNhdGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVtb3RlU3RyZWFtcygpLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgZGVzY3JpcHRpb24gZnJvbSB0aGUgdW5kZXJseWluZyBtZWRpYSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgdG8gYmUgdXNlZCBieSBnZXREZXNjcmlwdGlvblxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW1Db25zdHJhaW50c30gW29wdGlvbnMuY29uc3RyYWludHNdIE1lZGlhU3RyZWFtQ29uc3RyYWludHNcbiAgICAgKiAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYVN0cmVhbUNvbnN0cmFpbnRzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9uc10gSWYgdGhpcyBpcyBzZXQgaXQgd2lsbCByZWNyZWF0ZSB0aGUgcGVlclxuICAgICAqICAgY29ubmVjdGlvbiB3aXRoIHRoZSBuZXcgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IFttb2RpZmllcnNdIEFycmF5IHdpdGggb25lIHRpbWUgdXNlIGRlc2NyaXB0aW9uIG1vZGlmaWVyc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbG9jYWwgZGVzY3JpcHRpb24gdG8gYmUgdXNlZCBmb3IgdGhlIHNlc3Npb25cbiAgICAgKi9cbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5nZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKG1vZGlmaWVycyA9PT0gdm9pZCAwKSB7IG1vZGlmaWVycyA9IFtdOyB9XG4gICAgICAgIGlmIChvcHRpb25zLnBlZXJDb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5pbml0UGVlckNvbm5lY3Rpb24ob3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1lcmdlIHBhc3NlZCBjb25zdHJhaW50cyB3aXRoIHNhdmVkIGNvbnN0cmFpbnRzIGFuZCBzYXZlXG4gICAgICAgIHZhciBuZXdDb25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29uc3RyYWludHMsIG9wdGlvbnMuY29uc3RyYWludHMpO1xuICAgICAgICBuZXdDb25zdHJhaW50cyA9IHRoaXMuY2hlY2tBbmREZWZhdWx0Q29uc3RyYWludHMobmV3Q29uc3RyYWludHMpO1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmV3Q29uc3RyYWludHMpICE9PSBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IG5ld0NvbnN0cmFpbnRzO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRBY3F1aXJlTWVkaWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICBtb2RpZmllcnMgPSBbbW9kaWZpZXJzXTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMuY29uY2F0KHRoaXMubW9kaWZpZXJzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNob3VsZEFjcXVpcmVNZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hY3F1aXJlKF90aGlzLmNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvdWxkQWNxdWlyZU1lZGlhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY3JlYXRlT2ZmZXJPckFuc3dlcihvcHRpb25zLlJUQ09mZmVyT3B0aW9ucywgbW9kaWZpZXJzKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uLnNkcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcImdldERlc2NyaXB0aW9uXCIsIHVuZGVmaW5lZCwgXCJTRFAgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdChcImdldERlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYm9keTogZGVzY3JpcHRpb24uc2RwLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBfdGhpcy5DT05URU5UX1RZUEVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIFNlc3Npb24gRGVzY3JpcHRpb24gSGFuZGxlciBjYW4gaGFuZGxlIHRoZSBDb250ZW50LVR5cGUgZGVzY3JpYmVkIGJ5IGEgU0lQIE1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFR5cGUgVGhlIGNvbnRlbnQgdHlwZSB0aGF0IGlzIGluIHRoZSBTSVAgTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmhhc0Rlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50VHlwZSA9PT0gdGhpcy5DT05URU5UX1RZUEU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgbW9kaWZpZXIgdGhhdCBzaG91bGQgYmUgdXNlZCB3aGVuIHRoZSBzZXNzaW9uIHdvdWxkIGxpa2UgdG8gcGxhY2UgdGhlIGNhbGwgb24gaG9sZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2RwXSBUaGUgZGVzY3JpcHRpb24gdGhhdCB3aWxsIGJlIG1vZGlmaWVkXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIG1vZGlmaWVkIFNEUFxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmhvbGRNb2RpZmllciA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoL2E9KHNlbmRyZWN2fHNlbmRvbmx5fHJlY3Zvbmx5fGluYWN0aXZlKS8pLnRlc3QoZGVzY3JpcHRpb24uc2RwKSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gZGVzY3JpcHRpb24uc2RwLnJlcGxhY2UoLyhtPVteXFxyXSpcXHJcXG4pL2csIFwiJDFhPXNlbmRvbmx5XFxyXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gZGVzY3JpcHRpb24uc2RwLnJlcGxhY2UoL2E9c2VuZHJlY3ZcXHJcXG4vZywgXCJhPXNlbmRvbmx5XFxyXFxuXCIpO1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uc2RwID0gZGVzY3JpcHRpb24uc2RwLnJlcGxhY2UoL2E9cmVjdm9ubHlcXHJcXG4vZywgXCJhPWluYWN0aXZlXFxyXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzY3JpcHRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSByZW1vdGUgZGVzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgbWVkaWEgaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Vzc2lvbkRlc2NyaXB0aW9uIFRoZSBkZXNjcmlwdGlvbiBwcm92aWRlZCBieSBhIFNJUCBtZXNzYWdlIHRvIGJlIHNldCBvbiB0aGUgbWVkaWEgaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHRvIGJlIHVzZWQgYnkgZ2V0RGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtQ29uc3RyYWludHN9IFtvcHRpb25zLmNvbnN0cmFpbnRzXSBNZWRpYVN0cmVhbUNvbnN0cmFpbnRzXG4gICAgICogICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFTdHJlYW1Db25zdHJhaW50c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnNdIElmIHRoaXMgaXMgc2V0IGl0IHdpbGwgcmVjcmVhdGUgdGhlIHBlZXJcbiAgICAgKiAgIGNvbm5lY3Rpb24gd2l0aCB0aGUgbmV3IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbbW9kaWZpZXJzXSBBcnJheSB3aXRoIG9uZSB0aW1lIHVzZSBkZXNjcmlwdGlvbiBtb2RpZmllcnNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRlc2NyaXB0aW9uIGlzIHNldFxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKHNlc3Npb25EZXNjcmlwdGlvbiwgb3B0aW9ucywgbW9kaWZpZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBbXTsgfVxuICAgICAgICBpZiAob3B0aW9ucy5wZWVyQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFBlZXJDb25uZWN0aW9uKG9wdGlvbnMucGVlckNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kaWZpZXJzKSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzID0gW21vZGlmaWVyc107XG4gICAgICAgIH1cbiAgICAgICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzLmNvbmNhdCh0aGlzLm1vZGlmaWVycyk7XG4gICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuaGFzT2ZmZXIoXCJsb2NhbFwiKSA/IFwiYW5zd2VyXCIgOiBcIm9mZmVyXCIsXG4gICAgICAgICAgICBzZHA6IHNlc3Npb25EZXNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBNZWRpYSBzaG91bGQgYmUgYWNxdWlyZWQgaW4gZ2V0RGVzY3JpcHRpb24gdW5sZXNzIHdlIG5lZWQgdG8gZG8gaXQgc29vbmVyIGZvciBzb21lIHJlYXNvbiAoRkY2MSspXG4gICAgICAgICAgICBpZiAoX3RoaXMuc2hvdWxkQWNxdWlyZU1lZGlhICYmIF90aGlzLm9wdGlvbnMuYWx3YXlzQWNxdWlyZU1lZGlhRmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYWNxdWlyZShfdGhpcy5jb25zdHJhaW50cykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNob3VsZEFjcXVpcmVNZWRpYSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFV0aWxzXzEuVXRpbHMucmVkdWNlUHJvbWlzZXMobW9kaWZpZXJzLCBkZXNjcmlwdGlvbik7IH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJzZXREZXNjcmlwdGlvblwiLCBlLCBcIlRoZSBtb2RpZmllcnMgZGlkIG5vdCByZXNvbHZlIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZWVyQ29ubmVjdGlvbi1zZXRSZW1vdGVEZXNjcmlwdGlvbkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAobW9kaWZpZWREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInNldERlc2NyaXB0aW9uXCIsIG1vZGlmaWVkRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKG1vZGlmaWVkRGVzY3JpcHRpb24pO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIG9yaWdpbmFsIFNEUCBmb3IgdmlkZW8sIGFuZCBlbnN1cmUgdGhhdCB3ZSBoYXZlIHdhbnQgdG8gZG8gYXVkaW8gZmFsbGJhY2tcbiAgICAgICAgICAgIGlmICgoL15tPXZpZGVvLiskL2dtKS50ZXN0KHNlc3Npb25EZXNjcmlwdGlvbikgJiYgIW9wdGlvbnMuZGlzYWJsZUF1ZGlvRmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdHJ5IHRvIGF1ZGlvIGZhbGxiYWNrIGFnYWluXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kaXNhYmxlQXVkaW9GYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHZpZGVvIGZpcnN0LCB0aGVuIGRvIHRoZSBvdGhlciBtb2RpZmllcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2V0RGVzY3JpcHRpb24oc2Vzc2lvbkRlc2NyaXB0aW9uLCBvcHRpb25zLCBbTW9kaWZpZXJzLnN0cmlwVmlkZW9dLmNvbmNhdChtb2RpZmllcnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJzZXREZXNjcmlwdGlvblwiLCBlKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVlckNvbm5lY3Rpb24tc2V0UmVtb3RlRGVzY3JpcHRpb25GYWlsZWRcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBlZXJDb25uZWN0aW9uLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJzZXRSZW1vdGVEZXNjcmlwdGlvblwiLCBfdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRSZWNlaXZlcnMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwic2V0UmVtb3RlRGVzY3JpcHRpb25cIiwgX3RoaXMucGVlckNvbm5lY3Rpb24uZ2V0UmVtb3RlU3RyZWFtcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJjb25maXJtZWRcIiwgX3RoaXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgRFRNRiB2aWEgUlRQIChSRkMgNDczMylcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdG9uZXMgQSBzdHJpbmcgY29udGFpbmluZyBEVE1GIGRpZ2l0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3QgdG8gYmUgdXNlZCBieSBzZW5kRHRtZlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIERUTUYgc2VuZCBpcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5zZW5kRHRtZiA9IGZ1bmN0aW9uICh0b25lcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoIXRoaXMuZHRtZlNlbmRlciAmJiB0aGlzLmhhc0Jyb3dzZXJHZXRTZW5kZXJTdXBwb3J0KCkpIHtcbiAgICAgICAgICAgIHZhciBzZW5kZXJzID0gdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCk7XG4gICAgICAgICAgICBpZiAoc2VuZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdG1mU2VuZGVyID0gc2VuZGVyc1swXS5kdG1mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kdG1mU2VuZGVyICYmIHRoaXMuaGFzQnJvd3NlclRyYWNrU3VwcG9ydCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RyZWFtcyA9IHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0TG9jYWxTdHJlYW1zKCk7XG4gICAgICAgICAgICBpZiAoc3RyZWFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvVHJhY2tzID0gc3RyZWFtc1swXS5nZXRBdWRpb1RyYWNrcygpO1xuICAgICAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHRtZlNlbmRlciA9IHRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlRFRNRlNlbmRlcihhdWRpb1RyYWNrc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5kdG1mU2VuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZHRtZlNlbmRlci5pbnNlcnREVE1GKHRvbmVzLCBvcHRpb25zLmR1cmF0aW9uLCBvcHRpb25zLmludGVyVG9uZUdhcCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IFwiSW52YWxpZFN0YXRlRXJyb3JcIiB8fCBlLnR5cGUgPT09IFwiSW52YWxpZENoYXJhY3RlckVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkRUTUYgc2VudCB2aWEgUlRQOiBcIiArIHRvbmVzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZXNzaW9uIGRlc2NyaXB0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gZGlyZWN0aW9uIG9mIHRoZSBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmdldERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHsgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBuYW1lLCBjYWxsYmFjayk7IH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuZ2V0TWVkaWFTdHJlYW0gPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICB9O1xuICAgIC8vIEludGVybmFsIGZ1bmN0aW9uc1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZU9mZmVyT3JBbnN3ZXIgPSBmdW5jdGlvbiAoUlRDT2ZmZXJPcHRpb25zLCBtb2RpZmllcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKFJUQ09mZmVyT3B0aW9ucyA9PT0gdm9pZCAwKSB7IFJUQ09mZmVyT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmIChtb2RpZmllcnMgPT09IHZvaWQgMCkgeyBtb2RpZmllcnMgPSBbXTsgfVxuICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IHRoaXMuaGFzT2ZmZXIoXCJyZW1vdGVcIikgPyBcImNyZWF0ZUFuc3dlclwiIDogXCJjcmVhdGVPZmZlclwiO1xuICAgICAgICB2YXIgcGMgPSB0aGlzLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2cobWV0aG9kTmFtZSk7XG4gICAgICAgIHZhciBtZXRob2QgPSB0aGlzLmhhc09mZmVyKFwicmVtb3RlXCIpID8gcGMuY3JlYXRlQW5zd2VyIDogcGMuY3JlYXRlT2ZmZXI7XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkocGMsIFJUQ09mZmVyT3B0aW9ucykuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJjcmVhdGVPZmZlck9yQW5zd2VyXCIsIGUsIFwicGVlckNvbm5lY3Rpb24tXCIgKyBtZXRob2ROYW1lICsgXCJGYWlsZWRcIik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVlckNvbm5lY3Rpb24tXCIgKyBtZXRob2ROYW1lICsgXCJGYWlsZWRcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNkcCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMucmVkdWNlUHJvbWlzZXMobW9kaWZpZXJzLCBfdGhpcy5jcmVhdGVSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KHNkcCkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChzZHApIHtcbiAgICAgICAgICAgIF90aGlzLnJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJTZXR0aW5nIGxvY2FsIHNkcC5cIik7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwic2RwIGlzIFwiICsgc2RwLnNkcCB8fCBcInVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkcCk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiY3JlYXRlT2ZmZXJPckFuc3dlclwiLCBlLCBcInBlZXJDb25uZWN0aW9uLVNldExvY2FsRGVzY3JpcHRpb25GYWlsZWRcIik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicGVlckNvbm5lY3Rpb24tU2V0TG9jYWxEZXNjcmlwdGlvbkZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy53YWl0Rm9ySWNlR2F0aGVyaW5nQ29tcGxldGUoKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMucGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJNaXNzaW5nIGxvY2FsIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvY2FsRGVzY3JpcHRpb24gPSBfdGhpcy5jcmVhdGVSVENTZXNzaW9uRGVzY3JpcHRpb25Jbml0KF90aGlzLnBlZXJDb25uZWN0aW9uLmxvY2FsRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzXzEuVXRpbHMucmVkdWNlUHJvbWlzZXMobW9kaWZpZXJzLCBsb2NhbERlc2NyaXB0aW9uKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAobG9jYWxEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuc2V0RGlyZWN0aW9uKGxvY2FsRGVzY3JpcHRpb24uc2RwIHx8IFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsRGVzY3JpcHRpb247XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBFbnVtc18xLlR5cGVTdHJpbmdzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKFwiY3JlYXRlT2ZmZXJPckFuc3dlclwiLCBlKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIENyZWF0ZXMgYW4gUlRDU2Vzc2lvbkRlc2NyaXB0aW9uSW5pdCBmcm9tIGFuIFJUQ1Nlc3Npb25EZXNjcmlwdGlvblxuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmNyZWF0ZVJUQ1Nlc3Npb25EZXNjcmlwdGlvbkluaXQgPSBmdW5jdGlvbiAoUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBSVENTZXNzaW9uRGVzY3JpcHRpb24udHlwZSxcbiAgICAgICAgICAgIHNkcDogUlRDU2Vzc2lvbkRlc2NyaXB0aW9uLnNkcFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuYWRkRGVmYXVsdEljZUNoZWNraW5nVGltZW91dCA9IGZ1bmN0aW9uIChwZWVyQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHBlZXJDb25uZWN0aW9uT3B0aW9ucy5pY2VDaGVja2luZ1RpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGVlckNvbm5lY3Rpb25PcHRpb25zLmljZUNoZWNraW5nVGltZW91dCA9IDUwMDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uT3B0aW9ucztcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmFkZERlZmF1bHRJY2VTZXJ2ZXJzID0gZnVuY3Rpb24gKHJ0Y0NvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKCFydGNDb25maWd1cmF0aW9uLmljZVNlcnZlcnMpIHtcbiAgICAgICAgICAgIHJ0Y0NvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IFt7IHVybHM6IFwic3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMlwiIH1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydGNDb25maWd1cmF0aW9uO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuY2hlY2tBbmREZWZhdWx0Q29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29uc3RyYWludHMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRDb25zdHJhaW50cyA9IHsgYXVkaW86IHRydWUsIHZpZGVvOiAhdGhpcy5vcHRpb25zLmFsd2F5c0FjcXVpcmVNZWRpYUZpcnN0IH07XG4gICAgICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMgfHwgZGVmYXVsdENvbnN0cmFpbnRzO1xuICAgICAgICAvLyBFbXB0eSBvYmplY3QgY2hlY2tcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGNvbnN0cmFpbnRzKS5sZW5ndGggPT09IDAgJiYgY29uc3RyYWludHMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb25zdHJhaW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5oYXNCcm93c2VyVHJhY2tTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKTtcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmhhc0Jyb3dzZXJHZXRTZW5kZXJTdXBwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnBlZXJDb25uZWN0aW9uLmdldFNlbmRlcnMpO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wcm90b3R5cGUuaW5pdFBlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuYWRkRGVmYXVsdEljZUNoZWNraW5nVGltZW91dChvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5ydGNDb25maWd1cmF0aW9uID0gb3B0aW9ucy5ydGNDb25maWd1cmF0aW9uIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24gPSB0aGlzLmFkZERlZmF1bHRJY2VTZXJ2ZXJzKG9wdGlvbnMucnRjQ29uZmlndXJhdGlvbik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImluaXRQZWVyQ29ubmVjdGlvblwiKTtcbiAgICAgICAgaWYgKHRoaXMucGVlckNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIkFscmVhZHkgaGF2ZSBhIHBlZXIgY29ubmVjdGlvbiBmb3IgdGhpcyBzZXNzaW9uLiBUZWFyaW5nIGRvd24uXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldEljZUdhdGhlcmluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24pO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJOZXcgcGVlciBjb25uZWN0aW9uIGNyZWF0ZWRcIik7XG4gICAgICAgIGlmIChcIm9udHJhY2tcIiBpbiB0aGlzLnBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJ0cmFjayBhZGRlZFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vYnNlcnZlci50cmFja0FkZGVkKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFkZFRyYWNrXCIsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVXNpbmcgb25hZGRzdHJlYW0gd2hpY2ggaXMgZGVwcmVjYXRlZFwiKTtcbiAgICAgICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25hZGRzdHJlYW0gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJzdHJlYW0gYWRkZWRcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImFkZFN0cmVhbVwiLCBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGlvbi5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwiaWNlQ2FuZGlkYXRlXCIsIGUpO1xuICAgICAgICAgICAgaWYgKGUuY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIklDRSBjYW5kaWRhdGUgcmVjZWl2ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKGUuY2FuZGlkYXRlLmNhbmRpZGF0ZSA9PT0gbnVsbCA/IG51bGwgOiBlLmNhbmRpZGF0ZS5jYW5kaWRhdGUudHJpbSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmNhbmRpZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGluZGljYXRlcyB0aGUgZW5kIG9mIGNhbmRpZGF0ZSBnYXRoZXJpbmdcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiSUNFIGNhbmRpZGF0ZSBnYXRoZXJpbmcgY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlckljZUdhdGhlcmluZ0NvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSVENJY2VHYXRoZXJpbmdTdGF0ZSBjaGFuZ2VkOiBcIiArIF90aGlzLnBlZXJDb25uZWN0aW9uLmljZUdhdGhlcmluZ1N0YXRlKTtcbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMucGVlckNvbm5lY3Rpb24uaWNlR2F0aGVyaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2F0aGVyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJpY2VHYXRoZXJpbmdcIiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmljZUdhdGhlcmluZ1RpbWVyICYmIG9wdGlvbnMuaWNlQ2hlY2tpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pY2VHYXRoZXJpbmdUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pY2VHYXRoZXJpbmdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJSVENJY2VDaGVja2luZyBUaW1lb3V0IFRyaWdnZXJlZCBhZnRlciBcIiArIG9wdGlvbnMuaWNlQ2hlY2tpbmdUaW1lb3V0ICsgXCIgbWlsbGlzZWNvbmRzXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmljZUdhdGhlcmluZ1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJJY2VHYXRoZXJpbmdDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5pY2VDaGVja2luZ1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VySWNlR2F0aGVyaW5nQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVFdmVudDtcbiAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMucGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5ld1wiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGVja2luZ1wiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ2hlY2tpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVFdmVudCA9IFwiaWNlQ29ubmVjdGlvbkNvbXBsZXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlRXZlbnQgPSBcImljZUNvbm5lY3Rpb25GYWlsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRpc2Nvbm5lY3RlZFwiOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUV2ZW50ID0gXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjbG9zZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVFdmVudCA9IFwiaWNlQ29ubmVjdGlvbkNsb3NlZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcIlVua25vd24gaWNlQ29ubmVjdGlvbiBzdGF0ZTogXCIgKyBfdGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiSUNFIENvbm5lY3Rpb24gU3RhdGUgY2hhbmdlZCB0byBcIiArIHN0YXRlRXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChzdGF0ZUV2ZW50LCBfdGhpcyk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIERlZmF1bHQgYXVkaW8gJiB2aWRlbyB0byB0cnVlXG4gICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jaGVja0FuZERlZmF1bHRDb25zdHJhaW50cyhjb25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogTWFrZSB0aGUgY2FsbCBhc3luY2hyb25vdXMsIHNvIHRoYXQgSUNDcyBoYXZlIGEgY2hhbmNlXG4gICAgICAgICAgICAgKiB0byBkZWZpbmUgY2FsbGJhY2tzIHRvIGB1c2VyTWVkaWFSZXF1ZXN0YFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiYWNxdWlyaW5nIGxvY2FsIG1lZGlhXCIpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInVzZXJNZWRpYVJlcXVlc3RcIiwgY29uc3RyYWludHMpO1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmF1ZGlvIHx8IGNvbnN0cmFpbnRzLnZpZGVvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZ2V0TWVkaWFTdHJlYW0oY29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKHN0cmVhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXIudHJhY2tBZGRlZCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwidXNlck1lZGlhXCIsIHN0cmVhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0cmVhbXMpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJ1c2VyTWVkaWFGYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvY2FsIHN0cmVhbXMgd2VyZSBleHBsaWNpdGx5IGV4Y2x1ZGVkLlxuICAgICAgICAgICAgICAgIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcImFjcXVpcmVcIiwgZSwgXCJ1bmFibGUgdG8gYWNxdWlyZSBzdHJlYW1zXCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChzdHJlYW1zKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiYWNxdWlyZWQgbG9jYWwgbWVkaWEgc3RyZWFtc1wiKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgdHJhY2tzXG4gICAgICAgICAgICBpZiAoX3RoaXMucGVlckNvbm5lY3Rpb24ucmVtb3ZlVHJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlZXJDb25uZWN0aW9uLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtcztcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09IEVudW1zXzEuVHlwZVN0cmluZ3MuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IoXCJhY3F1aXJlXCIsIGUsIFwiZXJyb3IgcmVtb3Zpbmcgc3RyZWFtc1wiKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChlcnJvci5lcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc3RyZWFtcykge1xuICAgICAgICAgICAgdmFyIHN0cmVhbXNBcnIgPSBbXS5jb25jYXQoc3RyZWFtcyk7XG4gICAgICAgICAgICBzdHJlYW1zQXJyLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRUcmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENocm9tZSA1OSBkb2VzIG5vdCBzdXBwb3J0IGFkZFRyYWNrXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBlZXJDb25uZWN0aW9uLmFkZFN0cmVhbShzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihcImFjcXVpcmVcIiwgZSwgXCJlcnJvciBhZGRpbmcgc3RyZWFtXCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLmhhc09mZmVyID0gZnVuY3Rpb24gKHdoZXJlKSB7XG4gICAgICAgIHZhciBvZmZlclN0YXRlID0gXCJoYXZlLVwiICsgd2hlcmUgKyBcIi1vZmZlclwiO1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSA9PT0gb2ZmZXJTdGF0ZTtcbiAgICB9O1xuICAgIC8vIElDRSBnYXRoZXJpbmcgc3RhdGUgaGFuZGxpbmdcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS5pc0ljZUdhdGhlcmluZ0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VHYXRoZXJpbmdTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8IHRoaXMuaWNlR2F0aGVyaW5nVGltZW91dDtcbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLnJlc2V0SWNlR2F0aGVyaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nVGltZW91dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJyZXNldEljZUdhdGhlcmluZ0NvbXBsZXRlXCIpO1xuICAgICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWNlR2F0aGVyaW5nVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCkge1xuICAgICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZC5yZWplY3QoKTtcbiAgICAgICAgICAgIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9IGZ1bmN0aW9uIChzZHApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc2RwLm1hdGNoKC9hPShzZW5kcmVjdnxzZW5kb25seXxyZWN2b25seXxpbmFjdGl2ZSkvKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuQy5ESVJFQ1RJT04uTlVMTDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlyZWN0aW9uQ2hhbmdlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5DLkRJUkVDVElPTi5TRU5EUkVDVjpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5DLkRJUkVDVElPTi5TRU5ET05MWTpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5DLkRJUkVDVElPTi5SRUNWT05MWTpcbiAgICAgICAgICAgIGNhc2UgdGhpcy5DLkRJUkVDVElPTi5JTkFDVElWRTpcbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSB0aGlzLkMuRElSRUNUSU9OLk5VTEw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlci5kaXJlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS50cmlnZ2VySWNlR2F0aGVyaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSWNlR2F0aGVyaW5nQ29tcGxldGUoKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiaWNlR2F0aGVyaW5nQ29tcGxldGVcIiwgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5pY2VHYXRoZXJpbmdUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmljZUdhdGhlcmluZ1RpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ1RpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnByb3RvdHlwZS53YWl0Rm9ySWNlR2F0aGVyaW5nQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIndhaXRGb3JJY2VHYXRoZXJpbmdDb21wbGV0ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJY2VHYXRoZXJpbmdDb21wbGV0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJQ0UgaXMgYWxyZWFkeSBjb21wbGV0ZS4gUmV0dXJuIHJlc29sdmVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCkge1xuICAgICAgICAgICAgdGhpcy5pY2VHYXRoZXJpbmdEZWZlcnJlZCA9IFV0aWxzXzEuVXRpbHMuZGVmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJQ0UgaXMgbm90IGNvbXBsZXRlLiBSZXR1cm5pbmcgcHJvbWlzZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNlR2F0aGVyaW5nRGVmZXJyZWQgPyB0aGlzLmljZUdhdGhlcmluZ0RlZmVycmVkLnByb21pc2UgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi4vYXBpL3Nlc3Npb25cIik7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuLi9FbnVtc1wiKTtcbi8qIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlclxuICogQGNsYXNzIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgT2JzZXJ2ZXIgQ2xhc3MuXG4gKiBAcGFyYW0ge1NJUC5TZXNzaW9ufSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKi9cbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyKHNlc3Npb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPYnNlcnZlci5wcm90b3R5cGUudHJhY2tBZGRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiBpbnN0YW5jZW9mIHNlc3Npb25fMS5TZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uLmVtaXQoXCJ0cmFja0FkZGVkXCIpO1xuICAgIH07XG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyLnByb3RvdHlwZS5kaXJlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uIGluc3RhbmNlb2Ygc2Vzc2lvbl8xLlNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24uZW1pdChcImRpcmVjdGlvbkNoYW5nZWRcIik7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyO1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyID0gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9ic2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgVUFfMSA9IHJlcXVpcmUoXCIuLi9VQVwiKTtcbnZhciBNb2RpZmllcnMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9Nb2RpZmllcnNcIikpO1xuLyogU2ltcGxlXG4gKiBAY2xhc3MgU2ltcGxlXG4gKi9cbnZhciBTaW1wbGVTdGF0dXM7XG4oZnVuY3Rpb24gKFNpbXBsZVN0YXR1cykge1xuICAgIFNpbXBsZVN0YXR1c1tTaW1wbGVTdGF0dXNbXCJTVEFUVVNfTlVMTFwiXSA9IDBdID0gXCJTVEFUVVNfTlVMTFwiO1xuICAgIFNpbXBsZVN0YXR1c1tTaW1wbGVTdGF0dXNbXCJTVEFUVVNfTkVXXCJdID0gMV0gPSBcIlNUQVRVU19ORVdcIjtcbiAgICBTaW1wbGVTdGF0dXNbU2ltcGxlU3RhdHVzW1wiU1RBVFVTX0NPTk5FQ1RJTkdcIl0gPSAyXSA9IFwiU1RBVFVTX0NPTk5FQ1RJTkdcIjtcbiAgICBTaW1wbGVTdGF0dXNbU2ltcGxlU3RhdHVzW1wiU1RBVFVTX0NPTk5FQ1RFRFwiXSA9IDNdID0gXCJTVEFUVVNfQ09OTkVDVEVEXCI7XG4gICAgU2ltcGxlU3RhdHVzW1NpbXBsZVN0YXR1c1tcIlNUQVRVU19DT01QTEVURURcIl0gPSA0XSA9IFwiU1RBVFVTX0NPTVBMRVRFRFwiO1xufSkoU2ltcGxlU3RhdHVzID0gZXhwb3J0cy5TaW1wbGVTdGF0dXMgfHwgKGV4cG9ydHMuU2ltcGxlU3RhdHVzID0ge30pKTtcbnZhciBTaW1wbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2ltcGxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpbXBsZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qXG4gICAgICAgICogIHtcbiAgICAgICAgKiAgICBtZWRpYToge1xuICAgICAgICAqICAgICAgcmVtb3RlOiB7XG4gICAgICAgICogICAgICAgIGF1ZGlvOiA8RE9NIGVsZW1lbnQ+LFxuICAgICAgICAqICAgICAgICB2aWRlbzogPERPTSBlbGVtZW50PlxuICAgICAgICAqICAgICAgfSxcbiAgICAgICAgKiAgICAgIGxvY2FsOiB7XG4gICAgICAgICogICAgICAgIHZpZGVvOiA8RE9NIGVsZW1lbnQ+XG4gICAgICAgICogICAgICB9XG4gICAgICAgICogICAgfSxcbiAgICAgICAgKiAgICB1YToge1xuICAgICAgICAqICAgICAgIDxVQSBDb25maWd1cmF0aW9uIE9wdGlvbnM+XG4gICAgICAgICogICAgfVxuICAgICAgICAqICB9XG4gICAgICAgICovXG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlbykge1xuICAgICAgICAgICAgX3RoaXMudmlkZW8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMudmlkZW8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tZWRpYS5yZW1vdGUuYXVkaW8pIHtcbiAgICAgICAgICAgIF90aGlzLmF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmF1ZGlvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpcy5hdWRpbyAmJiAhX3RoaXMudmlkZW8pIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gZG8gYXQgbGVhc3QgYXVkaW8gb3IgdmlkZW9cbiAgICAgICAgICAgIC8vIEVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgcmVtb3RlIGF1ZGlvIG9yIHZpZGVvIGVsZW1lbnQgaXMgcmVxdWlyZWQgZm9yIFNpbXBsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc5NDQ0NjAvZGV0ZWN0LXNhZmFyaS1icm93c2VyXG4gICAgICAgIHZhciBicm93c2VyVWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpc1NhZmFyaSA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNGaXJlZm94ID0gZmFsc2U7XG4gICAgICAgIGlmIChicm93c2VyVWEuaW5kZXhPZihcInNhZmFyaVwiKSA+IC0xICYmIGJyb3dzZXJVYS5pbmRleE9mKFwiY2hyb21lXCIpIDwgMCkge1xuICAgICAgICAgICAgaXNTYWZhcmkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXJVYS5pbmRleE9mKFwiZmlyZWZveFwiKSA+IC0xICYmIGJyb3dzZXJVYS5pbmRleE9mKFwiY2hyb21lXCIpIDwgMCkge1xuICAgICAgICAgICAgaXNGaXJlZm94ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zID0ge307XG4gICAgICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zLm1vZGlmaWVycyA9IFtNb2RpZmllcnMuc3RyaXBHNzIyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaXJlZm94KSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeU9wdGlvbnMuYWx3YXlzQWNxdWlyZU1lZGlhRmlyc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX3RoaXMub3B0aW9ucy51YS51cmkpIHtcbiAgICAgICAgICAgIF90aGlzLmFub255bW91cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5hbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy51YSA9IG5ldyBVQV8xLlVBKHtcbiAgICAgICAgICAgIC8vIFVzZXIgQ29uZmlndXJhYmxlIE9wdGlvbnNcbiAgICAgICAgICAgIHVyaTogX3RoaXMub3B0aW9ucy51YS51cmksXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uVXNlcjogX3RoaXMub3B0aW9ucy51YS5hdXRob3JpemF0aW9uVXNlcixcbiAgICAgICAgICAgIHBhc3N3b3JkOiBfdGhpcy5vcHRpb25zLnVhLnBhc3N3b3JkLFxuICAgICAgICAgICAgZGlzcGxheU5hbWU6IF90aGlzLm9wdGlvbnMudWEuZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAvLyBVbmRvY3VtZW50ZWQgXCJBZHZhbmNlZFwiIE9wdGlvbnNcbiAgICAgICAgICAgIHVzZXJBZ2VudFN0cmluZzogX3RoaXMub3B0aW9ucy51YS51c2VyQWdlbnRTdHJpbmcsXG4gICAgICAgICAgICAvLyBGaXhlZCBPcHRpb25zXG4gICAgICAgICAgICByZWdpc3RlcjogdHJ1ZSxcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5T3B0aW9uczogc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zLFxuICAgICAgICAgICAgdHJhbnNwb3J0T3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHRyYWNlU2lwOiBfdGhpcy5vcHRpb25zLnVhLnRyYWNlU2lwLFxuICAgICAgICAgICAgICAgIHdzU2VydmVyczogX3RoaXMub3B0aW9ucy51YS53c1NlcnZlcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnN0YXRlID0gU2ltcGxlU3RhdHVzLlNUQVRVU19OVUxMO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBfdGhpcy51YS5nZXRMb2dnZXIoXCJzaXAuc2ltcGxlXCIpO1xuICAgICAgICBfdGhpcy51YS5vbihcInJlZ2lzdGVyZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInJlZ2lzdGVyZWRcIiwgX3RoaXMudWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMudWEub24oXCJ1bnJlZ2lzdGVyZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcInVucmVnaXN0ZXJlZFwiLCBfdGhpcy51YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy51YS5vbihcInJlZ2lzdHJhdGlvbkZhaWxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwidW5yZWdpc3RlcmVkXCIsIF90aGlzLnVhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnVhLm9uKFwiaW52aXRlXCIsIGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGFuIGFjdGl2ZSBzZXNzaW9uIHJlamVjdCB0aGUgaW5jb21pbmcgc2Vzc2lvblxuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX05VTEwgJiYgX3RoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJSZWplY3RpbmcgaW5jb21pbmcgY2FsbC4gU2ltcGxlIG9ubHkgc3VwcG9ydHMgMSBjYWxsIGF0IGEgdGltZVwiKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICAgICAgX3RoaXMuc2V0dXBTZXNzaW9uKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFwicmluZ2luZ1wiLCBfdGhpcy5zZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLnVhLm9uKFwibWVzc2FnZVwiLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcIm1lc3NhZ2VcIiwgbWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZS5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMudWEgfHwgIXRoaXMuY2hlY2tSZWdpc3RyYXRpb24oKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkEgcmVnaXN0ZXJlZCBVQSBpcyByZXF1aXJlZCBmb3IgY2FsbGluZ1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19OVUxMICYmIHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09NUExFVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQ2Fubm90IG1ha2UgbW9yZSB0aGFuIGEgc2luZ2xlIGNhbGwgd2l0aCBTaW1wbGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FmYXJpIGhhY2ssIGJlY2F1c2UgeW91IGNhbm5vdCBjYWxsIC5wbGF5KCkgZnJvbSBhIG5vbiB1c2VyIGFjdGlvblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwgJiYgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnZvbHVtZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXNzaW9uID0gdGhpcy51YS5pbnZpdGUoZGVzdGluYXRpb24sIHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRoaXMuYXVkaW8sXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0aGlzLnZpZGVvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXR1cFNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbjtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuYW5zd2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19ORVcgJiYgdGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gY2FsbCB0byBhbnN3ZXJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FmYXJpIGhhY2ssIGJlY2F1c2UgeW91IGNhbm5vdCBjYWxsIC5wbGF5KCkgZnJvbSBhIG5vbiB1c2VyIGFjdGlvblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8pIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uYWNjZXB0KHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgY29uc3RyYWludHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW86IHRoaXMuYXVkaW8sXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvOiB0aGlzLnZpZGVvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZW1pdCBjYWxsIGlzIGFjdGl2ZVxuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX05FVyAmJiB0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYWxsIGlzIGFscmVhZHkgYW5zd2VyZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5yZWplY3QoKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuaGFuZ3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVElORyAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19ORVcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBhY3RpdmUgY2FsbCB0byBoYW5nIHVwIG9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlc3Npb24uYnllKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVEVEIHx8ICF0aGlzLnNlc3Npb24gfHwgdGhpcy5zZXNzaW9uLmxvY2FsSG9sZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkNhbm5vdCBwdXQgY2FsbCBvbiBob2xkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJQbGFjaW5nIHNlc3Npb24gb24gaG9sZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi5ob2xkKCk7XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnVuaG9sZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVEVEIHx8ICF0aGlzLnNlc3Npb24gfHwgIXRoaXMuc2Vzc2lvbi5sb2NhbEhvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJDYW5ub3QgdW5ob2xkIGEgY2FsbCB0aGF0IGlzIG5vdCBvbiBob2xkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5tdXRlKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlBsYWNpbmcgY2FsbCBvZmYgaG9sZFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbi51bmhvbGQoKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUubXV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQW4gYWNpdHZlIGNhbGwgaXMgcmVxdWlyZWQgdG8gbXV0ZSBhdWRpb1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJNdXRpbmcgQXVkaW9cIik7XG4gICAgICAgIHRoaXMudG9nZ2xlTXV0ZSh0cnVlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwibXV0ZVwiLCB0aGlzKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJBbiBhY3RpdmUgY2FsbCBpcyByZXF1aXJlZCB0byB1bm11dGUgYXVkaW9cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiVW5tdXRpbmcgQXVkaW9cIik7XG4gICAgICAgIHRoaXMudG9nZ2xlTXV0ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuZW1pdChcInVubXV0ZVwiLCB0aGlzKTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuc2VuZERUTUYgPSBmdW5jdGlvbiAodG9uZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2ltcGxlU3RhdHVzLlNUQVRVU19DT05ORUNURUQgfHwgIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFuIGFjdGl2ZSBjYWxsIGlzIHJlcXVpcmVkIHRvIHNlbmQgYSBEVE1GIHRvbmVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2VuZGluZyBEVE1GIHRvbmU6IFwiICsgdG9uZSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5kdG1mKHRvbmUpO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy51YSB8fCAhdGhpcy5jaGVja1JlZ2lzdHJhdGlvbigpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiQSByZWdpc3RlcmVkIFVBIGlzIHJlcXVpcmVkIHRvIHNlbmQgYSBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24gfHwgIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJBIGRlc3RpbmF0aW9uIGFuZCBtZXNzYWdlIGFyZSByZXF1aXJlZCB0byBzZW5kIGEgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVhLm1lc3NhZ2UoZGVzdGluYXRpb24sIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLy8gUHJpdmF0ZSBIZWxwZXJzXG4gICAgU2ltcGxlLnByb3RvdHlwZS5jaGVja1JlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFub255bW91cyB8fCAodGhpcy51YSAmJiB0aGlzLnVhLmlzUmVnaXN0ZXJlZCgpKSk7XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnNldHVwUmVtb3RlTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gc2Vzc2lvbiB0byBzZXQgcmVtb3RlIG1lZGlhIG9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgdmlkZW8gdHJhY2ssIGl0IHdpbGwgYXR0YWNoIHRoZSB2aWRlbyBhbmQgYXVkaW8gdG8gdGhlIHNhbWUgZWxlbWVudFxuICAgICAgICB2YXIgcGMgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHJlbW90ZVN0cmVhbTtcbiAgICAgICAgaWYgKHBjLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgcmVtb3RlU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgICAgICBwYy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjayA9IHJlY2VpdmVyLnRyYWNrO1xuICAgICAgICAgICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVtb3RlU3RyZWFtID0gcGMuZ2V0UmVtb3RlU3RyZWFtcygpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLnZpZGVvLnNyY09iamVjdCA9IHJlbW90ZVN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUudmlkZW8ucGxheSgpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwicGxheSB3YXMgcmVqZWN0ZWRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmF1ZGlvKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEucmVtb3RlLmF1ZGlvLnNyY09iamVjdCA9IHJlbW90ZVN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5yZW1vdGUuYXVkaW8ucGxheSgpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwicGxheSB3YXMgcmVqZWN0ZWRcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5zZXR1cExvY2FsTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gc2Vzc2lvbiB0byBzZXQgbG9jYWwgbWVkaWEgb25cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlkZW8gJiYgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsICYmIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlbykge1xuICAgICAgICAgICAgdmFyIHBjID0gdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAgICAgICB2YXIgbG9jYWxTdHJlYW1fMTtcbiAgICAgICAgICAgIGlmIChwYy5nZXRTZW5kZXJzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdHJlYW1fMSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIHBjLmdldFNlbmRlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gc2VuZGVyLnRyYWNrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2sua2luZCA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbV8xLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdHJlYW1fMSA9IHBjLmdldExvY2FsU3RyZWFtcygpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLmxvY2FsLnZpZGVvLnNyY09iamVjdCA9IGxvY2FsU3RyZWFtXzE7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8udm9sdW1lID0gMDtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbC52aWRlby5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuY2xlYW51cE1lZGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS52aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tZWRpYS5sb2NhbCAmJiB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubWVkaWEubG9jYWwudmlkZW8ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1lZGlhLnJlbW90ZS5hdWRpby5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnNldHVwU2Vzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJObyBzZXNzaW9uIHRvIHNldCB1cFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gU2ltcGxlU3RhdHVzLlNUQVRVU19ORVc7XG4gICAgICAgIHRoaXMuZW1pdChcIm5ld1wiLCB0aGlzLnNlc3Npb24pO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJwcm9ncmVzc1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vblByb2dyZXNzKCk7IH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJhY2NlcHRlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkFjY2VwdGVkKCk7IH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJyZWplY3RlZFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vbkVuZGVkKCk7IH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJmYWlsZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25GYWlsZWQoKTsgfSk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcInRlcm1pbmF0ZWRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25FbmRlZCgpOyB9KTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUuZGVzdHJveU1lZGlhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLnRvZ2dsZU11dGUgPSBmdW5jdGlvbiAobXV0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vIHNlc3Npb24gdG8gdG9nZ2xlIG11dGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBjID0gdGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XG4gICAgICAgIGlmIChwYy5nZXRTZW5kZXJzKSB7XG4gICAgICAgICAgICBwYy5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbmRlci50cmFjaykge1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXIudHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGMuZ2V0TG9jYWxTdHJlYW1zKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFtdXRlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSAhbXV0ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLm9uQWNjZXB0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiTm8gc2Vzc2lvbiBmb3IgYWNjZXB0aW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTk5FQ1RFRDtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGVkXCIsIHRoaXMuc2Vzc2lvbik7XG4gICAgICAgIHRoaXMuc2V0dXBMb2NhbE1lZGlhKCk7XG4gICAgICAgIHRoaXMuc2V0dXBSZW1vdGVNZWRpYSgpO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLm9uKFwiYWRkVHJhY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJBIHRyYWNrIGhhcyBiZWVuIGFkZGVkLCB0cmlnZ2VyaW5nIG5ldyByZW1vdGVNZWRpYSBzZXR1cFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXR1cFJlbW90ZU1lZGlhKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLm9uKFwiYWRkU3RyZWFtXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiQSBzdHJlYW0gaGFzIGJlZW4gYWRkZWQsIHRyaWdnZXIgbmV3IHJlbW90ZU1lZGlhIHNldHVwXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldHVwUmVtb3RlTWVkaWEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5vbihcImR0bWZcIiwgZnVuY3Rpb24gKHJlcXVlc3QsIGR0bWYpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkdG1mXCIsIGR0bWYudG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlc3Npb24ub24oXCJieWVcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25FbmRlZCgpOyB9KTtcbiAgICB9O1xuICAgIFNpbXBsZS5wcm90b3R5cGUub25Qcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNpbXBsZVN0YXR1cy5TVEFUVVNfQ09OTkVDVElORztcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGluZ1wiLCB0aGlzLnNlc3Npb24pO1xuICAgIH07XG4gICAgU2ltcGxlLnByb3RvdHlwZS5vbkZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbkVuZGVkKCk7XG4gICAgfTtcbiAgICBTaW1wbGUucHJvdG90eXBlLm9uRW5kZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBTaW1wbGVTdGF0dXMuU1RBVFVTX0NPTVBMRVRFRDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kZWRcIiwgdGhpcy5zZXNzaW9uKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwTWVkaWEoKTtcbiAgICB9O1xuICAgIFNpbXBsZS5DID0gU2ltcGxlU3RhdHVzO1xuICAgIHJldHVybiBTaW1wbGU7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5TaW1wbGUgPSBTaW1wbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuLi9jb3JlXCIpO1xudmFyIEVudW1zXzEgPSByZXF1aXJlKFwiLi4vRW51bXNcIik7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL0V4Y2VwdGlvbnNcIik7XG52YXIgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vVHJhbnNwb3J0XCIpO1xudmFyIFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vVXRpbHNcIik7XG52YXIgVHJhbnNwb3J0U3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc3BvcnRTdGF0dXMpIHtcbiAgICBUcmFuc3BvcnRTdGF0dXNbVHJhbnNwb3J0U3RhdHVzW1wiU1RBVFVTX0NPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiU1RBVFVTX0NPTk5FQ1RJTkdcIjtcbiAgICBUcmFuc3BvcnRTdGF0dXNbVHJhbnNwb3J0U3RhdHVzW1wiU1RBVFVTX09QRU5cIl0gPSAxXSA9IFwiU1RBVFVTX09QRU5cIjtcbiAgICBUcmFuc3BvcnRTdGF0dXNbVHJhbnNwb3J0U3RhdHVzW1wiU1RBVFVTX0NMT1NJTkdcIl0gPSAyXSA9IFwiU1RBVFVTX0NMT1NJTkdcIjtcbiAgICBUcmFuc3BvcnRTdGF0dXNbVHJhbnNwb3J0U3RhdHVzW1wiU1RBVFVTX0NMT1NFRFwiXSA9IDNdID0gXCJTVEFUVVNfQ0xPU0VEXCI7XG59KShUcmFuc3BvcnRTdGF0dXMgPSBleHBvcnRzLlRyYW5zcG9ydFN0YXR1cyB8fCAoZXhwb3J0cy5UcmFuc3BvcnRTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBDb21wdXRlIGFuIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgc2VuZGluZyBhbm90aGVyXG4gKiBrZWVwLWFsaXZlLlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xudmFyIGNvbXB1dGVLZWVwQWxpdmVUaW1lb3V0ID0gZnVuY3Rpb24gKHVwcGVyQm91bmQpIHtcbiAgICB2YXIgbG93ZXJCb3VuZCA9IHVwcGVyQm91bmQgKiAwLjg7XG4gICAgcmV0dXJuIDEwMDAgKiAoTWF0aC5yYW5kb20oKSAqICh1cHBlckJvdW5kIC0gbG93ZXJCb3VuZCkgKyBsb3dlckJvdW5kKTtcbn07XG4vKipcbiAqIEBjbGFzcyBUcmFuc3BvcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbnZhciBUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbG9nZ2VyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gRW51bXNfMS5UeXBlU3RyaW5ncy5UcmFuc3BvcnQ7XG4gICAgICAgIF90aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gMDtcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DT05ORUNUSU5HO1xuICAgICAgICBfdGhpcy5jb25maWd1cmF0aW9uID0gX3RoaXMubG9hZENvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuc2VydmVyID0gX3RoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnNbMF07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX09QRU47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIE91dGdvaW5nIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRQcm9taXNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwidW5hYmxlIHRvIHNlbmQgbWVzc2FnZSAtIFdlYlNvY2tldCB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV2ViU29ja2V0IHVuZGVmaW5lZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FOiBUaGlzIGNoZWNrIGlzIGxpa2VseSBub3QgbmVjZXNzYXJ5IGFzIFdlYlNvY2tldC5zZW5kKCkgd2lsbFxuICAgICAgICAvLyB0aHJvdyBJTlZBTElEX1NUQVRFX0VSUiBpZiB0aGUgY29ubmVjdGlvbiBpcyBub3QgY3VycmVudGx5IG9wZW5cbiAgICAgICAgLy8gd2hpY2ggY291bGQgaGFwcGVuIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB3ZSB0aGluZyB0aGUgc3RhdGUgaXMuXG4gICAgICAgIGlmICghdGhpcy5zdGF0dXNBc3NlcnQoVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19PUEVOLCBvcHRpb25zLmZvcmNlKSkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwidW5hYmxlIHRvIHNlbmQgbWVzc2FnZSAtIFdlYlNvY2tldCBub3Qgb3BlblwiKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbm90IG9wZW4uXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJzZW5kaW5nIFdlYlNvY2tldCBtZXNzYWdlOlxcblxcblwiICsgbWVzc2FnZSArIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlYlNvY2tldC5zZW5kKCkgY2FuIHRocm93LlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViU29ja2V0L3NlbmRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkZhaWxlZCB0byBzZW5kIG1lc3NhZ2UuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgbXNnOiBtZXNzYWdlIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBzb2NrZXQuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNjb25uZWN0UHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlKSB7IC8vIEFscmVhZHkgZGlzY29ubmVjdGluZy4gSnVzdCByZXR1cm4gdGhpcy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuY29kZSA9IG9wdGlvbnMuY29kZSB8fCAxMDAwO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzVHJhbnNpdGlvbihUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NJTkcsIG9wdGlvbnMuZm9yY2UpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VEKSB7IC8vIFdlYnNvY2tldCBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBvdmVycmlkZUV2ZW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSkgeyAvLyBXZWJzb2NrZXQgaXMgY29ubmVjdGluZywgY2Fubm90IG1vdmUgdG8gZGlzY29ubmV0aW5nIHlldFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJUaGUgd2Vic29ja2V0IGRpZCBub3QgZGlzY29ubmVjdFwiKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IG92ZXJyaWRlRXZlbnQ6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2Fubm90IG1vdmUgdG8gZGlzY29ubmVjdGluZywgYnV0IG5vdCBpbiBjb25uZWN0aW5nIHN0YXRlLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlRoZSB3ZWJzb2NrZXQgZGlkIG5vdCBkaXNjb25uZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RpbmdcIik7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMud3MpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdG9wU2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nKFwiY2xvc2luZyBXZWJTb2NrZXQgXCIgKyBfdGhpcy5zZXJ2ZXIud3NVcmkpO1xuICAgICAgICAgICAgICAgIF90aGlzLndzLmNsb3NlKG9wdGlvbnMuY29kZSwgb3B0aW9ucy5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFwiQXR0ZW1wdGVkIHRvIGRpc2Nvbm5lY3QgYnV0IHRoZSB3ZWJzb2NrZXQgZG9lc24ndCBleGlzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2Nvbm5lY3Rpb25Qcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCBzb2NrZXQuXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0UHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TSU5HICYmICFvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJXZWJTb2NrZXQgXCIgKyB0aGlzLnNlcnZlci53c1VyaSArIFwiIGlzIGNsb3NpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyID0gdGhpcy5zZXJ2ZXIgfHwgdGhpcy5nZXROZXh0V3NTZXJ2ZXIob3B0aW9ucy5mb3JjZSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoKF90aGlzLnN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19PUEVOIHx8IF90aGlzLnN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TSU5HKVxuICAgICAgICAgICAgICAgICYmICFvcHRpb25zLmZvcmNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJXZWJTb2NrZXQgXCIgKyBfdGhpcy5zZXJ2ZXIud3NVcmkgKyBcIiBpcyBhbHJlYWR5IGNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJGYWlsZWQgc3RhdHVzIGNoZWNrIC0gYXR0ZW1wdGVkIHRvIG9wZW4gYSBjb25uZWN0aW9uIGJ1dCBhbHJlYWR5IG9wZW4vY2xvc2luZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLmNvbm5lY3REZWZlcnJlZFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIF90aGlzLnN0YXR1cyA9IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ09OTkVDVElORztcbiAgICAgICAgICAgIF90aGlzLmVtaXQoXCJjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcImNvbm5lY3RpbmcgdG8gV2ViU29ja2V0IFwiICsgX3RoaXMuc2VydmVyLndzVXJpKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VXcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQoX3RoaXMuc2VydmVyLndzVXJpLCBcInNpcFwiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy53cy5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiOyAvLyBzZXQgZGF0YSB0eXBlIG9mIHJlY2VpdmVkIGJpbmFyeSBtZXNzYWdlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VELCB0cnVlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkVycm9yKFwiZXJyb3IgY29ubmVjdGluZyB0byBXZWJTb2NrZXQgXCIgKyBfdGhpcy5zZXJ2ZXIud3NVcmkgKyBcIjpcIiArIGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdChcIkZhaWxlZCB0byBjcmVhdGUgYSB3ZWJzb2NrZXRcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy53cykge1xuICAgICAgICAgICAgICAgIHJlamVjdChcIlVuZXhwZWN0ZWQgaW5zdGFuY2Ugd2Vic29ja2V0IG5vdCBzZXRcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VEKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihcInRvb2sgdG9vIGxvbmcgdG8gY29ubmVjdCAtIGV4Y2VlZGVkIHRpbWUgc2V0IGluIGNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblRpbWVvdXQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29uZmlndXJhdGlvbi5jb25uZWN0aW9uVGltZW91dCArIFwic1wiKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIsIHsgY29kZTogMTAwMCB9KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZWplY3QoXCJDb25uZWN0aW9uIHRpbWVvdXRcIik7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdmFyIHdzID0gX3RoaXMud3M7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcG9zZVdzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHdzLmNsb3NlKDEwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF90aGlzLmNvbmZpZ3VyYXRpb24uY29ubmVjdGlvblRpbWVvdXQgKiAxMDAwKTtcbiAgICAgICAgICAgIF90aGlzLmJvdW5kT25PcGVuID0gX3RoaXMub25PcGVuLmJpbmQoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuYm91bmRPbk1lc3NhZ2UgPSBfdGhpcy5vbk1lc3NhZ2UuYmluZChfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5ib3VuZE9uQ2xvc2UgPSBfdGhpcy5vbkNsb3NlLmJpbmQoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuYm91bmRPbkVycm9yID0gX3RoaXMub25XZWJzb2NrZXRFcnJvci5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLndzLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIF90aGlzLmJvdW5kT25PcGVuKTtcbiAgICAgICAgICAgIF90aGlzLndzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIF90aGlzLmJvdW5kT25NZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzLndzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBfdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICAgICAgX3RoaXMud3MuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIF90aGlzLmJvdW5kT25FcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkYXRhID0gZS5kYXRhO1xuICAgICAgICB2YXIgZmluaXNoZWREYXRhO1xuICAgICAgICAvLyBDUkxGIEtlZXAgQWxpdmUgcmVzcG9uc2UgZnJvbSBzZXJ2ZXIuIENsZWFyIG91ciBrZWVwIGFsaXZlIHRpbWVvdXQuXG4gICAgICAgIGlmICgvXihcXHJcXG4pKyQvLnRlc3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJLZWVwQWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmVjZWl2ZWQgV2ViU29ja2V0IG1lc3NhZ2Ugd2l0aCBDUkxGIEtlZXAgQWxpdmUgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJyZWNlaXZlZCBlbXB0eSBtZXNzYWdlLCBtZXNzYWdlIGRpc2NhcmRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikgeyAvLyBXZWJTb2NrZXQgYmluYXJ5IG1lc3NhZ2UuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBVSW50OERhdGEgd2FzIGhlcmUgcHJpb3IgdG8gdHlwZXMsIGFuZCBkb2Vzbid0IGNoZWNrXG4gICAgICAgICAgICAgICAgZmluaXNoZWREYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInJlY2VpdmVkIFdlYlNvY2tldCBiaW5hcnkgbWVzc2FnZSBmYWlsZWQgdG8gYmUgY29udmVydGVkIGludG8gc3RyaW5nLCBtZXNzYWdlIGRpc2NhcmRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWd1cmF0aW9uLnRyYWNlU2lwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwicmVjZWl2ZWQgV2ViU29ja2V0IGJpbmFyeSBtZXNzYWdlOlxcblxcblwiICsgZGF0YSArIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBXZWJTb2NrZXQgdGV4dCBtZXNzYWdlLlxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi50cmFjZVNpcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcInJlY2VpdmVkIFdlYlNvY2tldCB0ZXh0IG1lc3NhZ2U6XFxuXFxuXCIgKyBkYXRhICsgXCJcXG5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5pc2hlZERhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgZmluaXNoZWREYXRhKTtcbiAgICB9O1xuICAgIC8vIFRyYW5zcG9ydCBFdmVudCBIYW5kbGVyc1xuICAgIC8qKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NFRCkgeyAvLyBJbmRpY2F0ZWQgdGhhdCB0aGUgdHJhbnNwb3J0IHRoaW5rcyB0aGUgd3MgaXMgZGVhZCBhbHJlYWR5XG4gICAgICAgICAgICB2YXIgd3MgPSB0aGlzLndzO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlV3MoKTtcbiAgICAgICAgICAgIGlmICh3cykge1xuICAgICAgICAgICAgICAgIHdzLmNsb3NlKDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzVHJhbnNpdGlvbihUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX09QRU4sIHRydWUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0ZWRcIik7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIldlYlNvY2tldCBcIiArIHRoaXMuc2VydmVyLndzVXJpICsgXCIgY29ubmVjdGVkXCIpO1xuICAgICAgICAvLyBDbGVhciByZWNvbm5lY3RUaW1lciBzaW5jZSB3ZSBhcmUgbm90IGRpc2Nvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHJlY29ubmVjdGlvbkF0dGVtcHRzXG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSAwO1xuICAgICAgICAvLyBSZXNldCBkaXNjb25uZWN0aW9uIHByb21pc2Ugc28gd2UgY2FuIGRpc2Nvbm5lY3QgZnJvbSBhIGZyZXNoIHN0YXRlXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdGlvblByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gU3RhcnQgc2VuZGluZyBrZWVwLWFsaXZlc1xuICAgICAgICB0aGlzLnN0YXJ0U2VuZGluZ0tlZXBBbGl2ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0RGVmZXJyZWRSZXNvbHZlKHsgb3ZlcnJpZGVFdmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdERlZmVycmVkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdERlZmVycmVkUmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVuZXhwZWN0ZWQgd2Vic29ja2V0Lm9uT3BlbiB3aXRoIG5vIGNvbm5lY3REZWZlcnJlZFJlc29sdmVcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJXZWJTb2NrZXQgZGlzY29ubmVjdGVkIChjb2RlOiBcIiArIGUuY29kZSArIChlLnJlYXNvbiA/IFwifCByZWFzb246IFwiICsgZS5yZWFzb24gOiBcIlwiKSArIFwiKVwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NJTkcpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJXZWJTb2NrZXQgY2xvc2VkIHdpdGhvdXQgU0lQLmpzIHJlcXVlc3RpbmcgaXRcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnRFcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgICAvLyBDbGVhbiB1cCBjb25uZWN0aW9uIHZhcmlhYmxlcyBzbyB3ZSBjYW4gY29ubmVjdCBhZ2FpbiBmcm9tIGEgZnJlc2ggc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0RGVmZXJyZWRSZWplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdERlZmVycmVkUmVqZWN0KFwiV2Vic29ja2V0IENsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbm5lY3REZWZlcnJlZFJlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdERlZmVycmVkUmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIHJlcXVlc3RlZCB0byBjbG9zZS5cbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdERlZmVycmVkUmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0RGVmZXJyZWRSZXNvbHZlKHsgb3ZlcnJpZGVFdmVudDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzVHJhbnNpdGlvbihUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NFRCk7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3REZWZlcnJlZFJlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXNUcmFuc2l0aW9uKFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ0xPU0VELCB0cnVlKTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIsIHsgY29kZTogZS5jb2RlLCByZWFzb246IGUucmVhc29uIH0pO1xuICAgICAgICB0aGlzLmRpc3Bvc2VXcygpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgYW5kIGNsZWFycyB0aGUgaW5zdGFuY2Ugd3NcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2VXcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMud3MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgdGhpcy5ib3VuZE9uT3Blbik7XG4gICAgICAgICAgICB0aGlzLndzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuYm91bmRPbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy53cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgdGhpcy5ib3VuZE9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy53cy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgdGhpcy5ib3VuZE9uRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVcbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVHJhbnNwb3J0IGVycm9yOiBcIiArIGUpO1xuICAgICAgICB0aGlzLmVtaXQoXCJ0cmFuc3BvcnRFcnJvclwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbldlYnNvY2tldEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9uRXJyb3IoXCJUaGUgV2Vic29ja2V0IGhhZCBhbiBlcnJvclwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdGlvbiBhdHRlbXB0IGxvZ2ljLlxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlJlY29ubmVjdGlvbiBhdHRlbXB0IFwiICsgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyArIFwiIGZhaWxlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ub0F2YWlsYWJsZVNlcnZlcnMoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImF0dGVtcHRlZCB0byBnZXQgbmV4dCB3cyBzZXJ2ZXIgYnV0IHRoZXJlIGFyZSBubyBhdmFpbGFibGUgd3Mgc2VydmVycyBsZWZ0XCIpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm5vIGF2YWlsYWJsZSB3cyBzZXJ2ZXJzIGxlZnQgLSBnb2luZyB0byBjbG9zZWQgc3RhdGVcIik7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1RyYW5zaXRpb24oVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlcnZlckVycm9yU3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImF0dGVtcHRlZCB0byByZWNvbm5lY3Qgd2hpbGUgY29ubmVjdGVkIC0gZm9yY2luZyBkaXNjb25uZWN0XCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHsgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyArPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA+IHRoaXMuY29uZmlndXJhdGlvbi5tYXhSZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzIGZvciBXZWJTb2NrZXQgXCIgKyB0aGlzLnNlcnZlci53c1VyaSk7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJ0cmFuc3BvcnQgXCIgKyB0aGlzLnNlcnZlci53c1VyaSArIFwiIGZhaWxlZCB8IGNvbm5lY3Rpb24gc3RhdGUgc2V0IHRvICdlcnJvcidcIik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5pc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRyYW5zcG9ydEVycm9yXCIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vQXZhaWxhYmxlU2VydmVycygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIgPSB0aGlzLmdldE5leHRXc1NlcnZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlIHNlcnZlcnMsIHRoZSByZWNvbm5lY3QgZnVuY3Rpb24gZW5kcyBvbiB0aGUgbmV4dCByZWN1cnNpdmUgY2FsbFxuICAgICAgICAgICAgLy8gYWZ0ZXIgY2hlY2tpbmcgZm9yIG5vIGF2YWlsYWJsZSBzZXJ2ZXJzIGFnYWluLlxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwidHJ5aW5nIHRvIHJlY29ubmVjdCB0byBXZWJTb2NrZXQgXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmVyLndzVXJpICsgXCIgKHJlY29ubmVjdGlvbiBhdHRlbXB0IFwiICsgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyArIFwiKVwiKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjb25uZWN0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LCAodGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9PT0gMSkgPyAwIDogdGhpcy5jb25maWd1cmF0aW9uLnJlY29ubmVjdGlvblRpbWVvdXQgKiAxMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBlcnJvciBzdGF0ZSBvZiBhbGwgc2VydmVycyBpbiB0aGUgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucmVzZXRTZXJ2ZXJFcnJvclN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgd2Vic29ja2V0ID0gX2FbX2ldO1xuICAgICAgICAgICAgd2Vic29ja2V0LmlzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIG5leHQgc2VydmVyIHRvIHdoaWNoIGNvbm5lY3QuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBhbGxvd3MgYnlwYXNzIG9mIHNlcnZlciBlcnJvciBzdGF0dXMgY2hlY2tpbmdcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBXc1NlcnZlclxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0TmV4dFdzU2VydmVyID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMubm9BdmFpbGFibGVTZXJ2ZXJzKCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJhdHRlbXB0ZWQgdG8gZ2V0IG5leHQgd3Mgc2VydmVyIGJ1dCB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlIHdzIHNlcnZlcnMgbGVmdFwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0dGVtcHRlZCB0byBnZXQgbmV4dCB3cyBzZXJ2ZXIsIGJ1dCB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlIHdzIHNlcnZlcnMgbGVmdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JkZXIgc2VydmVycyBieSB3ZWlnaHRcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29uZmlndXJhdGlvbi53c1NlcnZlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgd3NTZXJ2ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAod3NTZXJ2ZXIuaXNFcnJvciAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHdzU2VydmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdzU2VydmVyLndlaWdodCA+IGNhbmRpZGF0ZXNbMF0ud2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IFt3c1NlcnZlcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3c1NlcnZlci53ZWlnaHQgPT09IGNhbmRpZGF0ZXNbMF0ud2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHdzU2VydmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2FuZGlkYXRlcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlc1tpZHhdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGFsbCBjb25maWd1cmF0aW9uIHNlcnZlcnMsIHJldHVybnMgdHJ1ZSBpZiBhbGwgb2YgdGhlbSBoYXZlIGlzRXJyb3I6IHRydWUgYW5kIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUubm9BdmFpbGFibGVTZXJ2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb25maWd1cmF0aW9uLndzU2VydmVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBpZiAoIXNlcnZlci5pc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gS2VlcEFsaXZlIFN0dWZmXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGtlZXAtYWxpdmUgKGEgZG91YmxlLUNSTEYgc2VxdWVuY2UpLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gb3V0c3RhbmRpbmcga2VlcCBhbGl2ZSwgZG8gbm90IHNlbmQgYW5vdGhlci5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZW1pdChcImtlZXBBbGl2ZURlYm91bmNlVGltZW91dFwiKTtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyS2VlcEFsaXZlVGltZW91dCgpO1xuICAgICAgICB9LCB0aGlzLmNvbmZpZ3VyYXRpb24ua2VlcEFsaXZlRGVib3VuY2UgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIlxcclxcblxcclxcblwiKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuY2xlYXJLZWVwQWxpdmVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBBbGl2ZURlYm91bmNlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBzZW5kaW5nIGtlZXAtYWxpdmVzLlxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlndXJhdGlvbi5rZWVwQWxpdmVJbnRlcnZhbCAmJiAhdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwQWxpdmVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kS2VlcEFsaXZlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRTZW5kaW5nS2VlcEFsaXZlcygpO1xuICAgICAgICAgICAgfSwgY29tcHV0ZUtlZXBBbGl2ZVRpbWVvdXQodGhpcy5jb25maWd1cmF0aW9uLmtlZXBBbGl2ZUludGVydmFsKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3Agc2VuZGluZyBrZWVwLWFsaXZlcy5cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnN0b3BTZW5kaW5nS2VlcEFsaXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwQWxpdmVEZWJvdW5jZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcEFsaXZlSW50ZXJ2YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMua2VlcEFsaXZlRGVib3VuY2VUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gU3RhdHVzIFN0dWZmXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGdpdmVuIHN0YXR1cyBhZ2FpbnN0IGluc3RhbmNlIGN1cnJlbnQgc3RhdHVzLiBSZXR1cm5zIHRydWUgaWYgdGhleSBtYXRjaFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnN0YXR1c0Fzc2VydCA9IGZ1bmN0aW9uIChzdGF0dXMsIGZvcmNlKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJBdHRlbXB0ZWQgdG8gYXNzZXJ0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoVHJhbnNwb3J0U3RhdHVzKVt0aGlzLnN0YXR1c10gKyBcIiBhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKFRyYW5zcG9ydFN0YXR1cylbc3RhdHVzXSArIFwiLSBjb250aW51aW5nIHdpdGggb3B0aW9uOiAnZm9yY2UnXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlRyaWVkIHRvIGFzc2VydCBcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKFRyYW5zcG9ydFN0YXR1cylbc3RhdHVzXSArIFwiIGJ1dCBpcyBjdXJyZW50bHkgXCIgK1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhUcmFuc3BvcnRTdGF0dXMpW3RoaXMuc3RhdHVzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9ucyB0aGUgc3RhdHVzLiBDaGVja3MgZm9yIGxlZ2FsIHRyYW5zaXRpb24gdmlhIGFzc2VydGlvbiBiZWZvcmVoYW5kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuc3RhdHVzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChzdGF0dXMsIGZvcmNlKSB7XG4gICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiQXR0ZW1wdGluZyB0byB0cmFuc2l0aW9uIHN0YXR1cyBmcm9tIFwiICtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKFRyYW5zcG9ydFN0YXR1cylbdGhpcy5zdGF0dXNdICsgXCIgdG8gXCIgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoVHJhbnNwb3J0U3RhdHVzKVtzdGF0dXNdKTtcbiAgICAgICAgaWYgKChzdGF0dXMgPT09IFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ09OTkVDVElORyAmJiB0aGlzLnN0YXR1c0Fzc2VydChUcmFuc3BvcnRTdGF0dXMuU1RBVFVTX0NMT1NFRCwgZm9yY2UpKSB8fFxuICAgICAgICAgICAgKHN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19PUEVOICYmIHRoaXMuc3RhdHVzQXNzZXJ0KFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfQ09OTkVDVElORywgZm9yY2UpKSB8fFxuICAgICAgICAgICAgKHN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TSU5HICYmIHRoaXMuc3RhdHVzQXNzZXJ0KFRyYW5zcG9ydFN0YXR1cy5TVEFUVVNfT1BFTiwgZm9yY2UpKSB8fFxuICAgICAgICAgICAgKHN0YXR1cyA9PT0gVHJhbnNwb3J0U3RhdHVzLlNUQVRVU19DTE9TRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlN0YXR1cyB0cmFuc2l0aW9uIGZhaWxlZCAtIHJlc3VsdDogbm8tb3AgLSByZWFzb246XCIgK1xuICAgICAgICAgICAgICAgIFwiIGVpdGhlciBnYXZlIGFuIG5vbmV4aXN0ZW50IHN0YXR1cyBvciBhdHRlbXB0ZWQgaWxsZWdhbCB0cmFuc2l0aW9uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDb25maWd1cmF0aW9uIEhhbmRsaW5nXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBsb2FkLlxuICAgICAqIHJldHVybnMge0NvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5sb2FkQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgd3NTZXJ2ZXJzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWU6IFwiV1NTXCIsXG4gICAgICAgICAgICAgICAgICAgIHNpcFVyaTogXCI8c2lwOmVkZ2Uuc2lwLm9uc2lwLmNvbTt0cmFuc3BvcnQ9d3M7bHI+XCIsXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgd3NVcmk6IFwid3NzOi8vZWRnZS5zaXAub25zaXAuY29tXCIsXG4gICAgICAgICAgICAgICAgICAgIGlzRXJyb3I6IGZhbHNlXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogNSxcbiAgICAgICAgICAgIG1heFJlY29ubmVjdGlvbkF0dGVtcHRzOiAzLFxuICAgICAgICAgICAgcmVjb25uZWN0aW9uVGltZW91dDogNCxcbiAgICAgICAgICAgIGtlZXBBbGl2ZUludGVydmFsOiAwLFxuICAgICAgICAgICAga2VlcEFsaXZlRGVib3VuY2U6IDEwLFxuICAgICAgICAgICAgLy8gTG9nZ2luZ1xuICAgICAgICAgICAgdHJhY2VTaXA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb25maWdDaGVjayA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbkNoZWNrKCk7XG4gICAgICAgIC8vIENoZWNrIE1hbmRhdG9yeSBwYXJhbWV0ZXJzXG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBjb25maWdDaGVjay5tYW5kYXRvcnkpIHtcbiAgICAgICAgICAgIGlmICghY29uZmlndXJhdGlvbi5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zLkNvbmZpZ3VyYXRpb25FcnJvcihwYXJhbWV0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29uZmlndXJhdGlvbltwYXJhbWV0ZXJdO1xuICAgICAgICAgICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBjb25maWdDaGVjay5tYW5kYXRvcnlbcGFyYW1ldGVyXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW3BhcmFtZXRlcl0gPSBjaGVja2VkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uc18xLkV4Y2VwdGlvbnMuQ29uZmlndXJhdGlvbkVycm9yKHBhcmFtZXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICAgIGZvciAodmFyIHBhcmFtZXRlciBpbiBjb25maWdDaGVjay5vcHRpb25hbCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbmZpZ3VyYXRpb25bcGFyYW1ldGVyXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIGFuIGVtcHR5IGFycmF5LCBidXQgc2hvdWxkbid0IGJlLCBhcHBseSBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGlzIG51bGwsIGVtcHR5IHN0cmluZywgb3IgdW5kZWZpbmVkIHRoZW4gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIG51bWJlciB3aXRoIE5hTiB2YWx1ZSB0aGVuIGFsc28gYXBwbHkgaXRzIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgLy8gTk9URTogSlMgZG9lcyBub3QgYWxsb3cgXCJ2YWx1ZSA9PT0gTmFOXCIsIHRoZSBmb2xsb3dpbmcgZG9lcyB0aGUgd29yazpcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IFwiXCIgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIGlzTmFOKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGVja2VkVmFsdWUgPSBjb25maWdDaGVjay5vcHRpb25hbFtwYXJhbWV0ZXJdKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NbcGFyYW1ldGVyXSA9IGNoZWNrZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb25zXzEuRXhjZXB0aW9ucy5Db25maWd1cmF0aW9uRXJyb3IocGFyYW1ldGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBza2VsZXRvbiA9IHt9OyAvLyBGaWxsIHRoZSB2YWx1ZSBvZiB0aGUgY29uZmlndXJhdGlvbl9za2VsZXRvblxuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICAgICAgc2tlbGV0b25bcGFyYW1ldGVyXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzW3BhcmFtZXRlcl0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuQ29uZmlndXJhdGlvbiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCBza2VsZXRvbik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcImNvbmZpZ3VyYXRpb24gcGFyYW1ldGVycyBhZnRlciB2YWxpZGF0aW9uOlwiKTtcbiAgICAgICAgZm9yICh2YXIgcGFyYW1ldGVyIGluIHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkocGFyYW1ldGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIsK3IFwiICsgcGFyYW1ldGVyICsgXCI6IFwiICsgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3NbcGFyYW1ldGVyXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5Db25maWd1cmF0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBjaGVja2VyLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5nZXRDb25maWd1cmF0aW9uQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYW5kYXRvcnk6IHt9LFxuICAgICAgICAgICAgb3B0aW9uYWw6IHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiB0aGlzIGZ1bmN0aW9uIHVzZWQgdG8gY2FsbCAndGhpcy5sb2dnZXIuZXJyb3InIGJ1dCBjYWxsaW5nICd0aGlzJyB3aXRoIGFueXRoaW5nIGhlcmUgaXMgaW52YWxpZFxuICAgICAgICAgICAgICAgIHdzU2VydmVyczogZnVuY3Rpb24gKHdzU2VydmVycykge1xuICAgICAgICAgICAgICAgICAgICAvKiBBbGxvdyBkZWZpbmluZyB3c1NlcnZlcnMgcGFyYW1ldGVyIGFzOlxuICAgICAgICAgICAgICAgICAgICAgKiAgU3RyaW5nOiBcImhvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgKiAgQXJyYXkgb2YgU3RyaW5nczogW1wiaG9zdDFcIiwgXCJob3N0MlwiXVxuICAgICAgICAgICAgICAgICAgICAgKiAgQXJyYXkgb2YgT2JqZWN0czogW3t3c1VyaTpcImhvc3QxXCIsIHdlaWdodDoxfSwge3dzVXJpOlwiaG9zdDJcIiwgd2VpZ2h0OjB9XVxuICAgICAgICAgICAgICAgICAgICAgKiAgQXJyYXkgb2YgT2JqZWN0cyBhbmQgU3RyaW5nczogW3t3c1VyaTpcImhvc3QxXCJ9LCBcImhvc3QyXCJdXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdzU2VydmVycyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXJzID0gW3sgd3NVcmk6IHdzU2VydmVycyB9XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3c1NlcnZlcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgd3NTZXJ2ZXJzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdzU2VydmVyc1tpZHhdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzU2VydmVyc1tpZHhdID0geyB3c1VyaTogd3NTZXJ2ZXJzW2lkeF0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdzU2VydmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHdzU2VydmVyc18xID0gd3NTZXJ2ZXJzOyBfaSA8IHdzU2VydmVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdzU2VydmVyID0gd3NTZXJ2ZXJzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3c1NlcnZlci53c1VyaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3c1NlcnZlci53ZWlnaHQgJiYgIU51bWJlcih3c1NlcnZlci53ZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGNvcmVfMS5HcmFtbWFyLnBhcnNlKHdzU2VydmVyLndzVXJpLCBcImFic29sdXRlVVJJXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChbXCJ3c3NcIiwgXCJ3c1wiLCBcInVkcFwiXS5pbmRleE9mKHVybC5zY2hlbWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzU2VydmVyLnNpcFVyaSA9IFwiPHNpcDpcIiArIHVybC5ob3N0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHVybC5wb3J0ID8gXCI6XCIgKyB1cmwucG9ydCA6IFwiXCIpICsgXCI7dHJhbnNwb3J0PVwiICsgdXJsLnNjaGVtZS5yZXBsYWNlKC9ed3NzJC9pLCBcIndzXCIpICsgXCI7bHI+XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3c1NlcnZlci53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXIud2VpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3NTZXJ2ZXIuaXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdzU2VydmVyLnNjaGVtZSA9IHVybC5zY2hlbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3NTZXJ2ZXJzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlSW50ZXJ2YWw6IGZ1bmN0aW9uIChrZWVwQWxpdmVJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwoa2VlcEFsaXZlSW50ZXJ2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBOdW1iZXIoa2VlcEFsaXZlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAga2VlcEFsaXZlRGVib3VuY2U6IGZ1bmN0aW9uIChrZWVwQWxpdmVEZWJvdW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHNfMS5VdGlscy5pc0RlY2ltYWwoa2VlcEFsaXZlRGVib3VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBOdW1iZXIoa2VlcEFsaXZlRGVib3VuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhY2VTaXA6IGZ1bmN0aW9uICh0cmFjZVNpcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyYWNlU2lwID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYWNlU2lwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKGNvbm5lY3Rpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChjb25uZWN0aW9uVGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtYXhSZWNvbm5lY3Rpb25BdHRlbXB0czogZnVuY3Rpb24gKG1heFJlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsc18xLlV0aWxzLmlzRGVjaW1hbChtYXhSZWNvbm5lY3Rpb25BdHRlbXB0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IE51bWJlcihtYXhSZWNvbm5lY3Rpb25BdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKHJlY29ubmVjdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzXzEuVXRpbHMuaXNEZWNpbWFsKHJlY29ubmVjdGlvblRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBOdW1iZXIocmVjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgVHJhbnNwb3J0LkMgPSBUcmFuc3BvcnRTdGF0dXM7XG4gICAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oVHJhbnNwb3J0XzEuVHJhbnNwb3J0KSk7XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgTW9kaWZpZXJzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vTW9kaWZpZXJzXCIpKTtcbmV4cG9ydHMuTW9kaWZpZXJzID0gTW9kaWZpZXJzO1xudmFyIFNpbXBsZV8xID0gcmVxdWlyZShcIi4vU2ltcGxlXCIpO1xuZXhwb3J0cy5TaW1wbGUgPSBTaW1wbGVfMS5TaW1wbGU7XG52YXIgU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlclwiKTtcbmV4cG9ydHMuU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJfMS5TZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyO1xudmFyIFRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vVHJhbnNwb3J0XCIpO1xuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnRfMS5UcmFuc3BvcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGVuZCBhIHtAbGluayBTZXNzaW9ufSAoaW5jb21pbmcgQllFKS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEJ5ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gQnllKGluY29taW5nQnllUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmluY29taW5nQnllUmVxdWVzdCA9IGluY29taW5nQnllUmVxdWVzdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ5ZS5wcm90b3R5cGUsIFwicmVxdWVzdFwiLCB7XG4gICAgICAgIC8qKiBJbmNvbWluZyBCWUUgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY29taW5nQnllUmVxdWVzdC5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQWNjZXB0IHRoZSByZXF1ZXN0LiAqL1xuICAgIEJ5ZS5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0J5ZVJlcXVlc3QuYWNjZXB0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKiogUmVqZWN0IHRoZSByZXF1ZXN0LiAqL1xuICAgIEJ5ZS5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0J5ZVJlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQnllO1xufSgpKTtcbmV4cG9ydHMuQnllID0gQnllO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENyZWF0ZXMgYW4ge0BsaW5rIEVtaXR0ZXJ9LlxuICogQHBhcmFtIGV2ZW50RW1pdHRlciAtIEFuIGV2ZW50IGVtaXR0ZXIuXG4gKiBAcGFyYW0gZXZlbnROYW1lIC0gRXZlbnQgbmFtZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBfbWFrZUVtaXR0ZXIoZXZlbnRFbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgICBpZiAoZXZlbnROYW1lID09PSB2b2lkIDApIHsgZXZlbnROYW1lID0gXCJldmVudFwiOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgICAgICAgICBldmVudEVtaXR0ZXIub25jZShldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlci5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvbjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2U6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgZXZlbnRFbWl0dGVyLm9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5fbWFrZUVtaXR0ZXIgPSBfbWFrZUVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlXCIpO1xuLyoqXG4gKiBBbiBleGNlcHRpb24gaW5kaWNhdGluZyBhbiB1bnN1cHBvcnRlZCBjb250ZW50IHR5cGUgcHJldmVudGVkIGV4ZWN1dGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIENvbnRlbnRUeXBlVW5zdXBwb3J0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UgPyBtZXNzYWdlIDogXCJVbnN1cHBvcnRlZCBjb250ZW50IHR5cGUuXCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3I7XG59KGNvcmVfMS5FeGNlcHRpb24pKTtcbmV4cG9ydHMuQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yID0gQ29udGVudFR5cGVVbnN1cHBvcnRlZEVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnRlbnQtdHlwZS11bnN1cHBvcnRlZFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXF1ZXN0LXBlbmRpbmdcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Vzc2lvbi1kZXNjcmlwdGlvbi1oYW5kbGVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Nlc3Npb24tdGVybWluYXRlZFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdGF0ZS10cmFuc2l0aW9uXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmVcIik7XG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIGFuIG91dHN0YW5kaW5nIHByaW9yIHJlcXVlc3QgcHJldmVudGVkIGV4ZWN1dGlvbi5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlcXVlc3RQZW5kaW5nRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVxdWVzdFBlbmRpbmdFcnJvciwgX3N1cGVyKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gUmVxdWVzdFBlbmRpbmdFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlID8gbWVzc2FnZSA6IFwiUmVxdWVzdCBwZW5kaW5nLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdFBlbmRpbmdFcnJvcjtcbn0oY29yZV8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5SZXF1ZXN0UGVuZGluZ0Vycm9yID0gUmVxdWVzdFBlbmRpbmdFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmVcIik7XG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIGEgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGVycm9yIG9jY3VyZWQuXG4gKiBAcHVibGljXG4gKi9cbnZhciBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlID8gbWVzc2FnZSA6IFwiVW5zcGVjaWZpZWQgc2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGVycm9yLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckVycm9yO1xufShjb3JlXzEuRXhjZXB0aW9uKSk7XG5leHBvcnRzLlNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvciA9IFNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmVcIik7XG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIHRoZSBzZXNzaW9uIHRlcm1pbmF0ZWQgYmVmb3JlIHRoZSBhY3Rpb24gY29tcGxldGVkLlxuICogQHB1YmxpY1xuICovXG52YXIgU2Vzc2lvblRlcm1pbmF0ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTZXNzaW9uVGVybWluYXRlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlc3Npb25UZXJtaW5hdGVkRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIlRoZSBzZXNzaW9uIGhhcyB0ZXJtaW5hdGVkLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2Vzc2lvblRlcm1pbmF0ZWRFcnJvcjtcbn0oY29yZV8xLkV4Y2VwdGlvbikpO1xuZXhwb3J0cy5TZXNzaW9uVGVybWluYXRlZEVycm9yID0gU2Vzc2lvblRlcm1pbmF0ZWRFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmVcIik7XG4vKipcbiAqIEFuIGV4Y2VwdGlvbiBpbmRpY2F0aW5nIGFuIGludmFsaWQgc3RhdGUgdHJhbnNpdGlvbiBlcnJvciBvY2N1cmVkLlxuICogQHB1YmxpY1xuICovXG52YXIgU3RhdGVUcmFuc2l0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhdGVUcmFuc2l0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdGVUcmFuc2l0aW9uRXJyb3IobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSA/IG1lc3NhZ2UgOiBcIkFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBzdGF0ZSB0cmFuc2l0aW9uLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhdGVUcmFuc2l0aW9uRXJyb3I7XG59KGNvcmVfMS5FeGNlcHRpb24pKTtcbmV4cG9ydHMuU3RhdGVUcmFuc2l0aW9uRXJyb3IgPSBTdGF0ZVRyYW5zaXRpb25FcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBbiBleGNoYW5nZSBvZiBpbmZvcm1hdGlvbiAoaW5jb21pbmcgSU5GTykuXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBmdW5jdGlvbiBJbmZvKGluY29taW5nSW5mb1JlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0luZm9SZXF1ZXN0ID0gaW5jb21pbmdJbmZvUmVxdWVzdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZm8ucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogSW5jb21pbmcgTUVTU0FHRSByZXF1ZXN0IG1lc3NhZ2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdJbmZvUmVxdWVzdC5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQWNjZXB0IHRoZSByZXF1ZXN0LiAqL1xuICAgIEluZm8ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdJbmZvUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKiBSZWplY3QgdGhlIHJlcXVlc3QuICovXG4gICAgSW5mby5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ0luZm9SZXF1ZXN0LnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIEluZm87XG59KCkpO1xuZXhwb3J0cy5JbmZvID0gSW5mbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIHJlY2VpdmVkIG1lc3NhZ2UgKGluY29taW5nIE1FU1NBR0UpLlxuICogQHB1YmxpY1xuICovXG52YXIgTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgZnVuY3Rpb24gTWVzc2FnZShpbmNvbWluZ01lc3NhZ2VSZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUmVxdWVzdCA9IGluY29taW5nTWVzc2FnZVJlcXVlc3Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlLnByb3RvdHlwZSwgXCJyZXF1ZXN0XCIsIHtcbiAgICAgICAgLyoqIEluY29taW5nIE1FU1NBR0UgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY29taW5nTWVzc2FnZVJlcXVlc3QubWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEFjY2VwdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBNZXNzYWdlLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluY29taW5nTWVzc2FnZVJlcXVlc3QuYWNjZXB0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKiogUmVqZWN0IHRoZSByZXF1ZXN0LiAqL1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUmVxdWVzdC5yZWplY3Qob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBub3RpZmljYXRpb24gb2YgYW4gZXZlbnQgKGluY29taW5nIE5PVElGWSkuXG4gKiBAcHVibGljXG4gKi9cbnZhciBOb3RpZmljYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihpbmNvbWluZ05vdGlmeVJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5pbmNvbWluZ05vdGlmeVJlcXVlc3QgPSBpbmNvbWluZ05vdGlmeVJlcXVlc3Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOb3RpZmljYXRpb24ucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogSW5jb21pbmcgTk9USUZZIHJlcXVlc3QgbWVzc2FnZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmNvbWluZ05vdGlmeVJlcXVlc3QubWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEFjY2VwdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdOb3RpZnlSZXF1ZXN0LmFjY2VwdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqIFJlamVjdCB0aGUgcmVxdWVzdC4gKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdOb3RpZnlSZXF1ZXN0LnJlamVjdChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuLi9jb3JlXCIpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZXN0YWJsaXNoIGEge0BsaW5rIFNlc3Npb259IGVsc2V3aGVyZSAoaW5jb21pbmcgUkVGRVIpLlxuICogQHB1YmxpY1xuICovXG52YXIgUmVmZXJyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGZ1bmN0aW9uIFJlZmVycmFsKGluY29taW5nUmVmZXJSZXF1ZXN0LCBzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QgPSBpbmNvbWluZ1JlZmVyUmVxdWVzdDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVycmFsLnByb3RvdHlwZSwgXCJyZWZlclRvXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmZXJUbyA9IHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QubWVzc2FnZS5wYXJzZUhlYWRlcihcInJlZmVyLXRvXCIpO1xuICAgICAgICAgICAgaWYgKCEocmVmZXJUbyBpbnN0YW5jZW9mIGNvcmVfMS5OYW1lQWRkckhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2UgUmVmZXItVG8gaGVhZGVyLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWZlclRvO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJyYWwucHJvdG90eXBlLCBcInJlZmVycmVkQnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY29taW5nUmVmZXJSZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwicmVmZXJyZWQtYnlcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcnJhbC5wcm90b3R5cGUsIFwicmVwbGFjZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyVG8udXJpLmdldEhlYWRlcihcInJlcGxhY2VzXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJyYWwucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogSW5jb21pbmcgUkVGRVIgcmVxdWVzdCBtZXNzYWdlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluY29taW5nUmVmZXJSZXF1ZXN0Lm1lc3NhZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBBY2NlcHQgdGhlIHJlcXVlc3QuICovXG4gICAgUmVmZXJyYWwucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMjAyIH07IH1cbiAgICAgICAgdGhpcy5pbmNvbWluZ1JlZmVyUmVxdWVzdC5hY2NlcHQob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKiBSZWplY3QgdGhlIHJlcXVlc3QuICovXG4gICAgUmVmZXJyYWwucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5jb21pbmdSZWZlclJlcXVlc3QucmVqZWN0KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGludml0ZXIgd2hpY2ggbWF5IGJlIHVzZWQgdG8gc2VuZCBhbiBvdXQgb2YgZGlhbG9nIElOVklURSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIGEgaGVscGVyIG1ldGhvZCB0byBjcmVhdGUgYW4gSW52aXRlciB3aGljaCB3aWxsIGV4ZWN1dGUgdGhlIHJlZmVycmFsXG4gICAgICogb2YgdGhlIGBTZXNzaW9uYCB3aGljaCB3YXMgcmVmZXJyZWQuIFRoZSBhcHByb3ByaWF0ZSBoZWFkZXJzIGFyZSBzZXQgYW5kXG4gICAgICogdGhlIHJlZmVycmVkIGBTZXNzaW9uYCBpcyBsaW5rZWQgdG8gdGhlIG5ldyBgU2Vzc2lvbmAuIE5vdGUgdGhhdCBvbmx5IGFcbiAgICAgKiBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIGBJbnZpdGVyYCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkIChpZiBjYWxsZWRcbiAgICAgKiBtb3JlIHRoYW4gb25jZSBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBgSW52aXRlcmAgd2lsbCBiZSByZXR1cm5lZCBldmVyeSB0aW1lKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICogQHBhcmFtIG1vZGlmaWVycyAtIFNlc3Npb24gZGVzY3JpcHRpb24gaGFuZGxlciBtb2RpZmllcnMuXG4gICAgICovXG4gICAgUmVmZXJyYWwucHJvdG90eXBlLm1ha2VJbnZpdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaW52aXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52aXRlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFyZ2V0VVJJID0gdGhpcy5yZWZlclRvLnVyaS5jbG9uZSgpO1xuICAgICAgICB0YXJnZXRVUkkuY2xlYXJIZWFkZXJzKCk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICB2YXIgcmVwbGFjZXMgPSB0aGlzLnJlcGxhY2VzO1xuICAgICAgICBpZiAocmVwbGFjZXMpIHtcbiAgICAgICAgICAgIC8vIGRlY29kZVVSSUNvbXBvbmVudCBpcyBhIGhvbGRvdmVyIGZyb20gMmMwODZlYjQuIE5vdCBzdXJlIHRoYXQgaXQgaXMgYWN0dWFsbHkgbmVjZXNzYXJ5XG4gICAgICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIlJlcGxhY2VzOiBcIiArIGRlY29kZVVSSUNvbXBvbmVudChyZXBsYWNlcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZlcnJlZEJ5ID0gdGhpcy5yZWZlcnJlZEJ5O1xuICAgICAgICBpZiAocmVmZXJyZWRCeSkge1xuICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWZlcnJlZC1CeTogXCIgKyByZWZlcnJlZEJ5KTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycztcbiAgICAgICAgdGhpcy5pbnZpdGVyID0gdGhpcy5zZXNzaW9uLnVzZXJBZ2VudC5fbWFrZUludml0ZXIodGFyZ2V0VVJJLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbnZpdGVyLl9yZWZlcnJlZCA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5zZXNzaW9uLl9yZWZlcnJhbCA9IHRoaXMuaW52aXRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52aXRlcjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZlcnJhbDtcbn0oKSk7XG5leHBvcnRzLlJlZmVycmFsID0gUmVmZXJyYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICoge0BsaW5rIFNlc3Npb259IHN0YXRlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUge0BsaW5rIFNlc3Npb259IGJlaGF2ZXMgaW4gYSBkZXRlcm1pbmlzdGljIG1hbm5lciBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZ1xuICogRmluaXRlIFN0YXRlIE1hY2hpbmUgKEZTTSkuXG4gKiBgYGB0eHRcbiAqICAgICAgICAgICAgICAgICAgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXG4gKiAgICAgICAgICAgICAgICAgIHwgIF9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgfCB8ICAgICAgICAgICAgX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAgICB8ICAgICAgICAgICAgfFxuICogU2Vzc2lvbiAgICAgICAgICB8IHwgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiAgIHYgICAgICAgICAgICB2XG4gKiBDb25zdHJ1Y3RlZCAtPiBJbml0aWFsIC0+IEVzdGFibGlzaGluZyAtPiBFc3RhYmxpc2hlZCAtPiBUZXJtaW5hdGluZyAtPiBUZXJtaW5hdGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19eICAgXlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX3xcbiAqIGBgYFxuICogQHB1YmxpY1xuICovXG52YXIgU2Vzc2lvblN0YXRlO1xuKGZ1bmN0aW9uIChTZXNzaW9uU3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBJZiBgSW52aXRlcmAsIElOVklURSBub3Qgc2VudCB5ZXQuXG4gICAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUgKGJ1dCBubyBmaW5hbCByZXNwb25zZSBzZW50IHlldCkuXG4gICAgICovXG4gICAgU2Vzc2lvblN0YXRlW1wiSW5pdGlhbFwiXSA9IFwiSW5pdGlhbFwiO1xuICAgIC8qKlxuICAgICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUgYW5kIHdhaXRpbmcgZm9yIGEgZmluYWwgcmVzcG9uc2UuXG4gICAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUgYW5kIGF0dGVtcHRpbmcgdG8gc2VuZCAyMDAgZmluYWwgcmVzcG9uc2UgKGJ1dCBoYXMgbm90IHNlbnQgaXQgeWV0KS5cbiAgICAgKi9cbiAgICBTZXNzaW9uU3RhdGVbXCJFc3RhYmxpc2hpbmdcIl0gPSBcIkVzdGFibGlzaGluZ1wiO1xuICAgIC8qKlxuICAgICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUgYW5kIHJlY2VpdmVkIDIwMCBmaW5hbCByZXNwb25zZSBhbmQgc2VudCBBQ0suXG4gICAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUgYW5kIHNlbnQgMjAwIGZpbmFsIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIFNlc3Npb25TdGF0ZVtcIkVzdGFibGlzaGVkXCJdID0gXCJFc3RhYmxpc2hlZFwiO1xuICAgIC8qKlxuICAgICAqIElmIGBJbnZpdGVyYCwgc2VudCBJTlZJVEUsIHNlbnQgQ0FOQ0VMIGFuZCBub3cgd2FpdGluZyBmb3IgNDg3IGZpbmFsIHJlc3BvbnNlIHRvIEFDSyAob3IgMjAwIHRvIEFDSyAmIEJZRSkuXG4gICAgICogSWYgYEludml0YXRpb25gLCByZWNlaXZlZCBJTlZJVEUsIHNlbnQgMjAwIGZpbmFsIHJlc3BvbnNlIGFuZCBub3cgd2FpdGluZyBvbiBBQ0sgYW5kIHVwb24gcmVjZWlwdCB3aWxsIGF0dGVtcHQgQllFXG4gICAgICogKGFzIHRoZSBwcm90b2NvbCBzcGVjaWZpY2F0aW9uIHJlcXVpcmVzLCBiZWZvcmUgc2VuZGluZyBhIEJZRSB3ZSBtdXN0IHJlY2VpdmUgdGhlIEFDSyAtIHNvIHdlIGFyZSB3YWl0aW5nKS5cbiAgICAgKi9cbiAgICBTZXNzaW9uU3RhdGVbXCJUZXJtaW5hdGluZ1wiXSA9IFwiVGVybWluYXRpbmdcIjtcbiAgICAvKipcbiAgICAgKiBJZiBgSW52aXRlcmAsIHNlbnQgSU5WSVRFIGFuZCByZWNlaXZlZCBub24tMjAwIGZpbmFsIHJlc3BvbnNlIChvciBzZW50L3JlY2VpdmVkIEJZRSBhZnRlciByZWNlaXZpbmcgMjAwKS5cbiAgICAgKiBJZiBgSW52aXRhdGlvbmAsIHJlY2VpdmVkIElOVklURSBhbmQgc2VudCBub24tMjAwIGZpbmFsIHJlc3BvbnNlIChvciBzZW50L3JlY2VpdmVkIEJZRSBhZnRlciBzZW5kaW5nIDIwMCkuXG4gICAgICovXG4gICAgU2Vzc2lvblN0YXRlW1wiVGVybWluYXRlZFwiXSA9IFwiVGVybWluYXRlZFwiO1xufSkoU2Vzc2lvblN0YXRlID0gZXhwb3J0cy5TZXNzaW9uU3RhdGUgfHwgKGV4cG9ydHMuU2Vzc2lvblN0YXRlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBjb3JlXzEgPSByZXF1aXJlKFwiLi4vY29yZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4uL2NvcmUvbWVzc2FnZXMvdXRpbHNcIik7XG52YXIgYWxsb3dlZF9tZXRob2RzXzEgPSByZXF1aXJlKFwiLi4vY29yZS91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzXCIpO1xudmFyIGJ5ZV8xID0gcmVxdWlyZShcIi4vYnllXCIpO1xudmFyIGVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL2VtaXR0ZXJcIik7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vZXhjZXB0aW9uc1wiKTtcbnZhciBpbmZvXzEgPSByZXF1aXJlKFwiLi9pbmZvXCIpO1xudmFyIG1lc3NhZ2VfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2VcIik7XG52YXIgbm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKFwiLi9ub3RpZmljYXRpb25cIik7XG52YXIgcmVmZXJyYWxfMSA9IHJlcXVpcmUoXCIuL3JlZmVycmFsXCIpO1xudmFyIHNlc3Npb25fc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3Nlc3Npb24tc3RhdGVcIik7XG4vKipcbiAqIEEgc2Vzc2lvbiBwcm92aWRlcyByZWFsIHRpbWUgY29tbXVuaWNhdGlvbiBiZXR3ZWVuIG9uZSBvciBtb3JlIHBhcnRpY2lwYW50cy5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIHRyYW5zcG9ydCBiZWhhdmVzIGluIGEgZGV0ZXJtaW5pc3RpYyBtYW5uZXIgYWNjb3JkaW5nIHRvIHRoZVxuICogdGhlIHN0YXRlIGRlZmluZWQgaW4ge0BsaW5rIFNlc3Npb25TdGF0ZX0uXG4gKiBAcHVibGljXG4gKi9cbnZhciBTZXNzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSB1c2VyQWdlbnQgLSBVc2VyIGFnZW50LiBTZWUge0BsaW5rIFVzZXJBZ2VudH0gZm9yIGRldGFpbHMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2Vzc2lvbih1c2VyQWdlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLyoqIFRydWUgaWYgdGhlcmUgaXMgYSByZS1JTlZJVEUgcmVxdWVzdCBvdXRzdGFuZGluZy4gKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFNlc3Npb24gc3RhdGUuICovXG4gICAgICAgIHRoaXMuX3N0YXRlID0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Jbml0aWFsO1xuICAgICAgICAvKiogU2Vzc2lvbiBzdGF0ZSBlbWl0dGVyLiAqL1xuICAgICAgICB0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlciA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG9wdGlvbnMuZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuX3VzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uIFwiICsgdGhpcy5pZCArIFwiIGluIHN0YXRlIFwiICsgdGhpcy5fc3RhdGUgKyBcIiBpcyBiZWluZyBkaXNwb3NlZFwiKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIHVzZXIgYWdlbnQncyBzZXNzaW9uIGNvbGxlY3Rpb25cbiAgICAgICAgZGVsZXRlIHRoaXMudXNlckFnZW50Ll9zZXNzaW9uc1t0aGlzLmlkXTtcbiAgICAgICAgLy8gRGlzcG9zZSBvZiBkaWFsb2cgbWVkaWFcbiAgICAgICAgaWYgKHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoZSBTREggbmVlZHMgdG8gcmVtYWluIGRlZmluZWQgYXMgaXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgaXMgY2xvc2VkIGluIGNhc2VzXG4gICAgICAgICAgICAvLyB3aGVyZSBhbiBhbnN3ZXIvb2ZmZXIgYXJyaXZlcyB3aGlsZSB0aGUgc2Vzc2lvbiBpcyBiZWluZyB0b3JuIGRvd24uIFRoZXJlIGFyZSBhIHZhcmlldHlcbiAgICAgICAgICAgIC8vIG9mIGNpcmN1bXN0YW5jZXMgd2hlcmUgdGhpcyBjYW4gaGFwcGVuIC0gc2VuZGluZyBhIEJZRSBkdXJpbmcgYSByZS1JTlZJVEUgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICAvLyBUaGUgY29kZSBpcyBjdXJyZW50bHkgd3JpdHRlbiBzdWNoIHRoYXQgaXQgbGF6aWx5IG1ha2VzIGEgbmV3IFNESCB3aGVuIGl0IG5lZWRzIG9uZVxuICAgICAgICAgICAgLy8gYW5kIG9uZSBpcyBub3QgeWV0IGRlZmluZWQuIFRodXMgaWYgd2UgdW5kZWZpbmVkIGl0IGhlcmUsIGl0IHdpbGwgY3VycmVudGx5IG1ha2UgYVxuICAgICAgICAgICAgLy8gbmV3IG9uZSB3aGljaCBpcyBvdXQgb2Ygc3luYyBhbmQgdGhlbiBuZXZlciBnZXRzIGNsZWFuZWQgdXAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIGRvd25zaWRlIG9mIGxlYXZpbmcgaXQgZGVmaW5lZCBhcmUgdGhhdCBjYWxscyB0aGlzIGNsb3NlZCBTREggd2lsbCBjb250aW51ZSB0byBiZVxuICAgICAgICAgICAgLy8gbWFkZSAodGhpbmsgc2V0RGVzY3JpcHRpb24pIGFuZCB0aG9zZSBzaG91bGQvd2lsbCBmYWlsLiBUaGVzZSBmYWlsdXJlcyBhcmUgaGFuZGxlZCwgYnV0XG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgaXQgYWxsIGNvZGVkIHVwIGluIGEgd2F5IHdoZXJlIGhhdmluZyBhbiB1bmRlZmluZWQgU0RIIHdoZXJlXG4gICAgICAgICAgICAvLyBvbmUgaXMgZXhwZWN0ZWQgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gdGhlIEludml0ZXIvSW52aXRhdGlvbiBzdWIgY2xhc3MgZGlzcG9zZSBtZXRob2QgaGFuZGxlcyB0aGlzIGNhc2VcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmc6XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHRoZSBJbnZpdGVyL0ludml0YXRpb24gc3ViIGNsYXNzIGRpc3Bvc2UgbWV0aG9kIGhhbmRsZXMgdGhpcyBjYXNlXG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2J5ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWRpcmVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWplY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBiZSBkb25lXG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gbm90aGluZyB0byBiZSBkb25lXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RhdGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJhc3NlcnRlZElkZW50aXR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhc3NlcnRlZCBpZGVudGl0eSBvZiB0aGUgcmVtb3RlIHVzZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3NlcnRlZElkZW50aXR5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbi5wcm90b3R5cGUsIFwiZGlhbG9nXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb25maXJtZWQgc2Vzc2lvbiBkaWFsb2cuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaWFsb2c7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInJlcGxhY2VlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXNzaW9uIGJlaW5nIHJlcGxhY2UgYnkgdGhpcyBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXBsYWNlZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb24ucHJvdG90eXBlLCBcInNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyLlxuICAgICAgICAgKiBAcmVtYXJrc1xuICAgICAgICAgKiBJZiBgdGhpc2AgaXMgYW4gaW5zdGFuY2Ugb2YgYEludml0YXRpb25gLFxuICAgICAgICAgKiBgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcmAgd2lsbCBiZSBkZWZpbmVkIHdoZW4gdGhlIHNlc3Npb24gc3RhdGUgY2hhbmdlcyB0byBcImVzdGFibGlzaGVkXCIuXG4gICAgICAgICAqIElmIGB0aGlzYCBpcyBhbiBpbnN0YW5jZSBvZiBgSW52aXRlcmAgYW5kIGFuIG9mZmVyIHdhcyBzZW50IGluIHRoZSBJTlZJVEUsXG4gICAgICAgICAqIGBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyYCB3aWxsIGJlIGRlZmluZWQgd2hlbiB0aGUgc2Vzc2lvbiBzdGF0ZSBjaGFuZ2VzIHRvIFwiZXN0YWJsaXNoaW5nXCIuXG4gICAgICAgICAqIElmIGB0aGlzYCBpcyBhbiBpbnN0YW5jZSBvZiBgSW52aXRlcmAgYW5kIGFuIG9mZmVyIHdhcyBub3Qgc2VudCBpbiB0aGUgSU5WSVRFLFxuICAgICAgICAgKiBgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcmAgd2lsbCBiZSBkZWZpbmVkIHdoZW4gdGhlIHNlc3Npb24gc3RhdGUgY2hhbmdlcyB0byBcImVzdGFibGlzaGVkXCIuXG4gICAgICAgICAqIE90aGVyd2lzZSBgdW5kZWZpbmVkYC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyRmFjdG9yeVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXNzaW9uIGRlc2NyaXB0aW9uIGhhbmRsZXIgZmFjdG9yeS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckFnZW50LmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3Rvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJzdGF0ZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXNzaW9uIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJzdGF0ZUNoYW5nZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXNzaW9uIHN0YXRlIGNoYW5nZSBlbWl0dGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1pdHRlcl8xLl9tYWtlRW1pdHRlcih0aGlzLl9zdGF0ZUV2ZW50RW1pdHRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uLnByb3RvdHlwZSwgXCJ1c2VyQWdlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVzZXIgYWdlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VyQWdlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEVuZCB0aGUge0BsaW5rIFNlc3Npb259LiBTZW5kcyBhIEJZRS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LiBTZWUge0BsaW5rIFNlc3Npb25CeWVPcHRpb25zfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ieWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiU2Vzc2lvbi5ieWUoKSBtYXkgb25seSBiZSBjYWxsZWQgaWYgZXN0YWJsaXNoZWQgc2Vzc2lvbi5cIjtcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY2FuY2VsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIEludml0ZXIuaW52aXRlKCkgaGFzIG5vdCB5ZXQgYmVlbiBjYWxsZWQuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3Ugc2hvdWxkIGhhdmUgY2FsbGVkIEludml0ZXIuY2FuY2VsKCk/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnJlamVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgSG93ZXZlciBJbnZpdGF0aW9uLmFjY2VwdCgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IHNob3VsZCBoYXZlIGNhbGxlZCBJbnZpdGF0aW9uLnJlamVjdCgpP1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hpbmc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNhbmNlbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgSG93ZXZlciBhIGRpYWxvZyBkb2VzIG5vdCB5ZXQgZXhpc3QuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgUGVyaGFwcyB5b3Ugc2hvdWxkIGhhdmUgY2FsbGVkIEludml0ZXIuY2FuY2VsKCk/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnJlamVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgSG93ZXZlciBJbnZpdGF0aW9uLmFjY2VwdCgpIGhhcyBub3QgeWV0IGJlZW4gY2FsbGVkIChvciBub3QgeWV0IHJlc29sdmVkKS5cIjtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBzaG91bGQgaGF2ZSBjYWxsZWQgSW52aXRhdGlvbi5yZWplY3QoKT9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQ6XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REZWxlZ2F0ZSA9IG9wdGlvbnMucmVxdWVzdERlbGVnYXRlO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuY29weVJlcXVlc3RPcHRpb25zKG9wdGlvbnMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieWUocmVxdWVzdERlbGVnYXRlLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRpbmc6XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIHRoaXMgc2Vzc2lvbiBpcyBhbHJlYWR5IHRlcm1pbmF0aW5nLlwiO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFBlcmhhcHMgeW91IGhhdmUgYWxyZWFkeSBjYWxsZWQgSW52aXRlci5jYW5jZWwoKT9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMucmVqZWN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBQZXJoYXBzIHlvdSBoYXZlIGFscmVhZHkgY2FsbGVkIFNlc3Npb24uYnllKCk/XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiBIb3dldmVyIHRoaXMgc2Vzc2lvbiBpcyBhbHJlYWR5IHRlcm1pbmF0ZWQuXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHNlc3Npb24gc3RhdGUgXCIgKyB0aGlzLnN0YXRlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaGFyZSB7QGxpbmsgSW5mb30gd2l0aCBwZWVyLiBTZW5kcyBhbiBJTkZPLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgU2Vzc2lvbkluZm9PcHRpb25zfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gZ3VhcmQgc2Vzc2lvbiBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlNlc3Npb24uaW5mbygpIG1heSBvbmx5IGJlIGNhbGxlZCBpZiBlc3RhYmxpc2hlZCBzZXNzaW9uLlwiO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBzZXNzaW9uIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0RGVsZWdhdGUgPSBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZTtcbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5jb3B5UmVxdWVzdE9wdGlvbnMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmZvKHJlcXVlc3REZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVuZWdvdGlhdGUgdGhlIHNlc3Npb24uIFNlbmRzIGEgcmUtSU5WSVRFLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgU2Vzc2lvbkludml0ZU9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmludml0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24uaW52aXRlXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUmVpbnZpdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXhjZXB0aW9uc18xLlJlcXVlc3RQZW5kaW5nRXJyb3IoXCJSZWludml0ZSBpbiBwcm9ncmVzcy4gUGxlYXNlIHdhaXQgdW50aWwgY29tcGxldGUsIHRoZW4gdHJ5IGFnYWluLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSB0cnVlO1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICBvbkFjY2VwdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gQSByZS1JTlZJVEUgdHJhbnNhY3Rpb24gaGFzIGFuIG9mZmVyL2Fuc3dlciBbUkZDMzI2NF0gZXhjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggaXQuICBUaGUgVUFDIChVc2VyIEFnZW50IENsaWVudCkgZ2VuZXJhdGluZyBhIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gcmUtSU5WSVRFIGNhbiBhY3QgYXMgdGhlIG9mZmVyZXIgb3IgYXMgdGhlIGFuc3dlcmVyLiAgQSBVQUMgd2lsbGluZ1xuICAgICAgICAgICAgICAgIC8vIHRvIGFjdCBhcyB0aGUgb2ZmZXJlciBpbmNsdWRlcyBhbiBvZmZlciBpbiB0aGUgcmUtSU5WSVRFLiAgVGhlIFVBU1xuICAgICAgICAgICAgICAgIC8vIChVc2VyIEFnZW50IFNlcnZlcikgdGhlbiBwcm92aWRlcyBhbiBhbnN3ZXIgaW4gYSByZXNwb25zZSB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyByZS1JTlZJVEUuICBBIFVBQyB3aWxsaW5nIHRvIGFjdCBhcyBhbnN3ZXJlciBkb2VzIG5vdCBpbmNsdWRlIGFuXG4gICAgICAgICAgICAgICAgLy8gb2ZmZXIgaW4gdGhlIHJlLUlOVklURS4gIFRoZSBVQVMgdGhlbiBwcm92aWRlcyBhbiBvZmZlciBpbiBhIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIHJlLUlOVklURSBiZWNvbWluZywgdGh1cywgdGhlIG9mZmVyZXIuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxNDEjc2VjdGlvbi0xXG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBjb3JlXzEuZ2V0Qm9keShyZXNwb25zZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gd2F5IHRvIHJlY292ZXIsIHNvIHRlcm1pbmF0ZSBzZXNzaW9uIGFuZCBtYXJrIGFzIGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiUmVjZWl2ZWQgMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURSB3aXRob3V0IGEgc2Vzc2lvbiBkZXNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNrQW5kQnllKHJlc3BvbnNlLCA0MDAsIFwiTWlzc2luZyBzZXNzaW9uIGRlc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFNkcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJTlZJVEUgd2l0aG91dCBTRFAgLSBzZXQgcmVtb3RlIG9mZmVyIGFuZCBzZW5kIGFuIGFuc3dlciBpbiB0aGUgQUNLXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBTREggb3B0aW9ucyAmIFNESCBtb2RpZmllcnMgb3B0aW9ucyBhcmUgYXBwbGllZCBzb21ld2hhdCBhbWJpZ3VvdXNseVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgVGhpcyBiZWhhdmlvciB3YXMgcG9ydGVkIGZyb20gbGVnYWN5IGNvZGUgYW5kIHRoZSBpc3N1ZSBwdW50ZWQgZG93biB0aGUgcm9hZC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuc3dlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM6IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRPZmZlckFuZEdldEFuc3dlcihib2R5LCBhbnN3ZXJPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFuc3dlckJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFjayh7IGJvZHk6IGFuc3dlckJvZHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB3YXkgdG8gcmVjb3Zlciwgc28gdGVybWluYXRlIHNlc3Npb24gYW5kIG1hcmsgYXMgZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSBvZmZlciBpbiAyeHggcmVzcG9uc2UgdG8gcmUtSU5WSVRFXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIEJZRSBzaG91bGQgbm90IGJlIHNlbnQgaWYgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBhIEJZRSBtYXkgYmUgc2VudC9yZWNlaXZlZCB3aGlsZSByZS1JTlZJVEUgaXMgb3V0c3RhbmRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2tBbmRCeWUocmVzcG9uc2UsIDQ4OCwgXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUmVpbnZpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZSAmJiBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJTlZJVEUgd2l0aCBTRFAgLSBzZXQgcmVtb3RlIGFuc3dlciBhbmQgc2VuZCBhbiBBQ0tcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFNESCBvcHRpb25zICYgU0RIIG1vZGlmaWVycyBvcHRpb25zIGFyZSBhcHBsaWVkIHNvbWV3aGF0IGFtYmlndW91c2x5XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICBUaGlzIGJlaGF2aW9yIHdhcyBwb3J0ZWQgZnJvbSBsZWdhY3kgY29kZSBhbmQgdGhlIGlzc3VlIHB1bnRlZCBkb3duIHRoZSByb2FkLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5zd2VyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiBfdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiBfdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRBbnN3ZXIoYm9keSwgYW5zd2VyT3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gd2F5IHRvIHJlY292ZXIsIHNvIHRlcm1pbmF0ZSBzZXNzaW9uIGFuZCBtYXJrIGFzIGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBoYW5kbGUgYW5zd2VyIGluIDJ4eCByZXNwb25zZSB0byByZS1JTlZJVEVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIEJZRSBzaG91bGQgb25seSBiZSBzZW50IGlmIHNlc3Npb24gaXMgbm90IGFscmVhZHkgdGVybWluYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBhIEJZRSBtYXkgYmUgc2VudC9yZWNlaXZlZCB3aGlsZSByZS1JTlZJVEUgaXMgb3V0c3RhbmRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgQUNLIG5lZWRzIHRvIGJlIHNlbnQgcmVnYXJkbGVzcyBhcyBpdCB3YXMgbm90IGhhbmRsZWQgYnkgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2tBbmRCeWUocmVzcG9uc2UsIDQ4OCwgXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5hY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uQWNjZXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25BY2NlcHQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Qcm9ncmVzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVkaXJlY3Q6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlamVjdDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJSZWNlaXZlZCBhIG5vbi0yeHggcmVzcG9uc2UgdG8gcmUtSU5WSVRFXCIpO1xuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndpdGhvdXRTZHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVxdWVzdERlbGVnYXRlICYmIG9wdGlvbnMucmVxdWVzdERlbGVnYXRlLm9uUmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvbGxiYWNrT2ZmZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gd2F5IHRvIHJlY292ZXIsIHNvIHRlcm1pbmF0ZSBzZXNzaW9uIGFuZCBtYXJrIGFzIGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byByb2xsYmFjayBvZmZlciBvbiBub24tMnh4IHJlc3BvbnNlIHRvIHJlLUlOVklURVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgc2Vzc2lvbiBpcyBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIGEgQllFIG1heSBiZSBzZW50L3JlY2VpdmVkIHdoaWxlIHJlLUlOVklURSBpcyBvdXRzdGFuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgQUNLIHdhcyBhbHJlYWR5IHNlbnQgYnkgdGhlIHRyYW5zYWN0aW9uLCBzbyBqdXN0IG5lZWQgdG8gc2VuZCBCWUUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWFzb246IFwiICsgX3RoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNTAwLCBcIkludGVybmFsIFNlcnZlciBFcnJvclwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUgJiYgb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZS5vblJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblRyeWluZzogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSBvcHRpb25zLnJlcXVlc3RPcHRpb25zIHx8IHt9O1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgPSAocmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5fY29udGFjdCk7XG4gICAgICAgIC8vIEp1c3Qgc2VuZCBhbiBJTlZJVEUgd2l0aCBubyBzZHAuLi5cbiAgICAgICAgaWYgKG9wdGlvbnMud2l0aG91dFNkcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZGlhbG9nLmludml0ZShkZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYW4gb2ZmZXIgYW5kIHNlbmQgaXQgaW4gYW4gSU5WSVRFXG4gICAgICAgIC8vIEZJWE1FOiBTREggb3B0aW9ucyAmIFNESCBtb2RpZmllcnMgb3B0aW9ucyBhcmUgYXBwbGllZCBzb21ld2hhdCBhbWJpZ3VvdXNseVxuICAgICAgICAvLyAgICAgICAgVGhpcyBiZWhhdmlvciB3YXMgcG9ydGVkIGZyb20gbGVnYWN5IGNvZGUgYW5kIHRoZSBpc3N1ZSBwdW50ZWQgZG93biB0aGUgcm9hZC5cbiAgICAgICAgdmFyIG9mZmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zLFxuICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyczogb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9mZmVyT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChvZmZlckJvZHkpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGVuZGluZ1JlaW52aXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5ib2R5ID0gb2ZmZXJCb2R5O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmRpYWxvZy5pbnZpdGUoZGVsZWdhdGUsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBzZW5kIHJlLUlOVklURVwiKTtcbiAgICAgICAgICAgIF90aGlzLnBlbmRpbmdSZWludml0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsaXZlciBhIHtAbGluayBNZXNzYWdlfS4gU2VuZHMgYSBNRVNTQUdFLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuIFNlZSB7QGxpbmsgU2Vzc2lvbk1lc3NhZ2VPcHRpb25zfSBmb3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5tZXNzYWdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gZ3VhcmQgc2Vzc2lvbiBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlNlc3Npb24ubWVzc2FnZSgpIG1heSBvbmx5IGJlIGNhbGxlZCBpZiBlc3RhYmxpc2hlZCBzZXNzaW9uLlwiO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBzZXNzaW9uIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0RGVsZWdhdGUgPSBvcHRpb25zLnJlcXVlc3REZWxlZ2F0ZTtcbiAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0gdGhpcy5jb3B5UmVxdWVzdE9wdGlvbnMob3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlKHJlcXVlc3REZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvZmZlciBhIHtAbGluayBSZWZlcnJhbH0uIFNlbmQgYSBSRUZFUi5cbiAgICAgKiBAcGFyYW0gcmVmZXJUbyAtIFRoZSByZWZlcnJhbCB0YXJnZXQuIElmIGEgYFNlc3Npb25gLCBhIFJFRkVSIHcvUmVwbGFjZXMgaXMgc2VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LiBTZWUge0BsaW5rIFNlc3Npb25SZWZlck9wdGlvbnN9IGZvciBkZXRhaWxzLlxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlZmVyID0gZnVuY3Rpb24gKHJlZmVyVG8sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgLy8gZ3VhcmQgc2Vzc2lvbiBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIlNlc3Npb24ucmVmZXIoKSBtYXkgb25seSBiZSBjYWxsZWQgaWYgZXN0YWJsaXNoZWQgc2Vzc2lvbi5cIjtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdERlbGVnYXRlID0gb3B0aW9ucy5yZXF1ZXN0RGVsZWdhdGU7XG4gICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHRoaXMuY29weVJlcXVlc3RPcHRpb25zKG9wdGlvbnMucmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgP1xuICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMuZXh0cmFIZWFkZXJzLmNvbmNhdCh0aGlzLnJlZmVyRXh0cmFIZWFkZXJzKHRoaXMucmVmZXJUb1N0cmluZyhyZWZlclRvKSkpIDpcbiAgICAgICAgICAgIHRoaXMucmVmZXJFeHRyYUhlYWRlcnModGhpcy5yZWZlclRvU3RyaW5nKHJlZmVyVG8pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmVyKG9wdGlvbnMub25Ob3RpZnksIHJlcXVlc3REZWxlZ2F0ZSwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBCWUUuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9ucyBidWNrZXQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2J5ZSA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBVc2luZyBjb3JlIHNlc3Npb24gZGlhbG9nXG4gICAgICAgIGlmICghdGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTZXNzaW9uIGRpYWxvZyB1bmRlZmluZWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5kaWFsb2c7XG4gICAgICAgIC8vIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLFxuICAgICAgICAvLyBhbmQgdGhlIGNhbGxlZSdzIFVBIE1BWSBzZW5kIGEgQllFIG9uIGNvbmZpcm1lZCBkaWFsb2dzLCBidXQgTVVTVCBOT1RcbiAgICAgICAgLy8gc2VuZCBhIEJZRSBvbiBlYXJseSBkaWFsb2dzLiBIb3dldmVyLCB0aGUgY2FsbGVlJ3MgVUEgTVVTVCBOT1Qgc2VuZCBhXG4gICAgICAgIC8vIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2cgdW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eFxuICAgICAgICAvLyByZXNwb25zZSBvciB1bnRpbCB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgICAgICBzd2l0Y2ggKGRpYWxvZy5zZXNzaW9uU3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNlc3Npb25TdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlhbG9nIHN0YXRlIFwiICsgZGlhbG9nLnNlc3Npb25TdGF0ZSk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuRWFybHk6IC8vIEltcGxlbWVudGF0aW9uIGNob2ljZSAtIG5vdCBzZW5kaW5nIEJZRSBmb3IgZWFybHkgZGlhbG9ncy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpYWxvZyBzdGF0ZSBcIiArIGRpYWxvZy5zZXNzaW9uU3RhdGUpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2Vzc2lvblN0YXRlLkFja1dhaXQ6IHsgLy8gVGhpcyBzdGF0ZSBvbmx5IG9jY3VycyBpZiB3ZSBhcmUgdGhlIGNhbGxlZS5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nKTsgLy8gV2UncmUgdGVybWluYXRpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkaWFsb2cuZGVsZWdhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIEFDSyBzaG93cyB1cCwgc2F5IEJZRS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBkaWFsb2cuYnllKGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0IGJlZm9yZSB0aGUgQUNLIGFycml2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkFja1RpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGRpYWxvZy5ieWUoZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuQ29uZmlybWVkOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBkaWFsb2cuYnllKGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpYWxvZyBzdGF0ZSBcIiArIGRpYWxvZy5zZXNzaW9uU3RhdGUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgc3RhdGUuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIElORk8uXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9ucyBidWNrZXQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX2luZm8gPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVXNpbmcgY29yZSBzZXNzaW9uIGRpYWxvZ1xuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2Vzc2lvbiBkaWFsb2cgdW5kZWZpbmVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRpYWxvZy5pbmZvKGRlbGVnYXRlLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIE1FU1NBR0UuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlcXVlc3Qgb3B0aW9ucyBidWNrZXQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVXNpbmcgY29yZSBzZXNzaW9uIGRpYWxvZ1xuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiU2Vzc2lvbiBkaWFsb2cgdW5kZWZpbmVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRpYWxvZy5tZXNzYWdlKGRlbGVnYXRlLCBvcHRpb25zKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIFJFRkVSLlxuICAgICAqIEBwYXJhbSBvbk5vdGlmeSAtIE5vdGlmaWNhdGlvbiBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5fcmVmZXIgPSBmdW5jdGlvbiAob25Ob3RpZnksIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFVzaW5nIGNvcmUgc2Vzc2lvbiBkaWFsb2dcbiAgICAgICAgaWYgKCF0aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlNlc3Npb24gZGlhbG9nIHVuZGVmaW5lZC5cIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNldCwgZGVsaXZlciBhbnkgaW4tZGlhbG9nIE5PVElGWSByZXF1ZXN0cyBoZXJlLi4uXG4gICAgICAgIHRoaXMub25Ob3RpZnkgPSBvbk5vdGlmeTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmRpYWxvZy5yZWZlcihkZWxlZ2F0ZSwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBBQ0sgYW5kIHRoZW4gQllFLiBUaGVyZSBhcmUgdW5yZWNvdmVyYWJsZSBlcnJvcnMgd2hpY2ggY2FuIG9jY3VyXG4gICAgICogd2hpbGUgaGFuZGxpbmcgZGlhbG9nIGZvcm1pbmcgYW5kIGluLWRpYWxvZyBJTlZJVEUgcmVzcG9uc2VzIGFuZCB3aGVuXG4gICAgICogdGhleSBvY2N1ciB3ZSBBQ0sgdGhlIHJlc3BvbnNlIGFuZCBzZW5kIGEgQllFLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgQllFIGlzIHNlbnQgaW4gdGhlIGRpYWxvZyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlc3BvbnNlXG4gICAgICogd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IGB0aGlzLmRpYWxvZ2AuIEFuZCwgYWNjb3JkaW5nbHksIHRoZVxuICAgICAqIHNlc3Npb24gc3RhdGUgaXMgbm90IHRyYW5zaXRpb25lZCB0byB0ZXJtaW5hdGVkIGFuZCBzZXNzaW9uIGlzIG5vdCBjbG9zZWQuXG4gICAgICogQHBhcmFtIGludml0ZVJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIGNhdXNpbmcgdGhlIGVycm9yLlxuICAgICAqIEBwYXJhbSBzdGF0dXNDb2RlIC0gU3RhdHVzIGNvZGUgZm9yIGhlIHJlYXNvbiBwaHJhc2UuXG4gICAgICogQHBhcmFtIHJlYXNvblBocmFzZSAtIFJlYXNvbiBwaHJhc2UgZm9yIHRoZSBCWUUuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuYWNrQW5kQnllID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0dXNDb2RlLCByZWFzb25QaHJhc2UpIHtcbiAgICAgICAgcmVzcG9uc2UuYWNrKCk7XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoc3RhdHVzQ29kZSwgcmVhc29uUGhyYXNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNpbmcgdGhlIGRpYWxvZyBzZXNzaW9uIGFzc29jaWF0ZSB3aXRoIHRoZSByZXNwb25zZSAod2hpY2ggbWlnaHQgbm90IGJlIHRoaXMuZGlhbG9nKVxuICAgICAgICByZXNwb25zZS5zZXNzaW9uLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW4gZGlhbG9nIEFDSyByZXF1ZXN0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uQWNrUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25BY2tSZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCAmJiB0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkFDSyByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5kaWFsb2c7XG4gICAgICAgIGlmICghZGlhbG9nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGRpYWxvZy5zaWduYWxpbmdTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDoge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRlIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGFzIGZpcnN0IHJlbGlhYmxlIHJlc3BvbnNlIG11c3QgaGF2ZSBhbnN3ZXIvb2ZmZXIuXG4gICAgICAgICAgICAgICAgLy8gU28gd2UgbXVzdCBoYXZlIG5ldmVyIGhhcyBzZW50IGFuIG9mZmVyLlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyBkaWFsb2cuc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIlJlYXNvbjogXCIgKyB0aGlzLmdldFJlYXNvbkhlYWRlclZhbHVlKDQ4OCwgXCJCYWQgTWVkaWEgRGVzY3JpcHRpb25cIildO1xuICAgICAgICAgICAgICAgIGRpYWxvZy5ieWUodW5kZWZpbmVkLCB7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOiB7XG4gICAgICAgICAgICAgICAgLy8gU3RhdGUgd2Ugc2hvdWxkIGJlIGluLlxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB0aGUgQUNLIGhhcyB0aGUgYW5zd2VyIHRoYXQgZ290IHVzIGhlcmUsIG9yIHdlIHdlcmUgaW4gdGhpcyBzdGF0ZSBwcmlvciB0byB0aGUgQUNLLlxuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gY29yZV8xLmdldEJvZHkocmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgQUNLIGRvZXNuJ3QgaGF2ZSBhbiBhbnN3ZXIsIG5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm9keS5jb250ZW50RGlzcG9zaXRpb24gPT09IFwicmVuZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyYm9keSA9IGJvZHkuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVydHlwZSA9IGJvZHkuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuY29udGVudERpc3Bvc2l0aW9uICE9PSBcInNlc3Npb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY2VpdmVkIGFuc3dlciBpbiBBQ0suXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyczogdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVyc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBbnN3ZXIoYm9keSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXCJSZWFzb246IFwiICsgX3RoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKV07XG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5ieWUodW5kZWZpbmVkLCB7IGV4dHJhSGVhZGVyczogZXh0cmFIZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjoge1xuICAgICAgICAgICAgICAgIC8vIFN0YXRlIHNob3VsZCBuZXZlciBiZSByZWFjaGVkIGFzIGxvY2FsIG9mZmVyIHdvdWxkIGJlIGFuc3dlcmVkIGJ5IHRoaXMgQUNLLlxuICAgICAgICAgICAgICAgIC8vIFNvIHdlIG11c3QgaGF2ZSByZWNlaXZlZCBhbiBBQ0sgd2l0aG91dCBhbiBhbnN3ZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIGRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW1wiUmVhc29uOiBcIiArIHRoaXMuZ2V0UmVhc29uSGVhZGVyVmFsdWUoNDg4LCBcIkJhZCBNZWRpYSBEZXNjcmlwdGlvblwiKV07XG4gICAgICAgICAgICAgICAgZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6IHtcbiAgICAgICAgICAgICAgICAvLyBTdGF0ZSBzaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBhcyByZW1vdGUgb2ZmZXIgd291bGQgYmUgYW5zd2VyZWQgaW4gZmlyc3QgcmVsaWFibGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgLy8gU28gd2UgbXVzdCBoYXZlIG5ldmVyIGhhcyBzZW50IGFuIGFuc3dlci5cbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgZGlhbG9nLnNpZ25hbGluZ1N0YXRlICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXCJSZWFzb246IFwiICsgdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg0ODgsIFwiQmFkIE1lZGlhIERlc2NyaXB0aW9uXCIpXTtcbiAgICAgICAgICAgICAgICBkaWFsb2cuYnllKHVuZGVmaW5lZCwgeyBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgY29yZV8xLlNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ25hbGluZyBzdGF0ZSBcIiArIGRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYWxpbmcgc3RhdGUgXCIgKyBkaWFsb2cuc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgQllFIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25CeWVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbkJ5ZVJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIkJZRSByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uQnllKSB7XG4gICAgICAgICAgICB2YXIgYnllID0gbmV3IGJ5ZV8xLkJ5ZShyZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25CeWUoYnllKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24oc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgSU5GTyByZXF1ZXN0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uSW5mb1JlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uSW5mb1JlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIklORk8gcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlICsgXCIsIGRyb3BwaW5nIHJlcXVlc3RcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkluZm8pIHtcbiAgICAgICAgICAgIHZhciBpbmZvID0gbmV3IGluZm9fMS5JbmZvKHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkluZm8oaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogV2Ugc2hvdWxkIHJlamVjdCByZXF1ZXN0Li4uXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgYSBVQSByZWNlaXZlcyBhbiBJTkZPIHJlcXVlc3QgYXNzb2NpYXRlZCB3aXRoIGFuIEluZm8gUGFja2FnZSB0aGF0XG4gICAgICAgICAgICAvLyB0aGUgVUEgaGFzIG5vdCBpbmRpY2F0ZWQgd2lsbGluZ25lc3MgdG8gcmVjZWl2ZSwgdGhlIFVBIE1VU1Qgc2VuZCBhXG4gICAgICAgICAgICAvLyA0NjkgKEJhZCBJbmZvIFBhY2thZ2UpIHJlc3BvbnNlIChzZWUgU2VjdGlvbiAxMS42KSwgd2hpY2ggY29udGFpbnMgYVxuICAgICAgICAgICAgLy8gUmVjdi1JbmZvIGhlYWRlciBmaWVsZCB3aXRoIEluZm8gUGFja2FnZXMgZm9yIHdoaWNoIHRoZSBVQSBpcyB3aWxsaW5nXG4gICAgICAgICAgICAvLyB0byByZWNlaXZlIElORk8gcmVxdWVzdHMuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjA4NiNzZWN0aW9uLTQuMi4yXG4gICAgICAgICAgICByZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW4gZGlhbG9nIElOVklURSByZXF1ZXN0LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLm9uSW52aXRlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25JbnZpdGVSZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJJTlZJVEUgcmVjZWl2ZWQgd2hpbGUgaW4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlICsgXCIsIGRyb3BwaW5nIHJlcXVlc3RcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd291bGQgYmUgbmljZSB0byBoYXZlIGNvcmUgdHJhY2sgYW5kIHNldCB0aGUgQ29udGFjdCBoZWFkZXIsXG4gICAgICAgIC8vIGJ1dCBjdXJyZW50bHkgdGhlIHNlc3Npb24gd2hpY2ggaXMgc2V0dGluZyBpdCBpcyBob2xkaW5nIG9udG8gaXQuXG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSBbXCJDb250YWN0OiBcIiArIHRoaXMuX2NvbnRhY3RdO1xuICAgICAgICAvLyBIYW5kbGUgUC1Bc3NlcnRlZC1JZGVudGl0eVxuICAgICAgICBpZiAocmVxdWVzdC5tZXNzYWdlLmhhc0hlYWRlcihcIlAtQXNzZXJ0ZWQtSWRlbnRpdHlcIikpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSByZXF1ZXN0Lm1lc3NhZ2UuZ2V0SGVhZGVyKFwiUC1Bc3NlcnRlZC1JZGVudGl0eVwiKTtcbiAgICAgICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hc3NlcnRlZElkZW50aXR5ID0gY29yZV8xLkdyYW1tYXIubmFtZUFkZHJIZWFkZXJQYXJzZShoZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZJWE1FOiBTREggb3B0aW9ucyAmIFNESCBtb2RpZmllcnMgb3B0aW9ucyBhcmUgYXBwbGllZCBzb21ld2hhdCBhbWJpZ3VvdXNseVxuICAgICAgICAvLyAgICAgICAgVGhpcyBiZWhhdmlvciB3YXMgcG9ydGVkIGZyb20gbGVnYWN5IGNvZGUgYW5kIHRoZSBpc3N1ZSBwdW50ZWQgZG93biB0aGUgcm9hZC5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9uczogdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnMsXG4gICAgICAgICAgICBzZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzOiB0aGlzLl9zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyTW9kaWZpZXJzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VySW5EaWFsb2cob3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB2YXIgb3V0Z29pbmdSZXNwb25zZSA9IHJlcXVlc3QuYWNjZXB0KHsgc3RhdHVzQ29kZTogMjAwLCBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycywgYm9keTogYm9keSB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5kZWxlZ2F0ZSAmJiBfdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKHJlcXVlc3QubWVzc2FnZSwgb3V0Z29pbmdSZXNwb25zZS5tZXNzYWdlLCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGhhbmRsZSB0byByZS1JTlZJVEUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoX3RoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBsb2NhbC9yZW1vdGUgb2ZmZXIuLi5cbiAgICAgICAgICAgIGlmIChfdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5TdGFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdSZXNwb25zZSA9IHJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg4IH0pOyAvLyBOb3QgQWNjZXB0YWJsZSBIZXJlXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKHJlcXVlc3QubWVzc2FnZSwgb3V0Z29pbmdSZXNwb25zZS5tZXNzYWdlLCA0ODgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugcm9sbGJhY2tcbiAgICAgICAgICAgIF90aGlzLnJvbGxiYWNrT2ZmZXIoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdSZXNwb25zZSA9IHJlcXVlc3QucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg4IH0pOyAvLyBOb3QgQWNjZXB0YWJsZSBIZXJlXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlbGVnYXRlLm9uSW52aXRlKHJlcXVlc3QubWVzc2FnZSwgb3V0Z29pbmdSZXNwb25zZS5tZXNzYWdlLCA0ODgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvclJvbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gd2F5IHRvIHJlY292ZXIsIHNvIHRlcm1pbmF0ZSBzZXNzaW9uIGFuZCBtYXJrIGFzIGZhaWxlZC5cbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3JSb2xsYmFjay5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gcm9sbGJhY2sgb2ZmZXIgb24gcmUtSU5WSVRFIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgdmFyIG91dGdvaW5nUmVzcG9uc2UgPSByZXF1ZXN0LnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OCB9KTsgLy8gTm90IEFjY2VwdGFibGUgSGVyZVxuICAgICAgICAgICAgICAgIC8vIEEgQllFIHNob3VsZCBvbmx5IGJlIHNlbnQgaWYgc2Vzc2lvbiBpcyBub3QgYWxyZWFkeSB0ZXJtaW5hdGVkLlxuICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBhIEJZRSBtYXkgYmUgc2VudC9yZWNlaXZlZCB3aGlsZSByZS1JTlZJVEUgaXMgb3V0c3RhbmRpbmcuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBBQ0sgd2FzIGFscmVhZHkgc2VudCBieSB0aGUgdHJhbnNhY3Rpb24sIHNvIGp1c3QgbmVlZCB0byBzZW5kIEJZRS5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmRpYWxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVyc0J5ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnNCeWUucHVzaChcIlJlYXNvbjogXCIgKyBfdGhpcy5nZXRSZWFzb25IZWFkZXJWYWx1ZSg1MDAsIFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlhbG9nLmJ5ZSh1bmRlZmluZWQsIHsgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVHJhbnNpdGlvbihzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVsZWdhdGUgJiYgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsZWdhdGUub25JbnZpdGUocmVxdWVzdC5tZXNzYWdlLCBvdXRnb2luZ1Jlc3BvbnNlLm1lc3NhZ2UsIDQ4OCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBNRVNTQUdFIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25NZXNzYWdlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25NZXNzYWdlUmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiTUVTU0FHRSByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgbWVzc2FnZV8xLk1lc3NhZ2UocmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuYWNjZXB0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgTk9USUZZIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25Ob3RpZnlSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU2Vzc2lvbi5vbk5vdGlmeVJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIk5PVElGWSByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIGEgTk9USUZZIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvZ3Jlc3Mgb2YgYSBSRUZFUixcbiAgICAgICAgLy8gbG9vayB0byBkZWxlZ2F0ZSBoYW5kbGluZyB0byB0aGUgYXNzb2NpYXRlZCBjYWxsYmFjay5cbiAgICAgICAgaWYgKHRoaXMub25Ob3RpZnkpIHtcbiAgICAgICAgICAgIHZhciBub3RpZmljYXRpb24gPSBuZXcgbm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uKHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5vbk5vdGlmeShub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBhY2NlcHQgdGhlIE5PVElGWS5cbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSkge1xuICAgICAgICAgICAgdmFyIG5vdGlmaWNhdGlvbiA9IG5ldyBub3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24ocmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5KG5vdGlmaWNhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0LmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgaW4gZGlhbG9nIFBSQUNLIHJlcXVlc3QuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUub25QcmFja1JlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uLm9uUHJhY2tSZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJQUkFDSyByZWNlaXZlZCB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIiwgZHJvcHBpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkLlwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBpbiBkaWFsb2cgUkVGRVIgcmVxdWVzdC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5vblJlZmVyUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNlc3Npb24ub25SZWZlclJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlJFRkVSIHJlY2VpdmVkIHdoaWxlIGluIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSArIFwiLCBkcm9wcGluZyByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJFRkVSIGlzIGEgU0lQIHJlcXVlc3QgYW5kIGlzIGNvbnN0cnVjdGVkIGFzIGRlZmluZWQgaW4gWzFdLiAgQSBSRUZFUlxuICAgICAgICAvLyByZXF1ZXN0IE1VU1QgY29udGFpbiBleGFjdGx5IG9uZSBSZWZlci1UbyBoZWFkZXIgZmllbGQgdmFsdWUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjFcbiAgICAgICAgaWYgKCFyZXF1ZXN0Lm1lc3NhZ2UuaGFzSGVhZGVyKFwicmVmZXItdG9cIikpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJJbnZhbGlkIFJFRkVSIHBhY2tldC4gQSByZWZlci10byBoZWFkZXIgaXMgcmVxdWlyZWQuIFJlamVjdGluZy5cIik7XG4gICAgICAgICAgICByZXF1ZXN0LnJlamVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWZlcnJhbCA9IG5ldyByZWZlcnJhbF8xLlJlZmVycmFsKHJlcXVlc3QsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWZlcihyZWZlcnJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJObyBkZWxlZ2F0ZSBhdmFpbGFibGUgdG8gaGFuZGxlIFJFRkVSLCBhdXRvbWF0aWNhbGx5IGFjY2VwdGluZyBhbmQgZm9sbG93aW5nLlwiKTtcbiAgICAgICAgICAgIHJlZmVycmFsXG4gICAgICAgICAgICAgICAgLmFjY2VwdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVmZXJyYWxcbiAgICAgICAgICAgICAgICAubWFrZUludml0ZXIoX3RoaXMuX3JlZmVycmFsSW52aXRlck9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLmludml0ZSgpOyB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogbG9nZ2luZyBhbmQgZWF0aW5nIGVycm9yLi4uXG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIG9mZmVyIG9yIGFuc3dlciBmb3IgYSByZXNwb25zZSB0byBhbiBJTlZJVEUgcmVxdWVzdC5cbiAgICAgKiBJZiBhIHJlbW90ZSBvZmZlciB3YXMgcHJvdmlkZWQgaW4gdGhlIHJlcXVlc3QsIHNldCB0aGUgcmVtb3RlXG4gICAgICogZGVzY3JpcHRpb24gYW5kIGdldCBhIGxvY2FsIGFuc3dlci4gSWYgYSByZW1vdGUgb2ZmZXIgd2FzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBnZW5lcmF0ZXMgYSBsb2NhbCBvZmZlci5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5nZW5lcmF0ZVJlc3BvbnNlT2ZmZXJBbnN3ZXIgPSBmdW5jdGlvbiAocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVzcG9uc2VPZmZlckFuc3dlckluRGlhbG9nKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBib2R5ID0gY29yZV8xLmdldEJvZHkocmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgICAgaWYgKCFib2R5IHx8IGJvZHkuY29udGVudERpc3Bvc2l0aW9uICE9PSBcInNlc3Npb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2ZmZXIob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRPZmZlckFuZEdldEFuc3dlcihib2R5LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gb2ZmZXIgb3IgYW5zd2VyIGZvciBhIHJlc3BvbnNlIHRvIGFuIElOVklURSByZXF1ZXN0XG4gICAgICogd2hlbiBhIGRpYWxvZyAoZWFybHkgb3Igb3RoZXJ3aXNlKSBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBOT1QgYmUgY2FsbGVkIGlmIGEgZGlhbG9nIGhhcyB5ZXQgdG8gYmUgZXN0YWJsaXNoZWQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuZ2VuZXJhdGVSZXNwb25zZU9mZmVyQW5zd2VySW5EaWFsb2cgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZGlhbG9nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI6XG4gICAgICAgICAgICAgICAgLy8gbyAgT25jZSB0aGUgVUFTIGhhcyBzZW50IG9yIHJlY2VpdmVkIGFuIGFuc3dlciB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uIGFsb25lIGNhbiBuZXZlciBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyB1bnRpbFxuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjYXNlIGNvcmVfMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXI6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRpYWxvZy5vZmZlcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXNzaW9uIG9mZmVyIHVuZGVmaW5lZCBpbiBzaWduYWxpbmcgc3RhdGUgXCIgKyB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0T2ZmZXJBbmRHZXRBbnN3ZXIodGhpcy5kaWFsb2cub2ZmZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlOlxuICAgICAgICAgICAgICAgIC8vIG8gIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgICAvLyBvZmZlciwgaXQgTVVTVCBOT1QgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gYW55IHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBpbml0aWFsIElOVklURS4gIFRoaXMgbWVhbnMgdGhhdCBhIFVBUyBiYXNlZCBvbiB0aGlzXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0aW9uIG9mIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbiBkaWFsb2cgSU5WSVRFIHdpdGhvdXQgb2ZmZXIsIGdldCBhbiBvZmZlciBmb3IgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9mZmVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmFsaW5nIHN0YXRlIFwiICsgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCBsb2NhbCBvZmZlci5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5nZXRPZmZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZGggPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgICAgICB2YXIgc2RoT3B0aW9ucyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM7XG4gICAgICAgIHZhciBzZGhNb2RpZmllcnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIHZlcnkgZGVmZW5zaXZlbHkuIERvbid0IHRydXN0IFNESCB0byBiZWhhdmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2RoLmdldERlc2NyaXB0aW9uKHNkaE9wdGlvbnMsIHNkaE1vZGlmaWVycylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYm9keUFuZENvbnRlbnRUeXBlKSB7IHJldHVybiBjb3JlXzEuZnJvbUJvZHlMZWdhY3koYm9keUFuZENvbnRlbnRUeXBlKTsgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5nZXRPZmZlcjogU0RIIGdldERlc2NyaXB0aW9uIHJlamVjdGVkLi4uXCIpO1xuICAgICAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IC8vIGRvbid0IHRydXN0IFNESCB0byB0aHJvdyBhbiBFcnJvclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLmdldE9mZmVyOiBTREggZ2V0RGVzY3JpcHRpb24gdGhyZXcuLi5cIik7XG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayBsb2NhbC9yZW1vdGUgb2ZmZXIuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucm9sbGJhY2tPZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIGlmICghc2RoLnJvbGxiYWNrRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiB2ZXJ5IGRlZmVuc2l2ZWx5LiBEb24ndCB0cnVzdCBTREggdG8gYmVoYXZlLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNkaC5yb2xsYmFja0Rlc2NyaXB0aW9uKClcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5yb2xsYmFja09mZmVyOiBTREggcm9sbGJhY2tEZXNjcmlwdGlvbiByZWplY3RlZC4uLlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyAvLyBkb24ndCB0cnVzdCBTREggdG8gdGhyb3cgYW4gRXJyb3JcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKFwiU2Vzc2lvbi5yb2xsYmFja09mZmVyOiBTREggcm9sbGJhY2tEZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCByZW1vdGUgYW5zd2VyLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnNldEFuc3dlciA9IGZ1bmN0aW9uIChhbnN3ZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNkaCA9IHRoaXMuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyKCk7XG4gICAgICAgIHZhciBzZGhPcHRpb25zID0gb3B0aW9ucy5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyT3B0aW9ucztcbiAgICAgICAgdmFyIHNkaE1vZGlmaWVycyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck1vZGlmaWVycztcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gdmVyeSBkZWZlbnNpdmVseS4gRG9uJ3QgdHJ1c3QgU0RIIHRvIGJlaGF2ZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghc2RoLmhhc0Rlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGV4Y2VwdGlvbnNfMS5Db250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0QW5zd2VyOiBTREggaGFzRGVzY3JpcHRpb24gdGhyZXcuLi5cIik7XG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2RoLnNldERlc2NyaXB0aW9uKGFuc3dlci5jb250ZW50LCBzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0QW5zd2VyOiBTREggc2V0RGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgLy8gZG9uJ3QgdHJ1c3QgU0RIIHRvIHRocm93IGFuIEVycm9yXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0QW5zd2VyOiBTREggc2V0RGVzY3JpcHRpb24gdGhyZXcuLi5cIik7XG4gICAgICAgICAgICB2YXIgZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgcmVtb3RlIG9mZmVyIGFuZCBnZXQgbG9jYWwgYW5zd2VyLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnNldE9mZmVyQW5kR2V0QW5zd2VyID0gZnVuY3Rpb24gKG9mZmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZGggPSB0aGlzLnNldHVwU2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcigpO1xuICAgICAgICB2YXIgc2RoT3B0aW9ucyA9IG9wdGlvbnMuc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM7XG4gICAgICAgIHZhciBzZGhNb2RpZmllcnMgPSBvcHRpb25zLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJNb2RpZmllcnM7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIHZlcnkgZGVmZW5zaXZlbHkuIERvbid0IHRydXN0IFNESCB0byBiZWhhdmUuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXNkaC5oYXNEZXNjcmlwdGlvbihvZmZlci5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGV4Y2VwdGlvbnNfMS5Db250ZW50VHlwZVVuc3VwcG9ydGVkRXJyb3IoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0T2ZmZXJBbmRHZXRBbnN3ZXI6IFNESCBoYXNEZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZGguc2V0RGVzY3JpcHRpb24ob2ZmZXIuY29udGVudCwgc2RoT3B0aW9ucywgc2RoTW9kaWZpZXJzKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNkaC5nZXREZXNjcmlwdGlvbihzZGhPcHRpb25zLCBzZGhNb2RpZmllcnMpOyB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5QW5kQ29udGVudFR5cGUpIHsgcmV0dXJuIGNvcmVfMS5mcm9tQm9keUxlZ2FjeShib2R5QW5kQ29udGVudFR5cGUpOyB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJTZXNzaW9uLnNldE9mZmVyQW5kR2V0QW5zd2VyOiBTREggc2V0RGVzY3JpcHRpb24gb3IgZ2V0RGVzY3JpcHRpb24gcmVqZWN0ZWQuLi5cIik7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgLy8gZG9uJ3QgdHJ1c3QgU0RIIHRvIHRocm93IGFuIEVycm9yXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcIlNlc3Npb24uc2V0T2ZmZXJBbmRHZXRBbnN3ZXI6IFNESCBzZXREZXNjcmlwdGlvbiBvciBnZXREZXNjcmlwdGlvbiB0aHJldy4uLlwiKTtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNESCBmb3IgY29uZmlybWVkIGRpYWxvZy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5zZXRTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gZnVuY3Rpb24gKHNkaCkge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2Vzc2lvbiBkZXNjcmlwdGlvbiBoYW5kbGVyIGRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIgPSBzZGg7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTREggZm9yIGNvbmZpcm1lZCBkaWFsb2cuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc2V0dXBTZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlciA9XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJGYWN0b3J5KHRoaXMsIHRoaXMudXNlckFnZW50LmNvbmZpZ3VyYXRpb24uc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlckZhY3RvcnlPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmFuc2l0aW9uIHNlc3Npb24gc3RhdGUuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgU2Vzc2lvbi5wcm90b3R5cGUuc3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpbnZhbGlkVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIFwiICsgX3RoaXMuX3N0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFZhbGlkYXRlIHRyYW5zaXRpb25cbiAgICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZSAhPT0gc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzZXNzaW9uX3N0YXRlXzEuU2Vzc2lvblN0YXRlLkVzdGFibGlzaGluZzpcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuRXN0YWJsaXNoZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5Fc3RhYmxpc2hlZDpcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGluZzpcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl9zdGF0ZV8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGludmFsaWRUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhbnNpdGlvblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJTZXNzaW9uIFwiICsgdGhpcy5pZCArIFwiIHRyYW5zaXRpb25lZCB0byBzdGF0ZSBcIiArIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgdGhpcy5fc3RhdGVFdmVudEVtaXR0ZXIuZW1pdChcImV2ZW50XCIsIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgLy8gRGlzcG9zZVxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHNlc3Npb25fc3RhdGVfMS5TZXNzaW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmNvcHlSZXF1ZXN0T3B0aW9ucyA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICBpZiAocmVxdWVzdE9wdGlvbnMgPT09IHZvaWQgMCkgeyByZXF1ZXN0T3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBleHRyYUhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMgPyByZXF1ZXN0T3B0aW9ucy5leHRyYUhlYWRlcnMuc2xpY2UoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGJvZHkgPSByZXF1ZXN0T3B0aW9ucy5ib2R5ID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IHJlcXVlc3RPcHRpb25zLmJvZHkuY29udGVudERpc3Bvc2l0aW9uIHx8IFwicmVuZGVyXCIsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHJlcXVlc3RPcHRpb25zLmJvZHkuY29udGVudFR5cGUgfHwgXCJ0ZXh0L3BsYWluXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVxdWVzdE9wdGlvbnMuYm9keS5jb250ZW50IHx8IFwiXCJcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHRyYUhlYWRlcnM6IGV4dHJhSGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLmdldFJlYXNvbkhlYWRlclZhbHVlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICB2YXIgY2F1c2UgPSBjb2RlO1xuICAgICAgICB2YXIgdGV4dCA9IHV0aWxzXzEuZ2V0UmVhc29uUGhyYXNlKGNvZGUpO1xuICAgICAgICBpZiAoIXRleHQgJiYgcmVhc29uKSB7XG4gICAgICAgICAgICB0ZXh0ID0gcmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlNJUDtjYXVzZT1cIiArIGNhdXNlICsgJzt0ZXh0PVwiJyArIHRleHQgKyAnXCInO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUucmVmZXJFeHRyYUhlYWRlcnMgPSBmdW5jdGlvbiAocmVmZXJUbykge1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gW107XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiUmVmZXJyZWQtQnk6IDxcIiArIHRoaXMudXNlckFnZW50LmNvbmZpZ3VyYXRpb24udXJpICsgXCI+XCIpO1xuICAgICAgICBleHRyYUhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgdGhpcy5fY29udGFjdCk7XG4gICAgICAgIGV4dHJhSGVhZGVycy5wdXNoKFwiQWxsb3c6IFwiICsgW1xuICAgICAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgICAgICBcIklOVklURVwiLFxuICAgICAgICAgICAgXCJNRVNTQUdFXCIsXG4gICAgICAgICAgICBcIkJZRVwiLFxuICAgICAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgICAgICBcIklORk9cIixcbiAgICAgICAgICAgIFwiTk9USUZZXCIsXG4gICAgICAgICAgICBcIlJFRkVSXCJcbiAgICAgICAgXS50b1N0cmluZygpKTtcbiAgICAgICAgZXh0cmFIZWFkZXJzLnB1c2goXCJSZWZlci1UbzogXCIgKyByZWZlclRvKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhSGVhZGVycztcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnJlZmVyVG9TdHJpbmcgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIHZhciByZWZlclRvO1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgY29yZV8xLlVSSSkge1xuICAgICAgICAgICAgLy8gUkVGRVIgd2l0aG91dCBSZXBsYWNlcyAoQmxpbmQgVHJhbnNmZXIpXG4gICAgICAgICAgICByZWZlclRvID0gdGFyZ2V0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSRUZFUiB3aXRoIFJlcGxhY2VzIChBdHRlbmRlZCBUcmFuc2ZlcilcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LmRpYWxvZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdGFyZ2V0LnJlbW90ZUlkZW50aXR5LmZyaWVuZGx5TmFtZTtcbiAgICAgICAgICAgIHZhciByZW1vdGVUYXJnZXQgPSB0YXJnZXQuZGlhbG9nLnJlbW90ZVRhcmdldC50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGNhbGxJZCA9IHRhcmdldC5kaWFsb2cuY2FsbElkO1xuICAgICAgICAgICAgdmFyIHJlbW90ZVRhZyA9IHRhcmdldC5kaWFsb2cucmVtb3RlVGFnO1xuICAgICAgICAgICAgdmFyIGxvY2FsVGFnID0gdGFyZ2V0LmRpYWxvZy5sb2NhbFRhZztcbiAgICAgICAgICAgIHZhciByZXBsYWNlcyA9IGVuY29kZVVSSUNvbXBvbmVudChjYWxsSWQgKyBcIjt0by10YWc9XCIgKyByZW1vdGVUYWcgKyBcIjtmcm9tLXRhZz1cIiArIGxvY2FsVGFnKTtcbiAgICAgICAgICAgIHJlZmVyVG8gPSBcIlxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiIDxcIiArIHJlbW90ZVRhcmdldCArIFwiP1JlcGxhY2VzPVwiICsgcmVwbGFjZXMgKyBcIj5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJUbztcbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uO1xufSgpKTtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xuLyoqXG4gKiBEaWFsb2cuXG4gKiBAcmVtYXJrc1xuICogQSBrZXkgY29uY2VwdCBmb3IgYSB1c2VyIGFnZW50IGlzIHRoYXQgb2YgYSBkaWFsb2cuICBBIGRpYWxvZ1xuICogcmVwcmVzZW50cyBhIHBlZXItdG8tcGVlciBTSVAgcmVsYXRpb25zaGlwIGJldHdlZW4gdHdvIHVzZXIgYWdlbnRzXG4gKiB0aGF0IHBlcnNpc3RzIGZvciBzb21lIHRpbWUuICBUaGUgZGlhbG9nIGZhY2lsaXRhdGVzIHNlcXVlbmNpbmcgb2ZcbiAqIG1lc3NhZ2VzIGJldHdlZW4gdGhlIHVzZXIgYWdlbnRzIGFuZCBwcm9wZXIgcm91dGluZyBvZiByZXF1ZXN0c1xuICogYmV0d2VlbiBib3RoIG9mIHRoZW0uICBUaGUgZGlhbG9nIHJlcHJlc2VudHMgYSBjb250ZXh0IGluIHdoaWNoIHRvXG4gKiBpbnRlcnByZXQgU0lQIG1lc3NhZ2VzLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMlxuICogQHB1YmxpY1xuICovXG52YXIgRGlhbG9nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIERpYWxvZyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gY29yZSAtIFVzZXIgYWdlbnQgY29yZS5cbiAgICAgKiBAcGFyYW0gZGlhbG9nU3RhdGUgLSBJbml0aWFsIGRpYWxvZyBzdGF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaWFsb2coY29yZSwgZGlhbG9nU3RhdGUpIHtcbiAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5kaWFsb2dTdGF0ZSA9IGRpYWxvZ1N0YXRlO1xuICAgICAgICB0aGlzLmNvcmUuZGlhbG9ncy5zZXQodGhpcy5pZCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gYSBVQUMgcmVjZWl2ZXMgYSByZXNwb25zZSB0aGF0IGVzdGFibGlzaGVzIGEgZGlhbG9nLCBpdFxuICAgICAqIGNvbnN0cnVjdHMgdGhlIHN0YXRlIG9mIHRoZSBkaWFsb2cuICBUaGlzIHN0YXRlIE1VU1QgYmUgbWFpbnRhaW5lZFxuICAgICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAqIEBwYXJhbSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlIC0gT3V0Z29pbmcgcmVxdWVzdCBtZXNzYWdlIGZvciBkaWFsb2cuXG4gICAgICogQHBhcmFtIGluY29taW5nUmVzcG9uc2VNZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBjcmVhdGluZyBkaWFsb2cuXG4gICAgICovXG4gICAgRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudENsaWVudCA9IGZ1bmN0aW9uIChvdXRnb2luZ1JlcXVlc3RNZXNzYWdlLCBpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCB3YXMgc2VudCBvdmVyIFRMUywgYW5kIHRoZSBSZXF1ZXN0LVVSSSBjb250YWluZWQgYVxuICAgICAgICAvLyBTSVBTIFVSSSwgdGhlIFwic2VjdXJlXCIgZmxhZyBpcyBzZXQgdG8gVFJVRS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjJcbiAgICAgICAgdmFyIHNlY3VyZSA9IGZhbHNlOyAvLyBGSVhNRTogQ3VycmVudGx5IG5vIHN1cHBvcnQgZm9yIFRMUy5cbiAgICAgICAgLy8gVGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgbGlzdCBvZiBVUklzIGluIHRoZSBSZWNvcmQtUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlLCB0YWtlbiBpbiByZXZlcnNlIG9yZGVyIGFuZCBwcmVzZXJ2aW5nXG4gICAgICAgIC8vIGFsbCBVUkkgcGFyYW1ldGVycy4gIElmIG5vIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgaXMgcHJlc2VudCBpblxuICAgICAgICAvLyB0aGUgcmVzcG9uc2UsIHRoZSByb3V0ZSBzZXQgTVVTVCBiZSBzZXQgdG8gdGhlIGVtcHR5IHNldC4gIFRoaXMgcm91dGVcbiAgICAgICAgLy8gc2V0LCBldmVuIGlmIGVtcHR5LCBvdmVycmlkZXMgYW55IHByZS1leGlzdGluZyByb3V0ZSBzZXQgZm9yIGZ1dHVyZVxuICAgICAgICAvLyByZXF1ZXN0cyBpbiB0aGlzIGRpYWxvZy4gIFRoZSByZW1vdGUgdGFyZ2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBVUklcbiAgICAgICAgLy8gZnJvbSB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICB2YXIgcm91dGVTZXQgPSBpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpLnJldmVyc2UoKTtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSBpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgICAgIGlmICghY29udGFjdCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3QgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjb250YWN0IGluc3RhbmNlb2YgbWVzc2FnZXNfMS5OYW1lQWRkckhlYWRlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3Qgbm90IGluc3RhbmNlIG9mIE5hbWVBZGRySGVhZGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVtb3RlVGFyZ2V0ID0gY29udGFjdC51cmk7XG4gICAgICAgIC8vIFRoZSBsb2NhbCBzZXF1ZW5jZSBudW1iZXIgTVVTVCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBzZXF1ZW5jZVxuICAgICAgICAvLyBudW1iZXIgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0LiAgVGhlIHJlbW90ZSBzZXF1ZW5jZVxuICAgICAgICAvLyBudW1iZXIgTVVTVCBiZSBlbXB0eSAoaXQgaXMgZXN0YWJsaXNoZWQgd2hlbiB0aGUgcmVtb3RlIFVBIHNlbmRzIGFcbiAgICAgICAgLy8gcmVxdWVzdCB3aXRoaW4gdGhlIGRpYWxvZykuICBUaGUgY2FsbCBpZGVudGlmaWVyIGNvbXBvbmVudCBvZiB0aGVcbiAgICAgICAgLy8gZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgQ2FsbC1JRCBpbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy8gVGhlIGxvY2FsIHRhZyBjb21wb25lbnQgb2YgdGhlIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluXG4gICAgICAgIC8vIHRoZSBGcm9tIGZpZWxkIGluIHRoZSByZXF1ZXN0LCBhbmQgdGhlIHJlbW90ZSB0YWcgY29tcG9uZW50IG9mIHRoZVxuICAgICAgICAvLyBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBpbiB0aGUgVG8gZmllbGQgb2YgdGhlIHJlc3BvbnNlLiAgQVxuICAgICAgICAvLyBVQUMgTVVTVCBiZSBwcmVwYXJlZCB0byByZWNlaXZlIGEgcmVzcG9uc2Ugd2l0aG91dCBhIHRhZyBpbiB0aGUgVG9cbiAgICAgICAgLy8gZmllbGQsIGluIHdoaWNoIGNhc2UgdGhlIHRhZyBpcyBjb25zaWRlcmVkIHRvIGhhdmUgYSB2YWx1ZSBvZiBudWxsLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBUaGlzIGlzIHRvIG1haW50YWluIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggUkZDIDI1NDMsIHdoaWNoXG4gICAgICAgIC8vICAgIGRpZCBub3QgbWFuZGF0ZSBUbyB0YWdzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICB2YXIgbG9jYWxTZXF1ZW5jZU51bWJlciA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuY3NlcTtcbiAgICAgICAgdmFyIHJlbW90ZVNlcXVlbmNlTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY2FsbElkID0gb3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5jYWxsSWQ7XG4gICAgICAgIHZhciBsb2NhbFRhZyA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZnJvbVRhZztcbiAgICAgICAgdmFyIHJlbW90ZVRhZyA9IGluY29taW5nUmVzcG9uc2VNZXNzYWdlLnRvVGFnO1xuICAgICAgICBpZiAoIWNhbGxJZCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaWQgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvY2FsVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB0YWcgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbW90ZVRhZykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHRhZyB1bmRlZmluZWQuXCIpOyAvLyBGSVhNRTogTm8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0M1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSByZW1vdGUgVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIFRvIGZpZWxkLCBhbmQgdGhlIGxvY2FsXG4gICAgICAgIC8vIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBGcm9tIGZpZWxkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICBpZiAoIW91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZnJvbSkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyb20gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW91dGdvaW5nUmVxdWVzdE1lc3NhZ2UudG8pIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbFVSSSA9IG91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZnJvbS51cmk7XG4gICAgICAgIHZhciByZW1vdGVVUkkgPSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnRvLnVyaTtcbiAgICAgICAgLy8gQSBkaWFsb2cgY2FuIGFsc28gYmUgaW4gdGhlIFwiZWFybHlcIiBzdGF0ZSwgd2hpY2ggb2NjdXJzIHdoZW4gaXQgaXNcbiAgICAgICAgLy8gY3JlYXRlZCB3aXRoIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGFuZCB0aGVuIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgICAgIC8vIFwiY29uZmlybWVkXCIgc3RhdGUgd2hlbiBhIDJ4eCBmaW5hbCByZXNwb25zZSBhcnJpdmVzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gICAgICAgIGlmICghaW5jb21pbmdSZXNwb25zZU1lc3NhZ2Uuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb21pbmcgcmVzcG9uc2Ugc3RhdHVzIGNvZGUgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWFybHkgPSBpbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZS5zdGF0dXNDb2RlIDwgMjAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB2YXIgZGlhbG9nU3RhdGUgPSB7XG4gICAgICAgICAgICBpZDogY2FsbElkICsgbG9jYWxUYWcgKyByZW1vdGVUYWcsXG4gICAgICAgICAgICBlYXJseTogZWFybHksXG4gICAgICAgICAgICBjYWxsSWQ6IGNhbGxJZCxcbiAgICAgICAgICAgIGxvY2FsVGFnOiBsb2NhbFRhZyxcbiAgICAgICAgICAgIHJlbW90ZVRhZzogcmVtb3RlVGFnLFxuICAgICAgICAgICAgbG9jYWxTZXF1ZW5jZU51bWJlcjogbG9jYWxTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIHJlbW90ZVNlcXVlbmNlTnVtYmVyOiByZW1vdGVTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIGxvY2FsVVJJOiBsb2NhbFVSSSxcbiAgICAgICAgICAgIHJlbW90ZVVSSTogcmVtb3RlVVJJLFxuICAgICAgICAgICAgcmVtb3RlVGFyZ2V0OiByZW1vdGVUYXJnZXQsXG4gICAgICAgICAgICByb3V0ZVNldDogcm91dGVTZXQsXG4gICAgICAgICAgICBzZWN1cmU6IHNlY3VyZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGlhbG9nU3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgVUFTIHRoZW4gY29uc3RydWN0cyB0aGUgc3RhdGUgb2YgdGhlIGRpYWxvZy4gIFRoaXMgc3RhdGUgTVVTVCBiZVxuICAgICAqIG1haW50YWluZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgZGlhbG9nLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4xXG4gICAgICogQHBhcmFtIGluY29taW5nUmVxdWVzdE1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgY3JlYXRpbmcgZGlhbG9nLlxuICAgICAqIEBwYXJhbSB0b1RhZyAtIFRhZyBpbiB0aGUgVG8gZmllbGQgaW4gdGhlIHJlc3BvbnNlIHRvIHRoZSBpbmNvbWluZyByZXF1ZXN0LlxuICAgICAqL1xuICAgIERpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRTZXJ2ZXIgPSBmdW5jdGlvbiAoaW5jb21pbmdSZXF1ZXN0TWVzc2FnZSwgdG9UYWcsIGVhcmx5KSB7XG4gICAgICAgIGlmIChlYXJseSA9PT0gdm9pZCAwKSB7IGVhcmx5ID0gZmFsc2U7IH1cbiAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgYXJyaXZlZCBvdmVyIFRMUywgYW5kIHRoZSBSZXF1ZXN0LVVSSSBjb250YWluZWQgYSBTSVBTXG4gICAgICAgIC8vIFVSSSwgdGhlIFwic2VjdXJlXCIgZmxhZyBpcyBzZXQgdG8gVFJVRS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjFcbiAgICAgICAgdmFyIHNlY3VyZSA9IGZhbHNlOyAvLyBGSVhNRTogQ3VycmVudGx5IG5vIHN1cHBvcnQgZm9yIFRMUy5cbiAgICAgICAgLy8gVGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgbGlzdCBvZiBVUklzIGluIHRoZSBSZWNvcmQtUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIGZyb20gdGhlIHJlcXVlc3QsIHRha2VuIGluIG9yZGVyIGFuZCBwcmVzZXJ2aW5nIGFsbCBVUklcbiAgICAgICAgLy8gcGFyYW1ldGVycy4gIElmIG5vIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQgaXMgcHJlc2VudCBpbiB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCwgdGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgZW1wdHkgc2V0LiAgVGhpcyByb3V0ZSBzZXQsXG4gICAgICAgIC8vIGV2ZW4gaWYgZW1wdHksIG92ZXJyaWRlcyBhbnkgcHJlLWV4aXN0aW5nIHJvdXRlIHNldCBmb3IgZnV0dXJlXG4gICAgICAgIC8vIHJlcXVlc3RzIGluIHRoaXMgZGlhbG9nLiAgVGhlIHJlbW90ZSB0YXJnZXQgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSVxuICAgICAgICAvLyBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjFcbiAgICAgICAgdmFyIHJvdXRlU2V0ID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpO1xuICAgICAgICB2YXIgY29udGFjdCA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjb250YWN0XCIpO1xuICAgICAgICBpZiAoIWNvbnRhY3QpIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY29udGFjdCBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuTmFtZUFkZHJIZWFkZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250YWN0IG5vdCBpbnN0YW5jZSBvZiBOYW1lQWRkckhlYWRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbW90ZVRhcmdldCA9IGNvbnRhY3QudXJpO1xuICAgICAgICAvLyBUaGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgIC8vIG51bWJlciBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgbG9jYWwgc2VxdWVuY2VcbiAgICAgICAgLy8gbnVtYmVyIE1VU1QgYmUgZW1wdHkuICBUaGUgY2FsbCBpZGVudGlmaWVyIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIElEXG4gICAgICAgIC8vIE1VU1QgYmUgc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgQ2FsbC1JRCBpbiB0aGUgcmVxdWVzdC4gIFRoZSBsb2NhbFxuICAgICAgICAvLyB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBpbiB0aGUgVG8gZmllbGRcbiAgICAgICAgLy8gaW4gdGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0ICh3aGljaCBhbHdheXMgaW5jbHVkZXMgYSB0YWcpLCBhbmQgdGhlXG4gICAgICAgIC8vIHJlbW90ZSB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHRhZyBmcm9tIHRoZVxuICAgICAgICAvLyBGcm9tIGZpZWxkIGluIHRoZSByZXF1ZXN0LiAgQSBVQVMgTVVTVCBiZSBwcmVwYXJlZCB0byByZWNlaXZlIGFcbiAgICAgICAgLy8gcmVxdWVzdCB3aXRob3V0IGEgdGFnIGluIHRoZSBGcm9tIGZpZWxkLCBpbiB3aGljaCBjYXNlIHRoZSB0YWcgaXNcbiAgICAgICAgLy8gY29uc2lkZXJlZCB0byBoYXZlIGEgdmFsdWUgb2YgbnVsbC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgVGhpcyBpcyB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIFJGQyAyNTQzLCB3aGljaFxuICAgICAgICAvLyAgICBkaWQgbm90IG1hbmRhdGUgRnJvbSB0YWdzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgcmVtb3RlU2VxdWVuY2VOdW1iZXIgPSBpbmNvbWluZ1JlcXVlc3RNZXNzYWdlLmNzZXE7XG4gICAgICAgIHZhciBsb2NhbFNlcXVlbmNlTnVtYmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgY2FsbElkID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5jYWxsSWQ7XG4gICAgICAgIHZhciBsb2NhbFRhZyA9IHRvVGFnO1xuICAgICAgICB2YXIgcmVtb3RlVGFnID0gaW5jb21pbmdSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuICAgICAgICAvLyBUaGUgcmVtb3RlIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBGcm9tIGZpZWxkLCBhbmQgdGhlXG4gICAgICAgIC8vIGxvY2FsIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBUbyBmaWVsZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4xLjFcbiAgICAgICAgdmFyIHJlbW90ZVVSSSA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UuZnJvbS51cmk7XG4gICAgICAgIHZhciBsb2NhbFVSSSA9IGluY29taW5nUmVxdWVzdE1lc3NhZ2UudG8udXJpO1xuICAgICAgICB2YXIgZGlhbG9nU3RhdGUgPSB7XG4gICAgICAgICAgICBpZDogY2FsbElkICsgbG9jYWxUYWcgKyByZW1vdGVUYWcsXG4gICAgICAgICAgICBlYXJseTogZWFybHksXG4gICAgICAgICAgICBjYWxsSWQ6IGNhbGxJZCxcbiAgICAgICAgICAgIGxvY2FsVGFnOiBsb2NhbFRhZyxcbiAgICAgICAgICAgIHJlbW90ZVRhZzogcmVtb3RlVGFnLFxuICAgICAgICAgICAgbG9jYWxTZXF1ZW5jZU51bWJlcjogbG9jYWxTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIHJlbW90ZVNlcXVlbmNlTnVtYmVyOiByZW1vdGVTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIGxvY2FsVVJJOiBsb2NhbFVSSSxcbiAgICAgICAgICAgIHJlbW90ZVVSSTogcmVtb3RlVVJJLFxuICAgICAgICAgICAgcmVtb3RlVGFyZ2V0OiByZW1vdGVUYXJnZXQsXG4gICAgICAgICAgICByb3V0ZVNldDogcm91dGVTZXQsXG4gICAgICAgICAgICBzZWN1cmU6IHNlY3VyZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGlhbG9nU3RhdGU7XG4gICAgfTtcbiAgICAvKiogRGVzdHJ1Y3Rvci4gKi9cbiAgICBEaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29yZS5kaWFsb2dzLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGlhbG9nIGlzIGlkZW50aWZpZWQgYXQgZWFjaCBVQSB3aXRoIGEgZGlhbG9nIElELCB3aGljaCBjb25zaXN0cyBvZlxuICAgICAgICAgKiBhIENhbGwtSUQgdmFsdWUsIGEgbG9jYWwgdGFnIGFuZCBhIHJlbW90ZSB0YWcuICBUaGUgZGlhbG9nIElEIGF0IGVhY2hcbiAgICAgICAgICogVUEgaW52b2x2ZWQgaW4gdGhlIGRpYWxvZyBpcyBub3QgdGhlIHNhbWUuICBTcGVjaWZpY2FsbHksIHRoZSBsb2NhbFxuICAgICAgICAgKiB0YWcgYXQgb25lIFVBIGlzIGlkZW50aWNhbCB0byB0aGUgcmVtb3RlIHRhZyBhdCB0aGUgcGVlciBVQS4gIFRoZVxuICAgICAgICAgKiB0YWdzIGFyZSBvcGFxdWUgdG9rZW5zIHRoYXQgZmFjaWxpdGF0ZSB0aGUgZ2VuZXJhdGlvbiBvZiB1bmlxdWVcbiAgICAgICAgICogZGlhbG9nIElEcy5cbiAgICAgICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWFsb2dTdGF0ZS5pZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwiZWFybHlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBkaWFsb2cgY2FuIGFsc28gYmUgaW4gdGhlIFwiZWFybHlcIiBzdGF0ZSwgd2hpY2ggb2NjdXJzIHdoZW4gaXQgaXNcbiAgICAgICAgICogY3JlYXRlZCB3aXRoIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGFuZCB0aGVuIGl0IHRyYW5zaXRpb24gdG8gdGhlXG4gICAgICAgICAqIFwiY29uZmlybWVkXCIgc3RhdGUgd2hlbiBhIDJ4eCBmaW5hbCByZXNwb25zZSByZWNlaXZlZCBvciBpcyBzZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBSRkMgMzI2MSBpcyBjb25jaXNlIG9uIHdoZW4gYSBkaWFsb2cgaXMgXCJjb25maXJtZWRcIiwgYnV0IGl0XG4gICAgICAgICAqIGNhbiBiZSBhIHBvaW50IG9mIGNvbmZ1c2lvbiBpZiBhbiBJTlZJVEUgZGlhbG9nIGlzIFwiY29uZmlybWVkXCIgYWZ0ZXJcbiAgICAgICAgICogYSAyeHggaXMgc2VudCBvciBhZnRlciByZWNlaXZpbmcgdGhlIEFDSyBmb3IgdGhlIDJ4eCByZXNwb25zZS5cbiAgICAgICAgICogV2l0aCBjYXJlZnVsIHJlYWRpbmcgaXQgY2FuIGJlIGluZmVycmVkIGEgZGlhbG9nIGlzIGFsd2F5cyBpc1xuICAgICAgICAgKiBcImNvbmZpcm1lZFwiIHdoZW4gdGhlIDJ4eCBpcyBzZW50IChyZWdhcmRsZXNzIG9mIHR5cGUgb2YgZGlhbG9nKS5cbiAgICAgICAgICogSG93ZXZlciBhIElOVklURSBkaWFsb2cgZG9lcyBoYXZlIGFkZGl0aW9uYWwgY29uc2lkZXJhdGlvbnNcbiAgICAgICAgICogd2hlbiBpdCBpcyBjb25maXJtZWQgYnV0IGFuIEFDSyBoYXMgbm90IHlldCBiZWVuIHJlY2VpdmVkIChpblxuICAgICAgICAgKiBwYXJ0aWN1bGFyIHdpdGggcmVnYXJkIHRvIGEgY2FsbGVlIHNlbmRpbmcgQllFIHJlcXVlc3RzKS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuZWFybHk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcImNhbGxJZFwiLCB7XG4gICAgICAgIC8qKiBDYWxsIGlkZW50aWZpZXIgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgaWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuY2FsbElkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJsb2NhbFRhZ1wiLCB7XG4gICAgICAgIC8qKiBMb2NhbCB0YWcgY29tcG9uZW50IG9mIHRoZSBkaWFsb2cgaWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUubG9jYWxUYWc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInJlbW90ZVRhZ1wiLCB7XG4gICAgICAgIC8qKiBSZW1vdGUgdGFnIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIGlkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVRhZztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwibG9jYWxTZXF1ZW5jZU51bWJlclwiLCB7XG4gICAgICAgIC8qKiBMb2NhbCBzZXF1ZW5jZSBudW1iZXIgKHVzZWQgdG8gb3JkZXIgcmVxdWVzdHMgZnJvbSB0aGUgVUEgdG8gaXRzIHBlZXIpLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLmxvY2FsU2VxdWVuY2VOdW1iZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInJlbW90ZVNlcXVlbmNlTnVtYmVyXCIsIHtcbiAgICAgICAgLyoqIFJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgKHVzZWQgdG8gb3JkZXIgcmVxdWVzdHMgZnJvbSBpdHMgcGVlciB0byB0aGUgVUEpLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVNlcXVlbmNlTnVtYmVyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJsb2NhbFVSSVwiLCB7XG4gICAgICAgIC8qKiBMb2NhbCBVUkkuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUubG9jYWxVUkk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInJlbW90ZVVSSVwiLCB7XG4gICAgICAgIC8qKiBSZW1vdGUgVVJJLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVVSSTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpYWxvZy5wcm90b3R5cGUsIFwicmVtb3RlVGFyZ2V0XCIsIHtcbiAgICAgICAgLyoqIFJlbW90ZSB0YXJnZXQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlVGFyZ2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJyb3V0ZVNldFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb3V0ZSBzZXQsIHdoaWNoIGlzIGFuIG9yZGVyZWQgbGlzdCBvZiBVUklzLiBUaGUgcm91dGUgc2V0IGlzIHRoZVxuICAgICAgICAgKiBsaXN0IG9mIHNlcnZlcnMgdGhhdCBuZWVkIHRvIGJlIHRyYXZlcnNlZCB0byBzZW5kIGEgcmVxdWVzdCB0byB0aGUgcGVlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUucm91dGVTZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaWFsb2cucHJvdG90eXBlLCBcInNlY3VyZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcmVxdWVzdCB3YXMgc2VudCBvdmVyIFRMUywgYW5kIHRoZSBSZXF1ZXN0LVVSSSBjb250YWluZWRcbiAgICAgICAgICogYSBTSVBTIFVSSSwgdGhlIFwic2VjdXJlXCIgZmxhZyBpcyBzZXQgdG8gdHJ1ZS4gKk5PVCBJTVBMRU1FTlRFRCpcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlhbG9nU3RhdGUuc2VjdXJlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlhbG9nLnByb3RvdHlwZSwgXCJ1c2VyQWdlbnRDb3JlXCIsIHtcbiAgICAgICAgLyoqIFRoZSB1c2VyIGFnZW50IGNvcmUgc2VydmljaW5nIHRoaXMgZGlhbG9nLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBDb25maXJtIHRoZSBkaWFsb2cuIE9ubHkgbWF0dGVycyBpZiBkaWFsb2cgaXMgY3VycmVudGx5IGVhcmx5LiAqL1xuICAgIERpYWxvZy5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaWFsb2dTdGF0ZS5lYXJseSA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgc2VudCB3aXRoaW4gYSBkaWFsb2csIGFzIGFueSBvdGhlciByZXF1ZXN0cywgYXJlIGF0b21pYy4gIElmXG4gICAgICogYSBwYXJ0aWN1bGFyIHJlcXVlc3QgaXMgYWNjZXB0ZWQgYnkgdGhlIFVBUywgYWxsIHRoZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIGl0IGFyZSBwZXJmb3JtZWQuICBJZiB0aGUgcmVxdWVzdCBpcyByZWplY3RlZCwgbm9uZVxuICAgICAqIG9mIHRoZSBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAgICpcbiAgICAgKiAgICBOb3RlIHRoYXQgc29tZSByZXF1ZXN0cywgc3VjaCBhcyBJTlZJVEVzLCBhZmZlY3Qgc2V2ZXJhbCBwaWVjZXMgb2ZcbiAgICAgKiAgICBzdGF0ZS5cbiAgICAgKlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2Ugd2l0aGluIHRoaXMgZGlhbG9nLlxuICAgICAqL1xuICAgIERpYWxvZy5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyBBQ0sgZ3VhcmQuXG4gICAgICAgIC8vIEJ5IGNvbnZlbnRpb24sIHRoZSBoYW5kbGluZyBvZiBBQ0tzIGlzIHRoZSByZXNwb25zaWJpbGl0eVxuICAgICAgICAvLyB0aGUgcGFydGljdWxhciBkaWFsb2cgaW1wbGVtZW50YXRpb24uIEZvciBleGFtcGxlLCBzZWUgU2Vzc2lvbkRpYWxvZy5cbiAgICAgICAgLy8gRnVydGhlcm1vcmUsIEFDS3MgaGF2ZSBzYW1lIHNlcXVlbmNlIG51bWJlciBhcyB0aGUgYXNzb2NpYXRlZCBJTlZJVEUuXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIHdhcyBub3QgZW1wdHksIGJ1dCB0aGUgc2VxdWVuY2UgbnVtYmVyXG4gICAgICAgIC8vIG9mIHRoZSByZXF1ZXN0IGlzIGxvd2VyIHRoYW4gdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIsIHRoZSByZXF1ZXN0XG4gICAgICAgIC8vIGlzIG91dCBvZiBvcmRlciBhbmQgTVVTVCBiZSByZWplY3RlZCB3aXRoIGEgNTAwIChTZXJ2ZXIgSW50ZXJuYWxcbiAgICAgICAgLy8gRXJyb3IpIHJlc3BvbnNlLiAgSWYgdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgd2FzIG5vdCBlbXB0eSwgYW5kXG4gICAgICAgIC8vIHRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIHJlcXVlc3QgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1vdGVcbiAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyLCB0aGUgcmVxdWVzdCBpcyBpbiBvcmRlci4gIEl0IGlzIHBvc3NpYmxlIGZvciB0aGVcbiAgICAgICAgLy8gQ1NlcSBzZXF1ZW5jZSBudW1iZXIgdG8gYmUgaGlnaGVyIHRoYW4gdGhlIHJlbW90ZSBzZXF1ZW5jZSBudW1iZXIgYnlcbiAgICAgICAgLy8gbW9yZSB0aGFuIG9uZS4gIFRoaXMgaXMgbm90IGFuIGVycm9yIGNvbmRpdGlvbiwgYW5kIGEgVUFTIFNIT1VMRCBiZVxuICAgICAgICAvLyBwcmVwYXJlZCB0byByZWNlaXZlIGFuZCBwcm9jZXNzIHJlcXVlc3RzIHdpdGggQ1NlcSB2YWx1ZXMgbW9yZSB0aGFuXG4gICAgICAgIC8vIG9uZSBoaWdoZXIgdGhhbiB0aGUgcHJldmlvdXMgcmVjZWl2ZWQgcmVxdWVzdC4gIFRoZSBVQVMgTVVTVCB0aGVuIHNldFxuICAgICAgICAvLyB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlIG51bWJlciBpbiB0aGVcbiAgICAgICAgLy8gQ1NlcSBoZWFkZXIgZmllbGQgdmFsdWUgaW4gdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIElmIGEgcHJveHkgY2hhbGxlbmdlcyBhIHJlcXVlc3QgZ2VuZXJhdGVkIGJ5IHRoZSBVQUMsIHRoZSBVQUMgaGFzXG4gICAgICAgIC8vICAgIHRvIHJlc3VibWl0IHRoZSByZXF1ZXN0IHdpdGggY3JlZGVudGlhbHMuICBUaGUgcmVzdWJtaXR0ZWQgcmVxdWVzdFxuICAgICAgICAvLyAgICB3aWxsIGhhdmUgYSBuZXcgQ1NlcSBudW1iZXIuICBUaGUgVUFTIHdpbGwgbmV2ZXIgc2VlIHRoZSBmaXJzdFxuICAgICAgICAvLyAgICByZXF1ZXN0LCBhbmQgdGh1cywgaXQgd2lsbCBub3RpY2UgYSBnYXAgaW4gdGhlIENTZXEgbnVtYmVyIHNwYWNlLlxuICAgICAgICAvLyAgICBTdWNoIGEgZ2FwIGRvZXMgbm90IHJlcHJlc2VudCBhbnkgZXJyb3IgY29uZGl0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICBpZiAodGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY3NlcSA8PSB0aGlzLnJlbW90ZVNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIHNlcXVlbmNlIGluIGRpYWxvZyByZXF1ZXN0LiBEaWQgeW91IGZvcmdldCB0byBjYWxsIHNlcXVlbmNlR3VhcmQoKT9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpYWxvZ1N0YXRlLnJlbW90ZVNlcXVlbmNlTnVtYmVyID0gbWVzc2FnZS5jc2VxO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIGlzIGVtcHR5LCBpdCBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWVcbiAgICAgICAgLy8gb2YgdGhlIHNlcXVlbmNlIG51bWJlciBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgdmFsdWUgaW4gdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIGlmICghdGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5kaWFsb2dTdGF0ZS5yZW1vdGVTZXF1ZW5jZU51bWJlciA9IG1lc3NhZ2UuY3NlcTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgVUFTIHJlY2VpdmVzIGEgdGFyZ2V0IHJlZnJlc2ggcmVxdWVzdCwgaXQgTVVTVCByZXBsYWNlIHRoZVxuICAgICAgICAvLyBkaWFsb2cncyByZW1vdGUgdGFyZ2V0IFVSSSB3aXRoIHRoZSBVUkkgZnJvbSB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGRcbiAgICAgICAgLy8gaW4gdGhhdCByZXF1ZXN0LCBpZiBwcmVzZW50LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICAvLyBOb3RlOiBcInRhcmdldCByZWZyZXNoIHJlcXVlc3RcIiBwcm9jZXNzaW5nIGRlbGVnYXRlZCB0byBzdWItY2xhc3MuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZGlhbG9nIGlkZW50aWZpZXIgaW4gdGhlIDJ4eCByZXNwb25zZSBtYXRjaGVzIHRoZSBkaWFsb2dcbiAgICAgKiBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGRpYWxvZywgdGhlIGRpYWxvZyBNVVNUIGJlIHRyYW5zaXRpb25lZCB0b1xuICAgICAqIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlLCBhbmQgdGhlIHJvdXRlIHNldCBmb3IgdGhlIGRpYWxvZyBNVVNUIGJlXG4gICAgICogcmVjb21wdXRlZCBiYXNlZCBvbiB0aGUgMnh4IHJlc3BvbnNlIHVzaW5nIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb25cbiAgICAgKiAxMi4yLjEuMi4gIE90aGVyd2lzZSwgYSBuZXcgZGlhbG9nIGluIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlIE1VU1QgYmVcbiAgICAgKiBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDEyLjEuMi5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb25seSBwaWVjZSBvZiBzdGF0ZSB0aGF0IGlzIHJlY29tcHV0ZWQgaXMgdGhlIHJvdXRlXG4gICAgICogc2V0LiAgT3RoZXIgcGllY2VzIG9mIHN0YXRlIHN1Y2ggYXMgdGhlIGhpZ2hlc3Qgc2VxdWVuY2UgbnVtYmVyc1xuICAgICAqIChyZW1vdGUgYW5kIGxvY2FsKSBzZW50IHdpdGhpbiB0aGUgZGlhbG9nIGFyZSBub3QgcmVjb21wdXRlZC4gIFRoZVxuICAgICAqIHJvdXRlIHNldCBvbmx5IGlzIHJlY29tcHV0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiAgUkZDXG4gICAgICogMjU0MyBkaWQgbm90IG1hbmRhdGUgbWlycm9yaW5nIG9mIHRoZSBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIGluXG4gICAgICogYSAxeHgsIG9ubHkgMnh4LiAgSG93ZXZlciwgd2UgY2Fubm90IHVwZGF0ZSB0aGUgZW50aXJlIHN0YXRlIG9mXG4gICAgICogdGhlIGRpYWxvZywgc2luY2UgbWlkLWRpYWxvZyByZXF1ZXN0cyBtYXkgaGF2ZSBiZWVuIHNlbnQgd2l0aGluXG4gICAgICogdGhlIGVhcmx5IGRpYWxvZywgbW9kaWZ5aW5nIHRoZSBzZXF1ZW5jZSBudW1iZXJzLCBmb3IgZXhhbXBsZS5cbiAgICAgKlxuICAgICAqICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICovXG4gICAgRGlhbG9nLnByb3RvdHlwZS5yZWNvbXB1dGVSb3V0ZVNldCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZGlhbG9nU3RhdGUucm91dGVTZXQgPSBtZXNzYWdlLmdldEhlYWRlcnMoXCJyZWNvcmQtcm91dGVcIikucmV2ZXJzZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IHdpdGhpbiBhIGRpYWxvZyBpcyBjb25zdHJ1Y3RlZCBieSB1c2luZyBtYW55IG9mIHRoZVxuICAgICAqIGNvbXBvbmVudHMgb2YgdGhlIHN0YXRlIHN0b3JlZCBhcyBwYXJ0IG9mIHRoZSBkaWFsb2cuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgICAqIEBwYXJhbSBtZXRob2QgLSBPdXRnb2luZyByZXF1ZXN0IG1ldGhvZC5cbiAgICAgKi9cbiAgICBEaWFsb2cucHJvdG90eXBlLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWV0aG9kLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoZSBVUkkgaW4gdGhlIFRvIGZpZWxkIG9mIHRoZSByZXF1ZXN0IE1VU1QgYmUgc2V0IHRvIHRoZSByZW1vdGUgVVJJXG4gICAgICAgIC8vIGZyb20gdGhlIGRpYWxvZyBzdGF0ZS4gIFRoZSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBNVVNUIGJlIHNldCB0byB0aGUgcmVtb3RlIHRhZyBvZiB0aGUgZGlhbG9nIElELiAgVGhlIEZyb20gVVJJIG9mIHRoZVxuICAgICAgICAvLyByZXF1ZXN0IE1VU1QgYmUgc2V0IHRvIHRoZSBsb2NhbCBVUkkgZnJvbSB0aGUgZGlhbG9nIHN0YXRlLiAgVGhlIHRhZ1xuICAgICAgICAvLyBpbiB0aGUgRnJvbSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QgTVVTVCBiZSBzZXQgdG8gdGhlIGxvY2FsIHRhZ1xuICAgICAgICAvLyBvZiB0aGUgZGlhbG9nIElELiAgSWYgdGhlIHZhbHVlIG9mIHRoZSByZW1vdGUgb3IgbG9jYWwgdGFncyBpcyBudWxsLFxuICAgICAgICAvLyB0aGUgdGFnIHBhcmFtZXRlciBNVVNUIGJlIG9taXR0ZWQgZnJvbSB0aGUgVG8gb3IgRnJvbSBoZWFkZXIgZmllbGRzLFxuICAgICAgICAvLyByZXNwZWN0aXZlbHkuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFVzYWdlIG9mIHRoZSBVUkkgZnJvbSB0aGUgVG8gYW5kIEZyb20gZmllbGRzIGluIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyAgICByZXF1ZXN0IHdpdGhpbiBzdWJzZXF1ZW50IHJlcXVlc3RzIGlzIGRvbmUgZm9yIGJhY2t3YXJkc1xuICAgICAgICAvLyAgICBjb21wYXRpYmlsaXR5IHdpdGggUkZDIDI1NDMsIHdoaWNoIHVzZWQgdGhlIFVSSSBmb3IgZGlhbG9nXG4gICAgICAgIC8vICAgIGlkZW50aWZpY2F0aW9uLiAgSW4gdGhpcyBzcGVjaWZpY2F0aW9uLCBvbmx5IHRoZSB0YWdzIGFyZSB1c2VkIGZvclxuICAgICAgICAvLyAgICBkaWFsb2cgaWRlbnRpZmljYXRpb24uICBJdCBpcyBleHBlY3RlZCB0aGF0IG1hbmRhdG9yeSByZWZsZWN0aW9uXG4gICAgICAgIC8vICAgIG9mIHRoZSBvcmlnaW5hbCBUbyBhbmQgRnJvbSBVUkkgaW4gbWlkLWRpYWxvZyByZXF1ZXN0cyB3aWxsIGJlXG4gICAgICAgIC8vICAgIGRlcHJlY2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHJldmlzaW9uIG9mIHRoaXMgc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgICAgICB2YXIgdG9VcmkgPSB0aGlzLnJlbW90ZVVSSTtcbiAgICAgICAgdmFyIHRvVGFnID0gdGhpcy5yZW1vdGVUYWc7XG4gICAgICAgIHZhciBmcm9tVXJpID0gdGhpcy5sb2NhbFVSSTtcbiAgICAgICAgdmFyIGZyb21UYWcgPSB0aGlzLmxvY2FsVGFnO1xuICAgICAgICAvLyBUaGUgQ2FsbC1JRCBvZiB0aGUgcmVxdWVzdCBNVVNUIGJlIHNldCB0byB0aGUgQ2FsbC1JRCBvZiB0aGUgZGlhbG9nLlxuICAgICAgICAvLyBSZXF1ZXN0cyB3aXRoaW4gYSBkaWFsb2cgTVVTVCBjb250YWluIHN0cmljdGx5IG1vbm90b25pY2FsbHlcbiAgICAgICAgLy8gaW5jcmVhc2luZyBhbmQgY29udGlndW91cyBDU2VxIHNlcXVlbmNlIG51bWJlcnMgKGluY3JlYXNpbmctYnktb25lKVxuICAgICAgICAvLyBpbiBlYWNoIGRpcmVjdGlvbiAoZXhjZXB0aW5nIEFDSyBhbmQgQ0FOQ0VMIG9mIGNvdXJzZSwgd2hvc2UgbnVtYmVyc1xuICAgICAgICAvLyBlcXVhbCB0aGUgcmVxdWVzdHMgYmVpbmcgYWNrbm93bGVkZ2VkIG9yIGNhbmNlbGxlZCkuICBUaGVyZWZvcmUsIGlmXG4gICAgICAgIC8vIHRoZSBsb2NhbCBzZXF1ZW5jZSBudW1iZXIgaXMgbm90IGVtcHR5LCB0aGUgdmFsdWUgb2YgdGhlIGxvY2FsXG4gICAgICAgIC8vIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIGluY3JlbWVudGVkIGJ5IG9uZSwgYW5kIHRoaXMgdmFsdWUgTVVTVCBiZVxuICAgICAgICAvLyBwbGFjZWQgaW50byB0aGUgQ1NlcSBoZWFkZXIgZmllbGQuICBJZiB0aGUgbG9jYWwgc2VxdWVuY2UgbnVtYmVyIGlzXG4gICAgICAgIC8vIGVtcHR5LCBhbiBpbml0aWFsIHZhbHVlIE1VU1QgYmUgY2hvc2VuIHVzaW5nIHRoZSBndWlkZWxpbmVzIG9mXG4gICAgICAgIC8vIFNlY3Rpb24gOC4xLjEuNS4gIFRoZSBtZXRob2QgZmllbGQgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIHZhbHVlXG4gICAgICAgIC8vIE1VU1QgbWF0Y2ggdGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgICAgICB2YXIgY2FsbElkID0gdGhpcy5jYWxsSWQ7XG4gICAgICAgIHZhciBjc2VxO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNzZXEpIHtcbiAgICAgICAgICAgIGNzZXEgPSBvcHRpb25zLmNzZXE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgY3NlcSA9IHRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlciA9IDE7IC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjEuNVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3NlcSA9IHRoaXMuZGlhbG9nU3RhdGUubG9jYWxTZXF1ZW5jZU51bWJlciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBVQUMgdXNlcyB0aGUgcmVtb3RlIHRhcmdldCBhbmQgcm91dGUgc2V0IHRvIGJ1aWxkIHRoZSBSZXF1ZXN0LVVSSVxuICAgICAgICAvLyBhbmQgUm91dGUgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgcm91dGUgc2V0IGlzIGVtcHR5LCB0aGUgVUFDIE1VU1QgcGxhY2UgdGhlIHJlbW90ZSB0YXJnZXQgVVJJXG4gICAgICAgIC8vIGludG8gdGhlIFJlcXVlc3QtVVJJLiAgVGhlIFVBQyBNVVNUIE5PVCBhZGQgYSBSb3V0ZSBoZWFkZXIgZmllbGQgdG9cbiAgICAgICAgLy8gdGhlIHJlcXVlc3QuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSByb3V0ZSBzZXQgaXMgbm90IGVtcHR5LCBhbmQgdGhlIGZpcnN0IFVSSSBpbiB0aGUgcm91dGUgc2V0XG4gICAgICAgIC8vIGNvbnRhaW5zIHRoZSBsciBwYXJhbWV0ZXIgKHNlZSBTZWN0aW9uIDE5LjEuMSksIHRoZSBVQUMgTVVTVCBwbGFjZVxuICAgICAgICAvLyB0aGUgcmVtb3RlIHRhcmdldCBVUkkgaW50byB0aGUgUmVxdWVzdC1VUkkgYW5kIE1VU1QgaW5jbHVkZSBhIFJvdXRlXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCBjb250YWluaW5nIHRoZSByb3V0ZSBzZXQgdmFsdWVzIGluIG9yZGVyLCBpbmNsdWRpbmcgYWxsXG4gICAgICAgIC8vIHBhcmFtZXRlcnMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoZSByb3V0ZSBzZXQgaXMgbm90IGVtcHR5LCBhbmQgaXRzIGZpcnN0IFVSSSBkb2VzIG5vdCBjb250YWluIHRoZVxuICAgICAgICAvLyBsciBwYXJhbWV0ZXIsIHRoZSBVQUMgTVVTVCBwbGFjZSB0aGUgZmlyc3QgVVJJIGZyb20gdGhlIHJvdXRlIHNldFxuICAgICAgICAvLyBpbnRvIHRoZSBSZXF1ZXN0LVVSSSwgc3RyaXBwaW5nIGFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG5vdCBhbGxvd2VkXG4gICAgICAgIC8vIGluIGEgUmVxdWVzdC1VUkkuICBUaGUgVUFDIE1VU1QgYWRkIGEgUm91dGUgaGVhZGVyIGZpZWxkIGNvbnRhaW5pbmdcbiAgICAgICAgLy8gdGhlIHJlbWFpbmRlciBvZiB0aGUgcm91dGUgc2V0IHZhbHVlcyBpbiBvcmRlciwgaW5jbHVkaW5nIGFsbFxuICAgICAgICAvLyBwYXJhbWV0ZXJzLiAgVGhlIFVBQyBNVVNUIHRoZW4gcGxhY2UgdGhlIHJlbW90ZSB0YXJnZXQgVVJJIGludG8gdGhlXG4gICAgICAgIC8vIFJvdXRlIGhlYWRlciBmaWVsZCBhcyB0aGUgbGFzdCB2YWx1ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgICAgICAvLyBUaGUgbHIgcGFyYW1ldGVyLCB3aGVuIHByZXNlbnQsIGluZGljYXRlcyB0aGF0IHRoZSBlbGVtZW50XG4gICAgICAgIC8vIHJlc3BvbnNpYmxlIGZvciB0aGlzIHJlc291cmNlIGltcGxlbWVudHMgdGhlIHJvdXRpbmcgbWVjaGFuaXNtc1xuICAgICAgICAvLyBzcGVjaWZpZWQgaW4gdGhpcyBkb2N1bWVudC4gIFRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgdXNlZCBpbiB0aGVcbiAgICAgICAgLy8gVVJJcyBwcm94aWVzIHBsYWNlIGludG8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCB2YWx1ZXMsIGFuZFxuICAgICAgICAvLyBtYXkgYXBwZWFyIGluIHRoZSBVUklzIGluIGEgcHJlLWV4aXN0aW5nIHJvdXRlIHNldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCB0byBhY2hpZXZlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGhcbiAgICAgICAgLy8gc3lzdGVtcyBpbXBsZW1lbnRpbmcgdGhlIHN0cmljdC1yb3V0aW5nIG1lY2hhbmlzbXMgb2YgUkZDIDI1NDNcbiAgICAgICAgLy8gYW5kIHRoZSByZmMyNTQzYmlzIGRyYWZ0cyB1cCB0byBiaXMtMDUuICBBbiBlbGVtZW50IHByZXBhcmluZ1xuICAgICAgICAvLyB0byBzZW5kIGEgcmVxdWVzdCBiYXNlZCBvbiBhIFVSSSBub3QgY29udGFpbmluZyB0aGlzIHBhcmFtZXRlclxuICAgICAgICAvLyBjYW4gYXNzdW1lIHRoZSByZWNlaXZpbmcgZWxlbWVudCBpbXBsZW1lbnRzIHN0cmljdC1yb3V0aW5nIGFuZFxuICAgICAgICAvLyByZWZvcm1hdCB0aGUgbWVzc2FnZSB0byBwcmVzZXJ2ZSB0aGUgaW5mb3JtYXRpb24gaW4gdGhlXG4gICAgICAgIC8vIFJlcXVlc3QtVVJJLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE5LjEuMVxuICAgICAgICAvLyBOT1RFOiBOb3QgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBSRkMgMjU0MyAobm8gc3VwcG9ydCBmb3Igc3RyaWN0LXJvdXRpbmcpLlxuICAgICAgICB2YXIgcnVyaSA9IHRoaXMucmVtb3RlVGFyZ2V0O1xuICAgICAgICB2YXIgcm91dGVTZXQgPSB0aGlzLnJvdXRlU2V0O1xuICAgICAgICB2YXIgZXh0cmFIZWFkZXJzID0gb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhSGVhZGVycztcbiAgICAgICAgdmFyIGJvZHkgPSBvcHRpb25zICYmIG9wdGlvbnMuYm9keTtcbiAgICAgICAgLy8gVGhlIHJlbGF0aXZlIG9yZGVyIG9mIGhlYWRlciBmaWVsZHMgd2l0aCBkaWZmZXJlbnQgZmllbGQgbmFtZXMgaXMgbm90XG4gICAgICAgIC8vIHNpZ25pZmljYW50LiAgSG93ZXZlciwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBoZWFkZXIgZmllbGRzIHdoaWNoIGFyZVxuICAgICAgICAvLyBuZWVkZWQgZm9yIHByb3h5IHByb2Nlc3NpbmcgKFZpYSwgUm91dGUsIFJlY29yZC1Sb3V0ZSwgUHJveHktUmVxdWlyZSxcbiAgICAgICAgLy8gTWF4LUZvcndhcmRzLCBhbmQgUHJveHktQXV0aG9yaXphdGlvbiwgZm9yIGV4YW1wbGUpIGFwcGVhciB0b3dhcmRzXG4gICAgICAgIC8vIHRoZSB0b3Agb2YgdGhlIG1lc3NhZ2UgdG8gZmFjaWxpdGF0ZSByYXBpZCBwYXJzaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTcuMy4xXG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy51c2VyQWdlbnRDb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1ldGhvZCwgcnVyaSwgZnJvbVVyaSwgdG9VcmksIHtcbiAgICAgICAgICAgIGNhbGxJZDogY2FsbElkLFxuICAgICAgICAgICAgY3NlcTogY3NlcSxcbiAgICAgICAgICAgIGZyb21UYWc6IGZyb21UYWcsXG4gICAgICAgICAgICB0b1RhZzogdG9UYWcsXG4gICAgICAgICAgICByb3V0ZVNldDogcm91dGVTZXRcbiAgICAgICAgfSwgZXh0cmFIZWFkZXJzLCBib2R5KTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgdGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBieSBvbmUuXG4gICAgICogSXQgZmVlbHMgbGlrZSB0aGlzIHNob3VsZCBiZSBwcm90ZWN0ZWQsIGJ1dCB0aGUgY3VycmVudCBhdXRoZW50aWNhdGlvbiBoYW5kbGluZyBjdXJyZW50bHlcbiAgICAgKiBuZWVkcyB0aGlzIHRvIGtlZXAgdGhlIGRpYWxvZyBpbiBzeW5jIHdoZW4gXCJhdXRvIHJlLXNlbmRzXCIgcmVxdWVzdCBtZXNzYWdlcy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBEaWFsb2cucHJvdG90eXBlLmluY3JlbWVudExvY2FsU2VxdWVuY2VOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaWFsb2dTdGF0ZS5sb2NhbFNlcXVlbmNlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBzZXF1ZW5jZSBudW1iZXIgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpYWxvZ1N0YXRlLmxvY2FsU2VxdWVuY2VOdW1iZXIgKz0gMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSByZW1vdGUgc2VxdWVuY2UgbnVtYmVyIHdhcyBub3QgZW1wdHksIGJ1dCB0aGUgc2VxdWVuY2UgbnVtYmVyXG4gICAgICogb2YgdGhlIHJlcXVlc3QgaXMgbG93ZXIgdGhhbiB0aGUgcmVtb3RlIHNlcXVlbmNlIG51bWJlciwgdGhlIHJlcXVlc3RcbiAgICAgKiBpcyBvdXQgb2Ygb3JkZXIgYW5kIE1VU1QgYmUgcmVqZWN0ZWQgd2l0aCBhIDUwMCAoU2VydmVyIEludGVybmFsXG4gICAgICogRXJyb3IpIHJlc3BvbnNlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBJbmNvbWluZyByZXF1ZXN0IHRvIGd1YXJkLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHByb2dyYW0gZXhlY3V0aW9uIGlzIHRvIGNvbnRpbnVlIGluIHRoZSBicmFuY2ggaW4gcXVlc3Rpb24uXG4gICAgICogICAgICAgICAgT3RoZXJ3aXNlIGEgNTAwIFNlcnZlciBJbnRlcm5hbCBFcnJvciB3YXMgc3RhdGVsZXNzIHNlbnQgYW5kIHJlcXVlc3QgcHJvY2Vzc2luZyBtdXN0IHN0b3AuXG4gICAgICovXG4gICAgRGlhbG9nLnByb3RvdHlwZS5zZXF1ZW5jZUd1YXJkID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gQUNLIGd1YXJkLlxuICAgICAgICAvLyBCeSBjb252ZW50aW9uLCBoYW5kbGluZyBvZiB1bmV4cGVjdGVkIEFDS3MgaXMgcmVzcG9uc2liaWxpdHlcbiAgICAgICAgLy8gdGhlIHBhcnRpY3VsYXIgZGlhbG9nIGltcGxlbWVudGF0aW9uLiBGb3IgZXhhbXBsZSwgc2VlIFNlc3Npb25EaWFsb2cuXG4gICAgICAgIC8vIEZ1cnRoZXJtb3JlLCB3ZSBjYW5ub3QgcmVwbHkgdG8gYW4gXCJvdXQgb2Ygc2VxdWVuY2VcIiBBQ0suXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogV2UgYXJlIHJlamVjdGluZyBvbiBcImxlc3MgdGhhbiBvciBlcXVhbCB0b1wiIHRoZSByZW1vdGVcbiAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIChleGNlcHRpbmcgQUNLIHdob3NlIG51bWJlcnMgZXF1YWwgdGhlIHJlcXVlc3RzXG4gICAgICAgIC8vIGJlaW5nIGFja25vd2xlZGdlZCBvciBjYW5jZWxsZWQpLCB3aGljaCBpcyB0aGUgY29ycmVjdCB0aGluZyB0b1xuICAgICAgICAvLyBkbyBpbiBvdXIgY2FzZS4gVGhlIG9ubHkgdGltZSBhIHJlcXVlc3Qgd2l0aCB0aGUgc2FtZSBzZXF1ZW5jZSBudW1iZXJcbiAgICAgICAgLy8gd2lsbCBzaG93IHVwIGhlcmUgaWYgaXMgYSkgaXQgaXMgYSB2ZXJ5IGxhdGUgcmV0cmFuc21pc3Npb24gb2YgYVxuICAgICAgICAvLyByZXF1ZXN0IHdlIGFscmVhZHkgaGFuZGxlZCBvciBiKSBpdCBpcyBhIGRpZmZlcmVudCByZXF1ZXN0IHdpdGggdGhlXG4gICAgICAgIC8vIHNhbWUgc2VxdWVuY2UgbnVtYmVyIHdoaWNoIHdvdWxkIGJlIHZpb2xhdGlvbiBvZiB0aGUgc3RhbmRhcmQuXG4gICAgICAgIC8vIFJlcXVlc3QgcmV0cmFuc21pc3Npb25zIGFyZSBhYnNvcmJlZCBieSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIsXG4gICAgICAgIC8vIHNvIGFueSByZXF1ZXN0IHdpdGggYSBkdXBsaWNhdGUgc2VxdWVuY2UgbnVtYmVyIGdldHRpbmcgaGVyZVxuICAgICAgICAvLyB3b3VsZCBoYXZlIHRvIGJlIGEgcmV0cmFuc21pc3Npb24gYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uIHRlcm1pbmF0ZWRcbiAgICAgICAgLy8gb3IgYSBicm9rZW4gcmVxdWVzdCAod2l0aCB1bmlxdWUgdmlhIGJyYW5jaCB2YWx1ZSkuXG4gICAgICAgIC8vIFJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBNVVNUIGNvbnRhaW4gc3RyaWN0bHkgbW9ub3RvbmljYWxseVxuICAgICAgICAvLyBpbmNyZWFzaW5nIGFuZCBjb250aWd1b3VzIENTZXEgc2VxdWVuY2UgbnVtYmVycyAoaW5jcmVhc2luZy1ieS1vbmUpXG4gICAgICAgIC8vIGluIGVhY2ggZGlyZWN0aW9uIChleGNlcHRpbmcgQUNLIGFuZCBDQU5DRUwgb2YgY291cnNlLCB3aG9zZSBudW1iZXJzXG4gICAgICAgIC8vIGVxdWFsIHRoZSByZXF1ZXN0cyBiZWluZyBhY2tub3dsZWRnZWQgb3IgY2FuY2VsbGVkKS4gIFRoZXJlZm9yZSwgaWZcbiAgICAgICAgLy8gdGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBpcyBub3QgZW1wdHksIHRoZSB2YWx1ZSBvZiB0aGUgbG9jYWxcbiAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgaW5jcmVtZW50ZWQgYnkgb25lLCBhbmQgdGhpcyB2YWx1ZSBNVVNUIGJlXG4gICAgICAgIC8vIHBsYWNlZCBpbnRvIHRoZSBDU2VxIGhlYWRlciBmaWVsZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjEuMVxuICAgICAgICBpZiAodGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlciAmJiBtZXNzYWdlLmNzZXEgPD0gdGhpcy5yZW1vdGVTZXF1ZW5jZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNTAwIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIERpYWxvZztcbn0oKSk7XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kaWFsb2dcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Vzc2lvbi1kaWFsb2dcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3Vic2NyaXB0aW9uLWRpYWxvZ1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4uL3Nlc3Npb25cIik7XG52YXIgdGltZXJzXzEgPSByZXF1aXJlKFwiLi4vdGltZXJzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciBieWVfdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9ieWUtdXNlci1hZ2VudC1jbGllbnRcIik7XG52YXIgYnllX3VzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi4vdXNlci1hZ2VudHMvYnllLXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIGluZm9fdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIGluZm9fdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9pbmZvLXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIG1lc3NhZ2VfdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9tZXNzYWdlLXVzZXItYWdlbnQtY2xpZW50XCIpO1xudmFyIG1lc3NhZ2VfdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9tZXNzYWdlLXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIG5vdGlmeV91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL25vdGlmeS11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciBub3RpZnlfdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9ub3RpZnktdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgcHJhY2tfdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9wcmFjay11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciBwcmFja191c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3ByYWNrLXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIHJlX2ludml0ZV91c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3JlLWludml0ZS11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciByZV9pbnZpdGVfdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9yZS1pbnZpdGUtdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG52YXIgcmVmZXJfdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9yZWZlci11c2VyLWFnZW50LWNsaWVudFwiKTtcbnZhciByZWZlcl91c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL3JlZmVyLXVzZXItYWdlbnQtc2VydmVyXCIpO1xudmFyIGRpYWxvZ18xID0gcmVxdWlyZShcIi4vZGlhbG9nXCIpO1xuLyoqXG4gKiBTZXNzaW9uIERpYWxvZy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFNlc3Npb25EaWFsb2cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Vzc2lvbkRpYWxvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTZXNzaW9uRGlhbG9nKGluaXRpYWxUcmFuc2FjdGlvbiwgY29yZSwgc3RhdGUsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvcmUsIHN0YXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbml0aWFsVHJhbnNhY3Rpb24gPSBpbml0aWFsVHJhbnNhY3Rpb247XG4gICAgICAgIC8qKiBUaGUgc3RhdGUgb2YgdGhlIG9mZmVyL2Fuc3dlciBleGNoYW5nZS4gKi9cbiAgICAgICAgX3RoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWw7XG4gICAgICAgIC8qKiBUcnVlIGlmIHdhaXRpbmcgZm9yIGFuIEFDSyB0byB0aGUgaW5pdGlhbCB0cmFuc2FjdGlvbiAyeHggKFVBUyBvbmx5KS4gKi9cbiAgICAgICAgX3RoaXMuYWNrV2FpdCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICBpZiAoaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGNyZWF0ZWQgYnkgYW4gaW52aXRlIHNlcnZlciB0cmFuc2FjdGlvbiwgd2UncmVcbiAgICAgICAgICAgIC8vIGdvaW5nIHRvIGJlIHdhaXRpbmcgZm9yIGFuIEFDSyBpZiBhcmUgdG8gYmUgY29uZmlybWVkLlxuICAgICAgICAgICAgX3RoaXMuYWNrV2FpdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgY29uZmlybWVkIHVwb24gY3JlYXRpb24gc3RhcnQgdGhlIHJldHJhbnNtaXR0aW5nIHdoYXRldmVyXG4gICAgICAgIC8vIHRoZSAyeHggZmluYWwgcmVzcG9uc2Ugd2FzIHRoYXQgY29uZmlybWVkIHVzIGludG8gZXhpc3RlbmNlLlxuICAgICAgICBpZiAoIV90aGlzLmVhcmx5KSB7XG4gICAgICAgICAgICBfdGhpcy5zdGFydDJ4eFJldHJhbnNtaXNzaW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24oaW5pdGlhbFRyYW5zYWN0aW9uLnJlcXVlc3QpO1xuICAgICAgICBfdGhpcy5sb2dnZXIgPSBjb3JlLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLmludml0ZS1kaWFsb2dcIik7XG4gICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJJTlZJVEUgZGlhbG9nIFwiICsgX3RoaXMuaWQgKyBcIiBjb25zdHJ1Y3RlZFwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkO1xuICAgICAgICB0aGlzLl9vZmZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5pbnZpdGUyeHhUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5pbnZpdGUyeHhUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgVUFTIE1VU1Qgc3RpbGwgcmVzcG9uZCB0byBhbnkgcGVuZGluZyByZXF1ZXN0cyByZWNlaXZlZCBmb3IgdGhhdFxuICAgICAgICAvLyBkaWFsb2cuICBJdCBpcyBSRUNPTU1FTkRFRCB0aGF0IGEgNDg3IChSZXF1ZXN0IFRlcm1pbmF0ZWQpIHJlc3BvbnNlXG4gICAgICAgIC8vIGJlIGdlbmVyYXRlZCB0byB0aG9zZSBwZW5kaW5nIHJlcXVlc3RzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1LjEuMlxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyB0aGlzLnVzZXJBZ2VudFNlcnZlcnMuZm9yRWFjaCgodWFzKSA9PiB1YXMucmVwbHkoNDg3KSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgZGVzdHJveWVkXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlc3Npb25EaWFsb2cucHJvdG90eXBlLCBcInNlc3Npb25TdGF0ZVwiLCB7XG4gICAgICAgIC8vIEZJWE1FOiBOZWVkIHJlYWwgc3RhdGUgbWFjaGluZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25fMS5TZXNzaW9uU3RhdGUuRWFybHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFja1dhaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbl8xLlNlc3Npb25TdGF0ZS5BY2tXYWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5DbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvbl8xLlNlc3Npb25TdGF0ZS5UZXJtaW5hdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25fMS5TZXNzaW9uU3RhdGUuQ29uZmlybWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUsIFwic2lnbmFsaW5nU3RhdGVcIiwge1xuICAgICAgICAvKiogVGhlIHN0YXRlIG9mIHRoZSBvZmZlci9hbnN3ZXIgZXhjaGFuZ2UuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hbGluZ1N0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUsIFwib2ZmZXJcIiwge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgb2ZmZXIuIFVuZGVmaW5lZCB1bmxlc3Mgc2lnbmFsaW5nIHN0YXRlIEhhdmVMb2NhbE9mZmVyLCBIYXZlUmVtb3RlT2ZmZXIsIG9mIFN0YWJsZS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2ZmZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXNzaW9uRGlhbG9nLnByb3RvdHlwZSwgXCJhbnN3ZXJcIiwge1xuICAgICAgICAvKiogVGhlIGN1cnJlbnQgYW5zd2VyLiBVbmRlZmluZWQgdW5sZXNzIHNpZ25hbGluZyBzdGF0ZSBTdGFibGUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fuc3dlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIENvbmZpcm0gdGhlIGRpYWxvZy4gT25seSBtYXR0ZXJzIGlmIGRpYWxvZyBpcyBjdXJyZW50bHkgZWFybHkuICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuY29uZmlybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSdyZSBjb25maXJtZWQgc3RhcnQgdGhlIHJldHJhbnNtaXR0aW5nIHdoYXRldmVyXG4gICAgICAgIC8vIHRoZSAyeHggZmluYWwgcmVzcG9uc2UgdGhhdCBtYXkgaGF2ZSBjb25maXJtZWQgdXMuXG4gICAgICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Mnh4UmV0cmFuc21pc3Npb25UaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY29uZmlybS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgLyoqIFJlLWNvbmZpcm0gdGhlIGRpYWxvZy4gT25seSBtYXR0ZXJzIGlmIGhhbmRsaW5nIHJlLUlOVklURSByZXF1ZXN0LiAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnJlQ29uZmlybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSdyZSBjb25maXJtZWQgc3RhcnQgdGhlIHJldHJhbnNtaXR0aW5nIHdoYXRldmVyXG4gICAgICAgIC8vIHRoZSAyeHggZmluYWwgcmVzcG9uc2UgdGhhdCBtYXkgaGF2ZSBjb25maXJtZWQgdXMuXG4gICAgICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVJbnZpdGUyeHhSZXRyYW5zbWlzc2lvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBVQUMgY29yZSBNVVNUIGdlbmVyYXRlIGFuIEFDSyByZXF1ZXN0IGZvciBlYWNoIDJ4eCByZWNlaXZlZCBmcm9tXG4gICAgICogdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgVGhlIGhlYWRlciBmaWVsZHMgb2YgdGhlIEFDSyBhcmUgY29uc3RydWN0ZWRcbiAgICAgKiBpbiB0aGUgc2FtZSB3YXkgYXMgZm9yIGFueSByZXF1ZXN0IHNlbnQgd2l0aGluIGEgZGlhbG9nIChzZWUgU2VjdGlvblxuICAgICAqIDEyKSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIENTZXEgYW5kIHRoZSBoZWFkZXIgZmllbGRzIHJlbGF0ZWQgdG9cbiAgICAgKiBhdXRoZW50aWNhdGlvbi4gIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIENTZXEgaGVhZGVyIGZpZWxkIE1VU1QgYmVcbiAgICAgKiB0aGUgc2FtZSBhcyB0aGUgSU5WSVRFIGJlaW5nIGFja25vd2xlZGdlZCwgYnV0IHRoZSBDU2VxIG1ldGhvZCBNVVNUXG4gICAgICogYmUgQUNLLiAgVGhlIEFDSyBNVVNUIGNvbnRhaW4gdGhlIHNhbWUgY3JlZGVudGlhbHMgYXMgdGhlIElOVklURS4gIElmXG4gICAgICogdGhlIDJ4eCBjb250YWlucyBhbiBvZmZlciAoYmFzZWQgb24gdGhlIHJ1bGVzIGFib3ZlKSwgdGhlIEFDSyBNVVNUXG4gICAgICogY2FycnkgYW4gYW5zd2VyIGluIGl0cyBib2R5LiAgSWYgdGhlIG9mZmVyIGluIHRoZSAyeHggcmVzcG9uc2UgaXMgbm90XG4gICAgICogYWNjZXB0YWJsZSwgdGhlIFVBQyBjb3JlIE1VU1QgZ2VuZXJhdGUgYSB2YWxpZCBhbnN3ZXIgaW4gdGhlIEFDSyBhbmRcbiAgICAgKiB0aGVuIHNlbmQgYSBCWUUgaW1tZWRpYXRlbHkuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuNFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQUNLIG9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBBQ0sgcmVxdWVzdFwiKTtcbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudENsaWVudCkge1xuICAgICAgICAgICAgLy8gV2UncmUgc2VuZGluZyBBQ0sgZm9yIGEgcmUtSU5WSVRFXG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50LnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy5yZWludml0ZVVzZXJBZ2VudENsaWVudC50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBzZW5kaW5nIEFDSyBmb3IgdGhlIGluaXRpYWwgSU5WSVRFXG4gICAgICAgICAgICBpZiAoISh0aGlzLmluaXRpYWxUcmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluaXRpYWwgdHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gdGhpcy5pbml0aWFsVHJhbnNhY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5jc2VxID0gdHJhbnNhY3Rpb24ucmVxdWVzdC5jc2VxOyAvLyBBQ0sgY3NlcSBpcyBJTlZJVEUgY3NlcVxuICAgICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXNzYWdlc18xLkMuQUNLLCBvcHRpb25zKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uYWNrUmVzcG9uc2UobWVzc2FnZSk7IC8vIFNlZSBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgICAgdGhpcy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlcm1pbmF0aW5nIGEgU2Vzc2lvblxuICAgICAqXG4gICAgICogVGhpcyBzZWN0aW9uIGRlc2NyaWJlcyB0aGUgcHJvY2VkdXJlcyBmb3IgdGVybWluYXRpbmcgYSBzZXNzaW9uXG4gICAgICogZXN0YWJsaXNoZWQgYnkgU0lQLiAgVGhlIHN0YXRlIG9mIHRoZSBzZXNzaW9uIGFuZCB0aGUgc3RhdGUgb2YgdGhlXG4gICAgICogZGlhbG9nIGFyZSB2ZXJ5IGNsb3NlbHkgcmVsYXRlZC4gIFdoZW4gYSBzZXNzaW9uIGlzIGluaXRpYXRlZCB3aXRoIGFuXG4gICAgICogSU5WSVRFLCBlYWNoIDF4eCBvciAyeHggcmVzcG9uc2UgZnJvbSBhIGRpc3RpbmN0IFVBUyBjcmVhdGVzIGFcbiAgICAgKiBkaWFsb2csIGFuZCBpZiB0aGF0IHJlc3BvbnNlIGNvbXBsZXRlcyB0aGUgb2ZmZXIvYW5zd2VyIGV4Y2hhbmdlLCBpdFxuICAgICAqIGFsc28gY3JlYXRlcyBhIHNlc3Npb24uICBBcyBhIHJlc3VsdCwgZWFjaCBzZXNzaW9uIGlzIFwiYXNzb2NpYXRlZFwiXG4gICAgICogd2l0aCBhIHNpbmdsZSBkaWFsb2cgLSB0aGUgb25lIHdoaWNoIHJlc3VsdGVkIGluIGl0cyBjcmVhdGlvbi4gIElmIGFuXG4gICAgICogaW5pdGlhbCBJTlZJVEUgZ2VuZXJhdGVzIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSwgdGhhdCB0ZXJtaW5hdGVzXG4gICAgICogYWxsIHNlc3Npb25zIChpZiBhbnkpIGFuZCBhbGwgZGlhbG9ncyAoaWYgYW55KSB0aGF0IHdlcmUgY3JlYXRlZFxuICAgICAqIHRocm91Z2ggcmVzcG9uc2VzIHRvIHRoZSByZXF1ZXN0LiAgQnkgdmlydHVlIG9mIGNvbXBsZXRpbmcgdGhlXG4gICAgICogdHJhbnNhY3Rpb24sIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSBhbHNvIHByZXZlbnRzIGZ1cnRoZXIgc2Vzc2lvbnNcbiAgICAgKiBmcm9tIGJlaW5nIGNyZWF0ZWQgYXMgYSByZXN1bHQgb2YgdGhlIElOVklURS4gIFRoZSBCWUUgcmVxdWVzdCBpc1xuICAgICAqIHVzZWQgdG8gdGVybWluYXRlIGEgc3BlY2lmaWMgc2Vzc2lvbiBvciBhdHRlbXB0ZWQgc2Vzc2lvbi4gIEluIHRoaXNcbiAgICAgKiBjYXNlLCB0aGUgc3BlY2lmaWMgc2Vzc2lvbiBpcyB0aGUgb25lIHdpdGggdGhlIHBlZXIgVUEgb24gdGhlIG90aGVyXG4gICAgICogc2lkZSBvZiB0aGUgZGlhbG9nLiAgV2hlbiBhIEJZRSBpcyByZWNlaXZlZCBvbiBhIGRpYWxvZywgYW55IHNlc3Npb25cbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhhdCBkaWFsb2cgU0hPVUxEIHRlcm1pbmF0ZS4gIEEgVUEgTVVTVCBOT1Qgc2VuZCBhXG4gICAgICogQllFIG91dHNpZGUgb2YgYSBkaWFsb2cuICBUaGUgY2FsbGVyJ3MgVUEgTUFZIHNlbmQgYSBCWUUgZm9yIGVpdGhlclxuICAgICAqIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLCBhbmQgdGhlIGNhbGxlZSdzIFVBIE1BWSBzZW5kIGEgQllFIG9uXG4gICAgICogY29uZmlybWVkIGRpYWxvZ3MsIGJ1dCBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCB0aGUgY2FsbGVlJ3MgVUEgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2dcbiAgICAgKiB1bnRpbCBpdCBoYXMgcmVjZWl2ZWQgYW4gQUNLIGZvciBpdHMgMnh4IHJlc3BvbnNlIG9yIHVudGlsIHRoZSBzZXJ2ZXJcbiAgICAgKiB0cmFuc2FjdGlvbiB0aW1lcyBvdXQuICBJZiBubyBTSVAgZXh0ZW5zaW9ucyBoYXZlIGRlZmluZWQgb3RoZXJcbiAgICAgKiBhcHBsaWNhdGlvbiBsYXllciBzdGF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBkaWFsb2csIHRoZSBCWUUgYWxzb1xuICAgICAqIHRlcm1pbmF0ZXMgdGhlIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTVcbiAgICAgKiBGSVhNRTogTWFrZSB0aGVzZSBwcm9wZXIgRXhjZXB0aW9ucy4uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQllFIG9wdGlvbnMgYnVja2V0LlxuICAgICAqIEByZXR1cm5zXG4gICAgICogVGhyb3dzIGBFcnJvcmAgaWYgY2FsbGVlJ3MgVUEgYXR0ZW1wdHMgYSBCWUUgb24gYW4gZWFybHkgZGlhbG9nLlxuICAgICAqIFRocm93cyBgRXJyb3JgIGlmIGNhbGxlZSdzIFVBIGF0dGVtcHRzIGEgQllFIG9uIGEgY29uZmlybWVkIGRpYWxvZ1xuICAgICAqICAgICAgICAgICAgICAgIHdoaWxlIGl0J3Mgd2FpdGluZyBvbiB0aGUgQUNLIGZvciBpdHMgMnh4IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLmJ5ZSA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHNlbmRpbmcgQllFIHJlcXVlc3RcIik7XG4gICAgICAgIC8vIFRoZSBjYWxsZXIncyBVQSBNQVkgc2VuZCBhIEJZRSBmb3IgZWl0aGVyXG4gICAgICAgIC8vIGNvbmZpcm1lZCBvciBlYXJseSBkaWFsb2dzLCBhbmQgdGhlIGNhbGxlZSdzIFVBIE1BWSBzZW5kIGEgQllFIG9uXG4gICAgICAgIC8vIGNvbmZpcm1lZCBkaWFsb2dzLCBidXQgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBlYXJseSBkaWFsb2dzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCB0aGUgY2FsbGVlJ3MgVUEgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2dcbiAgICAgICAgLy8gdW50aWwgaXQgaGFzIHJlY2VpdmVkIGFuIEFDSyBmb3IgaXRzIDJ4eCByZXNwb25zZSBvciB1bnRpbCB0aGUgc2VydmVyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNVxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVBUyBNVVNUIE5PVCBzZW5kIGEgQllFIG9uIGVhcmx5IGRpYWxvZ3MuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuYWNrV2FpdCAmJiB0aGlzLmluaXRpYWxUcmFuc2FjdGlvbi5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVQVMgTVVTVCBOT1Qgc2VuZCBhIEJZRSBvbiBhIGNvbmZpcm1lZCBkaWFsb2cgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcInVudGlsIGl0IGhhcyByZWNlaXZlZCBhbiBBQ0sgZm9yIGl0cyAyeHggcmVzcG9uc2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIm9yIHVudGlsIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gdGltZXMgb3V0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBIEJZRSByZXF1ZXN0IGlzIGNvbnN0cnVjdGVkIGFzIHdvdWxkIGFueSBvdGhlciByZXF1ZXN0IHdpdGhpbiBhXG4gICAgICAgIC8vIGRpYWxvZywgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE9uY2UgdGhlIEJZRSBpcyBjb25zdHJ1Y3RlZCwgdGhlIFVBQyBjb3JlIGNyZWF0ZXMgYSBuZXcgbm9uLUlOVklURVxuICAgICAgICAvLyBjbGllbnQgdHJhbnNhY3Rpb24sIGFuZCBwYXNzZXMgaXQgdGhlIEJZRSByZXF1ZXN0LiAgVGhlIFVBQyBNVVNUXG4gICAgICAgIC8vIGNvbnNpZGVyIHRoZSBzZXNzaW9uIHRlcm1pbmF0ZWQgKGFuZCB0aGVyZWZvcmUgc3RvcCBzZW5kaW5nIG9yXG4gICAgICAgIC8vIGxpc3RlbmluZyBmb3IgbWVkaWEpIGFzIHNvb24gYXMgdGhlIEJZRSByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGVcbiAgICAgICAgLy8gY2xpZW50IHRyYW5zYWN0aW9uLiAgSWYgdGhlIHJlc3BvbnNlIGZvciB0aGUgQllFIGlzIGEgNDgxXG4gICAgICAgIC8vIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSBvciBhIDQwOCAoUmVxdWVzdCBUaW1lb3V0KSBvciBub1xuICAgICAgICAvLyByZXNwb25zZSBhdCBhbGwgaXMgcmVjZWl2ZWQgZm9yIHRoZSBCWUUgKHRoYXQgaXMsIGEgdGltZW91dCBpc1xuICAgICAgICAvLyByZXR1cm5lZCBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uKSwgdGhlIFVBQyBNVVNUIGNvbnNpZGVyIHRoZVxuICAgICAgICAvLyBzZXNzaW9uIGFuZCB0aGUgZGlhbG9nIHRlcm1pbmF0ZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTUuMS4xXG4gICAgICAgIHJldHVybiBuZXcgYnllX3VzZXJfYWdlbnRfY2xpZW50XzEuQnllVXNlckFnZW50Q2xpZW50KHRoaXMsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIElORk8gcmVxdWVzdCBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGFuIEluZm8gUGFja2FnZSAoc2VlXG4gICAgICogU2VjdGlvbiA1KSwgb3IgYXNzb2NpYXRlZCB3aXRoIGEgbGVnYWN5IElORk8gdXNhZ2UgKHNlZSBTZWN0aW9uIDIpLlxuICAgICAqXG4gICAgICogVGhlIGNvbnN0cnVjdGlvbiBvZiB0aGUgSU5GTyByZXF1ZXN0IGlzIHRoZSBzYW1lIGFzIGFueSBvdGhlclxuICAgICAqIG5vbi10YXJnZXQgcmVmcmVzaCByZXF1ZXN0IHdpdGhpbiBhbiBleGlzdGluZyBpbnZpdGUgZGlhbG9nIHVzYWdlIGFzXG4gICAgICogZGVzY3JpYmVkIGluIFNlY3Rpb24gMTIuMiBvZiBSRkMgMzI2MS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjA4NiNzZWN0aW9uLTQuMi4xXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBJTkZPIHJlcXVlc3RcIik7XG4gICAgICAgIGlmICh0aGlzLmVhcmx5KSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlhbG9nIG5vdCBjb25maXJtZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgaW5mb191c2VyX2FnZW50X2NsaWVudF8xLkluZm9Vc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW9kaWZ5aW5nIGFuIEV4aXN0aW5nIFNlc3Npb25cbiAgICAgKlxuICAgICAqIEEgc3VjY2Vzc2Z1bCBJTlZJVEUgcmVxdWVzdCAoc2VlIFNlY3Rpb24gMTMpIGVzdGFibGlzaGVzIGJvdGggYVxuICAgICAqIGRpYWxvZyBiZXR3ZWVuIHR3byB1c2VyIGFnZW50cyBhbmQgYSBzZXNzaW9uIHVzaW5nIHRoZSBvZmZlci1hbnN3ZXJcbiAgICAgKiBtb2RlbC4gIFNlY3Rpb24gMTIgZXhwbGFpbnMgaG93IHRvIG1vZGlmeSBhbiBleGlzdGluZyBkaWFsb2cgdXNpbmcgYVxuICAgICAqIHRhcmdldCByZWZyZXNoIHJlcXVlc3QgKGZvciBleGFtcGxlLCBjaGFuZ2luZyB0aGUgcmVtb3RlIHRhcmdldCBVUklcbiAgICAgKiBvZiB0aGUgZGlhbG9nKS4gIFRoaXMgc2VjdGlvbiBkZXNjcmliZXMgaG93IHRvIG1vZGlmeSB0aGUgYWN0dWFsXG4gICAgICogc2Vzc2lvbi4gIFRoaXMgbW9kaWZpY2F0aW9uIGNhbiBpbnZvbHZlIGNoYW5naW5nIGFkZHJlc3NlcyBvciBwb3J0cyxcbiAgICAgKiBhZGRpbmcgYSBtZWRpYSBzdHJlYW0sIGRlbGV0aW5nIGEgbWVkaWEgc3RyZWFtLCBhbmQgc28gb24uICBUaGlzIGlzXG4gICAgICogYWNjb21wbGlzaGVkIGJ5IHNlbmRpbmcgYSBuZXcgSU5WSVRFIHJlcXVlc3Qgd2l0aGluIHRoZSBzYW1lIGRpYWxvZ1xuICAgICAqIHRoYXQgZXN0YWJsaXNoZWQgdGhlIHNlc3Npb24uICBBbiBJTlZJVEUgcmVxdWVzdCBzZW50IHdpdGhpbiBhblxuICAgICAqIGV4aXN0aW5nIGRpYWxvZyBpcyBrbm93biBhcyBhIHJlLUlOVklURS5cbiAgICAgKlxuICAgICAqICAgIE5vdGUgdGhhdCBhIHNpbmdsZSByZS1JTlZJVEUgY2FuIG1vZGlmeSB0aGUgZGlhbG9nIGFuZCB0aGVcbiAgICAgKiAgICBwYXJhbWV0ZXJzIG9mIHRoZSBzZXNzaW9uIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICpcbiAgICAgKiBFaXRoZXIgdGhlIGNhbGxlciBvciBjYWxsZWUgY2FuIG1vZGlmeSBhbiBleGlzdGluZyBzZXNzaW9uLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0XG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBJTlZJVEUgcmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IGEgVUFDIE1VU1QgTk9UIGluaXRpYXRlIGEgbmV3IElOVklURSB0cmFuc2FjdGlvbiB3aXRoaW4gYVxuICAgICAgICAvLyBkaWFsb2cgd2hpbGUgYW5vdGhlciBJTlZJVEUgdHJhbnNhY3Rpb24gaXMgaW4gcHJvZ3Jlc3MgaW4gZWl0aGVyXG4gICAgICAgIC8vIGRpcmVjdGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgMS4gSWYgdGhlcmUgaXMgYW4gb25nb2luZyBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uLCB0aGUgVFUgTVVTVFxuICAgICAgICAvLyAgICAgICB3YWl0IHVudGlsIHRoZSB0cmFuc2FjdGlvbiByZWFjaGVzIHRoZSBjb21wbGV0ZWQgb3IgdGVybWluYXRlZFxuICAgICAgICAvLyAgICAgICBzdGF0ZSBiZWZvcmUgaW5pdGlhdGluZyB0aGUgbmV3IElOVklURS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgMi4gSWYgdGhlcmUgaXMgYW4gb25nb2luZyBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uLCB0aGUgVFUgTVVTVFxuICAgICAgICAvLyAgICAgICB3YWl0IHVudGlsIHRoZSB0cmFuc2FjdGlvbiByZWFjaGVzIHRoZSBjb25maXJtZWQgb3IgdGVybWluYXRlZFxuICAgICAgICAvLyAgICAgICBzdGF0ZSBiZWZvcmUgaW5pdGlhdGluZyB0aGUgbmV3IElOVklURS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgYSBVQSBNQVkgaW5pdGlhdGUgYSByZWd1bGFyIHRyYW5zYWN0aW9uIHdoaWxlIGFuIElOVklURVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBpbiBwcm9ncmVzcy4gIEEgVUEgTUFZIGFsc28gaW5pdGlhdGUgYW4gSU5WSVRFXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWxlIGEgcmVndWxhciB0cmFuc2FjdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4xXG4gICAgICAgIGlmICh0aGlzLnJlaW52aXRlVXNlckFnZW50Q2xpZW50KSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogVGhpcyBzaG91bGQgdGhyb3cgYSBwcm9wZXIgZXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYW4gb25nb2luZyByZS1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlcikge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIGFuIG9uZ29pbmcgcmUtSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyByZV9pbnZpdGVfdXNlcl9hZ2VudF9jbGllbnRfMS5SZUludml0ZVVzZXJBZ2VudENsaWVudCh0aGlzLCBkZWxlZ2F0ZSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIFVBQyBNQVkgYXNzb2NpYXRlIGEgTUVTU0FHRSByZXF1ZXN0IHdpdGggYW4gZXhpc3RpbmcgZGlhbG9nLiAgSWYgYVxuICAgICAqIE1FU1NBR0UgcmVxdWVzdCBpcyBzZW50IHdpdGhpbiBhIGRpYWxvZywgaXQgaXMgXCJhc3NvY2lhdGVkXCIgd2l0aCBhbnlcbiAgICAgKiBtZWRpYSBzZXNzaW9uIG9yIHNlc3Npb25zIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGRpYWxvZy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQyOCNzZWN0aW9uLTRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAoZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIE1FU1NBR0UgcmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLk1FU1NBR0UsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IG1lc3NhZ2VfdXNlcl9hZ2VudF9jbGllbnRfMS5NZXNzYWdlVXNlckFnZW50Q2xpZW50KHRoaXMuY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIE5PVElGWSBtZWNoYW5pc20gZGVmaW5lZCBpbiBbMl0gTVVTVCBiZSB1c2VkIHRvIGluZm9ybSB0aGUgYWdlbnRcbiAgICAgKiBzZW5kaW5nIHRoZSBSRUZFUiBvZiB0aGUgc3RhdHVzIG9mIHRoZSByZWZlcmVuY2UuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MTUjc2VjdGlvbi0yLjQuNFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBOT1RJRlkgcmVxdWVzdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuZWFybHkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCB0aHJvdyBhIHByb3BlciBleGNlcHRpb24uXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsb2cgbm90IGNvbmZpcm1lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBub3RpZnlfdXNlcl9hZ2VudF9jbGllbnRfMS5Ob3RpZnlVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXNzdW1pbmcgdGhlIHJlc3BvbnNlIGlzIHRvIGJlIHRyYW5zbWl0dGVkIHJlbGlhYmx5LCB0aGUgVUFDIE1VU1RcbiAgICAgKiBjcmVhdGUgYSBuZXcgcmVxdWVzdCB3aXRoIG1ldGhvZCBQUkFDSy4gIFRoaXMgcmVxdWVzdCBpcyBzZW50IHdpdGhpblxuICAgICAqIHRoZSBkaWFsb2cgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSAoaW5kZWVkLCB0aGVcbiAgICAgKiBwcm92aXNpb25hbCByZXNwb25zZSBtYXkgaGF2ZSBjcmVhdGVkIHRoZSBkaWFsb2cpLiAgUFJBQ0sgcmVxdWVzdHNcbiAgICAgKiBNQVkgY29udGFpbiBib2RpZXMsIHdoaWNoIGFyZSBpbnRlcnByZXRlZCBhY2NvcmRpbmcgdG8gdGhlaXIgdHlwZSBhbmRcbiAgICAgKiBkaXNwb3NpdGlvbi5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnByYWNrID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBQUkFDSyByZXF1ZXN0XCIpO1xuICAgICAgICByZXR1cm4gbmV3IHByYWNrX3VzZXJfYWdlbnRfY2xpZW50XzEuUHJhY2tVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUkVGRVIgaXMgYSBTSVAgcmVxdWVzdCBhbmQgaXMgY29uc3RydWN0ZWQgYXMgZGVmaW5lZCBpbiBbMV0uICBBIFJFRkVSXG4gICAgICogcmVxdWVzdCBNVVNUIGNvbnRhaW4gZXhhY3RseSBvbmUgUmVmZXItVG8gaGVhZGVyIGZpZWxkIHZhbHVlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjFcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnJlZmVyID0gZnVuY3Rpb24gKGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgc2VuZGluZyBSRUZFUiByZXF1ZXN0XCIpO1xuICAgICAgICBpZiAodGhpcy5lYXJseSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoaXMgc2hvdWxkIHRocm93IGEgcHJvcGVyIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBub3QgY29uZmlybWVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGSVhNRTogVE9ETzogVmFsaWRhdGUgUmVmZXItVG8gaGVhZGVyIGZpZWxkIHZhbHVlLlxuICAgICAgICByZXR1cm4gbmV3IHJlZmVyX3VzZXJfYWdlbnRfY2xpZW50XzEuUmVmZXJVc2VyQWdlbnRDbGllbnQodGhpcywgZGVsZWdhdGUsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgc2VudCB3aXRoaW4gYSBkaWFsb2csIGFzIGFueSBvdGhlciByZXF1ZXN0cywgYXJlIGF0b21pYy4gIElmXG4gICAgICogYSBwYXJ0aWN1bGFyIHJlcXVlc3QgaXMgYWNjZXB0ZWQgYnkgdGhlIFVBUywgYWxsIHRoZSBzdGF0ZSBjaGFuZ2VzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIGl0IGFyZSBwZXJmb3JtZWQuICBJZiB0aGUgcmVxdWVzdCBpcyByZWplY3RlZCwgbm9uZVxuICAgICAqIG9mIHRoZSBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZSB3aXRoaW4gdGhpcyBkaWFsb2cuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0XCIpO1xuICAgICAgICAvLyBSZXNwb25zZSByZXRyYW5zbWlzc2lvbnMgY2Vhc2Ugd2hlbiBhbiBBQ0sgcmVxdWVzdCBmb3IgdGhlXG4gICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLiAgVGhpcyBpcyBpbmRlcGVuZGVudCBvZiB3aGF0ZXZlciB0cmFuc3BvcnRcbiAgICAgICAgLy8gcHJvdG9jb2xzIGFyZSB1c2VkIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5BQ0spIHtcbiAgICAgICAgICAgIC8vIElmIGFja1dhaXQgaXMgdHJ1ZSwgdGhlbiB0aGlzIGlzIHRoZSBBQ0sgdG8gdGhlIGluaXRpYWwgSU5WSVRFLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgaXMgYW4gQUNLIHRvIGFuIGluIGRpYWxvZyBJTlZJVEUuIEluIGVpdGhlciBjYXNlLFxuICAgICAgICAgICAgLy8gZ3VhcmQgdG8gbWFrZSBzdXJlIHRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIEFDSyBtYXRjaGVzIHRoZSBJTlZJVEUuXG4gICAgICAgICAgICBpZiAodGhpcy5hY2tXYWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgcmVxdWVzdCwgZHJvcHBpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxUcmFuc2FjdGlvbi5yZXF1ZXN0LmNzZXEgIT09IG1lc3NhZ2UuY3NlcSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWNlaXZlZCB1bmV4cGVjdGVkIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0LCBkcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGJlZm9yZSB0aGUgZGVsZWdhdGUgaGFzIGEgY2hhbmNlIHRvIGhhbmRsZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGFzIGRlbGVnYXRlIG1heSBjYWxsYmFjayBpbnRvIHRoaXMgZGlhbG9nLlxuICAgICAgICAgICAgICAgIHRoaXMuYWNrV2FpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlci50cmFuc2FjdGlvbi5yZXF1ZXN0LmNzZXEgIT09IG1lc3NhZ2UuY3NlcSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiSU5WSVRFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWNlaXZlZCB1bmV4cGVjdGVkIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0LCBkcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25BY2soeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIG91dCBvZiBzZXF1ZW5jZSBndWFyZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgaWYgKCF0aGlzLnNlcXVlbmNlR3VhcmQobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIklOVklURSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVqZWN0ZWQgb3V0IG9mIG9yZGVyIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUpIHtcbiAgICAgICAgICAgIC8vIEEgVUFTIHRoYXQgcmVjZWl2ZXMgYSBzZWNvbmQgSU5WSVRFIGJlZm9yZSBpdCBzZW5kcyB0aGUgZmluYWxcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIHRvIGEgZmlyc3QgSU5WSVRFIHdpdGggYSBsb3dlciBDU2VxIHNlcXVlbmNlIG51bWJlciBvbiB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgZGlhbG9nIE1VU1QgcmV0dXJuIGEgNTAwIChTZXJ2ZXIgSW50ZXJuYWwgRXJyb3IpIHJlc3BvbnNlIHRvIHRoZVxuICAgICAgICAgICAgLy8gc2Vjb25kIElOVklURSBhbmQgTVVTVCBpbmNsdWRlIGEgUmV0cnktQWZ0ZXIgaGVhZGVyIGZpZWxkIHdpdGggYVxuICAgICAgICAgICAgLy8gcmFuZG9tbHkgY2hvc2VuIHZhbHVlIG9mIGJldHdlZW4gMCBhbmQgMTAgc2Vjb25kcy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMlxuICAgICAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTIwLjMzXG4gICAgICAgICAgICAgICAgdmFyIHJldHJ5QWZ0ZXIgPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMTApKSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVycyA9IFtcIlJldHJ5LUFmdGVyOiBcIiArIHJldHJ5QWZ0ZXJdO1xuICAgICAgICAgICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDUwMCwgZXh0cmFIZWFkZXJzOiBleHRyYUhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBVQVMgdGhhdCByZWNlaXZlcyBhbiBJTlZJVEUgb24gYSBkaWFsb2cgd2hpbGUgYW4gSU5WSVRFIGl0IGhhZCBzZW50XG4gICAgICAgICAgICAvLyBvbiB0aGF0IGRpYWxvZyBpcyBpbiBwcm9ncmVzcyBNVVNUIHJldHVybiBhIDQ5MSAoUmVxdWVzdCBQZW5kaW5nKVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UgdG8gdGhlIHJlY2VpdmVkIElOVklURS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTQuMlxuICAgICAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0OTEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIGNvbW1vbiBwcm9jZXNzaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIFJlcXVlc3RzIHdpdGhpbiBhIGRpYWxvZyBNQVkgY29udGFpbiBSZWNvcmQtUm91dGUgYW5kIENvbnRhY3QgaGVhZGVyXG4gICAgICAgIC8vIGZpZWxkcy4gIEhvd2V2ZXIsIHRoZXNlIHJlcXVlc3RzIGRvIG5vdCBjYXVzZSB0aGUgZGlhbG9nJ3Mgcm91dGUgc2V0XG4gICAgICAgIC8vIHRvIGJlIG1vZGlmaWVkLCBhbHRob3VnaCB0aGV5IG1heSBtb2RpZnkgdGhlIHJlbW90ZSB0YXJnZXQgVVJJLlxuICAgICAgICAvLyBTcGVjaWZpY2FsbHksIHJlcXVlc3RzIHRoYXQgYXJlIG5vdCB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0cyBkbyBub3RcbiAgICAgICAgLy8gbW9kaWZ5IHRoZSBkaWFsb2cncyByZW1vdGUgdGFyZ2V0IFVSSSwgYW5kIHJlcXVlc3RzIHRoYXQgYXJlIHRhcmdldFxuICAgICAgICAvLyByZWZyZXNoIHJlcXVlc3RzIGRvLiAgRm9yIGRpYWxvZ3MgdGhhdCBoYXZlIGJlZW4gZXN0YWJsaXNoZWQgd2l0aCBhblxuICAgICAgICAvLyBJTlZJVEUsIHRoZSBvbmx5IHRhcmdldCByZWZyZXNoIHJlcXVlc3QgZGVmaW5lZCBpcyByZS1JTlZJVEUgKHNlZVxuICAgICAgICAvLyBTZWN0aW9uIDE0KS4gIE90aGVyIGV4dGVuc2lvbnMgbWF5IGRlZmluZSBkaWZmZXJlbnQgdGFyZ2V0IHJlZnJlc2hcbiAgICAgICAgLy8gcmVxdWVzdHMgZm9yIGRpYWxvZ3MgZXN0YWJsaXNoZWQgaW4gb3RoZXIgd2F5cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgTm90ZSB0aGF0IGFuIEFDSyBpcyBOT1QgYSB0YXJnZXQgcmVmcmVzaCByZXF1ZXN0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBUYXJnZXQgcmVmcmVzaCByZXF1ZXN0cyBvbmx5IHVwZGF0ZSB0aGUgZGlhbG9nJ3MgcmVtb3RlIHRhcmdldCBVUkksXG4gICAgICAgIC8vIGFuZCBub3QgdGhlIHJvdXRlIHNldCBmb3JtZWQgZnJvbSB0aGUgUmVjb3JkLVJvdXRlLiAgVXBkYXRpbmcgdGhlXG4gICAgICAgIC8vIGxhdHRlciB3b3VsZCBpbnRyb2R1Y2Ugc2V2ZXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByb2JsZW1zIHdpdGhcbiAgICAgICAgLy8gUkZDIDI1NDMtY29tcGxpYW50IHN5c3RlbXMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTVcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuSU5WSVRFKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogcGFyc2VyIG5lZWRzIHRvIGJlIHR5cGVkLi4uXG4gICAgICAgICAgICB2YXIgY29udGFjdCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjb250YWN0XCIpO1xuICAgICAgICAgICAgaWYgKCFjb250YWN0KSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3QgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGNvbnRhY3QgaW5zdGFuY2VvZiBtZXNzYWdlc18xLk5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRhY3Qgbm90IGluc3RhbmNlIG9mIE5hbWVBZGRySGVhZGVyLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlhbG9nU3RhdGUucmVtb3RlVGFyZ2V0ID0gY29udGFjdC51cmk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dpdGNoIG9uIG1ldGhvZCBhbmQgdGhlbiBkZWxlZ2F0ZS5cbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuQllFOlxuICAgICAgICAgICAgICAgIC8vIEEgVUFTIGNvcmUgcmVjZWl2aW5nIGEgQllFIHJlcXVlc3QgZm9yIGFuIGV4aXN0aW5nIGRpYWxvZyBNVVNUIGZvbGxvd1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMi4yIHRvIHByb2Nlc3MgdGhlIHJlcXVlc3QuICBPbmNlIGRvbmUsXG4gICAgICAgICAgICAgICAgLy8gdGhlIFVBUyBTSE9VTEQgdGVybWluYXRlIHRoZSBzZXNzaW9uIChhbmQgdGhlcmVmb3JlIHN0b3Agc2VuZGluZyBhbmRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgZm9yIG1lZGlhKS4gIFRoZSBvbmx5IGNhc2Ugd2hlcmUgaXQgY2FuIGVsZWN0IG5vdCB0byBhcmVcbiAgICAgICAgICAgICAgICAvLyBtdWx0aWNhc3Qgc2Vzc2lvbnMsIHdoZXJlIHBhcnRpY2lwYXRpb24gaXMgcG9zc2libGUgZXZlbiBpZiB0aGUgb3RoZXJcbiAgICAgICAgICAgICAgICAvLyBwYXJ0aWNpcGFudCBpbiB0aGUgZGlhbG9nIGhhcyB0ZXJtaW5hdGVkIGl0cyBpbnZvbHZlbWVudCBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZXNzaW9uLiAgV2hldGhlciBvciBub3QgaXQgZW5kcyBpdHMgcGFydGljaXBhdGlvbiBvbiB0aGUgc2Vzc2lvbixcbiAgICAgICAgICAgICAgICAvLyB0aGUgVUFTIGNvcmUgTVVTVCBnZW5lcmF0ZSBhIDJ4eCByZXNwb25zZSB0byB0aGUgQllFLCBhbmQgTVVTVCBwYXNzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUaGUgVUFTIE1VU1Qgc3RpbGwgcmVzcG9uZCB0byBhbnkgcGVuZGluZyByZXF1ZXN0cyByZWNlaXZlZCBmb3IgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGRpYWxvZy4gIEl0IGlzIFJFQ09NTUVOREVEIHRoYXQgYSA0ODcgKFJlcXVlc3QgVGVybWluYXRlZCkgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBiZSBnZW5lcmF0ZWQgdG8gdGhvc2UgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE1LjEuMlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyBieWVfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5CeWVVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkJ5ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQnllKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5JTkZPOlxuICAgICAgICAgICAgICAgIC8vIElmIGEgVUEgcmVjZWl2ZXMgYW4gSU5GTyByZXF1ZXN0IGFzc29jaWF0ZWQgd2l0aCBhbiBJbmZvIFBhY2thZ2UgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBVQSBoYXMgbm90IGluZGljYXRlZCB3aWxsaW5nbmVzcyB0byByZWNlaXZlLCB0aGUgVUEgTVVTVCBzZW5kIGFcbiAgICAgICAgICAgICAgICAvLyA0NjkgKEJhZCBJbmZvIFBhY2thZ2UpIHJlc3BvbnNlIChzZWUgU2VjdGlvbiAxMS42KSwgd2hpY2ggY29udGFpbnMgYVxuICAgICAgICAgICAgICAgIC8vIFJlY3YtSW5mbyBoZWFkZXIgZmllbGQgd2l0aCBJbmZvIFBhY2thZ2VzIGZvciB3aGljaCB0aGUgVUEgaXMgd2lsbGluZ1xuICAgICAgICAgICAgICAgIC8vIHRvIHJlY2VpdmUgSU5GTyByZXF1ZXN0cy5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgaW5mb191c2VyX2FnZW50X3NlcnZlcl8xLkluZm9Vc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkluZm8gP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkluZm8odWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0NjksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbXCJSZWN2LUluZm8gOlwiXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuSU5WSVRFOlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBuZXcgc2Vzc2lvbiBkZXNjcmlwdGlvbiBpcyBub3QgYWNjZXB0YWJsZSwgdGhlIFVBUyBjYW4gcmVqZWN0XG4gICAgICAgICAgICAgICAgLy8gaXQgYnkgcmV0dXJuaW5nIGEgNDg4IChOb3QgQWNjZXB0YWJsZSBIZXJlKSByZXNwb25zZSBmb3IgdGhlIHJlLVxuICAgICAgICAgICAgICAgIC8vIElOVklURS4gIFRoaXMgcmVzcG9uc2UgU0hPVUxEIGluY2x1ZGUgYSBXYXJuaW5nIGhlYWRlciBmaWVsZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0LjJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgcmVfaW52aXRlX3VzZXJfYWdlbnRfc2VydmVyXzEuUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25JbnZpdGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODggfSk7IC8vIFRPRE86IFdhcm5pbmcgaGVhZGVyIGZpZWxkLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLk1FU1NBR0U6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IG1lc3NhZ2VfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5NZXNzYWdlVXNlckFnZW50U2VydmVyKHRoaXMuY29yZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk1lc3NhZ2UgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk1lc3NhZ2UodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuTk9USUZZOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjRcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgbm90aWZ5X3VzZXJfYWdlbnRfc2VydmVyXzEuTm90aWZ5VXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5QUkFDSzpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgcHJhY2tfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5QcmFja1VzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUHJhY2sgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblByYWNrKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLlJFRkVSOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgcmVmZXJfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5SZWZlclVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVmZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coXCJJTlZJVEUgZGlhbG9nIFwiICsgdGhpcy5pZCArIFwiIHJlY2VpdmVkIHVuaW1wbGVtZW50ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDUwMSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNlc3Npb25EaWFsb2cucHJvdG90eXBlLnJlbGlhYmxlU2VxdWVuY2VHdWFyZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXR1cyBjb2RlIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA+IDEwMCAmJiBzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGlzIHJlY2VpdmVkIGZvciBhbiBpbml0aWFsIHJlcXVlc3QsIGFuZFxuICAgICAgICAgICAgLy8gdGhhdCByZXNwb25zZSBjb250YWlucyBhIFJlcXVpcmUgaGVhZGVyIGZpZWxkIGNvbnRhaW5pbmcgdGhlIG9wdGlvblxuICAgICAgICAgICAgLy8gdGFnIDEwMHJlbCwgdGhlIHJlc3BvbnNlIGlzIHRvIGJlIHNlbnQgcmVsaWFibHkuICBJZiB0aGUgcmVzcG9uc2UgaXNcbiAgICAgICAgICAgIC8vIGEgMTAwIChUcnlpbmcpIChhcyBvcHBvc2VkIHRvIDEwMSB0byAxOTkpLCB0aGlzIG9wdGlvbiB0YWcgTVVTVCBiZVxuICAgICAgICAgICAgLy8gaWdub3JlZCwgYW5kIHRoZSBwcm9jZWR1cmVzIGJlbG93IE1VU1QgTk9UIGJlIHVzZWQuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgICAgIHZhciByZXF1aXJlSGVhZGVyID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJyZXF1aXJlXCIpO1xuICAgICAgICAgICAgdmFyIHJzZXFIZWFkZXIgPSBtZXNzYWdlLmdldEhlYWRlcihcInJzZXFcIik7XG4gICAgICAgICAgICB2YXIgcnNlcSA9IHJlcXVpcmVIZWFkZXIgJiYgcmVxdWlyZUhlYWRlci5pbmNsdWRlcyhcIjEwMHJlbFwiKSAmJiByc2VxSGVhZGVyID8gTnVtYmVyKHJzZXFIZWFkZXIpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHJzZXEpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBvZiBzdWJzZXF1ZW50IHJlbGlhYmxlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBmb3IgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHJlcXVlc3QgZm9sbG93cyB0aGUgc2FtZSBydWxlcyBhcyBhYm92ZSwgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZTogcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIGFyZSBndWFyYW50ZWVkIHRvIGJlIGluXG4gICAgICAgICAgICAgICAgLy8gb3JkZXIuICBBcyBhIHJlc3VsdCwgaWYgdGhlIFVBQyByZWNlaXZlcyBhbm90aGVyIHJlbGlhYmxlIHByb3Zpc2lvbmFsXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgdG8gdGhlIHNhbWUgcmVxdWVzdCwgYW5kIGl0cyBSU2VxIHZhbHVlIGlzIG5vdCBvbmUgaGlnaGVyXG4gICAgICAgICAgICAgICAgLy8gdGhhbiB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlIG51bWJlciwgdGhhdCByZXNwb25zZSBNVVNUIE5PVCBiZVxuICAgICAgICAgICAgICAgIC8vIGFja25vd2xlZGdlZCB3aXRoIGEgUFJBQ0ssIGFuZCBNVVNUIE5PVCBiZSBwcm9jZXNzZWQgZnVydGhlciBieSB0aGVcbiAgICAgICAgICAgICAgICAvLyBVQUMuICBBbiBpbXBsZW1lbnRhdGlvbiBNQVkgZGlzY2FyZCB0aGUgcmVzcG9uc2UsIG9yIE1BWSBjYWNoZSB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSBpbiB0aGUgaG9wZXMgb2YgcmVjZWl2aW5nIHRoZSBtaXNzaW5nIHJlc3BvbnNlcy5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yc2VxICYmIHRoaXMucnNlcSArIDEgIT09IHJzZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPbmNlIGEgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgcmVjZWl2ZWQsIHJldHJhbnNtaXNzaW9ucyBvZlxuICAgICAgICAgICAgICAgIC8vIHRoYXQgcmVzcG9uc2UgTVVTVCBiZSBkaXNjYXJkZWQuICBBIHJlc3BvbnNlIGlzIGEgcmV0cmFuc21pc3Npb24gd2hlblxuICAgICAgICAgICAgICAgIC8vIGl0cyBkaWFsb2cgSUQsIENTZXEsIGFuZCBSU2VxIG1hdGNoIHRoZSBvcmlnaW5hbCByZXNwb25zZS4gIFRoZSBVQUNcbiAgICAgICAgICAgICAgICAvLyBNVVNUIG1haW50YWluIGEgc2VxdWVuY2UgbnVtYmVyIHRoYXQgaW5kaWNhdGVzIHRoZSBtb3N0IHJlY2VudGx5XG4gICAgICAgICAgICAgICAgLy8gcmVjZWl2ZWQgaW4tb3JkZXIgcmVsaWFibGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgZm9yIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdC4gIFRoaXMgc2VxdWVuY2UgbnVtYmVyIE1VU1QgYmUgbWFpbnRhaW5lZCB1bnRpbCBhIGZpbmFsXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQgZm9yIHRoZSBpbml0aWFsIHJlcXVlc3QuICBJdHMgdmFsdWUgTVVTVCBiZVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemVkIHRvIHRoZSBSU2VxIGhlYWRlciBmaWVsZCBpbiB0aGUgZmlyc3QgcmVsaWFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm92aXNpb25hbCByZXNwb25zZSByZWNlaXZlZCBmb3IgdGhlIGluaXRpYWwgcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MiNzZWN0aW9uLTRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucnNlcSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJzZXEgPSByc2VxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIG5vdCBpbiBhIHN0YWJsZSBzaWduYWxpbmcgc3RhdGUsIHJvbGxiYWNrIHRvIHByaW9yIHN0YWJsZSBzaWduYWxpbmcgc3RhdGUuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuc2lnbmFsaW5nU3RhdGVSb2xsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXIgfHxcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlUmVtb3RlT2ZmZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb2xsYmFja09mZmVyICYmIHRoaXMuX3JvbGxiYWNrQW5zd2VyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlO1xuICAgICAgICAgICAgICAgIHRoaXMuX29mZmVyID0gdGhpcy5fcm9sbGJhY2tPZmZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB0aGlzLl9yb2xsYmFja0Fuc3dlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzaWduYWxpbmcgc3RhdGUgb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGJhc2UgdGhlIHVwZGF0ZSBvZmYgb2YuXG4gICAgICovXG4gICAgU2Vzc2lvbkRpYWxvZy5wcm90b3R5cGUuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBtZXNzYWdlc18xLmdldEJvZHkobWVzc2FnZSk7XG4gICAgICAgIC8vIE5vIGJvZHksIG5vIHNlc3Npb24uIE5vLCB3b21hbiwgbm8gY3J5LlxuICAgICAgICBpZiAoIWJvZHkgfHwgYm9keS5jb250ZW50RGlzcG9zaXRpb24gIT09IFwic2Vzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UndmUgZ290IGFuIGV4aXN0aW5nIG9mZmVyIGFuZCBhbnN3ZXIgd2hpY2ggd2UgbWF5IHdpc2ggdG8gcm9sbGJhY2sgdG9cbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb2xsYmFja09mZmVyID0gdGhpcy5fb2ZmZXI7XG4gICAgICAgICAgICB0aGlzLl9yb2xsYmFja0Fuc3dlciA9IHRoaXMuX2Fuc3dlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBpbiBVQVMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlcXVlc3Qgd2l0aCBzZXNzaW9uIGRlc2NyaXB0aW9uXG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgbWVzc2FnZXNfMS5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3NpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmZXIgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgdG8gZG8gaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgaW4gVUFDIHJvbGUsIHJlY2VpdmluZyBpbmNvbWluZyByZXNwb25zZSB3aXRoIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBtZXNzYWdlc18xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3NpZ25hbGluZ1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbDpcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpZ25hbGluZ1N0YXRlID0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2ZmZXIgPSBib2R5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVMb2NhbE9mZmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkhhdmVSZW1vdGVPZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgdG8gZG8gaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuQ2xvc2VkOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHNpZ25hbGluZyBzdGF0ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgaW4gVUFDIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVxdWVzdCB3aXRoIHNlc3Npb24gZGVzY3JpcHRpb25cbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBtZXNzYWdlc18xLk91dGdvaW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZmVyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgdG8gZG8gaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzaWduYWxpbmcgc3RhdGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGluIFVBUyByb2xlLCBzZW5kaW5nIG91dGdvaW5nIHJlc3BvbnNlIHdpdGggc2Vzc2lvbiBkZXNjcmlwdGlvblxuICAgICAgICBpZiAobWVzc2FnZXNfMS5pc0JvZHkobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5Jbml0aWFsOlxuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLlN0YWJsZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lnbmFsaW5nU3RhdGUgPSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZmVyID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5zd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5IYXZlTG9jYWxPZmZlcjpcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBtYWtlIGEgbmV3IG9mZmVyIHdoaWxlIG9uZSBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFdoYXQgdG8gZG8gaGVyZT9cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zaWduYWxpbmdTdGF0ZSA9IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fuc3dlciA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkNsb3NlZDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzaWduYWxpbmcgc3RhdGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5zdGFydDJ4eFJldHJhbnNtaXNzaW9uVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxUcmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25fMSA9IHRoaXMuaW5pdGlhbFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgLy8gT25jZSB0aGUgcmVzcG9uc2UgaGFzIGJlZW4gY29uc3RydWN0ZWQsIGl0IGlzIHBhc3NlZCB0byB0aGUgSU5WSVRFXG4gICAgICAgICAgICAvLyBzZXJ2ZXIgdHJhbnNhY3Rpb24uICBJbiBvcmRlciB0byBlbnN1cmUgcmVsaWFibGUgZW5kLXRvLWVuZFxuICAgICAgICAgICAgLy8gdHJhbnNwb3J0IG9mIHRoZSByZXNwb25zZSwgaXQgaXMgbmVjZXNzYXJ5IHRvIHBlcmlvZGljYWxseSBwYXNzXG4gICAgICAgICAgICAvLyB0aGUgcmVzcG9uc2UgZGlyZWN0bHkgdG8gdGhlIHRyYW5zcG9ydCB1bnRpbCB0aGUgQUNLIGFycml2ZXMuICBUaGVcbiAgICAgICAgICAgIC8vIDJ4eCByZXNwb25zZSBpcyBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCB3aXRoIGFuIGludGVydmFsIHRoYXRcbiAgICAgICAgICAgIC8vIHN0YXJ0cyBhdCBUMSBzZWNvbmRzIGFuZCBkb3VibGVzIGZvciBlYWNoIHJldHJhbnNtaXNzaW9uIHVudGlsIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIFQyIHNlY29uZHMgKFQxIGFuZCBUMiBhcmUgZGVmaW5lZCBpbiBTZWN0aW9uIDE3KS5cbiAgICAgICAgICAgIC8vIFJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyBjZWFzZSB3aGVuIGFuIEFDSyByZXF1ZXN0IGZvciB0aGVcbiAgICAgICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLiAgVGhpcyBpcyBpbmRlcGVuZGVudCBvZiB3aGF0ZXZlciB0cmFuc3BvcnRcbiAgICAgICAgICAgIC8vIHByb3RvY29scyBhcmUgdXNlZCB0byBzZW5kIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC4xXG4gICAgICAgICAgICB2YXIgdGltZW91dF8xID0gdGltZXJzXzEuVGltZXJzLlQxO1xuICAgICAgICAgICAgdmFyIHJldHJhbnNtaXNzaW9uXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5hY2tXYWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJObyBBQ0sgZm9yIDJ4eCByZXNwb25zZSByZWNlaXZlZCwgYXR0ZW1wdGluZyByZXRyYW5zbWlzc2lvblwiKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl8xLnJldHJhbnNtaXRBY2NlcHRlZFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgdGltZW91dF8xID0gTWF0aC5taW4odGltZW91dF8xICogMiwgdGltZXJzXzEuVGltZXJzLlQyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnZpdGUyeHhUaW1lciA9IHNldFRpbWVvdXQocmV0cmFuc21pc3Npb25fMSwgdGltZW91dF8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbl8xLCB0aW1lb3V0XzEpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciByZXRyYW5zbWl0cyB0aGUgMnh4IHJlc3BvbnNlIGZvciA2NCpUMSBzZWNvbmRzIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIHJlY2VpdmluZyBhbiBBQ0ssIHRoZSBkaWFsb2cgaXMgY29uZmlybWVkLCBidXQgdGhlIHNlc3Npb24gU0hPVUxEIGJlXG4gICAgICAgICAgICAvLyB0ZXJtaW5hdGVkLiAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgd2l0aCBhIEJZRSwgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTUuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgICAgICB2YXIgc3RhdGVDaGFuZ2VkXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uXzEuc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl8xLnJlbW92ZUxpc3RlbmVyKFwic3RhdGVDaGFuZ2VkXCIsIHN0YXRlQ2hhbmdlZF8xKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmludml0ZTJ4eFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52aXRlMnh4VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmFja1dhaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZWxlZ2F0ZSAmJiBfdGhpcy5kZWxlZ2F0ZS5vbkFja1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxlZ2F0ZS5vbkFja1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmJ5ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uXzEuYWRkTGlzdGVuZXIoXCJzdGF0ZUNoYW5nZWRcIiwgc3RhdGVDaGFuZ2VkXzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBGSVhNRTogUmVmYWN0b3JcbiAgICBTZXNzaW9uRGlhbG9nLnByb3RvdHlwZS5zdGFydFJlSW52aXRlMnh4UmV0cmFuc21pc3Npb25UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgJiYgdGhpcy5yZWludml0ZVVzZXJBZ2VudFNlcnZlci50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25fMiA9IHRoaXMucmVpbnZpdGVVc2VyQWdlbnRTZXJ2ZXIudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSByZXNwb25zZSBoYXMgYmVlbiBjb25zdHJ1Y3RlZCwgaXQgaXMgcGFzc2VkIHRvIHRoZSBJTlZJVEVcbiAgICAgICAgICAgIC8vIHNlcnZlciB0cmFuc2FjdGlvbi4gIEluIG9yZGVyIHRvIGVuc3VyZSByZWxpYWJsZSBlbmQtdG8tZW5kXG4gICAgICAgICAgICAvLyB0cmFuc3BvcnQgb2YgdGhlIHJlc3BvbnNlLCBpdCBpcyBuZWNlc3NhcnkgdG8gcGVyaW9kaWNhbGx5IHBhc3NcbiAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBkaXJlY3RseSB0byB0aGUgdHJhbnNwb3J0IHVudGlsIHRoZSBBQ0sgYXJyaXZlcy4gIFRoZVxuICAgICAgICAgICAgLy8gMnh4IHJlc3BvbnNlIGlzIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IHdpdGggYW4gaW50ZXJ2YWwgdGhhdFxuICAgICAgICAgICAgLy8gc3RhcnRzIGF0IFQxIHNlY29uZHMgYW5kIGRvdWJsZXMgZm9yIGVhY2ggcmV0cmFuc21pc3Npb24gdW50aWwgaXRcbiAgICAgICAgICAgIC8vIHJlYWNoZXMgVDIgc2Vjb25kcyAoVDEgYW5kIFQyIGFyZSBkZWZpbmVkIGluIFNlY3Rpb24gMTcpLlxuICAgICAgICAgICAgLy8gUmVzcG9uc2UgcmV0cmFuc21pc3Npb25zIGNlYXNlIHdoZW4gYW4gQUNLIHJlcXVlc3QgZm9yIHRoZVxuICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgcmVjZWl2ZWQuICBUaGlzIGlzIGluZGVwZW5kZW50IG9mIHdoYXRldmVyIHRyYW5zcG9ydFxuICAgICAgICAgICAgLy8gcHJvdG9jb2xzIGFyZSB1c2VkIHRvIHNlbmQgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjFcbiAgICAgICAgICAgIHZhciB0aW1lb3V0XzIgPSB0aW1lcnNfMS5UaW1lcnMuVDE7XG4gICAgICAgICAgICB2YXIgcmV0cmFuc21pc3Npb25fMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmludml0ZTJ4eFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5sb2coXCJObyBBQ0sgZm9yIDJ4eCByZXNwb25zZSByZWNlaXZlZCwgYXR0ZW1wdGluZyByZXRyYW5zbWlzc2lvblwiKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl8yLnJldHJhbnNtaXRBY2NlcHRlZFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgdGltZW91dF8yID0gTWF0aC5taW4odGltZW91dF8yICogMiwgdGltZXJzXzEuVGltZXJzLlQyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnZpdGUyeHhUaW1lciA9IHNldFRpbWVvdXQocmV0cmFuc21pc3Npb25fMiwgdGltZW91dF8yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmludml0ZTJ4eFRpbWVyID0gc2V0VGltZW91dChyZXRyYW5zbWlzc2lvbl8yLCB0aW1lb3V0XzIpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciByZXRyYW5zbWl0cyB0aGUgMnh4IHJlc3BvbnNlIGZvciA2NCpUMSBzZWNvbmRzIHdpdGhvdXRcbiAgICAgICAgICAgIC8vIHJlY2VpdmluZyBhbiBBQ0ssIHRoZSBkaWFsb2cgaXMgY29uZmlybWVkLCBidXQgdGhlIHNlc3Npb24gU0hPVUxEIGJlXG4gICAgICAgICAgICAvLyB0ZXJtaW5hdGVkLiAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgd2l0aCBhIEJZRSwgYXMgZGVzY3JpYmVkIGluIFNlY3Rpb24gMTUuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgICAgICB2YXIgc3RhdGVDaGFuZ2VkXzIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uXzIuc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbl8yLnJlbW92ZUxpc3RlbmVyKFwic3RhdGVDaGFuZ2VkXCIsIHN0YXRlQ2hhbmdlZF8yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmludml0ZTJ4eFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaW52aXRlMnh4VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW52aXRlMnh4VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlaW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogVE9ETzogV2hhdCB0byBkbyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25fMi5hZGRMaXN0ZW5lcihcInN0YXRlQ2hhbmdlZFwiLCBzdGF0ZUNoYW5nZWRfMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTZXNzaW9uRGlhbG9nO1xufShkaWFsb2dfMS5EaWFsb2cpKTtcbmV4cG9ydHMuU2Vzc2lvbkRpYWxvZyA9IFNlc3Npb25EaWFsb2c7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgc3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vc3Vic2NyaXB0aW9uXCIpO1xudmFyIHRpbWVyc18xID0gcmVxdWlyZShcIi4uL3RpbWVyc1wiKTtcbnZhciBhbGxvd2VkX21ldGhvZHNfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzXCIpO1xudmFyIG5vdGlmeV91c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzL25vdGlmeS11c2VyLWFnZW50LXNlcnZlclwiKTtcbnZhciByZV9zdWJzY3JpYmVfdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50cy9yZS1zdWJzY3JpYmUtdXNlci1hZ2VudC1jbGllbnRcIik7XG52YXIgZGlhbG9nXzEgPSByZXF1aXJlKFwiLi9kaWFsb2dcIik7XG4vKipcbiAqIFN1YnNjcmlwdGlvbiBEaWFsb2cuXG4gKiBAcmVtYXJrc1xuICogU0lQLVNwZWNpZmljIEV2ZW50IE5vdGlmaWNhdGlvblxuICpcbiAqIEFic3RyYWN0XG4gKlxuICogICAgVGhpcyBkb2N1bWVudCBkZXNjcmliZXMgYW4gZXh0ZW5zaW9uIHRvIHRoZSBTZXNzaW9uIEluaXRpYXRpb25cbiAqICAgIFByb3RvY29sIChTSVApIGRlZmluZWQgYnkgUkZDIDMyNjEuICBUaGUgcHVycG9zZSBvZiB0aGlzIGV4dGVuc2lvbiBpc1xuICogICAgdG8gcHJvdmlkZSBhbiBleHRlbnNpYmxlIGZyYW1ld29yayBieSB3aGljaCBTSVAgbm9kZXMgY2FuIHJlcXVlc3RcbiAqICAgIG5vdGlmaWNhdGlvbiBmcm9tIHJlbW90ZSBub2RlcyBpbmRpY2F0aW5nIHRoYXQgY2VydGFpbiBldmVudHMgaGF2ZVxuICogICAgb2NjdXJyZWQuXG4gKlxuICogICAgTm90ZSB0aGF0IHRoZSBldmVudCBub3RpZmljYXRpb24gbWVjaGFuaXNtcyBkZWZpbmVkIGhlcmVpbiBhcmUgTk9UXG4gKiAgICBpbnRlbmRlZCB0byBiZSBhIGdlbmVyYWwtcHVycG9zZSBpbmZyYXN0cnVjdHVyZSBmb3IgYWxsIGNsYXNzZXMgb2ZcbiAqICAgIGV2ZW50IHN1YnNjcmlwdGlvbiBhbmQgbm90aWZpY2F0aW9uLlxuICpcbiAqICAgIFRoaXMgZG9jdW1lbnQgcmVwcmVzZW50cyBhIGJhY2t3YXJkcy1jb21wYXRpYmxlIGltcHJvdmVtZW50IG9uIHRoZVxuICogICAgb3JpZ2luYWwgbWVjaGFuaXNtIGRlc2NyaWJlZCBieSBSRkMgMzI2NSwgdGFraW5nIGludG8gYWNjb3VudCBzZXZlcmFsXG4gKiAgICB5ZWFycyBvZiBpbXBsZW1lbnRhdGlvbiBleHBlcmllbmNlLiAgQWNjb3JkaW5nbHksIHRoaXMgZG9jdW1lbnRcbiAqICAgIG9ic29sZXRlcyBSRkMgMzI2NS4gIFRoaXMgZG9jdW1lbnQgYWxzbyB1cGRhdGVzIFJGQyA0NjYwIHNsaWdodGx5IHRvXG4gKiAgICBhY2NvbW1vZGF0ZSBzb21lIHNtYWxsIGNoYW5nZXMgdG8gdGhlIG1lY2hhbmlzbSB0aGF0IHdlcmUgZGlzY3Vzc2VkXG4gKiAgICBpbiB0aGF0IGRvY3VtZW50LlxuICpcbiAqICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NVxuICogQHB1YmxpY1xuICovXG52YXIgU3Vic2NyaXB0aW9uRGlhbG9nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN1YnNjcmlwdGlvbkRpYWxvZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb25EaWFsb2coc3Vic2NyaXB0aW9uRXZlbnQsIHN1YnNjcmlwdGlvbkV4cGlyZXMsIHN1YnNjcmlwdGlvblN0YXRlLCBjb3JlLCBzdGF0ZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29yZSwgc3RhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIF90aGlzLl9hdXRvUmVmcmVzaCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uRXZlbnQgPSBzdWJzY3JpcHRpb25FdmVudDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXMgPSBzdWJzY3JpcHRpb25FeHBpcmVzO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0luaXRpYWwgPSBzdWJzY3JpcHRpb25FeHBpcmVzO1xuICAgICAgICBfdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0xhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoTGFzdFNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuX3N1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uU3RhdGU7XG4gICAgICAgIF90aGlzLmxvZ2dlciA9IGNvcmUubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAuc3Vic2NyaWJlLWRpYWxvZ1wiKTtcbiAgICAgICAgX3RoaXMubG9nZ2VyLmxvZyhcIlNVQlNDUklCRSBkaWFsb2cgXCIgKyBfdGhpcy5pZCArIFwiIGNvbnN0cnVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gYSBVQUMgcmVjZWl2ZXMgYSByZXNwb25zZSB0aGF0IGVzdGFibGlzaGVzIGEgZGlhbG9nLCBpdFxuICAgICAqIGNvbnN0cnVjdHMgdGhlIHN0YXRlIG9mIHRoZSBkaWFsb2cuICBUaGlzIHN0YXRlIE1VU1QgYmUgbWFpbnRhaW5lZFxuICAgICAqIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGRpYWxvZy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAqIEBwYXJhbSBvdXRnb2luZ1JlcXVlc3RNZXNzYWdlIC0gT3V0Z29pbmcgcmVxdWVzdCBtZXNzYWdlIGZvciBkaWFsb2cuXG4gICAgICogQHBhcmFtIGluY29taW5nUmVzcG9uc2VNZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBjcmVhdGluZyBkaWFsb2cuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLCBpbmNvbWluZ05vdGlmeVJlcXVlc3RNZXNzYWdlKSB7XG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IHdhcyBzZW50IG92ZXIgVExTLCBhbmQgdGhlIFJlcXVlc3QtVVJJIGNvbnRhaW5lZCBhXG4gICAgICAgIC8vIFNJUFMgVVJJLCB0aGUgXCJzZWN1cmVcIiBmbGFnIGlzIHNldCB0byBUUlVFLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICB2YXIgc2VjdXJlID0gZmFsc2U7IC8vIEZJWE1FOiBDdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgVExTLlxuICAgICAgICAvLyBUaGUgcm91dGUgc2V0IE1VU1QgYmUgc2V0IHRvIHRoZSBsaXN0IG9mIFVSSXMgaW4gdGhlIFJlY29yZC1Sb3V0ZVxuICAgICAgICAvLyBoZWFkZXIgZmllbGQgZnJvbSB0aGUgcmVzcG9uc2UsIHRha2VuIGluIHJldmVyc2Ugb3JkZXIgYW5kIHByZXNlcnZpbmdcbiAgICAgICAgLy8gYWxsIFVSSSBwYXJhbWV0ZXJzLiAgSWYgbm8gUmVjb3JkLVJvdXRlIGhlYWRlciBmaWVsZCBpcyBwcmVzZW50IGluXG4gICAgICAgIC8vIHRoZSByZXNwb25zZSwgdGhlIHJvdXRlIHNldCBNVVNUIGJlIHNldCB0byB0aGUgZW1wdHkgc2V0LiAgVGhpcyByb3V0ZVxuICAgICAgICAvLyBzZXQsIGV2ZW4gaWYgZW1wdHksIG92ZXJyaWRlcyBhbnkgcHJlLWV4aXN0aW5nIHJvdXRlIHNldCBmb3IgZnV0dXJlXG4gICAgICAgIC8vIHJlcXVlc3RzIGluIHRoaXMgZGlhbG9nLiAgVGhlIHJlbW90ZSB0YXJnZXQgTVVTVCBiZSBzZXQgdG8gdGhlIFVSSVxuICAgICAgICAvLyBmcm9tIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIHZhciByb3V0ZVNldCA9IGluY29taW5nTm90aWZ5UmVxdWVzdE1lc3NhZ2UuZ2V0SGVhZGVycyhcInJlY29yZC1yb3V0ZVwiKTtcbiAgICAgICAgdmFyIGNvbnRhY3QgPSBpbmNvbWluZ05vdGlmeVJlcXVlc3RNZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGFjdFwiKTtcbiAgICAgICAgaWYgKCFjb250YWN0KSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNvbnRhY3QgaW5zdGFuY2VvZiBtZXNzYWdlc18xLk5hbWVBZGRySGVhZGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGFjdCBub3QgaW5zdGFuY2Ugb2YgTmFtZUFkZHJIZWFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1vdGVUYXJnZXQgPSBjb250YWN0LnVyaTtcbiAgICAgICAgLy8gVGhlIGxvY2FsIHNlcXVlbmNlIG51bWJlciBNVVNUIGJlIHNldCB0byB0aGUgdmFsdWUgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgIC8vIG51bWJlciBpbiB0aGUgQ1NlcSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgcmVtb3RlIHNlcXVlbmNlXG4gICAgICAgIC8vIG51bWJlciBNVVNUIGJlIGVtcHR5IChpdCBpcyBlc3RhYmxpc2hlZCB3aGVuIHRoZSByZW1vdGUgVUEgc2VuZHMgYVxuICAgICAgICAvLyByZXF1ZXN0IHdpdGhpbiB0aGUgZGlhbG9nKS4gIFRoZSBjYWxsIGlkZW50aWZpZXIgY29tcG9uZW50IG9mIHRoZVxuICAgICAgICAvLyBkaWFsb2cgSUQgTVVTVCBiZSBzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBDYWxsLUlEIGluIHRoZSByZXF1ZXN0LlxuICAgICAgICAvLyBUaGUgbG9jYWwgdGFnIGNvbXBvbmVudCBvZiB0aGUgZGlhbG9nIElEIE1VU1QgYmUgc2V0IHRvIHRoZSB0YWcgaW5cbiAgICAgICAgLy8gdGhlIEZyb20gZmllbGQgaW4gdGhlIHJlcXVlc3QsIGFuZCB0aGUgcmVtb3RlIHRhZyBjb21wb25lbnQgb2YgdGhlXG4gICAgICAgIC8vIGRpYWxvZyBJRCBNVVNUIGJlIHNldCB0byB0aGUgdGFnIGluIHRoZSBUbyBmaWVsZCBvZiB0aGUgcmVzcG9uc2UuICBBXG4gICAgICAgIC8vIFVBQyBNVVNUIGJlIHByZXBhcmVkIHRvIHJlY2VpdmUgYSByZXNwb25zZSB3aXRob3V0IGEgdGFnIGluIHRoZSBUb1xuICAgICAgICAvLyBmaWVsZCwgaW4gd2hpY2ggY2FzZSB0aGUgdGFnIGlzIGNvbnNpZGVyZWQgdG8gaGF2ZSBhIHZhbHVlIG9mIG51bGwuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFRoaXMgaXMgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0Mywgd2hpY2hcbiAgICAgICAgLy8gICAgZGlkIG5vdCBtYW5kYXRlIFRvIHRhZ3MuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMS4yXG4gICAgICAgIHZhciBsb2NhbFNlcXVlbmNlTnVtYmVyID0gb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5jc2VxO1xuICAgICAgICB2YXIgcmVtb3RlU2VxdWVuY2VOdW1iZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjYWxsSWQgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLmNhbGxJZDtcbiAgICAgICAgdmFyIGxvY2FsVGFnID0gb3V0Z29pbmdTdWJzY3JpYmVSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuICAgICAgICB2YXIgcmVtb3RlVGFnID0gaW5jb21pbmdOb3RpZnlSZXF1ZXN0TWVzc2FnZS5mcm9tVGFnO1xuICAgICAgICBpZiAoIWNhbGxJZCkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGwgaWQgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvY2FsVGFnKSB7IC8vIFRPRE86IFJldmlldyB0byBtYWtlIHN1cmUgdGhpcyB3aWxsIG5ldmVyIGhhcHBlblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB0YWcgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbW90ZVRhZykgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHRhZyB1bmRlZmluZWQuXCIpOyAvLyBGSVhNRTogTm8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBSRkMgMjU0M1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSByZW1vdGUgVVJJIE1VU1QgYmUgc2V0IHRvIHRoZSBVUkkgaW4gdGhlIFRvIGZpZWxkLCBhbmQgdGhlIGxvY2FsXG4gICAgICAgIC8vIFVSSSBNVVNUIGJlIHNldCB0byB0aGUgVVJJIGluIHRoZSBGcm9tIGZpZWxkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMlxuICAgICAgICBpZiAoIW91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UuZnJvbSkgeyAvLyBUT0RPOiBSZXZpZXcgdG8gbWFrZSBzdXJlIHRoaXMgd2lsbCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyb20gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UudG8pIHsgLy8gVE9ETzogUmV2aWV3IHRvIG1ha2Ugc3VyZSB0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUbyB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbFVSSSA9IG91dGdvaW5nU3Vic2NyaWJlUmVxdWVzdE1lc3NhZ2UuZnJvbS51cmk7XG4gICAgICAgIHZhciByZW1vdGVVUkkgPSBvdXRnb2luZ1N1YnNjcmliZVJlcXVlc3RNZXNzYWdlLnRvLnVyaTtcbiAgICAgICAgLy8gQSBkaWFsb2cgY2FuIGFsc28gYmUgaW4gdGhlIFwiZWFybHlcIiBzdGF0ZSwgd2hpY2ggb2NjdXJzIHdoZW4gaXQgaXNcbiAgICAgICAgLy8gY3JlYXRlZCB3aXRoIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UsIGFuZCB0aGVuIHRyYW5zaXRpb24gdG8gdGhlXG4gICAgICAgIC8vIFwiY29uZmlybWVkXCIgc3RhdGUgd2hlbiBhIDJ4eCBmaW5hbCByZXNwb25zZSBhcnJpdmVzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyXG4gICAgICAgIHZhciBlYXJseSA9IGZhbHNlO1xuICAgICAgICB2YXIgZGlhbG9nU3RhdGUgPSB7XG4gICAgICAgICAgICBpZDogY2FsbElkICsgbG9jYWxUYWcgKyByZW1vdGVUYWcsXG4gICAgICAgICAgICBlYXJseTogZWFybHksXG4gICAgICAgICAgICBjYWxsSWQ6IGNhbGxJZCxcbiAgICAgICAgICAgIGxvY2FsVGFnOiBsb2NhbFRhZyxcbiAgICAgICAgICAgIHJlbW90ZVRhZzogcmVtb3RlVGFnLFxuICAgICAgICAgICAgbG9jYWxTZXF1ZW5jZU51bWJlcjogbG9jYWxTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIHJlbW90ZVNlcXVlbmNlTnVtYmVyOiByZW1vdGVTZXF1ZW5jZU51bWJlcixcbiAgICAgICAgICAgIGxvY2FsVVJJOiBsb2NhbFVSSSxcbiAgICAgICAgICAgIHJlbW90ZVVSSTogcmVtb3RlVVJJLFxuICAgICAgICAgICAgcmVtb3RlVGFyZ2V0OiByZW1vdGVUYXJnZXQsXG4gICAgICAgICAgICByb3V0ZVNldDogcm91dGVTZXQsXG4gICAgICAgICAgICBzZWN1cmU6IHNlY3VyZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGlhbG9nU3RhdGU7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5OKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5OKTtcbiAgICAgICAgICAgIHRoaXMuTiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lckNsZWFyKCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNVQlNDUklCRSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgZGVzdHJveWVkXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwiYXV0b1JlZnJlc2hcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvUmVmcmVzaDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYXV0b1JlZnJlc2gpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dG9SZWZyZXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVyU2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbkV2ZW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uRXZlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbkV4cGlyZXNcIiwge1xuICAgICAgICAvKiogTnVtYmVyIG9mIHNlY29uZHMgdW50aWwgc3Vic2NyaXB0aW9uIGV4cGlyZXMuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlY29uZHNTaW5jZUxhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXNMYXN0U2V0O1xuICAgICAgICAgICAgdmFyIHNlY29uZHNVbnRpbEV4cGlyZXMgPSB0aGlzLl9zdWJzY3JpcHRpb25FeHBpcmVzIC0gc2Vjb25kc1NpbmNlTGFzdFNldDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChzZWNvbmRzVW50aWxFeHBpcmVzLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZXhwaXJlcykge1xuICAgICAgICAgICAgaWYgKGV4cGlyZXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwaXJlcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkV4cGlyZXMgPSBleHBpcmVzO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0xhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnJlc2ggPSB0aGlzLnN1YnNjcmlwdGlvblJlZnJlc2g7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2ggPT09IHVuZGVmaW5lZCB8fCByZWZyZXNoID49IGV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXJTZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvbkV4cGlyZXNJbml0aWFsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaXB0aW9uRXhwaXJlc0luaXRpYWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLCBcInN1YnNjcmlwdGlvblJlZnJlc2hcIiwge1xuICAgICAgICAvKiogTnVtYmVyIG9mIHNlY29uZHMgdW50aWwgc3Vic2NyaXB0aW9uIGF1dG8gcmVmcmVzaC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlY29uZHNTaW5jZUxhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIHRoaXMuX3N1YnNjcmlwdGlvblJlZnJlc2hMYXN0U2V0O1xuICAgICAgICAgICAgdmFyIHNlY29uZHNVbnRpbEV4cGlyZXMgPSB0aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoIC0gc2Vjb25kc1NpbmNlTGFzdFNldDtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChzZWNvbmRzVW50aWxFeHBpcmVzLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUsIFwic3Vic2NyaXB0aW9uU3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpcHRpb25TdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSBpbiBkaWFsb2cgcmVxdWVzdCBtZXNzYWdlIGZyb20gdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gIFRoZSBpbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNVQlNDUklCRSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVjZWl2ZWQgXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3RcIik7XG4gICAgICAgIC8vIFJlcXVlc3Qgd2l0aGluIGEgZGlhbG9nIG91dCBvZiBzZXF1ZW5jZSBndWFyZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgaWYgKCF0aGlzLnNlcXVlbmNlR3VhcmQobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyhcIlNVQlNDUklCRSBkaWFsb2cgXCIgKyB0aGlzLmlkICsgXCIgcmVqZWN0ZWQgb3V0IG9mIG9yZGVyIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0LlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXF1ZXN0IHdpdGhpbiBhIGRpYWxvZyBjb21tb24gcHJvY2Vzc2luZy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdC5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBTd2l0Y2ggb24gbWV0aG9kIGFuZCB0aGVuIGRlbGVnYXRlLlxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5OT1RJRlk6XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5vdGlmeShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiByZWNlaXZlZCB1bmltcGxlbWVudGVkIFwiICsgbWVzc2FnZS5tZXRob2QgKyBcIiByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29yZS5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDUwMSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogNC4xLjIuMi4gIFJlZnJlc2hpbmcgb2YgU3Vic2NyaXB0aW9uc1xuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChhbGxvd0hlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJFdmVudDogXCIgKyB0aGlzLnN1YnNjcmlwdGlvbkV2ZW50KTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IFwiICsgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzSW5pdGlhbCk7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3QudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSh1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogNC4xLjIuMi4gIFJlZnJlc2hpbmcgb2YgU3Vic2NyaXB0aW9uc1xuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIERlbGVnYXRlIHRvIGhhbmRsZSByZXNwb25zZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZyAmJiB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIG5lZWRzIHRvIGJlIGEgcHJvcGVyIGV4Y2VwdGlvblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSBcIiArIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgKyBcIi4gTWF5IG9ubHkgcmUtc3Vic2NyaWJlIHdoaWxlIGluIHN0YXRlIFxcXCJwZW5kaW5nXFxcIiBvciBcXFwiYWN0aXZlXFxcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiU1VCU0NSSUJFIGRpYWxvZyBcIiArIHRoaXMuaWQgKyBcIiBzZW5kaW5nIFNVQlNDUklCRSByZXF1ZXN0XCIpO1xuICAgICAgICB2YXIgdWFjID0gbmV3IHJlX3N1YnNjcmliZV91c2VyX2FnZW50X2NsaWVudF8xLlJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50KHRoaXMsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgLy8gV2hlbiByZWZyZXNoaW5nIGEgc3Vic2NyaXB0aW9uLCBhIHN1YnNjcmliZXIgc3RhcnRzIFRpbWVyIE4sIHNldCB0b1xuICAgICAgICAvLyA2NCpUMSwgd2hlbiBpdCBzZW5kcyB0aGUgU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAgICB0aGlzLk4gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbWVyX04oKTsgfSwgdGltZXJzXzEuVGltZXJzLlRJTUVSX04pO1xuICAgICAgICByZXR1cm4gdWFjO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogNC40LjEuICBEaWFsb2cgQ3JlYXRpb24gYW5kIFRlcm1pbmF0aW9uXG4gICAgICogQSBzdWJzY3JpcHRpb24gaXMgZGVzdHJveWVkIGFmdGVyIGEgbm90aWZpZXIgc2VuZHMgYSBOT1RJRlkgcmVxdWVzdFxuICAgICAqIHdpdGggYSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIG9mIFwidGVybWluYXRlZFwiLCBvciBpbiBjZXJ0YWluIGVycm9yXG4gICAgICogc2l0dWF0aW9ucyBkZXNjcmliZWQgZWxzZXdoZXJlIGluIHRoaXMgZG9jdW1lbnQuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjQuMVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUudGVybWluYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbihzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDQuMS4yLjMuICBVbnN1YnNjcmliaW5nXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4zXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IChvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChhbGxvd0hlYWRlcik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJFdmVudDogXCIgKyB0aGlzLnN1YnNjcmlwdGlvbkV2ZW50KTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChcIkV4cGlyZXM6IDBcIik7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzLnB1c2goXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3QudG9TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZSh1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluIGRpYWxvZyBOT1RJRlkgcmVxdWVzdHMuXG4gICAgICogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBmaXJzdCBOT1RJRlkgd2hpY2ggY3JlYXRlZCB0aGUgZGlhbG9nLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGluY29taW5nIE5PVElGWSByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5vbk5vdGlmeSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIElmLCBmb3Igc29tZSByZWFzb24sIHRoZSBldmVudCBwYWNrYWdlIGRlc2lnbmF0ZWQgaW4gdGhlIFwiRXZlbnRcIlxuICAgICAgICAvLyBoZWFkZXIgZmllbGQgb2YgdGhlIE5PVElGWSByZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQsIHRoZSBzdWJzY3JpYmVyXG4gICAgICAgIC8vIHdpbGwgcmVzcG9uZCB3aXRoIGEgNDg5IChCYWQgRXZlbnQpIHJlc3BvbnNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4zXG4gICAgICAgIHZhciBldmVudCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJFdmVudFwiKS5ldmVudDtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudCAhPT0gdGhpcy5zdWJzY3JpcHRpb25FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb3JlLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBzdGF0ZSBkaWFncmFtLCBcIlJlLXN1YnNjcmlwdGlvbiB0aW1lcyBvdXRcIiBtZWFucyB0aGF0IGFuXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gcmVmcmVzaCBvciB1cGRhdGUgdGhlIHN1YnNjcmlwdGlvbiB1c2luZyBhIG5ldyBTVUJTQ1JJQkVcbiAgICAgICAgLy8gcmVxdWVzdCBkb2VzIG5vdCByZXN1bHQgaW4gYSBOT1RJRlkgcmVxdWVzdCBiZWZvcmUgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLy8gVGltZXIgTiBleHBpcmVzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yXG4gICAgICAgIGlmICh0aGlzLk4pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLk4pO1xuICAgICAgICAgICAgdGhpcy5OID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBNVVNUIGNvbnRhaW4gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGRzIHRoYXRcbiAgICAgICAgLy8gaW5kaWNhdGUgdGhlIHN0YXR1cyBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4zXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25TdGF0ZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJTdWJzY3JpcHRpb24tU3RhdGVcIik7XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uU3RhdGUgfHwgIXN1YnNjcmlwdGlvblN0YXRlLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmNvcmUucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXRlID0gc3Vic2NyaXB0aW9uU3RhdGUuc3RhdGU7XG4gICAgICAgIHZhciBleHBpcmVzID0gc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcyA/IE1hdGgubWF4KHN1YnNjcmlwdGlvblN0YXRlLmV4cGlyZXMsIDApIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBVcGRhdGUgb3VyIHN0YXRlIGFuZCBleHBpcmF0aW9uLlxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFjdGl2ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZSwgZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidGVybWluYXRlZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5yZWNvZ25pemVkIHN1YnNjcmlwdGlvbiBzdGF0ZS5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZWdhdGUgcmVtYWluZGVyIG9mIE5PVElGWSBoYW5kbGluZy5cbiAgICAgICAgdmFyIHVhcyA9IG5ldyBub3RpZnlfdXNlcl9hZ2VudF9zZXJ2ZXJfMS5Ob3RpZnlVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkodWFzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5vblJlZnJlc2ggPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZnJlc2gocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUub25UZXJtaW5hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblRlcm1pbmF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uRGlhbG9nLnByb3RvdHlwZS5yZWZyZXNoVGltZXJDbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmcmVzaFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWZyZXNoVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUucmVmcmVzaFRpbWVyU2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlZnJlc2hUaW1lckNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoICYmIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA+IDApIHtcbiAgICAgICAgICAgIHZhciByZWZyZXNoID0gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzICogOTAwO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaCA9IE1hdGguZmxvb3IocmVmcmVzaCAvIDEwMDApO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uUmVmcmVzaExhc3RTZXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVmcmVzaFRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpcHRpb25SZWZyZXNoTGFzdFNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblJlZnJlc2goX3RoaXMucmVmcmVzaCgpKTtcbiAgICAgICAgICAgIH0sIHJlZnJlc2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25EaWFsb2cucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgbmV3RXhwaXJlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIHZhciBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nZ2VyLndhcm4oXCJJbnZhbGlkIHN1YnNjcmlwdGlvbiBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkluaXRpYWw6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2Ugc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLk5vdGlmeVdhaXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5BY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5Ob3RpZnlXYWl0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSAhPT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgXCJTdWJzY3JpcHRpb24tU3RhdGVcIiB2YWx1ZSBpcyBcInBlbmRpbmdcIiwgdGhlIHN1YnNjcmlwdGlvbiBoYXNcbiAgICAgICAgLy8gYmVlbiByZWNlaXZlZCBieSB0aGUgbm90aWZpZXIsIGJ1dCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgcG9saWN5XG4gICAgICAgIC8vIGluZm9ybWF0aW9uIHRvIGdyYW50IG9yIGRlbnkgdGhlIHN1YnNjcmlwdGlvbiB5ZXQuICBJZiB0aGUgaGVhZGVyXG4gICAgICAgIC8vIGZpZWxkIGFsc28gY29udGFpbnMgYW4gXCJleHBpcmVzXCIgcGFyYW1ldGVyLCB0aGUgc3Vic2NyaWJlciBTSE9VTERcbiAgICAgICAgLy8gdGFrZSBpdCBhcyB0aGUgYXV0aG9yaXRhdGl2ZSBzdWJzY3JpcHRpb24gZHVyYXRpb24gYW5kIGFkanVzdFxuICAgICAgICAvLyBhY2NvcmRpbmdseS4gIE5vIGZ1cnRoZXIgYWN0aW9uIGlzIG5lY2Vzc2FyeSBvbiB0aGUgcGFydCBvZiB0aGVcbiAgICAgICAgLy8gc3Vic2NyaWJlci4gIFRoZSBcInJldHJ5LWFmdGVyXCIgYW5kIFwicmVhc29uXCIgcGFyYW1ldGVycyBoYXZlIG5vXG4gICAgICAgIC8vIHNlbWFudGljcyBmb3IgXCJwZW5kaW5nXCIuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjNcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5QZW5kaW5nKSB7XG4gICAgICAgICAgICBpZiAobmV3RXhwaXJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IG5ld0V4cGlyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgaGVhZGVyIGZpZWxkIHZhbHVlIGlzIFwiYWN0aXZlXCIsIGl0IG1lYW5zXG4gICAgICAgIC8vIHRoYXQgdGhlIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBhY2NlcHRlZCBhbmQgKGluIGdlbmVyYWwpIGhhcyBiZWVuXG4gICAgICAgIC8vIGF1dGhvcml6ZWQuICBJZiB0aGUgaGVhZGVyIGZpZWxkIGFsc28gY29udGFpbnMgYW4gXCJleHBpcmVzXCJcbiAgICAgICAgLy8gcGFyYW1ldGVyLCB0aGUgc3Vic2NyaWJlciBTSE9VTEQgdGFrZSBpdCBhcyB0aGUgYXV0aG9yaXRhdGl2ZVxuICAgICAgICAvLyBzdWJzY3JpcHRpb24gZHVyYXRpb24gYW5kIGFkanVzdCBhY2NvcmRpbmdseS4gIFRoZSBcInJldHJ5LWFmdGVyXCIgYW5kXG4gICAgICAgIC8vIFwicmVhc29uXCIgcGFyYW1ldGVycyBoYXZlIG5vIHNlbWFudGljcyBmb3IgXCJhY3RpdmVcIi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuM1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLkFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKG5ld0V4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSBuZXdFeHBpcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIHZhbHVlIGlzIFwidGVybWluYXRlZFwiLCB0aGUgc3Vic2NyaWJlclxuICAgICAgICAvLyBNVVNUIGNvbnNpZGVyIHRoZSBzdWJzY3JpcHRpb24gdGVybWluYXRlZC4gIFRoZSBcImV4cGlyZXNcIiBwYXJhbWV0ZXJcbiAgICAgICAgLy8gaGFzIG5vIHNlbWFudGljcyBmb3IgXCJ0ZXJtaW5hdGVkXCIgLS0gbm90aWZpZXJzIFNIT1VMRCBOT1QgaW5jbHVkZSBhblxuICAgICAgICAvLyBcImV4cGlyZXNcIiBwYXJhbWV0ZXIgb24gYSBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIGhlYWRlciBmaWVsZCB3aXRoIGFcbiAgICAgICAgLy8gdmFsdWUgb2YgXCJ0ZXJtaW5hdGVkXCIsIGFuZCBzdWJzY3JpYmVycyBNVVNUIGlnbm9yZSBhbnkgc3VjaFxuICAgICAgICAvLyBwYXJhbWV0ZXIsIGlmIHByZXNlbnQuXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gcmVmcmVzaGluZyBhIHN1YnNjcmlwdGlvbiwgYSBzdWJzY3JpYmVyIHN0YXJ0cyBUaW1lciBOLCBzZXQgdG9cbiAgICAgKiA2NCpUMSwgd2hlbiBpdCBzZW5kcyB0aGUgU1VCU0NSSUJFIHJlcXVlc3QuICBJZiB0aGlzIFRpbWVyIE4gZXhwaXJlc1xuICAgICAqIHByaW9yIHRvIHRoZSByZWNlaXB0IG9mIGEgTk9USUZZIHJlcXVlc3QsIHRoZSBzdWJzY3JpYmVyIGNvbnNpZGVyc1xuICAgICAqIHRoZSBzdWJzY3JpcHRpb24gdGVybWluYXRlZC4gIElmIHRoZSBzdWJzY3JpYmVyIHJlY2VpdmVzIGEgc3VjY2Vzc1xuICAgICAqIHJlc3BvbnNlIHRvIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdCB0aGF0IGluZGljYXRlcyB0aGF0IG5vIE5PVElGWVxuICAgICAqIHJlcXVlc3Qgd2lsbCBiZSBnZW5lcmF0ZWQgLS0gc3VjaCBhcyB0aGUgMjA0IHJlc3BvbnNlIGRlZmluZWQgZm9yIHVzZVxuICAgICAqIHdpdGggdGhlIG9wdGlvbmFsIGV4dGVuc2lvbiBkZXNjcmliZWQgaW4gW1JGQzU4MzldIC0tIHRoZW4gaXQgTVVTVFxuICAgICAqIGNhbmNlbCBUaW1lciBOLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbkRpYWxvZy5wcm90b3R5cGUudGltZXJfTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uU3RhdGUgIT09IHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICAgICAgdGhpcy5vblRlcm1pbmF0ZWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkRpYWxvZztcbn0oZGlhbG9nXzEuRGlhbG9nKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbkRpYWxvZyA9IFN1YnNjcmlwdGlvbkRpYWxvZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vKipcbiAqIEFuIEV4Y2VwdGlvbiBpcyBjb25zaWRlcmVkIGEgY29uZGl0aW9uIHRoYXQgYSByZWFzb25hYmxlIGFwcGxpY2F0aW9uIG1heSB3aXNoIHRvIGNhdGNoLlxuICogQW4gRXJyb3IgaW5kaWNhdGVzIHNlcmlvdXMgcHJvYmxlbXMgdGhhdCBhIHJlYXNvbmFibGUgYXBwbGljYXRpb24gc2hvdWxkIG5vdCB0cnkgdG8gY2F0Y2guXG4gKiBAcHVibGljXG4gKi9cbnZhciBFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXhjZXB0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7IC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1zdGF0ZS1lcnJvclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc3BvcnQtZXJyb3JcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBleGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIG9wZXJhdGlvbiBjb3VsZCBub3QgYmUgY29tcGxldGVkIGdpdmVuIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIHN0YXRlLlxuICogQHB1YmxpY1xuICovXG52YXIgVHJhbnNhY3Rpb25TdGF0ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFRyYW5zYWN0aW9uU3RhdGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvblN0YXRlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlRyYW5zYWN0aW9uIHN0YXRlIGVycm9yLlwiKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNhY3Rpb25TdGF0ZUVycm9yO1xufShleGNlcHRpb25fMS5FeGNlcHRpb24pKTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0ZUVycm9yID0gVHJhbnNhY3Rpb25TdGF0ZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBleGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2V4Y2VwdGlvblwiKTtcbi8qKlxuICogVHJhbnNwb3J0IGVycm9yLlxuICogQHB1YmxpY1xuICovXG52YXIgVHJhbnNwb3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNwb3J0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0RXJyb3IobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSA/IG1lc3NhZ2UgOiBcIlVuc3BlY2lmaWVkIHRyYW5zcG9ydCBlcnJvci5cIikgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zcG9ydEVycm9yO1xufShleGNlcHRpb25fMS5FeGNlcHRpb24pKTtcbmV4cG9ydHMuVHJhbnNwb3J0RXJyb3IgPSBUcmFuc3BvcnRFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIGNvcmUgbGlicmFyeSBpbXBsZW1lbnRpbmcgbG93IGxldmVsIFNJUCBwcm90b2NvbCBlbGVtZW50cy5cbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vIERpcmVjdG9yaWVzXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kaWFsb2dzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4Y2VwdGlvbnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2VzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Nlc3Npb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3Vic2NyaXB0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyLWFnZW50LWNvcmVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci1hZ2VudHNcIiksIGV4cG9ydHMpO1xuLy8gRmlsZXNcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RpbWVyc1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbGV2ZWxzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dlci1mYWN0b3J5XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2xvZ2dlclwiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogTG9nIGxldmVscy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIExldmVscztcbihmdW5jdGlvbiAoTGV2ZWxzKSB7XG4gICAgTGV2ZWxzW0xldmVsc1tcImVycm9yXCJdID0gMF0gPSBcImVycm9yXCI7XG4gICAgTGV2ZWxzW0xldmVsc1tcIndhcm5cIl0gPSAxXSA9IFwid2FyblwiO1xuICAgIExldmVsc1tMZXZlbHNbXCJsb2dcIl0gPSAyXSA9IFwibG9nXCI7XG4gICAgTGV2ZWxzW0xldmVsc1tcImRlYnVnXCJdID0gM10gPSBcImRlYnVnXCI7XG59KShMZXZlbHMgPSBleHBvcnRzLkxldmVscyB8fCAoZXhwb3J0cy5MZXZlbHMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGV2ZWxzXzEgPSByZXF1aXJlKFwiLi9sZXZlbHNcIik7XG52YXIgbG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9sb2dnZXJcIik7XG4vKipcbiAqIExvZ2dlci5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIExvZ2dlckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9nZ2VyRmFjdG9yeSgpIHtcbiAgICAgICAgdGhpcy5idWlsdGluRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWxzXzEuTGV2ZWxzLmxvZztcbiAgICAgICAgdGhpcy5sb2dnZXJzID0ge307XG4gICAgICAgIHRoaXMubG9nZ2VyID0gdGhpcy5nZXRMb2dnZXIoXCJzaXA6bG9nZ2VyZmFjdG9yeVwiKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ2dlckZhY3RvcnkucHJvdG90eXBlLCBcImxldmVsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZXZlbDsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3TGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdMZXZlbCA+PSAwICYmIG5ld0xldmVsIDw9IDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXZlbCA9IG5ld0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV3TGV2ZWwgPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGV2ZWwgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGV2ZWxzXzEuTGV2ZWxzLmhhc093blByb3BlcnR5KG5ld0xldmVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbmV3TGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihcImludmFsaWQgJ2xldmVsJyBwYXJhbWV0ZXIgdmFsdWU6IFwiICsgSlNPTi5zdHJpbmdpZnkobmV3TGV2ZWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExvZ2dlckZhY3RvcnkucHJvdG90eXBlLCBcImNvbm5lY3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RvciA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJpbnZhbGlkICdjb25uZWN0b3InIHBhcmFtZXRlciB2YWx1ZTogXCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRMb2dnZXIgPSBmdW5jdGlvbiAoY2F0ZWdvcnksIGxhYmVsKSB7XG4gICAgICAgIGlmIChsYWJlbCAmJiB0aGlzLmxldmVsID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGxvZ2dlcl8xLkxvZ2dlcih0aGlzLCBjYXRlZ29yeSwgbGFiZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubG9nZ2Vyc1tjYXRlZ29yeV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2dlcnNbY2F0ZWdvcnldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvZ2dlciA9IG5ldyBsb2dnZXJfMS5Mb2dnZXIodGhpcywgY2F0ZWdvcnkpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXJzW2NhdGVnb3J5XSA9IGxvZ2dlcjtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlckZhY3RvcnkucHJvdG90eXBlLmdlbmVyaWNMb2cgPSBmdW5jdGlvbiAobGV2ZWxUb0xvZywgY2F0ZWdvcnksIGxhYmVsLCBjb250ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmxldmVsID49IGxldmVsVG9Mb2cpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1aWx0aW5FbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmludChsZXZlbFRvTG9nLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IobGV2ZWxzXzEuTGV2ZWxzW2xldmVsVG9Mb2ddLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXJGYWN0b3J5LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIChsZXZlbFRvTG9nLCBjYXRlZ29yeSwgbGFiZWwsIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gW25ldyBEYXRlKCksIGNhdGVnb3J5XTtcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIHByZWZpeC5wdXNoKGxhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnQgPSBwcmVmaXguY29uY2F0KGNvbnRlbnQpLmpvaW4oXCIgfCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChsZXZlbFRvTG9nKSB7XG4gICAgICAgICAgICBjYXNlIGxldmVsc18xLkxldmVscy5lcnJvcjpcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGxldmVsc18xLkxldmVscy53YXJuOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBsZXZlbHNfMS5MZXZlbHMubG9nOlxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coY29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGxldmVsc18xLkxldmVscy5kZWJ1ZzpcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoY29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlckZhY3RvcnkgPSBMb2dnZXJGYWN0b3J5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbGV2ZWxzXzEgPSByZXF1aXJlKFwiLi9sZXZlbHNcIik7XG4vKipcbiAqIExvZ2dlci5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIobG9nZ2VyLCBjYXRlZ29yeSwgbGFiZWwpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBjYXRlZ29yeTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICBMb2dnZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgdGhpcy5nZW5lcmljTG9nKGxldmVsc18xLkxldmVscy5lcnJvciwgY29udGVudCk7IH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgdGhpcy5nZW5lcmljTG9nKGxldmVsc18xLkxldmVscy53YXJuLCBjb250ZW50KTsgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7IHRoaXMuZ2VuZXJpY0xvZyhsZXZlbHNfMS5MZXZlbHMubG9nLCBjb250ZW50KTsgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgdGhpcy5nZW5lcmljTG9nKGxldmVsc18xLkxldmVscy5kZWJ1ZywgY29udGVudCk7IH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5nZW5lcmljTG9nID0gZnVuY3Rpb24gKGxldmVsLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmdlbmVyaWNMb2cobGV2ZWwsIHRoaXMuY2F0ZWdvcnksIHRoaXMubGFiZWwsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGluY29taW5nX3JlcXVlc3RfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vaW5jb21pbmctcmVxdWVzdC1tZXNzYWdlXCIpO1xudmFyIGluY29taW5nX3Jlc3BvbnNlX21lc3NhZ2VfMSA9IHJlcXVpcmUoXCIuL2luY29taW5nLXJlc3BvbnNlLW1lc3NhZ2VcIik7XG52YXIgb3V0Z29pbmdfcmVxdWVzdF9tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9vdXRnb2luZy1yZXF1ZXN0LW1lc3NhZ2VcIik7XG4vKipcbiAqIENyZWF0ZSBhIEJvZHkgZ2l2ZW4gYSBsZWdhY3kgYm9keSB0eXBlLlxuICogQHBhcmFtIGJvZHlMZWdhY3kgLSBCb2R5IE9iamVjdFxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGZyb21Cb2R5TGVnYWN5KGJvZHlMZWdhY3kpIHtcbiAgICB2YXIgY29udGVudCA9ICh0eXBlb2YgYm9keUxlZ2FjeSA9PT0gXCJzdHJpbmdcIikgPyBib2R5TGVnYWN5IDogYm9keUxlZ2FjeS5ib2R5O1xuICAgIHZhciBjb250ZW50VHlwZSA9ICh0eXBlb2YgYm9keUxlZ2FjeSA9PT0gXCJzdHJpbmdcIikgPyBcImFwcGxpY2F0aW9uL3NkcFwiIDogYm9keUxlZ2FjeS5jb250ZW50VHlwZTtcbiAgICB2YXIgY29udGVudERpc3Bvc2l0aW9uID0gY29udGVudFR5cGVUb0NvbnRlbnREaXNwb3NpdGlvbihjb250ZW50VHlwZSk7XG4gICAgdmFyIGJvZHkgPSB7IGNvbnRlbnREaXNwb3NpdGlvbjogY29udGVudERpc3Bvc2l0aW9uLCBjb250ZW50VHlwZTogY29udGVudFR5cGUsIGNvbnRlbnQ6IGNvbnRlbnQgfTtcbiAgICByZXR1cm4gYm9keTtcbn1cbmV4cG9ydHMuZnJvbUJvZHlMZWdhY3kgPSBmcm9tQm9keUxlZ2FjeTtcbi8qKlxuICogR2l2ZW4gYSBtZXNzYWdlLCBnZXQgYSBub3JtYWxpemVkIGJvZHkuXG4gKiBUaGUgY29udGVudCBkaXNwb3NpdGlvbiBpcyBpbmZlcnJlZCBpZiBub3Qgc2V0LlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRCb2R5KG1lc3NhZ2UpIHtcbiAgICB2YXIgY29udGVudERpc3Bvc2l0aW9uO1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB2YXIgY29udGVudDtcbiAgICAvLyBXZSdyZSBpbiBVQVMgcm9sZSwgcmVjZWl2aW5nIGluY29taW5nIHJlcXVlc3RcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIGluY29taW5nX3JlcXVlc3RfbWVzc2FnZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFBhcnNpbmcgbmVlZHMgdHlwaW5nXG4gICAgICAgICAgICB2YXIgcGFyc2UgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IHBhcnNlID8gcGFyc2UudHlwZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBtZXNzYWdlLmJvZHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UncmUgaW4gVUFDIHJvbGUsIHJlY2VpdmluZyBpbmNvbWluZyByZXNwb25zZVxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgaW5jb21pbmdfcmVzcG9uc2VfbWVzc2FnZV8xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJvZHkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBQYXJzaW5nIG5lZWRzIHR5cGluZ1xuICAgICAgICAgICAgdmFyIHBhcnNlID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb24gPSBwYXJzZSA/IHBhcnNlLnR5cGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250ZW50VHlwZSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIik7XG4gICAgICAgICAgICBjb250ZW50ID0gbWVzc2FnZS5ib2R5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdlJ3JlIGluIFVBQyByb2xlLCBzZW5kaW5nIG91dGdvaW5nIHJlcXVlc3RcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIG91dGdvaW5nX3JlcXVlc3RfbWVzc2FnZV8xLk91dGdvaW5nUmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keSkge1xuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSBtZXNzYWdlLmdldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IE91dGdvaW5nUmVxdWVzdCBzaG91bGQgbm90IGFsbG93IGEgXCJzdHJpbmdcIiBib2R5IHdpdGhvdXQgYSBcIkNvbnRlbnQtVHlwZVwiIGhlYWRlci5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlciBjb250ZW50IHR5cGUgaGVhZGVyIGRvZXMgbm90IGVxdWFsIGJvZHkgY29udGVudCB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGVudCA9IG1lc3NhZ2UuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBPdXRnb2luZ1JlcXVlc3Qgc2hvdWxkIG5vdCBhbGxvdyB0aGUgXCJDb250ZW50LVR5cGVcIiBoZWFkZXIgbm90IHRvIG1hdGNoIHRoIGJvZHkgY29udGVudCB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlICE9PSBtZXNzYWdlLmJvZHkuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVyIGNvbnRlbnQgdHlwZSBoZWFkZXIgZG9lcyBub3QgZXF1YWwgYm9keSBjb250ZW50IHR5cGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IG1lc3NhZ2UuYm9keS5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gbWVzc2FnZS5ib2R5LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UncmUgaW4gVUFTIHJvbGUsIHNlbmRpbmcgb3V0Z29pbmcgcmVzcG9uc2VcbiAgICBpZiAoaXNCb2R5KG1lc3NhZ2UpKSB7XG4gICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IG1lc3NhZ2UuY29udGVudERpc3Bvc2l0aW9uO1xuICAgICAgICBjb250ZW50VHlwZSA9IG1lc3NhZ2UuY29udGVudFR5cGU7XG4gICAgICAgIGNvbnRlbnQgPSBtZXNzYWdlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIE5vIGNvbnRlbnQsIG5vIGJvZHkuXG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChjb250ZW50VHlwZSAmJiAhY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbiA9IGNvbnRlbnRUeXBlVG9Db250ZW50RGlzcG9zaXRpb24oY29udGVudFR5cGUpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRlbnREaXNwb3NpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IGRpc3Bvc2l0aW9uIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCB0eXBlIHVuZGVmaW5lZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogY29udGVudERpc3Bvc2l0aW9uLFxuICAgICAgICBjb250ZW50VHlwZTogY29udGVudFR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRCb2R5ID0gZ2V0Qm9keTtcbi8qKlxuICogVXNlci1EZWZpbmVkIFR5cGUgR3VhcmQgZm9yIEJvZHkuXG4gKiBAcGFyYW0gYm9keSAtIEJvZHkgdG8gY2hlY2suXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNCb2R5KGJvZHkpIHtcbiAgICByZXR1cm4gYm9keSAmJlxuICAgICAgICB0eXBlb2YgYm9keS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHR5cGVvZiBib2R5LmNvbnRlbnRUeXBlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIGJvZHkuY29udGVudERpc3Bvc2l0aW9uID09PSB1bmRlZmluZWQgPyB0cnVlIDogdHlwZW9mIGJvZHkuY29udGVudERpc3Bvc2l0aW9uID09PSBcInN0cmluZ1wiO1xufVxuZXhwb3J0cy5pc0JvZHkgPSBpc0JvZHk7XG4vLyBJZiB0aGUgQ29udGVudC1EaXNwb3NpdGlvbiBoZWFkZXIgZmllbGQgaXMgbWlzc2luZywgYm9kaWVzIG9mXG4vLyBDb250ZW50LVR5cGUgYXBwbGljYXRpb24vc2RwIGltcGx5IHRoZSBkaXNwb3NpdGlvbiBcInNlc3Npb25cIiwgd2hpbGVcbi8vIG90aGVyIGNvbnRlbnQgdHlwZXMgaW1wbHkgXCJyZW5kZXJcIi5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG5mdW5jdGlvbiBjb250ZW50VHlwZVRvQ29udGVudERpc3Bvc2l0aW9uKGNvbnRlbnRUeXBlKSB7XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3NkcFwiKSB7XG4gICAgICAgIHJldHVybiBcInNlc3Npb25cIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcInJlbmRlclwiO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWQ1XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3J5cHRvLWpzL21kNVwiKSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBEaWdlc3QgQXV0aGVudGljYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIERpZ2VzdEF1dGhlbnRpY2F0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBsb2dnZXJGYWN0b3J5IC0gTG9nZ2VyRmFjdG9yeS5cbiAgICAgKiBAcGFyYW0gdXNlcm5hbWUgLSBVc2VybmFtZS5cbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEaWdlc3RBdXRoZW50aWNhdGlvbihsb2dnZXJGYWN0b3J5LCB1c2VybmFtZSwgcGFzc3dvcmQpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXJGYWN0b3J5LmdldExvZ2dlcihcInNpcGpzLmRpZ2VzdGF1dGhlbnRpY2F0aW9uXCIpO1xuICAgICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcm5hbWU7XG4gICAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzd29yZDtcbiAgICAgICAgdGhpcy5uYyA9IDA7XG4gICAgICAgIHRoaXMubmNIZXggPSBcIjAwMDAwMDAwXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIERpZ2VzdCBhdXRoZW50aWNhdGlvbiBnaXZlbiBhIFNJUCByZXF1ZXN0IGFuZCB0aGUgY2hhbGxlbmdlXG4gICAgICogcmVjZWl2ZWQgaW4gYSByZXNwb25zZSB0byB0aGF0IHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLVxuICAgICAqIEBwYXJhbSBjaGFsbGVuZ2UgLVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgY3JlZGVudGlhbHMgd2VyZSBzdWNjZXNzZnVsbHkgZ2VuZXJhdGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgRGlnZXN0QXV0aGVudGljYXRpb24ucHJvdG90eXBlLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFsbGVuZ2UsIGJvZHkpIHtcbiAgICAgICAgLy8gSW5zcGVjdCBhbmQgdmFsaWRhdGUgdGhlIGNoYWxsZW5nZS5cbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBjaGFsbGVuZ2UuYWxnb3JpdGhtO1xuICAgICAgICB0aGlzLnJlYWxtID0gY2hhbGxlbmdlLnJlYWxtO1xuICAgICAgICB0aGlzLm5vbmNlID0gY2hhbGxlbmdlLm5vbmNlO1xuICAgICAgICB0aGlzLm9wYXF1ZSA9IGNoYWxsZW5nZS5vcGFxdWU7XG4gICAgICAgIHRoaXMuc3RhbGUgPSBjaGFsbGVuZ2Uuc3RhbGU7XG4gICAgICAgIGlmICh0aGlzLmFsZ29yaXRobSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxnb3JpdGhtICE9PSBcIk1ENVwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImNoYWxsZW5nZSB3aXRoIERpZ2VzdCBhbGdvcml0aG0gZGlmZmVyZW50IHRoYW4gJ01ENScsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBcIk1ENVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWFsbSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcImNoYWxsZW5nZSB3aXRob3V0IERpZ2VzdCByZWFsbSwgYXV0aGVudGljYXRpb24gYWJvcnRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubm9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3Qgbm9uY2UsIGF1dGhlbnRpY2F0aW9uIGFib3J0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gJ3FvcCcgY2FuIGNvbnRhaW4gYSBsaXN0IG9mIHZhbHVlcyAoQXJyYXkpLiBMZXQncyBjaG9vc2UganVzdCBvbmUuXG4gICAgICAgIGlmIChjaGFsbGVuZ2UucW9wKSB7XG4gICAgICAgICAgICBpZiAoY2hhbGxlbmdlLnFvcC5pbmRleE9mKFwiYXV0aFwiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xb3AgPSBcImF1dGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYWxsZW5nZS5xb3AuaW5kZXhPZihcImF1dGgtaW50XCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnFvcCA9IFwiYXV0aC1pbnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSAncW9wJyBpcyBwcmVzZW50IGJ1dCBkb2VzIG5vdCBjb250YWluICdhdXRoJyBvciAnYXV0aC1pbnQnLCBzbyBhYm9ydCBoZXJlLlxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJjaGFsbGVuZ2Ugd2l0aG91dCBEaWdlc3QgcW9wIGRpZmZlcmVudCB0aGFuICdhdXRoJyBvciAnYXV0aC1pbnQnLCBhdXRoZW50aWNhdGlvbiBhYm9ydGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucW9wID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbGwgb3RoZXIgYXR0cmlidXRlcy5cbiAgICAgICAgdGhpcy5tZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgdGhpcy51cmkgPSByZXF1ZXN0LnJ1cmk7XG4gICAgICAgIHRoaXMuY25vbmNlID0gdXRpbHNfMS5jcmVhdGVSYW5kb21Ub2tlbigxMik7XG4gICAgICAgIHRoaXMubmMgKz0gMTtcbiAgICAgICAgdGhpcy51cGRhdGVOY0hleCgpO1xuICAgICAgICAvLyBuYy12YWx1ZSA9IDhMSEVYLiBNYXggdmFsdWUgPSAnRkZGRkZGRkYnLlxuICAgICAgICBpZiAodGhpcy5uYyA9PT0gNDI5NDk2NzI5Nikge1xuICAgICAgICAgICAgdGhpcy5uYyA9IDE7XG4gICAgICAgICAgICB0aGlzLm5jSGV4ID0gXCIwMDAwMDAwMVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgRGlnZXN0IFwicmVzcG9uc2VcIiB2YWx1ZS5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVSZXNwb25zZShib2R5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFByb3h5LUF1dGhvcml6YXRpb24gb3IgV1dXLUF1dGhvcml6YXRpb24gaGVhZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIERpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGF1dGhQYXJhbXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXNwb25zZSBmaWVsZCBkb2VzIG5vdCBleGlzdCwgY2Fubm90IGdlbmVyYXRlIEF1dGhvcml6YXRpb24gaGVhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhQYXJhbXMucHVzaChcImFsZ29yaXRobT1cIiArIHRoaXMuYWxnb3JpdGhtKTtcbiAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCd1c2VybmFtZT1cIicgKyB0aGlzLnVzZXJuYW1lICsgJ1wiJyk7XG4gICAgICAgIGF1dGhQYXJhbXMucHVzaCgncmVhbG09XCInICsgdGhpcy5yZWFsbSArICdcIicpO1xuICAgICAgICBhdXRoUGFyYW1zLnB1c2goJ25vbmNlPVwiJyArIHRoaXMubm9uY2UgKyAnXCInKTtcbiAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCd1cmk9XCInICsgdGhpcy51cmkgKyAnXCInKTtcbiAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCdyZXNwb25zZT1cIicgKyB0aGlzLnJlc3BvbnNlICsgJ1wiJyk7XG4gICAgICAgIGlmICh0aGlzLm9wYXF1ZSkge1xuICAgICAgICAgICAgYXV0aFBhcmFtcy5wdXNoKCdvcGFxdWU9XCInICsgdGhpcy5vcGFxdWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xb3ApIHtcbiAgICAgICAgICAgIGF1dGhQYXJhbXMucHVzaChcInFvcD1cIiArIHRoaXMucW9wKTtcbiAgICAgICAgICAgIGF1dGhQYXJhbXMucHVzaCgnY25vbmNlPVwiJyArIHRoaXMuY25vbmNlICsgJ1wiJyk7XG4gICAgICAgICAgICBhdXRoUGFyYW1zLnB1c2goXCJuYz1cIiArIHRoaXMubmNIZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkRpZ2VzdCBcIiArIGF1dGhQYXJhbXMuam9pbihcIiwgXCIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlICduYycgdmFsdWUgYXMgcmVxdWlyZWQgYnkgRGlnZXN0IGluIHRoaXMubmNIZXggYnkgcmVhZGluZyB0aGlzLm5jLlxuICAgICAqL1xuICAgIERpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS51cGRhdGVOY0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhleCA9IE51bWJlcih0aGlzLm5jKS50b1N0cmluZygxNik7XG4gICAgICAgIHRoaXMubmNIZXggPSBcIjAwMDAwMDAwXCIuc3Vic3RyKDAsIDggLSBoZXgubGVuZ3RoKSArIGhleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIERpZ2VzdCAncmVzcG9uc2UnIHZhbHVlLlxuICAgICAqL1xuICAgIERpZ2VzdEF1dGhlbnRpY2F0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVSZXNwb25zZSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgIHZhciBoYTI7XG4gICAgICAgIC8vIEhBMSA9IE1ENShBMSkgPSBNRDUodXNlcm5hbWU6cmVhbG06cGFzc3dvcmQpXG4gICAgICAgIHZhciBoYTEgPSBtZDVfMS5kZWZhdWx0KHRoaXMudXNlcm5hbWUgKyBcIjpcIiArIHRoaXMucmVhbG0gKyBcIjpcIiArIHRoaXMucGFzc3dvcmQpO1xuICAgICAgICBpZiAodGhpcy5xb3AgPT09IFwiYXV0aFwiKSB7XG4gICAgICAgICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgICAgICAgICBoYTIgPSBtZDVfMS5kZWZhdWx0KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSk7XG4gICAgICAgICAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6bm9uY2VDb3VudDpjcmVkZW50aWFsc05vbmNlOnFvcDpIQTIpXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gbWQ1XzEuZGVmYXVsdChoYTEgKyBcIjpcIiArIHRoaXMubm9uY2UgKyBcIjpcIiArIHRoaXMubmNIZXggKyBcIjpcIiArIHRoaXMuY25vbmNlICsgXCI6YXV0aDpcIiArIGhhMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5xb3AgPT09IFwiYXV0aC1pbnRcIikge1xuICAgICAgICAgICAgLy8gSEEyID0gTUQ1KEEyKSA9IE1ENShtZXRob2Q6ZGlnZXN0VVJJOk1ENShlbnRpdHlCb2R5KSlcbiAgICAgICAgICAgIGhhMiA9IG1kNV8xLmRlZmF1bHQodGhpcy5tZXRob2QgKyBcIjpcIiArIHRoaXMudXJpICsgXCI6XCIgKyBtZDVfMS5kZWZhdWx0KGJvZHkgPyBib2R5IDogXCJcIikpO1xuICAgICAgICAgICAgLy8gcmVzcG9uc2UgPSBNRDUoSEExOm5vbmNlOm5vbmNlQ291bnQ6Y3JlZGVudGlhbHNOb25jZTpxb3A6SEEyKVxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IG1kNV8xLmRlZmF1bHQoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyB0aGlzLm5jSGV4ICsgXCI6XCIgKyB0aGlzLmNub25jZSArIFwiOmF1dGgtaW50OlwiICsgaGEyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnFvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBIQTIgPSBNRDUoQTIpID0gTUQ1KG1ldGhvZDpkaWdlc3RVUkkpXG4gICAgICAgICAgICBoYTIgPSBtZDVfMS5kZWZhdWx0KHRoaXMubWV0aG9kICsgXCI6XCIgKyB0aGlzLnVyaSk7XG4gICAgICAgICAgICAvLyByZXNwb25zZSA9IE1ENShIQTE6bm9uY2U6SEEyKVxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IG1kNV8xLmRlZmF1bHQoaGExICsgXCI6XCIgKyB0aGlzLm5vbmNlICsgXCI6XCIgKyBoYTIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGlnZXN0QXV0aGVudGljYXRpb247XG59KCkpO1xuZXhwb3J0cy5EaWdlc3RBdXRoZW50aWNhdGlvbiA9IERpZ2VzdEF1dGhlbnRpY2F0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBwZWdHcmFtbWFyID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL2dyYW1tYXIvZGlzdC9ncmFtbWFyXCIpKTtcbi8qKlxuICogR3JhbW1hci5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgR3JhbW1hcjtcbihmdW5jdGlvbiAoR3JhbW1hcikge1xuICAgIC8qKlxuICAgICAqIFBhcnNlLlxuICAgICAqIEBwYXJhbSBpbnB1dCAtXG4gICAgICogQHBhcmFtIHN0YXJ0UnVsZSAtXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2UoaW5wdXQsIHN0YXJ0UnVsZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHsgc3RhcnRSdWxlOiBzdGFydFJ1bGUgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBlZ0dyYW1tYXIucGFyc2UoaW5wdXQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5kYXRhO1xuICAgIH1cbiAgICBHcmFtbWFyLnBhcnNlID0gcGFyc2U7XG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyBhIFNJUC5OYW1lQWRkckhlYWRlciBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWZcbiAgICAgKiBpdCBpcyBhbiBpbnZhbGlkIE5hbWVBZGRySGVhZGVyLlxuICAgICAqIEBwYXJhbSBuYW1lX2FkZHJfaGVhZGVyIC1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuYW1lQWRkckhlYWRlclBhcnNlKG5hbWVBZGRySGVhZGVyKSB7XG4gICAgICAgIHZhciBwYXJzZWROYW1lQWRkckhlYWRlciA9IEdyYW1tYXIucGFyc2UobmFtZUFkZHJIZWFkZXIsIFwiTmFtZV9BZGRyX0hlYWRlclwiKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZE5hbWVBZGRySGVhZGVyICE9PSAtMSA/IHBhcnNlZE5hbWVBZGRySGVhZGVyIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBHcmFtbWFyLm5hbWVBZGRySGVhZGVyUGFyc2UgPSBuYW1lQWRkckhlYWRlclBhcnNlO1xuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgYSBTSVAuVVJJIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZlxuICAgICAqIGl0IGlzIGFuIGludmFsaWQgVVJJLlxuICAgICAqIEBwYXJhbSB1cmkgLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVSSVBhcnNlKHVyaSkge1xuICAgICAgICB2YXIgcGFyc2VkVXJpID0gR3JhbW1hci5wYXJzZSh1cmksIFwiU0lQX1VSSVwiKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFVyaSAhPT0gLTEgPyBwYXJzZWRVcmkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEdyYW1tYXIuVVJJUGFyc2UgPSBVUklQYXJzZTtcbn0pKEdyYW1tYXIgPSBleHBvcnRzLkdyYW1tYXIgfHwgKGV4cG9ydHMuR3JhbW1hciA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFtbWFyXzEgPSByZXF1aXJlKFwiLi9ncmFtbWFyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogSW5jb21pbmcgbWVzc2FnZS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEluY29taW5nTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmNvbWluZ01lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnQgYSBoZWFkZXIgb2YgdGhlIGdpdmVuIG5hbWUgYW5kIHZhbHVlIGludG8gdGhlIGxhc3QgcG9zaXRpb24gb2YgdGhlXG4gICAgICogaGVhZGVyIGFycmF5LlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBoZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLmFkZEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGVhZGVyID0geyByYXc6IHZhbHVlIH07XG4gICAgICAgIG5hbWUgPSB1dGlsc18xLmhlYWRlcml6ZShuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW25hbWVdLnB1c2goaGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1tuYW1lXSA9IFtoZWFkZXJdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIHVuZGVmaW5lZCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldO1xuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlYWRlclswXS5yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIEFycmF5IC0gd2l0aCBhbGwgdGhlIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAqL1xuICAgIEluY29taW5nTWVzc2FnZS5wcm90b3R5cGUuZ2V0SGVhZGVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBoZWFkZXJfMSA9IGhlYWRlcjsgX2kgPCBoZWFkZXJfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJQYXJ0ID0gaGVhZGVyXzFbX2ldO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaGVhZGVyUGFydC5yYXcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWZXJpZnkgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGhlYWRlciB3aXRoIGdpdmVuIG5hbWUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLmhhc0hlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuaGVhZGVyc1t1dGlsc18xLmhlYWRlcml6ZShuYW1lKV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIG9uIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHBhcmFtIGlkeCAtIGhlYWRlciBpbmRleFxuICAgICAqIEByZXR1cm5zIFBhcnNlZCBoZWFkZXIgb2JqZWN0LCB1bmRlZmluZWQgaWYgdGhlXG4gICAgICogICBoZWFkZXIgaXMgbm90IHByZXNlbnQgb3IgaW4gY2FzZSBvZiBhIHBhcnNpbmcgZXJyb3IuXG4gICAgICovXG4gICAgSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCBpZHgpIHtcbiAgICAgICAgaWYgKGlkeCA9PT0gdm9pZCAwKSB7IGlkeCA9IDA7IH1cbiAgICAgICAgbmFtZSA9IHV0aWxzXzEuaGVhZGVyaXplKG5hbWUpO1xuICAgICAgICBpZiAoIXRoaXMuaGVhZGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgLy8gdGhpcy5sb2dnZXIubG9nKFwiaGVhZGVyICdcIiArIG5hbWUgKyBcIicgbm90IHByZXNlbnRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWR4ID49IHRoaXMuaGVhZGVyc1tuYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubG9nZ2VyLmxvZyhcIm5vdCBzbyBtYW55ICdcIiArIG5hbWUgKyBcIicgaGVhZGVycyBwcmVzZW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXIgPSB0aGlzLmhlYWRlcnNbbmFtZV1baWR4XTtcbiAgICAgICAgdmFyIHZhbHVlID0gaGVhZGVyLnJhdztcbiAgICAgICAgaWYgKGhlYWRlci5wYXJzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZWFkZXIucGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1YnN0aXR1dGUgJy0nIGJ5ICdfJyBmb3IgZ3JhbW1hciBydWxlIG1hdGNoaW5nLlxuICAgICAgICB2YXIgcGFyc2VkID0gZ3JhbW1hcl8xLkdyYW1tYXIucGFyc2UodmFsdWUsIG5hbWUucmVwbGFjZSgvLS9nLCBcIl9cIikpO1xuICAgICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW25hbWVdLnNwbGljZShpZHgsIDEpOyAvLyBkZWxldGUgZnJvbSBoZWFkZXJzXG4gICAgICAgICAgICAvLyB0aGlzLmxvZ2dlci53YXJuKCdlcnJvciBwYXJzaW5nIFwiJyArIG5hbWUgKyAnXCIgaGVhZGVyIGZpZWxkIHdpdGggdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlci5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIEhlYWRlciBhdHRyaWJ1dGUgc2VsZWN0b3IuIEFsaWFzIG9mIHBhcnNlSGVhZGVyLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gaWR4IC0gaGVhZGVyIGluZGV4XG4gICAgICogQHJldHVybnMgUGFyc2VkIGhlYWRlciBvYmplY3QsIHVuZGVmaW5lZCBpZiB0aGVcbiAgICAgKiAgIGhlYWRlciBpcyBub3QgcHJlc2VudCBvciBpbiBjYXNlIG9mIGEgcGFyc2luZyBlcnJvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbWVzc2FnZS5zKCd2aWEnLDMpLnBvcnRcbiAgICAgKi9cbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLnMgPSBmdW5jdGlvbiAobmFtZSwgaWR4KSB7XG4gICAgICAgIGlmIChpZHggPT09IHZvaWQgMCkgeyBpZHggPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGVhZGVyKG5hbWUsIGlkeCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gaGVhZGVyIGJ5IHRoZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIGhlYWRlciBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlIC0gaGVhZGVyIHZhbHVlXG4gICAgICovXG4gICAgSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW3V0aWxzXzEuaGVhZGVyaXplKG5hbWUpXSA9IFt7IHJhdzogdmFsdWUgfV07XG4gICAgfTtcbiAgICBJbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIEluY29taW5nTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLkluY29taW5nTWVzc2FnZSA9IEluY29taW5nTWVzc2FnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgaW5jb21pbmdfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vaW5jb21pbmctbWVzc2FnZVwiKTtcbi8qKlxuICogSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlLlxuICogQHB1YmxpY1xuICovXG52YXIgSW5jb21pbmdSZXF1ZXN0TWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbmNvbWluZ1JlcXVlc3RNZXNzYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluY29taW5nUmVxdWVzdE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5jb21pbmdSZXF1ZXN0TWVzc2FnZTtcbn0oaW5jb21pbmdfbWVzc2FnZV8xLkluY29taW5nTWVzc2FnZSkpO1xuZXhwb3J0cy5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlID0gSW5jb21pbmdSZXF1ZXN0TWVzc2FnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgaW5jb21pbmdfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vaW5jb21pbmctbWVzc2FnZVwiKTtcbi8qKlxuICogSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIEluY29taW5nUmVzcG9uc2VNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEluY29taW5nUmVzcG9uc2VNZXNzYWdlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluY29taW5nUmVzcG9uc2VNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEluY29taW5nUmVzcG9uc2VNZXNzYWdlO1xufShpbmNvbWluZ19tZXNzYWdlXzEuSW5jb21pbmdNZXNzYWdlKSk7XG5leHBvcnRzLkluY29taW5nUmVzcG9uc2VNZXNzYWdlID0gSW5jb21pbmdSZXNwb25zZU1lc3NhZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLy8gRGlyZWN0b3JpZXNcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21ldGhvZHNcIiksIGV4cG9ydHMpO1xuLy8gRmlsZXNcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JvZHlcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGlnZXN0LWF1dGhlbnRpY2F0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dyYW1tYXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5jb21pbmctbWVzc2FnZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2VcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5jb21pbmctcmVzcG9uc2UtbWVzc2FnZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9uYW1lLWFkZHItaGVhZGVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL291dGdvaW5nLXJlcXVlc3QtbWVzc2FnZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vdXRnb2luZy1yZXNwb25zZVwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wYXJhbWV0ZXJzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhcnNlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91cmlcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNJUCBNZXRob2RzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIEM7XG4oZnVuY3Rpb24gKEMpIHtcbiAgICBDLkFDSyA9IFwiQUNLXCI7XG4gICAgQy5CWUUgPSBcIkJZRVwiO1xuICAgIEMuQ0FOQ0VMID0gXCJDQU5DRUxcIjtcbiAgICBDLklORk8gPSBcIklORk9cIjtcbiAgICBDLklOVklURSA9IFwiSU5WSVRFXCI7XG4gICAgQy5NRVNTQUdFID0gXCJNRVNTQUdFXCI7XG4gICAgQy5OT1RJRlkgPSBcIk5PVElGWVwiO1xuICAgIEMuT1BUSU9OUyA9IFwiT1BUSU9OU1wiO1xuICAgIEMuUkVHSVNURVIgPSBcIlJFR0lTVEVSXCI7XG4gICAgQy5VUERBVEUgPSBcIlVQREFURVwiO1xuICAgIEMuU1VCU0NSSUJFID0gXCJTVUJTQ1JJQkVcIjtcbiAgICBDLlBVQkxJU0ggPSBcIlBVQkxJU0hcIjtcbiAgICBDLlJFRkVSID0gXCJSRUZFUlwiO1xuICAgIEMuUFJBQ0sgPSBcIlBSQUNLXCI7XG59KShDID0gZXhwb3J0cy5DIHx8IChleHBvcnRzLkMgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL3BhcmFtZXRlcnNcIik7XG4vKipcbiAqIE5hbWUgQWRkcmVzcyBTSVAgaGVhZGVyLlxuICogQHB1YmxpY1xuICovXG52YXIgTmFtZUFkZHJIZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTmFtZUFkZHJIZWFkZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdXJpIC1cbiAgICAgKiBAcGFyYW0gZGlzcGxheU5hbWUgLVxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBOYW1lQWRkckhlYWRlcih1cmksIGRpc3BsYXlOYW1lLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBhcmFtZXRlcnMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgX3RoaXMuX2Rpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVBZGRySGVhZGVyLnByb3RvdHlwZSwgXCJmcmllbmRseU5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMudXJpLmFvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5hbWVBZGRySGVhZGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5TmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGlzcGxheU5hbWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5TmFtZSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBOYW1lQWRkckhlYWRlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmFtZUFkZHJIZWFkZXIodGhpcy51cmkuY2xvbmUoKSwgdGhpcy5fZGlzcGxheU5hbWUsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKSkpO1xuICAgIH07XG4gICAgTmFtZUFkZHJIZWFkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9keSA9ICh0aGlzLmRpc3BsYXlOYW1lIHx8IHRoaXMuZGlzcGxheU5hbWUgPT09IFwiMFwiKSA/ICdcIicgKyB0aGlzLmRpc3BsYXlOYW1lICsgJ1wiICcgOiBcIlwiO1xuICAgICAgICBib2R5ICs9IFwiPFwiICsgdGhpcy51cmkudG9TdHJpbmcoKSArIFwiPlwiO1xuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICBib2R5ICs9IFwiO1wiICsgcGFyYW1ldGVyO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ICs9IFwiPVwiICsgdGhpcy5wYXJhbWV0ZXJzW3BhcmFtZXRlcl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG4gICAgcmV0dXJuIE5hbWVBZGRySGVhZGVyO1xufShwYXJhbWV0ZXJzXzEuUGFyYW1ldGVycykpO1xuZXhwb3J0cy5OYW1lQWRkckhlYWRlciA9IE5hbWVBZGRySGVhZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBuYW1lX2FkZHJfaGVhZGVyXzEgPSByZXF1aXJlKFwiLi9uYW1lLWFkZHItaGVhZGVyXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogT3V0Z29pbmcgU0lQIHJlcXVlc3QgbWVzc2FnZS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXRob2QsIHJ1cmksIGZyb21VUkksIHRvVVJJLCBvcHRpb25zLCBleHRyYUhlYWRlcnMsIGJvZHkpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuZXh0cmFIZWFkZXJzID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgLy8gT3B0aW9ucyAtIG1lcmdlIGEgZGVlcCBjb3B5XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcHRpb25UYWdzICYmIHRoaXMub3B0aW9ucy5vcHRpb25UYWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcHRpb25UYWdzID0gdGhpcy5vcHRpb25zLm9wdGlvblRhZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucm91dGVTZXQgJiYgdGhpcy5vcHRpb25zLnJvdXRlU2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yb3V0ZVNldCA9IHRoaXMub3B0aW9ucy5yb3V0ZVNldC5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV4dHJhIGhlYWRlcnMgLSBkZWVwIGNvcHlcbiAgICAgICAgaWYgKGV4dHJhSGVhZGVycyAmJiBleHRyYUhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhSGVhZGVycyA9IGV4dHJhSGVhZGVycy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvZHkgLSBkZWVwIGNvcHlcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGludGVybmFsIHJlcHJlc2VudGF0aW9uIHNob3VsZCBiZSBCb2R5XG4gICAgICAgICAgICAvLyB0aGlzLmJvZHkgPSB7IC4uLmJvZHkgfTtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IGJvZHkuY29udGVudFR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWV0aG9kXG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAvLyBSVVJJXG4gICAgICAgIHRoaXMucnVyaSA9IHJ1cmkuY2xvbmUoKTtcbiAgICAgICAgLy8gRnJvbVxuICAgICAgICB0aGlzLmZyb21VUkkgPSBmcm9tVVJJLmNsb25lKCk7XG4gICAgICAgIHRoaXMuZnJvbVRhZyA9IHRoaXMub3B0aW9ucy5mcm9tVGFnID8gdGhpcy5vcHRpb25zLmZyb21UYWcgOiB1dGlsc18xLm5ld1RhZygpO1xuICAgICAgICB0aGlzLmZyb20gPSBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLm1ha2VOYW1lQWRkckhlYWRlcih0aGlzLmZyb21VUkksIHRoaXMub3B0aW9ucy5mcm9tRGlzcGxheU5hbWUsIHRoaXMuZnJvbVRhZyk7XG4gICAgICAgIC8vIFRvXG4gICAgICAgIHRoaXMudG9VUkkgPSB0b1VSSS5jbG9uZSgpO1xuICAgICAgICB0aGlzLnRvVGFnID0gdGhpcy5vcHRpb25zLnRvVGFnO1xuICAgICAgICB0aGlzLnRvID0gT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5tYWtlTmFtZUFkZHJIZWFkZXIodGhpcy50b1VSSSwgdGhpcy5vcHRpb25zLnRvRGlzcGxheU5hbWUsIHRoaXMudG9UYWcpO1xuICAgICAgICAvLyBDYWxsLUlEXG4gICAgICAgIHRoaXMuY2FsbElkID0gdGhpcy5vcHRpb25zLmNhbGxJZCA/IHRoaXMub3B0aW9ucy5jYWxsSWQgOiB0aGlzLm9wdGlvbnMuY2FsbElkUHJlZml4ICsgdXRpbHNfMS5jcmVhdGVSYW5kb21Ub2tlbigxNSk7XG4gICAgICAgIC8vIENTZXFcbiAgICAgICAgdGhpcy5jc2VxID0gdGhpcy5vcHRpb25zLmNzZXE7XG4gICAgICAgIC8vIFRoZSByZWxhdGl2ZSBvcmRlciBvZiBoZWFkZXIgZmllbGRzIHdpdGggZGlmZmVyZW50IGZpZWxkIG5hbWVzIGlzIG5vdFxuICAgICAgICAvLyBzaWduaWZpY2FudC4gIEhvd2V2ZXIsIGl0IGlzIFJFQ09NTUVOREVEIHRoYXQgaGVhZGVyIGZpZWxkcyB3aGljaCBhcmVcbiAgICAgICAgLy8gbmVlZGVkIGZvciBwcm94eSBwcm9jZXNzaW5nIChWaWEsIFJvdXRlLCBSZWNvcmQtUm91dGUsIFByb3h5LVJlcXVpcmUsXG4gICAgICAgIC8vIE1heC1Gb3J3YXJkcywgYW5kIFByb3h5LUF1dGhvcml6YXRpb24sIGZvciBleGFtcGxlKSBhcHBlYXIgdG93YXJkc1xuICAgICAgICAvLyB0aGUgdG9wIG9mIHRoZSBtZXNzYWdlIHRvIGZhY2lsaXRhdGUgcmFwaWQgcGFyc2luZy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi03LjMuMVxuICAgICAgICB0aGlzLnNldEhlYWRlcihcInJvdXRlXCIsIHRoaXMub3B0aW9ucy5yb3V0ZVNldCk7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwidmlhXCIsIFwiXCIpO1xuICAgICAgICB0aGlzLnNldEhlYWRlcihcInRvXCIsIHRoaXMudG8udG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwiZnJvbVwiLCB0aGlzLmZyb20udG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwiY3NlcVwiLCB0aGlzLmNzZXEgKyBcIiBcIiArIHRoaXMubWV0aG9kKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJjYWxsLWlkXCIsIHRoaXMuY2FsbElkKTtcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoXCJtYXgtZm9yd2FyZHNcIiwgXCI3MFwiKTtcbiAgICB9XG4gICAgLyoqIEdldCBhIGNvcHkgb2YgdGhlIGRlZmF1bHQgb3B0aW9ucy4gKi9cbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLmdldERlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FsbElkOiBcIlwiLFxuICAgICAgICAgICAgY2FsbElkUHJlZml4OiBcIlwiLFxuICAgICAgICAgICAgY3NlcTogMSxcbiAgICAgICAgICAgIHRvRGlzcGxheU5hbWU6IFwiXCIsXG4gICAgICAgICAgICB0b1RhZzogXCJcIixcbiAgICAgICAgICAgIGZyb21EaXNwbGF5TmFtZTogXCJcIixcbiAgICAgICAgICAgIGZyb21UYWc6IFwiXCIsXG4gICAgICAgICAgICBmb3JjZVJwb3J0OiBmYWxzZSxcbiAgICAgICAgICAgIGhhY2tWaWFUY3A6IGZhbHNlLFxuICAgICAgICAgICAgb3B0aW9uVGFnczogW1wib3V0Ym91bmRcIl0sXG4gICAgICAgICAgICByb3V0ZVNldDogW10sXG4gICAgICAgICAgICB1c2VyQWdlbnRTdHJpbmc6IFwic2lwLmpzXCIsXG4gICAgICAgICAgICB2aWFIb3N0OiBcIlwiXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLm1ha2VOYW1lQWRkckhlYWRlciA9IGZ1bmN0aW9uICh1cmksIGRpc3BsYXlOYW1lLCB0YWcpIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgcGFyYW1ldGVycy50YWcgPSB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBuYW1lX2FkZHJfaGVhZGVyXzEuTmFtZUFkZHJIZWFkZXIodXJpLCBkaXNwbGF5TmFtZSwgcGFyYW1ldGVycyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBoZWFkZXIgbmFtZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHNwZWNpZmllZCBoZWFkZXIsIHVuZGVmaW5lZCBpZiBoZWFkZXIgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXJzW3V0aWxzXzEuaGVhZGVyaXplKG5hbWUpXTtcbiAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgaWYgKGhlYWRlclswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChcIl5cXFxccypcIiArIG5hbWUgKyBcIlxcXFxzKjpcIiwgXCJpXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZXh0cmFIZWFkZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBleEhlYWRlciA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXhwLnRlc3QoZXhIZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleEhlYWRlci5zdWJzdHJpbmcoZXhIZWFkZXIuaW5kZXhPZihcIjpcIikgKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGVhZGVyL3Mgb2YgdGhlIGdpdmVuIG5hbWUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIEFycmF5IHdpdGggYWxsIHRoZSBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKi9cbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS5nZXRIZWFkZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB2YXIgaGVhZGVyQXJyYXkgPSB0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldO1xuICAgICAgICBpZiAoaGVhZGVyQXJyYXkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgaGVhZGVyQXJyYXlfMSA9IGhlYWRlckFycmF5OyBfaSA8IGhlYWRlckFycmF5XzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlclBhcnQgPSBoZWFkZXJBcnJheV8xW19pXTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChoZWFkZXJQYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqOlwiLCBcImlcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gdGhpcy5leHRyYUhlYWRlcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4SGVhZGVyID0gX2JbX2FdO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChleEhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZXhIZWFkZXIuc3Vic3RyaW5nKGV4SGVhZGVyLmluZGV4T2YoXCI6XCIpICsgMSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmeSB0aGUgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBoZWFkZXIuXG4gICAgICogQHBhcmFtIG5hbWUgLSBoZWFkZXIgbmFtZVxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgaGVhZGVyIHdpdGggZ2l2ZW4gbmFtZSBleGlzdHMsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIE91dGdvaW5nUmVxdWVzdE1lc3NhZ2UucHJvdG90eXBlLmhhc0hlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnNbdXRpbHNfMS5oZWFkZXJpemUobmFtZSldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICsgbmFtZSArIFwiXFxcXHMqOlwiLCBcImlcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5leHRyYUhlYWRlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhSGVhZGVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChleHRyYUhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIHRoZSBnaXZlbiBoZWFkZXIgYnkgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAqIEBwYXJhbSBuYW1lIC0gaGVhZGVyIG5hbWVcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBoZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS5zZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzW3V0aWxzXzEuaGVhZGVyaXplKG5hbWUpXSA9ICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBWaWEgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdHJhbnNwb3J0IHVzZWQgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIGFuZCBpZGVudGlmaWVzIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgc2VudC4gIEEgVmlhXG4gICAgICogaGVhZGVyIGZpZWxkIHZhbHVlIGlzIGFkZGVkIG9ubHkgYWZ0ZXIgdGhlIHRyYW5zcG9ydCB0aGF0IHdpbGwgYmVcbiAgICAgKiB1c2VkIHRvIHJlYWNoIHRoZSBuZXh0IGhvcCBoYXMgYmVlbiBzZWxlY3RlZCAod2hpY2ggbWF5IGludm9sdmUgdGhlXG4gICAgICogdXNhZ2Ugb2YgdGhlIHByb2NlZHVyZXMgaW4gWzRdKS5cbiAgICAgKlxuICAgICAqIFdoZW4gdGhlIFVBQyBjcmVhdGVzIGEgcmVxdWVzdCwgaXQgTVVTVCBpbnNlcnQgYSBWaWEgaW50byB0aGF0XG4gICAgICogcmVxdWVzdC4gIFRoZSBwcm90b2NvbCBuYW1lIGFuZCBwcm90b2NvbCB2ZXJzaW9uIGluIHRoZSBoZWFkZXIgZmllbGRcbiAgICAgKiBNVVNUIGJlIFNJUCBhbmQgMi4wLCByZXNwZWN0aXZlbHkuICBUaGUgVmlhIGhlYWRlciBmaWVsZCB2YWx1ZSBNVVNUXG4gICAgICogY29udGFpbiBhIGJyYW5jaCBwYXJhbWV0ZXIuICBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZVxuICAgICAqIHRyYW5zYWN0aW9uIGNyZWF0ZWQgYnkgdGhhdCByZXF1ZXN0LiAgVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCBieSBib3RoXG4gICAgICogdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlci5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4xLjdcbiAgICAgKiBAcGFyYW0gYnJhbmNoUGFyYW1ldGVyIC0gVGhlIGJyYW5jaCBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydCAtIFRoZSBzZW50IHByb3RvY29sIHRyYW5zcG9ydC5cbiAgICAgKi9cbiAgICBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlLnByb3RvdHlwZS5zZXRWaWFIZWFkZXIgPSBmdW5jdGlvbiAoYnJhbmNoLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgLy8gRklYTUU6IEhhY2tcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYWNrVmlhVGNwKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBcIlRDUFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWEgPSBcIlNJUC8yLjAvXCIgKyB0cmFuc3BvcnQ7XG4gICAgICAgIHZpYSArPSBcIiBcIiArIHRoaXMub3B0aW9ucy52aWFIb3N0ICsgXCI7YnJhbmNoPVwiICsgYnJhbmNoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmNlUnBvcnQpIHtcbiAgICAgICAgICAgIHZpYSArPSBcIjtycG9ydFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKFwidmlhXCIsIHZpYSk7XG4gICAgICAgIHRoaXMuYnJhbmNoID0gYnJhbmNoO1xuICAgIH07XG4gICAgT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtc2cgPSBcIlwiO1xuICAgICAgICBtc2cgKz0gdGhpcy5tZXRob2QgKyBcIiBcIiArIHRoaXMucnVyaS50b1JhdygpICsgXCIgU0lQLzIuMFxcclxcblwiO1xuICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5oZWFkZXJzW2hlYWRlcl07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJQYXJ0ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBtc2cgKz0gaGVhZGVyICsgXCI6IFwiICsgaGVhZGVyUGFydCArIFwiXFxyXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLmV4dHJhSGVhZGVyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXIgPSBfY1tfYl07XG4gICAgICAgICAgICBtc2cgKz0gaGVhZGVyLnRyaW0oKSArIFwiXFxyXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgbXNnICs9IFwiU3VwcG9ydGVkOiBcIiArIHRoaXMub3B0aW9ucy5vcHRpb25UYWdzLmpvaW4oXCIsIFwiKSArIFwiXFxyXFxuXCI7XG4gICAgICAgIG1zZyArPSBcIlVzZXItQWdlbnQ6IFwiICsgdGhpcy5vcHRpb25zLnVzZXJBZ2VudFN0cmluZyArIFwiXFxyXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmJvZHkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5ib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgdXRpbHNfMS5zdHJfdXRmOF9sZW5ndGgodGhpcy5ib2R5KSArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgICAgICAgICAgbXNnICs9IHRoaXMuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZHkuYm9keSAmJiB0aGlzLmJvZHkuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiQ29udGVudC1UeXBlOiBcIiArIHRoaXMuYm9keS5jb250ZW50VHlwZSArIFwiXFxyXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArIHV0aWxzXzEuc3RyX3V0ZjhfbGVuZ3RoKHRoaXMuYm9keS5ib2R5KSArIFwiXFxyXFxuXFxyXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSB0aGlzLmJvZHkuYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyArPSBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArIDAgKyBcIlxcclxcblxcclxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1zZyArPSBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArIDAgKyBcIlxcclxcblxcclxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLk91dGdvaW5nUmVxdWVzdE1lc3NhZ2UgPSBPdXRnb2luZ1JlcXVlc3RNZXNzYWdlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBXaGVuIGEgVUFTIHdpc2hlcyB0byBjb25zdHJ1Y3QgYSByZXNwb25zZSB0byBhIHJlcXVlc3QsIGl0IGZvbGxvd3NcbiAqIHRoZSBnZW5lcmFsIHByb2NlZHVyZXMgZGV0YWlsZWQgaW4gdGhlIGZvbGxvd2luZyBzdWJzZWN0aW9ucy5cbiAqIEFkZGl0aW9uYWwgYmVoYXZpb3JzIHNwZWNpZmljIHRvIHRoZSByZXNwb25zZSBjb2RlIGluIHF1ZXN0aW9uLCB3aGljaFxuICogYXJlIG5vdCBkZXRhaWxlZCBpbiB0aGlzIHNlY3Rpb24sIG1heSBhbHNvIGJlIHJlcXVpcmVkLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2UobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHZhciBDUkxGID0gXCJcXHJcXG5cIjtcbiAgICBpZiAob3B0aW9ucy5zdGF0dXNDb2RlIDwgMTAwIHx8IG9wdGlvbnMuc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBzdGF0dXNDb2RlOiBcIiArIG9wdGlvbnMuc3RhdHVzQ29kZSk7XG4gICAgfVxuICAgIHZhciByZWFzb25QaHJhc2UgPSBvcHRpb25zLnJlYXNvblBocmFzZSA/IG9wdGlvbnMucmVhc29uUGhyYXNlIDogdXRpbHNfMS5nZXRSZWFzb25QaHJhc2Uob3B0aW9ucy5zdGF0dXNDb2RlKTtcbiAgICAvLyBTSVAgcmVzcG9uc2VzIGFyZSBkaXN0aW5ndWlzaGVkIGZyb20gcmVxdWVzdHMgYnkgaGF2aW5nIGEgU3RhdHVzLUxpbmVcbiAgICAvLyBhcyB0aGVpciBzdGFydC1saW5lLiAgQSBTdGF0dXMtTGluZSBjb25zaXN0cyBvZiB0aGUgcHJvdG9jb2wgdmVyc2lvblxuICAgIC8vIGZvbGxvd2VkIGJ5IGEgbnVtZXJpYyBTdGF0dXMtQ29kZSBhbmQgaXRzIGFzc29jaWF0ZWQgdGV4dHVhbCBwaHJhc2UsXG4gICAgLy8gd2l0aCBlYWNoIGVsZW1lbnQgc2VwYXJhdGVkIGJ5IGEgc2luZ2xlIFNQIGNoYXJhY3Rlci5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTcuMlxuICAgIHZhciByZXNwb25zZSA9IFwiU0lQLzIuMCBcIiArIG9wdGlvbnMuc3RhdHVzQ29kZSArIFwiIFwiICsgcmVhc29uUGhyYXNlICsgQ1JMRjtcbiAgICAvLyBPbmUgbGFyZ2VseSBub24tbWV0aG9kLXNwZWNpZmljIGd1aWRlbGluZSBmb3IgdGhlIGdlbmVyYXRpb24gb2ZcbiAgICAvLyByZXNwb25zZXMgaXMgdGhhdCBVQVNzIFNIT1VMRCBOT1QgaXNzdWUgYSBwcm92aXNpb25hbCByZXNwb25zZSBmb3IgYVxuICAgIC8vIG5vbi1JTlZJVEUgcmVxdWVzdC4gIFJhdGhlciwgVUFTcyBTSE9VTEQgZ2VuZXJhdGUgYSBmaW5hbCByZXNwb25zZSB0b1xuICAgIC8vIGEgbm9uLUlOVklURSByZXF1ZXN0IGFzIHNvb24gYXMgcG9zc2libGUuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuNi4xXG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA+PSAxMDAgJiYgb3B0aW9ucy5zdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICB9XG4gICAgLy8gV2hlbiBhIDEwMCAoVHJ5aW5nKSByZXNwb25zZSBpcyBnZW5lcmF0ZWQsIGFueSBUaW1lc3RhbXAgaGVhZGVyIGZpZWxkXG4gICAgLy8gcHJlc2VudCBpbiB0aGUgcmVxdWVzdCBNVVNUIGJlIGNvcGllZCBpbnRvIHRoaXMgMTAwIChUcnlpbmcpXG4gICAgLy8gcmVzcG9uc2UuICBJZiB0aGVyZSBpcyBhIGRlbGF5IGluIGdlbmVyYXRpbmcgdGhlIHJlc3BvbnNlLCB0aGUgVUFTXG4gICAgLy8gU0hPVUxEIGFkZCBhIGRlbGF5IHZhbHVlIGludG8gdGhlIFRpbWVzdGFtcCB2YWx1ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgLy8gVGhpcyB2YWx1ZSBNVVNUIGNvbnRhaW4gdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdGltZSBvZiBzZW5kaW5nIG9mXG4gICAgLy8gdGhlIHJlc3BvbnNlIGFuZCByZWNlaXB0IG9mIHRoZSByZXF1ZXN0LCBtZWFzdXJlZCBpbiBzZWNvbmRzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjYuMVxuICAgIGlmIChvcHRpb25zLnN0YXR1c0NvZGUgPT09IDEwMCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgfVxuICAgIC8vIFRoZSBGcm9tIGZpZWxkIG9mIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoZSBGcm9tIGhlYWRlciBmaWVsZCBvZlxuICAgIC8vIHRoZSByZXF1ZXN0LiAgVGhlIENhbGwtSUQgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoZVxuICAgIC8vIENhbGwtSUQgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0LiAgVGhlIENTZXEgaGVhZGVyIGZpZWxkIG9mIHRoZVxuICAgIC8vIHJlc3BvbnNlIE1VU1QgZXF1YWwgdGhlIENTZXEgZmllbGQgb2YgdGhlIHJlcXVlc3QuICBUaGUgVmlhIGhlYWRlclxuICAgIC8vIGZpZWxkIHZhbHVlcyBpbiB0aGUgcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGUgVmlhIGhlYWRlciBmaWVsZCB2YWx1ZXNcbiAgICAvLyBpbiB0aGUgcmVxdWVzdCBhbmQgTVVTVCBtYWludGFpbiB0aGUgc2FtZSBvcmRlcmluZy5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42LjJcbiAgICB2YXIgZnJvbUhlYWRlciA9IFwiRnJvbTogXCIgKyBtZXNzYWdlLmdldEhlYWRlcihcIkZyb21cIikgKyBDUkxGO1xuICAgIHZhciBjYWxsSWRIZWFkZXIgPSBcIkNhbGwtSUQ6IFwiICsgbWVzc2FnZS5jYWxsSWQgKyBDUkxGO1xuICAgIHZhciBjU2VxSGVhZGVyID0gXCJDU2VxOiBcIiArIG1lc3NhZ2UuY3NlcSArIFwiIFwiICsgbWVzc2FnZS5tZXRob2QgKyBDUkxGO1xuICAgIHZhciB2aWFIZWFkZXJzID0gbWVzc2FnZS5nZXRIZWFkZXJzKFwidmlhXCIpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzICsgXCJWaWE6IFwiICsgY3VycmVudCArIENSTEY7XG4gICAgfSwgXCJcIik7XG4gICAgLy8gSWYgYSByZXF1ZXN0IGNvbnRhaW5lZCBhIFRvIHRhZyBpbiB0aGUgcmVxdWVzdCwgdGhlIFRvIGhlYWRlciBmaWVsZFxuICAgIC8vIGluIHRoZSByZXNwb25zZSBNVVNUIGVxdWFsIHRoYXQgb2YgdGhlIHJlcXVlc3QuICBIb3dldmVyLCBpZiB0aGUgVG9cbiAgICAvLyBoZWFkZXIgZmllbGQgaW4gdGhlIHJlcXVlc3QgZGlkIG5vdCBjb250YWluIGEgdGFnLCB0aGUgVVJJIGluIHRoZSBUb1xuICAgIC8vIGhlYWRlciBmaWVsZCBpbiB0aGUgcmVzcG9uc2UgTVVTVCBlcXVhbCB0aGUgVVJJIGluIHRoZSBUbyBoZWFkZXJcbiAgICAvLyBmaWVsZDsgYWRkaXRpb25hbGx5LCB0aGUgVUFTIE1VU1QgYWRkIGEgdGFnIHRvIHRoZSBUbyBoZWFkZXIgZmllbGQgaW5cbiAgICAvLyB0aGUgcmVzcG9uc2UgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgMTAwIChUcnlpbmcpIHJlc3BvbnNlLCBpblxuICAgIC8vIHdoaWNoIGEgdGFnIE1BWSBiZSBwcmVzZW50KS4gIFRoaXMgc2VydmVzIHRvIGlkZW50aWZ5IHRoZSBVQVMgdGhhdCBpc1xuICAgIC8vIHJlc3BvbmRpbmcsIHBvc3NpYmx5IHJlc3VsdGluZyBpbiBhIGNvbXBvbmVudCBvZiBhIGRpYWxvZyBJRC4gIFRoZVxuICAgIC8vIHNhbWUgdGFnIE1VU1QgYmUgdXNlZCBmb3IgYWxsIHJlc3BvbnNlcyB0byB0aGF0IHJlcXVlc3QsIGJvdGggZmluYWxcbiAgICAvLyBhbmQgcHJvdmlzaW9uYWwgKGFnYWluIGV4Y2VwdGluZyB0aGUgMTAwIChUcnlpbmcpKS5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42LjJcbiAgICB2YXIgdG9IZWFkZXIgPSBcIlRvOiBcIiArIG1lc3NhZ2UuZ2V0SGVhZGVyKFwidG9cIik7XG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzQ29kZSA+IDEwMCAmJiAhbWVzc2FnZS5wYXJzZUhlYWRlcihcInRvXCIpLmhhc1BhcmFtKFwidGFnXCIpKSB7XG4gICAgICAgIHZhciB0b1RhZyA9IG9wdGlvbnMudG9UYWc7XG4gICAgICAgIGlmICghdG9UYWcpIHtcbiAgICAgICAgICAgIC8vIFN0YXRlbGVzcyBVQVMgQmVoYXZpb3IuLi5cbiAgICAgICAgICAgIC8vIG8gIFRvIGhlYWRlciB0YWdzIE1VU1QgYmUgZ2VuZXJhdGVkIGZvciByZXNwb25zZXMgaW4gYSBzdGF0ZWxlc3NcbiAgICAgICAgICAgIC8vICAgIG1hbm5lciAtIGluIGEgbWFubmVyIHRoYXQgd2lsbCBnZW5lcmF0ZSB0aGUgc2FtZSB0YWcgZm9yIHRoZVxuICAgICAgICAgICAgLy8gICAgc2FtZSByZXF1ZXN0IGNvbnNpc3RlbnRseS4gIEZvciBpbmZvcm1hdGlvbiBvbiB0YWcgY29uc3RydWN0aW9uXG4gICAgICAgICAgICAvLyAgICBzZWUgU2VjdGlvbiAxOS4zLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuN1xuICAgICAgICAgICAgdG9UYWcgPSB1dGlsc18xLm5ld1RhZygpOyAvLyBGSVhNRTogbmV3VGFnKCkgY3VycmVudGx5IGdlbmVyYXRlcyByYW5kb20gdGFnc1xuICAgICAgICB9XG4gICAgICAgIHRvSGVhZGVyICs9IFwiO3RhZz1cIiArIHRvVGFnO1xuICAgIH1cbiAgICB0b0hlYWRlciArPSBDUkxGO1xuICAgIC8vIEZJWE1FOiBUT0RPOiBuZWVkcyByZXZpZXcuLi4gbW92ZWQgdG8gSW52aXRlVXNlckFnZW50U2VydmVyIChhcyBpdCBpcyBzcGVjaWZpYyB0byB0aGF0KVxuICAgIC8vIGxldCByZWNvcmRSb3V0ZUhlYWRlcnMgPSBcIlwiO1xuICAgIC8vIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gQy5JTlZJVEUgJiYgc3RhdHVzQ29kZSA+IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDIwMCkge1xuICAgIC8vICAgcmVjb3JkUm91dGVIZWFkZXJzID0gcmVxdWVzdC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIHByZXZpb3VzICsgXCJSZWNvcmQtUm91dGU6IFwiICsgY3VycmVudCArIENSTEY7XG4gICAgLy8gICB9LCBcIlwiKTtcbiAgICAvLyB9XG4gICAgLy8gRklYTUU6IFRPRE86IG5lZWRzIHJldmlldy4uLlxuICAgIHZhciBzdXBwb3J0ZWRIZWFkZXIgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLnN1cHBvcnRlZCkge1xuICAgICAgICBzdXBwb3J0ZWRIZWFkZXIgPSBcIlN1cHBvcnRlZDogXCIgKyBvcHRpb25zLnN1cHBvcnRlZC5qb2luKFwiLCBcIikgKyBDUkxGO1xuICAgIH1cbiAgICAvLyBGSVhNRTogVE9ETzogbmVlZHMgcmV2aWV3Li4uXG4gICAgdmFyIHVzZXJBZ2VudEhlYWRlciA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMudXNlckFnZW50KSB7XG4gICAgICAgIHVzZXJBZ2VudEhlYWRlciA9IFwiVXNlci1BZ2VudDogXCIgKyBvcHRpb25zLnVzZXJBZ2VudCArIENSTEY7XG4gICAgfVxuICAgIHZhciBleHRlbnNpb25IZWFkZXJzID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5leHRyYUhlYWRlcnMpIHtcbiAgICAgICAgZXh0ZW5zaW9uSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyArIGN1cnJlbnQudHJpbSgpICsgQ1JMRjtcbiAgICAgICAgfSwgXCJcIik7XG4gICAgfVxuICAgIC8vIFRoZSByZWxhdGl2ZSBvcmRlciBvZiBoZWFkZXIgZmllbGRzIHdpdGggZGlmZmVyZW50IGZpZWxkIG5hbWVzIGlzIG5vdFxuICAgIC8vIHNpZ25pZmljYW50LiAgSG93ZXZlciwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBoZWFkZXIgZmllbGRzIHdoaWNoIGFyZVxuICAgIC8vIG5lZWRlZCBmb3IgcHJveHkgcHJvY2Vzc2luZyAoVmlhLCBSb3V0ZSwgUmVjb3JkLVJvdXRlLCBQcm94eS1SZXF1aXJlLFxuICAgIC8vIE1heC1Gb3J3YXJkcywgYW5kIFByb3h5LUF1dGhvcml6YXRpb24sIGZvciBleGFtcGxlKSBhcHBlYXIgdG93YXJkc1xuICAgIC8vIHRoZSB0b3Agb2YgdGhlIG1lc3NhZ2UgdG8gZmFjaWxpdGF0ZSByYXBpZCBwYXJzaW5nLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tNy4zLjFcbiAgICAvLyByZXNwb25zZSArPSByZWNvcmRSb3V0ZUhlYWRlcnM7XG4gICAgcmVzcG9uc2UgKz0gdmlhSGVhZGVycztcbiAgICByZXNwb25zZSArPSBmcm9tSGVhZGVyO1xuICAgIHJlc3BvbnNlICs9IHRvSGVhZGVyO1xuICAgIHJlc3BvbnNlICs9IGNTZXFIZWFkZXI7XG4gICAgcmVzcG9uc2UgKz0gY2FsbElkSGVhZGVyO1xuICAgIHJlc3BvbnNlICs9IHN1cHBvcnRlZEhlYWRlcjtcbiAgICByZXNwb25zZSArPSB1c2VyQWdlbnRIZWFkZXI7XG4gICAgcmVzcG9uc2UgKz0gZXh0ZW5zaW9uSGVhZGVycztcbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgIHJlc3BvbnNlICs9IFwiQ29udGVudC1UeXBlOiBcIiArIG9wdGlvbnMuYm9keS5jb250ZW50VHlwZSArIENSTEY7XG4gICAgICAgIHJlc3BvbnNlICs9IFwiQ29udGVudC1MZW5ndGg6IFwiICsgdXRpbHNfMS5zdHJfdXRmOF9sZW5ndGgob3B0aW9ucy5ib2R5LmNvbnRlbnQpICsgQ1JMRiArIENSTEY7XG4gICAgICAgIHJlc3BvbnNlICs9IG9wdGlvbnMuYm9keS5jb250ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2UgKz0gXCJDb250ZW50LUxlbmd0aDogXCIgKyAwICsgQ1JMRiArIENSTEY7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2U6IHJlc3BvbnNlIH07XG59XG5leHBvcnRzLmNvbnN0cnVjdE91dGdvaW5nUmVzcG9uc2UgPSBjb25zdHJ1Y3RPdXRnb2luZ1Jlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUGFyYW1ldGVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gICAgICAgIGZvciAodmFyIHBhcmFtIGluIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFyYW0ocGFyYW0sIHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRQYXJhbSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlID09PSBudWxsKSA/IG51bGwgOiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRQYXJhbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1ldGVyc1trZXkudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcmFtZXRlcnMucHJvdG90eXBlLmhhc1BhcmFtID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLnBhcmFtZXRlcnMuaGFzT3duUHJvcGVydHkoa2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFBhcmFtZXRlcnMucHJvdG90eXBlLmRlbGV0ZVBhcmFtID0gZnVuY3Rpb24gKHBhcmFtZXRlcikge1xuICAgICAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eShwYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtZXRlcnNbcGFyYW1ldGVyXTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyYW1ldGVycy5wcm90b3R5cGUuY2xlYXJQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyYW1ldGVycyA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtZXRlcnM7XG59KCkpO1xuZXhwb3J0cy5QYXJhbWV0ZXJzID0gUGFyYW1ldGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYW1tYXJfMSA9IHJlcXVpcmUoXCIuL2dyYW1tYXJcIik7XG52YXIgaW5jb21pbmdfcmVxdWVzdF9tZXNzYWdlXzEgPSByZXF1aXJlKFwiLi9pbmNvbWluZy1yZXF1ZXN0LW1lc3NhZ2VcIik7XG52YXIgaW5jb21pbmdfcmVzcG9uc2VfbWVzc2FnZV8xID0gcmVxdWlyZShcIi4vaW5jb21pbmctcmVzcG9uc2UtbWVzc2FnZVwiKTtcbi8qKlxuICogRXh0cmFjdCBhbmQgcGFyc2UgZXZlcnkgaGVhZGVyIG9mIGEgU0lQIG1lc3NhZ2UuXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFBhcnNlcjtcbihmdW5jdGlvbiAoUGFyc2VyKSB7XG4gICAgZnVuY3Rpb24gZ2V0SGVhZGVyKGRhdGEsIGhlYWRlclN0YXJ0KSB7XG4gICAgICAgIC8vICdzdGFydCcgcG9zaXRpb24gb2YgdGhlIGhlYWRlci5cbiAgICAgICAgdmFyIHN0YXJ0ID0gaGVhZGVyU3RhcnQ7XG4gICAgICAgIC8vICdlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgICAgIHZhciBlbmQgPSAwO1xuICAgICAgICAvLyAncGFydGlhbCBlbmQnIHBvc2l0aW9uIG9mIHRoZSBoZWFkZXIuXG4gICAgICAgIHZhciBwYXJ0aWFsRW5kID0gMDtcbiAgICAgICAgLy8gRW5kIG9mIG1lc3NhZ2UuXG4gICAgICAgIGlmIChkYXRhLnN1YnN0cmluZyhzdGFydCwgc3RhcnQgKyAyKS5tYXRjaCgvKF5cXHJcXG4pLykpIHtcbiAgICAgICAgICAgIHJldHVybiAtMjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZW5kID09PSAwKSB7XG4gICAgICAgICAgICAvLyBQYXJ0aWFsIEVuZCBvZiBIZWFkZXIuXG4gICAgICAgICAgICBwYXJ0aWFsRW5kID0gZGF0YS5pbmRleE9mKFwiXFxyXFxuXCIsIHN0YXJ0KTtcbiAgICAgICAgICAgIC8vICdpbmRleE9mJyByZXR1cm5zIC0xIGlmIHRoZSB2YWx1ZSB0byBiZSBmb3VuZCBuZXZlciBvY2N1cnMuXG4gICAgICAgICAgICBpZiAocGFydGlhbEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YS5zdWJzdHJpbmcocGFydGlhbEVuZCArIDIsIHBhcnRpYWxFbmQgKyA0KS5tYXRjaCgvKF5cXHJcXG4pLykgJiZcbiAgICAgICAgICAgICAgICBkYXRhLmNoYXJBdChwYXJ0aWFsRW5kICsgMikubWF0Y2goLyheXFxzKykvKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCB0aGUgZW5kIG9mIHRoZSBtZXNzYWdlLiBDb250aW51ZSBmcm9tIHRoZSBuZXh0IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGFydGlhbEVuZCArIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBwYXJ0aWFsRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIFBhcnNlci5nZXRIZWFkZXIgPSBnZXRIZWFkZXI7XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIobWVzc2FnZSwgZGF0YSwgaGVhZGVyU3RhcnQsIGhlYWRlckVuZCkge1xuICAgICAgICB2YXIgaGNvbG9uSW5kZXggPSBkYXRhLmluZGV4T2YoXCI6XCIsIGhlYWRlclN0YXJ0KTtcbiAgICAgICAgdmFyIGhlYWRlck5hbWUgPSBkYXRhLnN1YnN0cmluZyhoZWFkZXJTdGFydCwgaGNvbG9uSW5kZXgpLnRyaW0oKTtcbiAgICAgICAgdmFyIGhlYWRlclZhbHVlID0gZGF0YS5zdWJzdHJpbmcoaGNvbG9uSW5kZXggKyAxLCBoZWFkZXJFbmQpLnRyaW0oKTtcbiAgICAgICAgdmFyIHBhcnNlZDtcbiAgICAgICAgLy8gSWYgaGVhZGVyLWZpZWxkIGlzIHdlbGwta25vd24sIHBhcnNlIGl0LlxuICAgICAgICBzd2l0Y2ggKGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInZpYVwiOlxuICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcihcInZpYVwiLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZ2V0SGVhZGVycyhcInZpYVwiKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gbWVzc2FnZS5wYXJzZUhlYWRlcihcIlZpYVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52aWEgPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZpYUJyYW5jaCA9IHBhcnNlZC5icmFuY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZyb21cIjpcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zZXRIZWFkZXIoXCJmcm9tXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiZnJvbVwiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnJvbSA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tVGFnID0gcGFyc2VkLmdldFBhcmFtKFwidGFnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b1wiOlxuICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcInRvXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwidG9cIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvVGFnID0gcGFyc2VkLmdldFBhcmFtKFwidGFnXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZWNvcmQtcm91dGVcIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBncmFtbWFyXzEuR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgXCJSZWNvcmRfUm91dGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRIZWFkZXIoXCJyZWNvcmQtcm91dGVcIiwgaGVhZGVyVmFsdWUuc3Vic3RyaW5nKGhlYWRlci5wb3NpdGlvbiwgaGVhZGVyLm9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlcnNbXCJSZWNvcmQtUm91dGVcIl1bbWVzc2FnZS5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpLmxlbmd0aCAtIDFdLnBhcnNlZCA9IGhlYWRlci5wYXJzZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2FsbC1pZFwiOlxuICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNhbGwtaWRcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjYWxsLWlkXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYWxsSWQgPSBoZWFkZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29udGFjdFwiOlxuICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBncmFtbWFyXzEuR3JhbW1hci5wYXJzZShoZWFkZXJWYWx1ZSwgXCJDb250YWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkSGVhZGVyKFwiY29udGFjdFwiLCBoZWFkZXJWYWx1ZS5zdWJzdHJpbmcoaGVhZGVyLnBvc2l0aW9uLCBoZWFkZXIub2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVycy5Db250YWN0W21lc3NhZ2UuZ2V0SGVhZGVycyhcImNvbnRhY3RcIikubGVuZ3RoIC0gMV0ucGFyc2VkID0gaGVhZGVyLnBhcnNlZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50LWxlbmd0aFwiOlxuICAgICAgICAgICAgY2FzZSBcImxcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNvbnRlbnQtbGVuZ3RoXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGVudC1sZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY29udGVudC10eXBlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNzZXFcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcImNzZXFcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJjc2VxXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jc2VxID0gcGFyc2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIGluY29taW5nX3Jlc3BvbnNlX21lc3NhZ2VfMS5JbmNvbWluZ1Jlc3BvbnNlTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1heC1mb3J3YXJkc1wiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwibWF4LWZvcndhcmRzXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwibWF4LWZvcndhcmRzXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInd3dy1hdXRoZW50aWNhdGVcIjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNldEhlYWRlcihcInd3dy1hdXRoZW50aWNhdGVcIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJ3d3ctYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInByb3h5LWF1dGhlbnRpY2F0ZVwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwicHJveHktYXV0aGVudGljYXRlXCIsIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwicHJveHktYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJlZmVyLXRvXCI6XG4gICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwicmVmZXItdG9cIiwgaGVhZGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJyZWZlci10b1wiKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVmZXJUbyA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBwYXJzZSB0aGlzIGhlYWRlci5cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZEhlYWRlcihoZWFkZXJOYW1lLnRvTG93ZXJDYXNlKCksIGhlYWRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogXCJlcnJvciBwYXJzaW5nIGhlYWRlciAnXCIgKyBoZWFkZXJOYW1lICsgXCInXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZXIucGFyc2VIZWFkZXIgPSBwYXJzZUhlYWRlcjtcbiAgICBmdW5jdGlvbiBwYXJzZU1lc3NhZ2UoZGF0YSwgbG9nZ2VyKSB7XG4gICAgICAgIHZhciBoZWFkZXJTdGFydCA9IDA7XG4gICAgICAgIHZhciBoZWFkZXJFbmQgPSBkYXRhLmluZGV4T2YoXCJcXHJcXG5cIik7XG4gICAgICAgIGlmIChoZWFkZXJFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIm5vIENSTEYgZm91bmQsIG5vdCBhIFNJUCBtZXNzYWdlLCBkaXNjYXJkZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgZmlyc3QgbGluZS4gQ2hlY2sgaWYgaXQgaXMgYSBSZXF1ZXN0IG9yIGEgUmVwbHkuXG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBkYXRhLnN1YnN0cmluZygwLCBoZWFkZXJFbmQpO1xuICAgICAgICB2YXIgcGFyc2VkID0gZ3JhbW1hcl8xLkdyYW1tYXIucGFyc2UoZmlyc3RMaW5lLCBcIlJlcXVlc3RfUmVzcG9uc2VcIik7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAocGFyc2VkID09PSAtMSkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2Vycm9yIHBhcnNpbmcgZmlyc3QgbGluZSBvZiBTSVAgbWVzc2FnZTogXCInICsgZmlyc3RMaW5lICsgJ1wiJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXBhcnNlZC5zdGF0dXNfY29kZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IG5ldyBpbmNvbWluZ19yZXF1ZXN0X21lc3NhZ2VfMS5JbmNvbWluZ1JlcXVlc3RNZXNzYWdlKCk7XG4gICAgICAgICAgICBtZXNzYWdlLm1ldGhvZCA9IHBhcnNlZC5tZXRob2Q7XG4gICAgICAgICAgICBtZXNzYWdlLnJ1cmkgPSBwYXJzZWQudXJpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IG5ldyBpbmNvbWluZ19yZXNwb25zZV9tZXNzYWdlXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UoKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RhdHVzQ29kZSA9IHBhcnNlZC5zdGF0dXNfY29kZTtcbiAgICAgICAgICAgIG1lc3NhZ2UucmVhc29uUGhyYXNlID0gcGFyc2VkLnJlYXNvbl9waHJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5kYXRhID0gZGF0YTtcbiAgICAgICAgaGVhZGVyU3RhcnQgPSBoZWFkZXJFbmQgKyAyO1xuICAgICAgICAvLyBMb29wIG92ZXIgZXZlcnkgbGluZSBpbiBkYXRhLiBEZXRlY3QgdGhlIGVuZCBvZiBlYWNoIGhlYWRlciBhbmQgcGFyc2VcbiAgICAgICAgLy8gaXQgb3Igc2ltcGx5IGFkZCB0byB0aGUgaGVhZGVycyBjb2xsZWN0aW9uLlxuICAgICAgICB2YXIgYm9keVN0YXJ0O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaGVhZGVyRW5kID0gZ2V0SGVhZGVyKGRhdGEsIGhlYWRlclN0YXJ0KTtcbiAgICAgICAgICAgIC8vIFRoZSBTSVAgbWVzc2FnZSBoYXMgbm9ybWFsbHkgZmluaXNoZWQuXG4gICAgICAgICAgICBpZiAoaGVhZGVyRW5kID09PSAtMikge1xuICAgICAgICAgICAgICAgIGJvZHlTdGFydCA9IGhlYWRlclN0YXJ0ICsgMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhlYWRlckVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRhLmluZGV4T2YgcmV0dXJuZWQgLTEgZHVlIHRvIGEgbWFsZm9ybWVkIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwibWFsZm9ybWVkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnNlZEhlYWRlciA9IHBhcnNlSGVhZGVyKG1lc3NhZ2UsIGRhdGEsIGhlYWRlclN0YXJ0LCBoZWFkZXJFbmQpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZEhlYWRlciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihwYXJzZWQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlclN0YXJ0ID0gaGVhZGVyRW5kICsgMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSRkMzMjYxIDE4LjMuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIGJ5dGVzIGluIHRoZSB0cmFuc3BvcnQgcGFja2V0XG4gICAgICAgIC8vIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBib2R5LCB0aGV5IE1VU1QgYmUgZGlzY2FyZGVkLlxuICAgICAgICBpZiAobWVzc2FnZS5oYXNIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKSkge1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5ID0gZGF0YS5zdWJzdHIoYm9keVN0YXJ0LCBOdW1iZXIobWVzc2FnZS5nZXRIZWFkZXIoXCJjb250ZW50LWxlbmd0aFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZS5ib2R5ID0gZGF0YS5zdWJzdHJpbmcoYm9keVN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgUGFyc2VyLnBhcnNlTWVzc2FnZSA9IHBhcnNlTWVzc2FnZTtcbn0pKFBhcnNlciA9IGV4cG9ydHMuUGFyc2VyIHx8IChleHBvcnRzLlBhcnNlciA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHBhcmFtZXRlcnNfMSA9IHJlcXVpcmUoXCIuL3BhcmFtZXRlcnNcIik7XG4vKipcbiAqIFVSSS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFVSSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhVUkksIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gc2NoZW1lIC1cbiAgICAgKiBAcGFyYW0gdXNlciAtXG4gICAgICogQHBhcmFtIGhvc3QgLVxuICAgICAqIEBwYXJhbSBwb3J0IC1cbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtXG4gICAgICogQHBhcmFtIGhlYWRlcnMgLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVSSShzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhcmFtZXRlcnMsIGhlYWRlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1ldGVycykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICAvLyBDaGVja3NcbiAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIG9yIGludmFsaWQgXCJob3N0XCIgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzXG4gICAgICAgIHNjaGVtZSA9IHNjaGVtZSB8fCBcInNpcFwiO1xuICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEhlYWRlcihoZWFkZXIsIGhlYWRlcnNbaGVhZGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmF3IFVSSVxuICAgICAgICBfdGhpcy5yYXcgPSB7XG4gICAgICAgICAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgcG9ydDogcG9ydFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb3JtYWxpemVkIFVSSVxuICAgICAgICBfdGhpcy5ub3JtYWwgPSB7XG4gICAgICAgICAgICBzY2hlbWU6IHNjaGVtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgdXNlcjogdXNlcixcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJJLnByb3RvdHlwZSwgXCJzY2hlbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsLnNjaGVtZTsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LnNjaGVtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwuc2NoZW1lID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSSS5wcm90b3R5cGUsIFwidXNlclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5ub3JtYWwudXNlcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsLnVzZXIgPSB0aGlzLnJhdy51c2VyID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkkucHJvdG90eXBlLCBcImhvc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsLmhvc3Q7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5ob3N0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbC5ob3N0ID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVSSS5wcm90b3R5cGUsIFwiYW9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vcm1hbC51c2VyICsgXCJAXCIgKyB0aGlzLm5vcm1hbC5ob3N0OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJJLnByb3RvdHlwZSwgXCJwb3J0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLm5vcm1hbC5wb3J0OyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ub3JtYWwucG9ydCA9IHRoaXMucmF3LnBvcnQgPSB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFVSSS5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1t0aGlzLmhlYWRlcml6ZShuYW1lKV0gPSAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLmdldEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzW3RoaXMuaGVhZGVyaXplKG5hbWUpXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVVJJLnByb3RvdHlwZS5oYXNIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gISFuYW1lICYmICEhdGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KHRoaXMuaGVhZGVyaXplKG5hbWUpKTtcbiAgICB9O1xuICAgIFVSSS5wcm90b3R5cGUuZGVsZXRlSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICBoZWFkZXIgPSB0aGlzLmhlYWRlcml6ZShoZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLmNsZWFySGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSSSh0aGlzLl9yYXcuc2NoZW1lLCB0aGlzLl9yYXcudXNlciB8fCBcIlwiLCB0aGlzLl9yYXcuaG9zdCwgdGhpcy5fcmF3LnBvcnQsIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXJhbWV0ZXJzKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5oZWFkZXJzKSkpO1xuICAgIH07XG4gICAgVVJJLnByb3RvdHlwZS50b1JhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nKHRoaXMuX3Jhdyk7XG4gICAgfTtcbiAgICBVUkkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9TdHJpbmcodGhpcy5fbm9ybWFsKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVUkkucHJvdG90eXBlLCBcIl9ub3JtYWxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubm9ybWFsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVVJJLnByb3RvdHlwZSwgXCJfcmF3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJhdzsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVVJJLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodXJpKSB7XG4gICAgICAgIHZhciB1cmlTdHJpbmcgPSB1cmkuc2NoZW1lICsgXCI6XCI7XG4gICAgICAgIC8vIGFkZCBzbGFzaGVzIGlmIGl0J3Mgbm90IGEgc2lwKHMpIFVSSVxuICAgICAgICBpZiAoIXVyaS5zY2hlbWUudG9Mb3dlckNhc2UoKS5tYXRjaChcIl5zaXBzPyRcIikpIHtcbiAgICAgICAgICAgIHVyaVN0cmluZyArPSBcIi8vXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaS51c2VyKSB7XG4gICAgICAgICAgICB1cmlTdHJpbmcgKz0gdGhpcy5lc2NhcGVVc2VyKHVyaS51c2VyKSArIFwiQFwiO1xuICAgICAgICB9XG4gICAgICAgIHVyaVN0cmluZyArPSB1cmkuaG9zdDtcbiAgICAgICAgaWYgKHVyaS5wb3J0IHx8IHVyaS5wb3J0ID09PSAwKSB7XG4gICAgICAgICAgICB1cmlTdHJpbmcgKz0gXCI6XCIgKyB1cmkucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwYXJhbWV0ZXIgaW4gdGhpcy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgICAgICB1cmlTdHJpbmcgKz0gXCI7XCIgKyBwYXJhbWV0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVyaVN0cmluZyArPSBcIj1cIiArIHRoaXMucGFyYW1ldGVyc1twYXJhbWV0ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBoZWFkZXIgaW4gdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkZXJzLmhhc093blByb3BlcnR5KGhlYWRlcikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggaW4gdGhpcy5oZWFkZXJzW2hlYWRlcl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGVhZGVyc1toZWFkZXJdLmhhc093blByb3BlcnR5KGlkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChoZWFkZXIgKyBcIj1cIiArIHRoaXMuaGVhZGVyc1toZWFkZXJdW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVyaVN0cmluZyArPSBcIj9cIiArIGhlYWRlcnMuam9pbihcIiZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaVN0cmluZztcbiAgICB9O1xuICAgIC8qXG4gICAgICogSGV4LWVzY2FwZSBhIFNJUCBVUkkgdXNlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICAgICovXG4gICAgVVJJLnByb3RvdHlwZS5lc2NhcGVVc2VyID0gZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgdmFyIGRlY29kZWRVc2VyO1xuICAgICAgICAvLyBGSVhNRTogVGhpcyBpcyBjYWxsZWQgYnkgdG9TdHJpbmcgYWJvdmUgd2hpY2ggc2hvdWxkIG5ldmVyIHRocm93LCBidXRcbiAgICAgICAgLy8gZGVjb2RlVVJJQ29tcG9uZW50IGNhbiB0aHJvdyBhbmQgSSd2ZSBzZWVuIG9uZSBjYXNlIGluIHByb2R1Y3Rpb24gd2hlcmVcbiAgICAgICAgLy8gaXQgZGlkIHRocm93IHJlc3VsdGluZyBpbiBhIGNhc2NhZGluZyBmYWlsdXJlLiBUaGlzIGNsYXNzIHNob3VsZCBiZVxuICAgICAgICAvLyBmaXhlZCBzbyB0aGF0IGRlY29kZVVSSUNvbXBvbmVudCBpcyBub3QgY2FsbGVkIGF0IHRoaXMgcG9pbnQgKGluIHRvU3RyaW5nKS5cbiAgICAgICAgLy8gVGhlIHVzZXIgc2hvdWxkIGJlIGRlY29kZWQgd2hlbiB0aGUgVVJJIGlzIGNvbnN0cnVjdG9yIG9yIHNvbWUgb3RoZXJcbiAgICAgICAgLy8gcGxhY2Ugd2hlcmUgd2UgY2FuIGNhdGNoIHRoZSBlcnJvciBiZWZvcmUgdGhlIFVSSSBpcyBjcmVhdGVkIG9yIHNvbWVzdWNoLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVjb2RlZFVzZXIgPSBkZWNvZGVVUklDb21wb25lbnQodXNlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBoZXgtZXNjYXBlICc6JyAoJTNBKSwgJysnICglMkIpLCAnPycgKCUzRlwiKSwgJy8nICglMkYpLlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZWRVc2VyKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUzQS9pZywgXCI6XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJCL2lnLCBcIitcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8lM0YvaWcsIFwiP1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyUyRi9pZywgXCIvXCIpO1xuICAgIH07XG4gICAgVVJJLnByb3RvdHlwZS5oZWFkZXJpemUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBleGNlcHRpb25zID0ge1xuICAgICAgICAgICAgXCJDYWxsLUlkXCI6IFwiQ2FsbC1JRFwiLFxuICAgICAgICAgICAgXCJDc2VxXCI6IFwiQ1NlcVwiLFxuICAgICAgICAgICAgXCJNaW4tU2VcIjogXCJNaW4tU0VcIixcbiAgICAgICAgICAgIFwiUmFja1wiOiBcIlJBY2tcIixcbiAgICAgICAgICAgIFwiUnNlcVwiOiBcIlJTZXFcIixcbiAgICAgICAgICAgIFwiV3d3LUF1dGhlbnRpY2F0ZVwiOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5hbWUgPSBzdHIudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9fL2csIFwiLVwiKS5zcGxpdChcIi1cIik7XG4gICAgICAgIHZhciBwYXJ0cyA9IG5hbWUubGVuZ3RoO1xuICAgICAgICB2YXIgaG5hbWUgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBwYXJ0ID0gMDsgcGFydCA8IHBhcnRzOyBwYXJ0KyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaG5hbWUgKz0gXCItXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBobmFtZSArPSBuYW1lW3BhcnRdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZVtwYXJ0XS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2VwdGlvbnNbaG5hbWVdKSB7XG4gICAgICAgICAgICBobmFtZSA9IGV4Y2VwdGlvbnNbaG5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBobmFtZTtcbiAgICB9O1xuICAgIHJldHVybiBVUkk7XG59KHBhcmFtZXRlcnNfMS5QYXJhbWV0ZXJzKSk7XG5leHBvcnRzLlVSSSA9IFVSSTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAcGFyYW0gc2l6ZSAtXG4gKiBAcGFyYW0gYmFzZSAtXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZG9tVG9rZW4oc2l6ZSwgYmFzZSkge1xuICAgIGlmIChiYXNlID09PSB2b2lkIDApIHsgYmFzZSA9IDMyOyB9XG4gICAgdmFyIHRva2VuID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGJhc2UpO1xuICAgICAgICB0b2tlbiArPSByLnRvU3RyaW5nKGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW47XG59XG5leHBvcnRzLmNyZWF0ZVJhbmRvbVRva2VuID0gY3JlYXRlUmFuZG9tVG9rZW47XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRSZWFzb25QaHJhc2UoY29kZSkge1xuICAgIHJldHVybiBSRUFTT05fUEhSQVNFW2NvZGVdIHx8IFwiXCI7XG59XG5leHBvcnRzLmdldFJlYXNvblBocmFzZSA9IGdldFJlYXNvblBocmFzZTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5ld1RhZygpIHtcbiAgICByZXR1cm4gY3JlYXRlUmFuZG9tVG9rZW4oMTApO1xufVxuZXhwb3J0cy5uZXdUYWcgPSBuZXdUYWc7XG4vKipcbiAqIEBwYXJhbSBzdHIgLVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhlYWRlcml6ZShzdHIpIHtcbiAgICB2YXIgZXhjZXB0aW9ucyA9IHtcbiAgICAgICAgXCJDYWxsLUlkXCI6IFwiQ2FsbC1JRFwiLFxuICAgICAgICBcIkNzZXFcIjogXCJDU2VxXCIsXG4gICAgICAgIFwiTWluLVNlXCI6IFwiTWluLVNFXCIsXG4gICAgICAgIFwiUmFja1wiOiBcIlJBY2tcIixcbiAgICAgICAgXCJSc2VxXCI6IFwiUlNlcVwiLFxuICAgICAgICBcIld3dy1BdXRoZW50aWNhdGVcIjogXCJXV1ctQXV0aGVudGljYXRlXCIsXG4gICAgfTtcbiAgICB2YXIgbmFtZSA9IHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18vZywgXCItXCIpLnNwbGl0KFwiLVwiKTtcbiAgICB2YXIgcGFydHMgPSBuYW1lLmxlbmd0aDtcbiAgICB2YXIgaG5hbWUgPSBcIlwiO1xuICAgIGZvciAodmFyIHBhcnQgPSAwOyBwYXJ0IDwgcGFydHM7IHBhcnQrKykge1xuICAgICAgICBpZiAocGFydCAhPT0gMCkge1xuICAgICAgICAgICAgaG5hbWUgKz0gXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgaG5hbWUgKz0gbmFtZVtwYXJ0XS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWVbcGFydF0uc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoZXhjZXB0aW9uc1tobmFtZV0pIHtcbiAgICAgICAgaG5hbWUgPSBleGNlcHRpb25zW2huYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIGhuYW1lO1xufVxuZXhwb3J0cy5oZWFkZXJpemUgPSBoZWFkZXJpemU7XG4vKipcbiAqIEBwYXJhbSBzdHIgLVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHN0cl91dGY4X2xlbmd0aChzdHIpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvJVtBLUZcXGRdezJ9L2csIFwiVVwiKS5sZW5ndGg7XG59XG5leHBvcnRzLnN0cl91dGY4X2xlbmd0aCA9IHN0cl91dGY4X2xlbmd0aDtcbi8qKlxuICogU0lQIFJlc3BvbnNlIFJlYXNvbnNcbiAqIERPQzogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9zaXAtcGFyYW1ldGVyc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSRUFTT05fUEhSQVNFID0ge1xuICAgIDEwMDogXCJUcnlpbmdcIixcbiAgICAxODA6IFwiUmluZ2luZ1wiLFxuICAgIDE4MTogXCJDYWxsIElzIEJlaW5nIEZvcndhcmRlZFwiLFxuICAgIDE4MjogXCJRdWV1ZWRcIixcbiAgICAxODM6IFwiU2Vzc2lvbiBQcm9ncmVzc1wiLFxuICAgIDE5OTogXCJFYXJseSBEaWFsb2cgVGVybWluYXRlZFwiLFxuICAgIDIwMDogXCJPS1wiLFxuICAgIDIwMjogXCJBY2NlcHRlZFwiLFxuICAgIDIwNDogXCJObyBOb3RpZmljYXRpb25cIixcbiAgICAzMDA6IFwiTXVsdGlwbGUgQ2hvaWNlc1wiLFxuICAgIDMwMTogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICAgIDMwMjogXCJNb3ZlZCBUZW1wb3JhcmlseVwiLFxuICAgIDMwNTogXCJVc2UgUHJveHlcIixcbiAgICAzODA6IFwiQWx0ZXJuYXRpdmUgU2VydmljZVwiLFxuICAgIDQwMDogXCJCYWQgUmVxdWVzdFwiLFxuICAgIDQwMTogXCJVbmF1dGhvcml6ZWRcIixcbiAgICA0MDI6IFwiUGF5bWVudCBSZXF1aXJlZFwiLFxuICAgIDQwMzogXCJGb3JiaWRkZW5cIixcbiAgICA0MDQ6IFwiTm90IEZvdW5kXCIsXG4gICAgNDA1OiBcIk1ldGhvZCBOb3QgQWxsb3dlZFwiLFxuICAgIDQwNjogXCJOb3QgQWNjZXB0YWJsZVwiLFxuICAgIDQwNzogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgIDQwODogXCJSZXF1ZXN0IFRpbWVvdXRcIixcbiAgICA0MTA6IFwiR29uZVwiLFxuICAgIDQxMjogXCJDb25kaXRpb25hbCBSZXF1ZXN0IEZhaWxlZFwiLFxuICAgIDQxMzogXCJSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2VcIixcbiAgICA0MTQ6IFwiUmVxdWVzdC1VUkkgVG9vIExvbmdcIixcbiAgICA0MTU6IFwiVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZVwiLFxuICAgIDQxNjogXCJVbnN1cHBvcnRlZCBVUkkgU2NoZW1lXCIsXG4gICAgNDE3OiBcIlVua25vd24gUmVzb3VyY2UtUHJpb3JpdHlcIixcbiAgICA0MjA6IFwiQmFkIEV4dGVuc2lvblwiLFxuICAgIDQyMTogXCJFeHRlbnNpb24gUmVxdWlyZWRcIixcbiAgICA0MjI6IFwiU2Vzc2lvbiBJbnRlcnZhbCBUb28gU21hbGxcIixcbiAgICA0MjM6IFwiSW50ZXJ2YWwgVG9vIEJyaWVmXCIsXG4gICAgNDI4OiBcIlVzZSBJZGVudGl0eSBIZWFkZXJcIixcbiAgICA0Mjk6IFwiUHJvdmlkZSBSZWZlcnJlciBJZGVudGl0eVwiLFxuICAgIDQzMDogXCJGbG93IEZhaWxlZFwiLFxuICAgIDQzMzogXCJBbm9ueW1pdHkgRGlzYWxsb3dlZFwiLFxuICAgIDQzNjogXCJCYWQgSWRlbnRpdHktSW5mb1wiLFxuICAgIDQzNzogXCJVbnN1cHBvcnRlZCBDZXJ0aWZpY2F0ZVwiLFxuICAgIDQzODogXCJJbnZhbGlkIElkZW50aXR5IEhlYWRlclwiLFxuICAgIDQzOTogXCJGaXJzdCBIb3AgTGFja3MgT3V0Ym91bmQgU3VwcG9ydFwiLFxuICAgIDQ0MDogXCJNYXgtQnJlYWR0aCBFeGNlZWRlZFwiLFxuICAgIDQ2OTogXCJCYWQgSW5mbyBQYWNrYWdlXCIsXG4gICAgNDcwOiBcIkNvbnNlbnQgTmVlZGVkXCIsXG4gICAgNDc4OiBcIlVucmVzb2x2YWJsZSBEZXN0aW5hdGlvblwiLFxuICAgIDQ4MDogXCJUZW1wb3JhcmlseSBVbmF2YWlsYWJsZVwiLFxuICAgIDQ4MTogXCJDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0XCIsXG4gICAgNDgyOiBcIkxvb3AgRGV0ZWN0ZWRcIixcbiAgICA0ODM6IFwiVG9vIE1hbnkgSG9wc1wiLFxuICAgIDQ4NDogXCJBZGRyZXNzIEluY29tcGxldGVcIixcbiAgICA0ODU6IFwiQW1iaWd1b3VzXCIsXG4gICAgNDg2OiBcIkJ1c3kgSGVyZVwiLFxuICAgIDQ4NzogXCJSZXF1ZXN0IFRlcm1pbmF0ZWRcIixcbiAgICA0ODg6IFwiTm90IEFjY2VwdGFibGUgSGVyZVwiLFxuICAgIDQ4OTogXCJCYWQgRXZlbnRcIixcbiAgICA0OTE6IFwiUmVxdWVzdCBQZW5kaW5nXCIsXG4gICAgNDkzOiBcIlVuZGVjaXBoZXJhYmxlXCIsXG4gICAgNDk0OiBcIlNlY3VyaXR5IEFncmVlbWVudCBSZXF1aXJlZFwiLFxuICAgIDUwMDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgICA1MDE6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gICAgNTAyOiBcIkJhZCBHYXRld2F5XCIsXG4gICAgNTAzOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgICA1MDQ6IFwiU2VydmVyIFRpbWUtb3V0XCIsXG4gICAgNTA1OiBcIlZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICAgIDUxMzogXCJNZXNzYWdlIFRvbyBMYXJnZVwiLFxuICAgIDU4MDogXCJQcmVjb25kaXRpb24gRmFpbHVyZVwiLFxuICAgIDYwMDogXCJCdXN5IEV2ZXJ5d2hlcmVcIixcbiAgICA2MDM6IFwiRGVjbGluZVwiLFxuICAgIDYwNDogXCJEb2VzIE5vdCBFeGlzdCBBbnl3aGVyZVwiLFxuICAgIDYwNjogXCJOb3QgQWNjZXB0YWJsZVwiXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Nlc3Npb25cIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFNlc3Npb24gc3RhdGUuXG4gKiBAcmVtYXJrc1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xM1xuICogQHB1YmxpY1xuICovXG52YXIgU2Vzc2lvblN0YXRlO1xuKGZ1bmN0aW9uIChTZXNzaW9uU3RhdGUpIHtcbiAgICBTZXNzaW9uU3RhdGVbXCJJbml0aWFsXCJdID0gXCJJbml0aWFsXCI7XG4gICAgU2Vzc2lvblN0YXRlW1wiRWFybHlcIl0gPSBcIkVhcmx5XCI7XG4gICAgU2Vzc2lvblN0YXRlW1wiQWNrV2FpdFwiXSA9IFwiQWNrV2FpdFwiO1xuICAgIFNlc3Npb25TdGF0ZVtcIkNvbmZpcm1lZFwiXSA9IFwiQ29uZmlybWVkXCI7XG4gICAgU2Vzc2lvblN0YXRlW1wiVGVybWluYXRlZFwiXSA9IFwiVGVybWluYXRlZFwiO1xufSkoU2Vzc2lvblN0YXRlID0gZXhwb3J0cy5TZXNzaW9uU3RhdGUgfHwgKGV4cG9ydHMuU2Vzc2lvblN0YXRlID0ge30pKTtcbi8qKlxuICogT2ZmZXIvQW5zd2VyIHN0YXRlLlxuICogQHJlbWFya3NcbiAqIGBgYHR4dFxuICogICAgICAgICBPZmZlciAgICAgICAgICAgICAgICBBbnN3ZXIgICAgICAgICAgICAgUkZDICAgIEluaSBFc3QgRWFybHlcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgMS4gSU5WSVRFIFJlcS4gICAgICAgICAgMnh4IElOVklURSBSZXNwLiAgICAgUkZDIDMyNjEgIFkgICBZICAgIE5cbiAqICAyLiAyeHggSU5WSVRFIFJlc3AuICAgICBBQ0sgUmVxLiAgICAgICAgICAgICBSRkMgMzI2MSAgWSAgIFkgICAgTlxuICogIDMuIElOVklURSBSZXEuICAgICAgICAgIDF4eC1yZWwgSU5WSVRFIFJlc3AuIFJGQyAzMjYyICBZICAgWSAgICBOXG4gKiAgNC4gMXh4LXJlbCBJTlZJVEUgUmVzcC4gUFJBQ0sgUmVxLiAgICAgICAgICAgUkZDIDMyNjIgIFkgICBZICAgIE5cbiAqICA1LiBQUkFDSyBSZXEuICAgICAgICAgICAyMDAgUFJBQ0sgUmVzcC4gICAgICBSRkMgMzI2MiAgTiAgIFkgICAgWVxuICogIDYuIFVQREFURSBSZXEuICAgICAgICAgIDJ4eCBVUERBVEUgUmVzcC4gICAgIFJGQyAzMzExICBOICAgWSAgICBZXG4gKlxuICogICAgICAgVGFibGUgMTogU3VtbWFyeSBvZiBTSVAgVXNhZ2Ugb2YgdGhlIE9mZmVyL0Fuc3dlciBNb2RlbFxuICogYGBgXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjMzNyNzZWN0aW9uLTIuMlxuICogQHB1YmxpY1xuICovXG52YXIgU2lnbmFsaW5nU3RhdGU7XG4oZnVuY3Rpb24gKFNpZ25hbGluZ1N0YXRlKSB7XG4gICAgU2lnbmFsaW5nU3RhdGVbXCJJbml0aWFsXCJdID0gXCJJbml0aWFsXCI7XG4gICAgU2lnbmFsaW5nU3RhdGVbXCJIYXZlTG9jYWxPZmZlclwiXSA9IFwiSGF2ZUxvY2FsT2ZmZXJcIjtcbiAgICBTaWduYWxpbmdTdGF0ZVtcIkhhdmVSZW1vdGVPZmZlclwiXSA9IFwiSGF2ZVJlbW90ZU9mZmVyXCI7XG4gICAgU2lnbmFsaW5nU3RhdGVbXCJTdGFibGVcIl0gPSBcIlN0YWJsZVwiO1xuICAgIFNpZ25hbGluZ1N0YXRlW1wiQ2xvc2VkXCJdID0gXCJDbG9zZWRcIjtcbn0pKFNpZ25hbGluZ1N0YXRlID0gZXhwb3J0cy5TaWduYWxpbmdTdGF0ZSB8fCAoZXhwb3J0cy5TaWduYWxpbmdTdGF0ZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3Vic2NyaXB0aW9uXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBTdWJzY3JpcHRpb24gc3RhdGUuXG4gKiBAcmVtYXJrc1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMlxuICogQHB1YmxpY1xuICovXG52YXIgU3Vic2NyaXB0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKFN1YnNjcmlwdGlvblN0YXRlKSB7XG4gICAgU3Vic2NyaXB0aW9uU3RhdGVbXCJJbml0aWFsXCJdID0gXCJJbml0aWFsXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdGVbXCJOb3RpZnlXYWl0XCJdID0gXCJOb3RpZnlXYWl0XCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdGVbXCJQZW5kaW5nXCJdID0gXCJQZW5kaW5nXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdGVbXCJBY3RpdmVcIl0gPSBcIkFjdGl2ZVwiO1xuICAgIFN1YnNjcmlwdGlvblN0YXRlW1wiVGVybWluYXRlZFwiXSA9IFwiVGVybWluYXRlZFwiO1xufSkoU3Vic2NyaXB0aW9uU3RhdGUgPSBleHBvcnRzLlN1YnNjcmlwdGlvblN0YXRlIHx8IChleHBvcnRzLlN1YnNjcmlwdGlvblN0YXRlID0ge30pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFQxID0gNTAwO1xudmFyIFQyID0gNDAwMDtcbnZhciBUNCA9IDUwMDA7XG4vKipcbiAqIFRpbWVycy5cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5UaW1lcnMgPSB7XG4gICAgVDE6IFQxLFxuICAgIFQyOiBUMixcbiAgICBUNDogVDQsXG4gICAgVElNRVJfQjogNjQgKiBUMSxcbiAgICBUSU1FUl9EOiAwICogVDEsXG4gICAgVElNRVJfRjogNjQgKiBUMSxcbiAgICBUSU1FUl9IOiA2NCAqIFQxLFxuICAgIFRJTUVSX0k6IDAgKiBUNCxcbiAgICBUSU1FUl9KOiAwICogVDEsXG4gICAgVElNRVJfSzogMCAqIFQ0LFxuICAgIFRJTUVSX0w6IDY0ICogVDEsXG4gICAgVElNRVJfTTogNjQgKiBUMSxcbiAgICBUSU1FUl9OOiA2NCAqIFQxLFxuICAgIFBST1ZJU0lPTkFMX1JFU1BPTlNFX0lOVEVSVkFMOiA2MDAwMCAvLyBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuLyoqXG4gKiBDbGllbnQgVHJhbnNhY3Rpb24uXG4gKiBAcmVtYXJrc1xuICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBwcm92aWRlcyBpdHMgZnVuY3Rpb25hbGl0eSB0aHJvdWdoIHRoZVxuICogbWFpbnRlbmFuY2Ugb2YgYSBzdGF0ZSBtYWNoaW5lLlxuICpcbiAqIFRoZSBUVSBjb21tdW5pY2F0ZXMgd2l0aCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHRocm91Z2ggYSBzaW1wbGVcbiAqIGludGVyZmFjZS4gIFdoZW4gdGhlIFRVIHdpc2hlcyB0byBpbml0aWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiwgaXRcbiAqIGNyZWF0ZXMgYSBjbGllbnQgdHJhbnNhY3Rpb24gYW5kIHBhc3NlcyBpdCB0aGUgU0lQIHJlcXVlc3QgdG8gc2VuZFxuICogYW5kIGFuIElQIGFkZHJlc3MsIHBvcnQsIGFuZCB0cmFuc3BvcnQgdG8gd2hpY2ggdG8gc2VuZCBpdC4gIFRoZVxuICogY2xpZW50IHRyYW5zYWN0aW9uIGJlZ2lucyBleGVjdXRpb24gb2YgaXRzIHN0YXRlIG1hY2hpbmUuICBWYWxpZFxuICogcmVzcG9uc2VzIGFyZSBwYXNzZWQgdXAgdG8gdGhlIFRVIGZyb20gdGhlIGNsaWVudCB0cmFuc2FjdGlvbi5cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMVxuICogQHB1YmxpY1xuICovXG52YXIgQ2xpZW50VHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2xpZW50VHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2xpZW50VHJhbnNhY3Rpb24oX3JlcXVlc3QsIHRyYW5zcG9ydCwgdXNlciwgc3RhdGUsIGxvZ2dlckNhdGVnb3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zcG9ydCwgdXNlciwgQ2xpZW50VHJhbnNhY3Rpb24ubWFrZUlkKF9yZXF1ZXN0KSwgc3RhdGUsIGxvZ2dlckNhdGVnb3J5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmVxdWVzdCA9IF9yZXF1ZXN0O1xuICAgICAgICBfdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgLy8gVGhlIFZpYSBoZWFkZXIgZmllbGQgaW5kaWNhdGVzIHRoZSB0cmFuc3BvcnQgdXNlZCBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIGFuZCBpZGVudGlmaWVzIHRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgcmVzcG9uc2UgaXMgdG8gYmUgc2VudC4gIEEgVmlhXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCB2YWx1ZSBpcyBhZGRlZCBvbmx5IGFmdGVyIHRoZSB0cmFuc3BvcnQgdGhhdCB3aWxsIGJlXG4gICAgICAgIC8vIHVzZWQgdG8gcmVhY2ggdGhlIG5leHQgaG9wIGhhcyBiZWVuIHNlbGVjdGVkICh3aGljaCBtYXkgaW52b2x2ZSB0aGVcbiAgICAgICAgLy8gdXNhZ2Ugb2YgdGhlIHByb2NlZHVyZXMgaW4gWzRdKS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMS43XG4gICAgICAgIF9yZXF1ZXN0LnNldFZpYUhlYWRlcihfdGhpcy5pZCwgdHJhbnNwb3J0LnByb3RvY29sKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDbGllbnRUcmFuc2FjdGlvbi5tYWtlSWQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IFwiQ0FOQ0VMXCIpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdC5icmFuY2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPdXRnb2luZyBDQU5DRUwgcmVxdWVzdCB3aXRob3V0IGEgYnJhbmNoLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LmJyYW5jaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIno5aEc0YktcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJyZXF1ZXN0XCIsIHtcbiAgICAgICAgLyoqIFRoZSBvdXRnb2luZyByZXF1ZXN0IHRoZSB0cmFuc2FjdGlvbiBoYW5kbGluZy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSA0MDggdG8gbm9uLUlOVklURSB3aWxsIGFsd2F5cyBhcnJpdmUgdG9vIGxhdGUgdG8gYmUgdXNlZnVsIChbM10pLFxuICAgICAqIFRoZSBjbGllbnQgYWxyZWFkeSBoYXMgZnVsbCBrbm93bGVkZ2Ugb2YgdGhlIHRpbWVvdXQuIFRoZSBvbmx5XG4gICAgICogaW5mb3JtYXRpb24gdGhpcyBtZXNzYWdlIHdvdWxkIGNvbnZleSBpcyB3aGV0aGVyIG9yIG5vdCB0aGUgc2VydmVyXG4gICAgICogYmVsaWV2ZWQgdGhlIHRyYW5zYWN0aW9uIHRpbWVkIG91dC4gSG93ZXZlciwgd2l0aCB0aGUgY3VycmVudCBkZXNpZ25cbiAgICAgKiBvZiB0aGUgTklULCBhIGNsaWVudCBjYW5ub3QgZG8gYW55dGhpbmcgd2l0aCB0aGlzIGtub3dsZWRnZS4gVGh1cyxcbiAgICAgKiB0aGUgNDA4IGlzIHNpbXBseSB3YXN0aW5nIG5ldHdvcmsgcmVzb3VyY2VzIGFuZCBjb250cmlidXRlcyB0byB0aGVcbiAgICAgKiByZXNwb25zZSBib21iYXJkbWVudCBpbGx1c3RyYXRlZCBpbiBbM10uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzMjAjc2VjdGlvbi00LjFcbiAgICAgKi9cbiAgICBDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlci5vblJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2xpZW50VHJhbnNhY3Rpb247XG59KHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24pKTtcbmV4cG9ydHMuQ2xpZW50VHJhbnNhY3Rpb24gPSBDbGllbnRUcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGllbnQtdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW52aXRlLWNsaWVudC10cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnZpdGUtc2VydmVyLXRyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vbi1pbnZpdGUtY2xpZW50LXRyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vbi1pbnZpdGUtc2VydmVyLXRyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludml0ZS1jbGllbnQtdHJhbnNhY3Rpb25cIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VydmVyLXRyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdGltZXJzXzEgPSByZXF1aXJlKFwiLi4vdGltZXJzXCIpO1xudmFyIGNsaWVudF90cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vY2xpZW50LXRyYW5zYWN0aW9uXCIpO1xudmFyIHRyYW5zYWN0aW9uX3N0YXRlXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1zdGF0ZVwiKTtcbi8qKlxuICogSU5WSVRFIENsaWVudCBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBUaGUgSU5WSVRFIHRyYW5zYWN0aW9uIGNvbnNpc3RzIG9mIGEgdGhyZWUtd2F5IGhhbmRzaGFrZS4gIFRoZSBjbGllbnRcbiAqIHRyYW5zYWN0aW9uIHNlbmRzIGFuIElOVklURSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBzZW5kcyByZXNwb25zZXMsXG4gKiBhbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBzZW5kcyBhbiBBQ0suXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMVxuICogQHB1YmxpY1xuICovXG52YXIgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogVXBvbiBjb25zdHJ1Y3Rpb24sIHRoZSBvdXRnb2luZyByZXF1ZXN0J3MgVmlhIGhlYWRlciBpcyB1cGRhdGVkIGJ5IGNhbGxpbmcgYHNldFZpYUhlYWRlcmAuXG4gICAgICogVGhlbiBgdG9TdHJpbmdgIGlzIGNhbGxlZCBvbiB0aGUgb3V0Z29pbmcgcmVxdWVzdCBhbmQgdGhlIG1lc3NhZ2UgaXMgc2VudCB2aWEgdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBBZnRlciBjb25zdHJ1Y3Rpb24gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgaW4gdGhlIFwiY2FsbGluZ1wiIHN0YXRlIGFuZCB0aGUgdHJhbnNhY3Rpb24gaWRcbiAgICAgKiB3aWxsIGVxdWFsIHRoZSBicmFuY2ggcGFyYW1ldGVyIHNldCBpbiB0aGUgVmlhIGhlYWRlciBvZiB0aGUgb3V0Z29pbmcgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMVxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIG91dGdvaW5nIElOVklURSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgLSBUaGUgdHJhbnNwb3J0LlxuICAgICAqIEBwYXJhbSB1c2VyIC0gVGhlIHRyYW5zYWN0aW9uIHVzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ocmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlcXVlc3QsIHRyYW5zcG9ydCwgdXNlciwgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcsIFwic2lwLnRyYW5zYWN0aW9uLmljdFwiKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIDJ4eCB0by10YWcgdG8gQUNLLlxuICAgICAgICAgKiBJZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLCB2YWx1ZSBpcyB0aGUgQUNLIHdoaWNoIHdhcyBzZW50LlxuICAgICAgICAgKiBJZiBrZXkgZXhpc3RzIGJ1dCB2YWx1ZSBpcyB1bmRlZmluZWQsIGEgMnh4IHdhcyByZWNlaXZlZCBidXQgdGhlIEFDSyBub3QgeWV0IHNlbnQuXG4gICAgICAgICAqIE90aGVyd2lzZSwgYSAyeHggd2FzIG5vdCAoeWV0KSByZWNlaXZlZCBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmFja1JldHJhbnNtaXNzaW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEZJWE1FOiBUaW1lciBBIGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydCBub3QgaW1wbGVtZW50ZWRcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgYW4gdW5yZWxpYWJsZSB0cmFuc3BvcnQgaXMgYmVpbmcgdXNlZCwgdGhlIGNsaWVudCB0cmFuc2FjdGlvblxuICAgICAgICAvLyBNVVNUIHN0YXJ0IHRpbWVyIEEgd2l0aCBhIHZhbHVlIG9mIFQxLiBJZiBhIHJlbGlhYmxlIHRyYW5zcG9ydCBpcyBiZWluZyB1c2VkLFxuICAgICAgICAvLyB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBOT1Qgc3RhcnQgdGltZXIgQSAoVGltZXIgQSBjb250cm9scyByZXF1ZXN0IHJldHJhbnNtaXNzaW9ucykuXG4gICAgICAgIC8vIEZvciBhbnkgdHJhbnNwb3J0LCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1Qgc3RhcnQgdGltZXIgQiB3aXRoIGEgdmFsdWVcbiAgICAgICAgLy8gb2YgNjQqVDEgc2Vjb25kcyAoVGltZXIgQiBjb250cm9scyB0cmFuc2FjdGlvbiB0aW1lb3V0cykuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2hpbGUgbm90IHNwZWxsZWQgb3V0IGluIHRoZSBSRkMsIFRpbWVyIEIgaXMgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBhIHNlbmRlclxuICAgICAgICAvLyB3aWxsIHdhaXQgZm9yIGFuIElOVklURSBtZXNzYWdlIHRvIGJlIGFja25vd2xlZGdlZCAoYSBTSVAgcmVzcG9uc2UgbWVzc2FnZSBpcyByZWNlaXZlZCkuXG4gICAgICAgIC8vIFNvIFRpbWVyIEIgc2hvdWxkIGJlIGNsZWFyZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgcHJvY2VlZHMgZnJvbSBcIkNhbGxpbmdcIi5cbiAgICAgICAgX3RoaXMuQiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfQigpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfQik7XG4gICAgICAgIF90aGlzLnNlbmQocmVxdWVzdC50b1N0cmluZygpKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIGluaXRpYWwgb3V0Z29pbmcgcmVxdWVzdC5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLkIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkIpO1xuICAgICAgICAgICAgdGhpcy5CID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkQpO1xuICAgICAgICAgICAgdGhpcy5EID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLk0pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLk0pO1xuICAgICAgICAgICAgdGhpcy5NID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaWN0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEFDSyBhIDJ4eCBmaW5hbCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiBpbmNsdWRlcyB0aGUgQUNLIG9ubHkgaWYgdGhlIGZpbmFsIHJlc3BvbnNlIHdhcyBub3QgYSAyeHggcmVzcG9uc2UgKHRoZVxuICAgICAqIHRyYW5zYWN0aW9uIHdpbGwgZ2VuZXJhdGUgYW5kIHNlbmQgdGhlIEFDSyB0byB0aGUgdHJhbnNwb3J0IGF1dG9tYWdpY2FsbHkpLiBJZiB0aGVcbiAgICAgKiBmaW5hbCByZXNwb25zZSB3YXMgYSAyeHgsIHRoZSBBQ0sgaXMgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgdHJhbnNhY3Rpb24gKHRoZVxuICAgICAqIHRyYW5zYWN0aW9uIHVzZXIgbmVlZHMgdG8gZ2VuZXJhdGUgYW5kIHNlbmQgdGhlIEFDSykuXG4gICAgICpcbiAgICAgKiBUaGlzIGxpYnJhcnkgaXMgbm90IHN0cmljdGx5IFJGQyBjb21wbGlhbnQgd2l0aCByZWdhcmQgdG8gQUNLIGhhbmRsaW5nIGZvciAyeHggZmluYWxcbiAgICAgKiByZXNwb25zZXMuIFNwZWNpZmljYWxseSwgcmV0cmFuc21pc3Npb25zIG9mIEFDS3MgdG8gYSAyeHggZmluYWwgcmVzcG9uc2VzIGlzIGhhbmRsZWRcbiAgICAgKiBieSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIgKGluc3RlYWQgb2YgdGhlIFVBQyBjb3JlKS4gVGhlIFwic3RhbmRhcmRcIiBhcHByb2FjaCBpcyBmb3JcbiAgICAgKiB0aGUgVUFDIGNvcmUgdG8gcmVjZWl2ZSBhbGwgMnh4IHJlc3BvbnNlcyBhbmQgbWFuYWdlIHNlbmRpbmcgQUNLIHJldHJhbnNtaXNzaW9ucyB0b1xuICAgICAqIHRoZSB0cmFuc3BvcnQgZGlyZWN0bHkuIEhlcmVpbiB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIgbWFuYWdlcyBzZW5kaW5nIEFDS3MgdG8gMnh4IHJlc3BvbnNlc1xuICAgICAqIGFuZCBhbnkgcmV0cmFuc21pc3Npb25zIG9mIHRob3NlIEFDS3MgYXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjayAtIFRoZSBvdXRnb2luZyBBQ0sgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUuYWNrUmVzcG9uc2UgPSBmdW5jdGlvbiAoYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB0b1RhZyA9IGFjay50b1RhZztcbiAgICAgICAgaWYgKCF0b1RhZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdGFnIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gXCJ6OWhHNGJLXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMCk7XG4gICAgICAgIGFjay5zZXRWaWFIZWFkZXIoaWQsIHRoaXMudHJhbnNwb3J0LnByb3RvY29sKTtcbiAgICAgICAgdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLnNldCh0b1RhZywgYWNrKTsgLy8gQWRkIHRvIEFDSyByZXRyYW5zbWlzc2lvbiBjYWNoZVxuICAgICAgICB0aGlzLnNlbmQoYWNrLnRvU3RyaW5nKCkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgQUNLIHRvIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgaW5jb21pbmcgcmVzcG9uc2VzIGZyb20gdGhlIHRyYW5zcG9ydCB3aGljaCBtYXRjaCB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBpbmNvbWluZyByZXNwb25zZS5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKCFzdGF0dXNDb2RlIHx8IHN0YXR1c0NvZGUgPCAxMDAgfHwgc3RhdHVzQ29kZSA+IDY5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0dXMgY29kZSBcIiArIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZzpcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIHJlY2VpdmVzIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2Ugd2hpbGUgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJDYWxsaW5nXCIgc3RhdGUsIGl0IHRyYW5zaXRpb25zIHRvIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZS4gSW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIE5PVCByZXRyYW5zbWl0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgYW55IGxvbmdlci4gRnVydGhlcm1vcmUsIHRoZSBwcm92aXNpb25hbCByZXNwb25zZSBNVVNUIGJlXG4gICAgICAgICAgICAgICAgLy8gcGFzc2VkIHRvIHRoZSBUVS4gIEFueSBmdXJ0aGVyIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBNVVNUIGJlIHBhc3NlZFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoZSBUVSB3aGlsZSBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDEwMCAmJiBzdGF0dXNDb2RlIDw9IDE5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gYSAyeHggcmVzcG9uc2UgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gZWl0aGVyIHRoZSBcIkNhbGxpbmdcIiBvclxuICAgICAgICAgICAgICAgIC8vIFwiUHJvY2VlZGluZ1wiIHN0YXRlcywgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLi4uIFRoZSAyeHggcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdXAgdG8gdGhlIFRVLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBOT1QgZ2VuZXJhdGUgYW4gQUNLIHRvIHRoZSAyeHggcmVzcG9uc2UgLS0gaXRzXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxpbmcgaXMgZGVsZWdhdGVkIHRvIHRoZSBUVS4gQSBVQUMgY29yZSB3aWxsIHNlbmQgYW4gQUNLIHRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIDJ4eCByZXNwb25zZSB1c2luZyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDI5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFja1JldHJhbnNtaXNzaW9uQ2FjaGUuc2V0KHJlc3BvbnNlLnRvVGFnLCB1bmRlZmluZWQpOyAvLyBQcmltZSB0aGUgQUNLIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gaW4gZWl0aGVyIHRoZSBcIkNhbGxpbmdcIiBvciBcIlByb2NlZWRpbmdcIiBzdGF0ZXMsIHJlY2VwdGlvbiBvZlxuICAgICAgICAgICAgICAgIC8vIGEgcmVzcG9uc2Ugd2l0aCBzdGF0dXMgY29kZSBmcm9tIDMwMC02OTkgTVVTVCBjYXVzZSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gdG8gdHJhbnNpdGlvbiB0byBcIkNvbXBsZXRlZFwiLiBUaGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gTVVTVCBwYXNzIHRoZSByZWNlaXZlZCByZXNwb25zZSB1cCB0byB0aGUgVFUsIGFuZCB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gTVVTVCBnZW5lcmF0ZSBhbiBBQ0sgcmVxdWVzdCwgZXZlbiBpZiB0aGUgdHJhbnNwb3J0IGlzXG4gICAgICAgICAgICAgICAgLy8gcmVsaWFibGUgKGd1aWRlbGluZXMgZm9yIGNvbnN0cnVjdGluZyB0aGUgQUNLIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gYXJlIGdpdmVuIGluIFNlY3Rpb24gMTcuMS4xLjMpLCBhbmQgdGhlbiBwYXNzIHRoZSBBQ0sgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uIFRoZSBBQ0sgTVVTVCBiZSBzZW50IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNhbWUgYWRkcmVzcywgcG9ydCwgYW5kIHRyYW5zcG9ydCB0byB3aGljaCB0aGUgb3JpZ2luYWwgcmVxdWVzdCB3YXMgc2VudC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDMwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCBOT1QgcmV0cmFuc21pdCB0aGVcbiAgICAgICAgICAgICAgICAvLyByZXF1ZXN0IGFueSBsb25nZXIuIEZ1cnRoZXJtb3JlLCB0aGUgcHJvdmlzaW9uYWwgcmVzcG9uc2UgTVVTVCBiZVxuICAgICAgICAgICAgICAgIC8vIHBhc3NlZCB0byB0aGUgVFUuICBBbnkgZnVydGhlciBwcm92aXNpb25hbCByZXNwb25zZXMgTVVTVCBiZSBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyB1cCB0byB0aGUgVFUgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBhIDJ4eCByZXNwb25zZSBpcyByZWNlaXZlZCB3aGlsZSBpbiBlaXRoZXIgdGhlIFwiQ2FsbGluZ1wiIG9yIFwiUHJvY2VlZGluZ1wiIHN0YXRlcyxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLi4uXG4gICAgICAgICAgICAgICAgLy8gVGhlIDJ4eCByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB1cCB0byB0aGUgVFUuIFRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBNVVNUIE5PVCBnZW5lcmF0ZSBhbiBBQ0sgdG8gdGhlIDJ4eCByZXNwb25zZSAtLSBpdHNcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGluZyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIFRVLiBBIFVBQyBjb3JlIHdpbGwgc2VuZCBhbiBBQ0sgdG9cbiAgICAgICAgICAgICAgICAvLyB0aGUgMnh4IHJlc3BvbnNlIHVzaW5nIGEgbmV3IHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZS5zZXQocmVzcG9uc2UudG9UYWcsIHVuZGVmaW5lZCk7IC8vIFByaW1lIHRoZSBBQ0sgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpbiBlaXRoZXIgdGhlIFwiQ2FsbGluZ1wiIG9yIFwiUHJvY2VlZGluZ1wiIHN0YXRlcywgcmVjZXB0aW9uIG9mXG4gICAgICAgICAgICAgICAgLy8gYSByZXNwb25zZSB3aXRoIHN0YXR1cyBjb2RlIGZyb20gMzAwLTY5OSBNVVNUIGNhdXNlIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiB0byB0cmFuc2l0aW9uIHRvIFwiQ29tcGxldGVkXCIuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBNVVNUIHBhc3MgdGhlIHJlY2VpdmVkIHJlc3BvbnNlIHVwIHRvIHRoZSBUVSwgYW5kIHRoZSBjbGllbnRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBNVVNUIGdlbmVyYXRlIGFuIEFDSyByZXF1ZXN0LCBldmVuIGlmIHRoZSB0cmFuc3BvcnQgaXNcbiAgICAgICAgICAgICAgICAvLyByZWxpYWJsZSAoZ3VpZGVsaW5lcyBmb3IgY29uc3RydWN0aW5nIHRoZSBBQ0sgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBhcmUgZ2l2ZW4gaW4gU2VjdGlvbiAxNy4xLjEuMyksIGFuZCB0aGVuIHBhc3MgdGhlIEFDSyB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi4gVGhlIEFDSyBNVVNUIGJlIHNlbnQgdG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBhZGRyZXNzLCBwb3J0LCBhbmQgdHJhbnNwb3J0IHRvIHdoaWNoIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBzZW50LlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSBpcyB0byBhbGxvdyB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gdG8gY29udGludWUgdG8gZXhpc3QgdG8gcmVjZWl2ZSwgYW5kIHBhc3MgdG8gdGhlIFRVLFxuICAgICAgICAgICAgICAgIC8vIGFueSByZXRyYW5zbWlzc2lvbnMgb2YgdGhlIDJ4eCByZXNwb25zZSBhbmQgYW55IGFkZGl0aW9uYWwgMnh4XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2VzIGZyb20gb3RoZXIgYnJhbmNoZXMgb2YgdGhlIElOVklURSBpZiBpdCBmb3JrZWRcbiAgICAgICAgICAgICAgICAvLyBkb3duc3RyZWFtLiBUaW1lciBNIHJlZmxlY3RzIHRoZSBhbW91bnQgb2YgdGltZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIHVzZXIgd2lsbCB3YWl0IGZvciBzdWNoIG1lc3NhZ2VzLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gQW55IDJ4eCByZXNwb25zZXMgdGhhdCBtYXRjaCB0aGlzIGNsaWVudCB0cmFuc2FjdGlvbiBhbmQgdGhhdCBhcmVcbiAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlIE1VU1QgYmUgcGFzc2VkIHVwIHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIFRVLiBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1QgTk9UIGdlbmVyYXRlIGFuIEFDSyB0byB0aGUgMnh4XG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UuIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gdGFrZXMgbm8gZnVydGhlciBhY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBoZXJlaW4gaXMgaW50ZW50aW9uYWxseSBub3QgUkZDIGNvbXBsaWFudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2hpbGUgdGhlIGZpcnN0IDJ4eCByZXNwb25zZSBmb3IgYSBnaXZlbiBicmFuY2ggaXMgcGFzc2VkIHVwIHRvIHRoZSBUVSxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cmFuc21pc3Npb25zIG9mIDJ4eCByZXNwb25zZXMgYXJlIGFic29yYmVkIGFuZCB0aGUgQUNLIGFzc29jaWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgb3JpZ2luYWwgcmVzcG9uc2UgaXMgcmVzZW50LiBUaGlzIGFwcHJvYWNoIGlzIHRha2VuIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gb3VyIGN1cnJlbnQgdHJhbnNhY3Rpb24gdXNlcnMgYXJlIG5vdCBjdXJyZW50bHkgaW4gYSBnb29kIHBvc2l0aW9uIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYWwgd2l0aCAyeHggcmV0cmFuc21pc3Npb24uIFRoaXMgU0hPVUxEIE5PVCBjYXVzZSBhbnkgY29tcGxpYW5jZSBpc3N1ZXMgLSA7KVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2FjaGUgaGl0LCBwYXNzIHRoZSByZXNwb25zZSB0byB0aGUgVFUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hY2tSZXRyYW5zbWlzc2lvbkNhY2hlLmhhcyhyZXNwb25zZS50b1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZS5zZXQocmVzcG9uc2UudG9UYWcsIHVuZGVmaW5lZCk7IC8vIFByaW1lIHRoZSBBQ0sgY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNhY2hlIGhpdCwgdHJ5IHB1bGxpbmcgdGhlIEFDSyBmcm9tIGNhY2hlIGFuZCByZXRyYW5zbWl0dGluZyBpdC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjayA9IHRoaXMuYWNrUmV0cmFuc21pc3Npb25DYWNoZS5nZXQocmVzcG9uc2UudG9UYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQoYWNrLnRvU3RyaW5nKCkpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHJldHJhbnNtaXNzaW9uIG9mIEFDSyB0byAyeHggcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gQUNLIHdhcyBub3QgZm91bmQgaW4gY2FjaGUgdGhlbiB3ZSBoYXZlIHJlY2VpdmVkIGEgcmV0cmFuc21pdHRlZCAyeHhcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgYmVmb3JlIHRoZSBUVSByZXNwb25kZWQgdG8gdGhlIG9yaWdpbmFsIHJlc3BvbnNlICh3ZSBkb24ndCBoYXZlIGFuIEFDSyB5ZXQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBTbyBkaXNjYXJkIHRoaXMgcmVzcG9uc2UgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgVFUgd2lsbCBldmVudHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCB1cyBhIEFDSyBmb3IgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIC8vIEFueSByZXRyYW5zbWlzc2lvbnMgb2YgYSByZXNwb25zZSB3aXRoIHN0YXR1cyBjb2RlIDMwMC02OTkgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGFyZSByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBNVVNUIGNhdXNlIHRoZSBBQ0sgdG9cbiAgICAgICAgICAgICAgICAvLyBiZSByZS1wYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgcmV0cmFuc21pc3Npb24sIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXdseSByZWNlaXZlZCByZXNwb25zZSBNVVNUIE5PVCBiZSBwYXNzZWQgdXAgdG8gdGhlIFRVLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdGUgXCIgKyB0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbnkgcmVzcG9uc2UgcmVjZWl2ZWQgdGhhdCBkb2VzIG5vdCBtYXRjaCBhbiBleGlzdGluZyBjbGllbnRcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUgbWFjaGluZSBpcyBzaW1wbHkgZHJvcHBlZC4gKEltcGxlbWVudGF0aW9ucyBhcmUsXG4gICAgICAgIC8vIG9mIGNvdXJzZSwgZnJlZSB0byBsb2cgb3IgZG8gb3RoZXIgaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgdGhpbmdzXG4gICAgICAgIC8vIHdpdGggc3VjaCByZXNwb25zZXMsIGJ1dCB0aGUgaW1wbGVtZW50ZXIgc2hvdWxkIGJlIHN1cmUgdG8gY29uc2lkZXJcbiAgICAgICAgLy8gdGhlIGltcGFjdCBvZiBsYXJnZSBudW1iZXJzIG9mIG1hbGljaW91cyBzdHJheSByZXNwb25zZXMuKVxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTcuMlxuICAgICAgICB2YXIgbWVzc2FnZSA9IFwiUmVjZWl2ZWQgdW5leHBlY3RlZCBcIiArIHN0YXR1c0NvZGUgKyBcIiByZXNwb25zZSB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIi5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSB0aGF0IGEgdHJhbnNwb3J0IGZhaWx1cmVcbiAgICAgKiBoYXMgb2NjdXJyZWQsIGFuZCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIFNIT1VMRCB0cmFuc2l0aW9uIGRpcmVjdGx5XG4gICAgICogdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLiAgVGhlIFRVIHdpbGwgaGFuZGxlIHRoZSBmYWlsb3ZlclxuICAgICAqIG1lY2hhbmlzbXMgZGVzY3JpYmVkIGluIFs0XS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuNFxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBpZiAodGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKiogRm9yIGxvZ2dpbmcuICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnR5cGVUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiSU5WSVRFIGNsaWVudCB0cmFuc2FjdGlvblwiO1xuICAgIH07XG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUaGUgQUNLIHJlcXVlc3QgY29uc3RydWN0ZWQgYnkgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIGNvbnRhaW5cbiAgICAgICAgLy8gdmFsdWVzIGZvciB0aGUgQ2FsbC1JRCwgRnJvbSwgYW5kIFJlcXVlc3QtVVJJIHRoYXQgYXJlIGVxdWFsIHRvIHRoZVxuICAgICAgICAvLyB2YWx1ZXMgb2YgdGhvc2UgaGVhZGVyIGZpZWxkcyBpbiB0aGUgcmVxdWVzdCBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydFxuICAgICAgICAvLyBieSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIChjYWxsIHRoaXMgdGhlIFwib3JpZ2luYWwgcmVxdWVzdFwiKS4gVGhlIFRvXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCBpbiB0aGUgQUNLIE1VU1QgZXF1YWwgdGhlIFRvIGhlYWRlciBmaWVsZCBpbiB0aGVcbiAgICAgICAgLy8gcmVzcG9uc2UgYmVpbmcgYWNrbm93bGVkZ2VkLCBhbmQgdGhlcmVmb3JlIHdpbGwgdXN1YWxseSBkaWZmZXIgZnJvbVxuICAgICAgICAvLyB0aGUgVG8gaGVhZGVyIGZpZWxkIGluIHRoZSBvcmlnaW5hbCByZXF1ZXN0IGJ5IHRoZSBhZGRpdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gdGFnIHBhcmFtZXRlci4gVGhlIEFDSyBNVVNUIGNvbnRhaW4gYSBzaW5nbGUgVmlhIGhlYWRlciBmaWVsZCwgYW5kXG4gICAgICAgIC8vIHRoaXMgTVVTVCBiZSBlcXVhbCB0byB0aGUgdG9wIFZpYSBoZWFkZXIgZmllbGQgb2YgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHJlcXVlc3QuIFRoZSBDU2VxIGhlYWRlciBmaWVsZCBpbiB0aGUgQUNLIE1VU1QgY29udGFpbiB0aGUgc2FtZVxuICAgICAgICAvLyB2YWx1ZSBmb3IgdGhlIHNlcXVlbmNlIG51bWJlciBhcyB3YXMgcHJlc2VudCBpbiB0aGUgb3JpZ2luYWwgcmVxdWVzdCxcbiAgICAgICAgLy8gYnV0IHRoZSBtZXRob2QgcGFyYW1ldGVyIE1VU1QgYmUgZXF1YWwgdG8gXCJBQ0tcIi5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIElOVklURSByZXF1ZXN0IHdob3NlIHJlc3BvbnNlIGlzIGJlaW5nIGFja25vd2xlZGdlZCBoYWQgUm91dGVcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkcywgdGhvc2UgaGVhZGVyIGZpZWxkcyBNVVNUIGFwcGVhciBpbiB0aGUgQUNLLiBUaGlzIGlzXG4gICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRoZSBBQ0sgY2FuIGJlIHJvdXRlZCBwcm9wZXJseSB0aHJvdWdoIGFueSBkb3duc3RyZWFtXG4gICAgICAgIC8vIHN0YXRlbGVzcyBwcm94aWVzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMS4zXG4gICAgICAgIHZhciBydXJpID0gdGhpcy5yZXF1ZXN0LnJ1cmk7XG4gICAgICAgIHZhciBjYWxsSWQgPSB0aGlzLnJlcXVlc3QuY2FsbElkO1xuICAgICAgICB2YXIgY3NlcSA9IHRoaXMucmVxdWVzdC5jc2VxO1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMucmVxdWVzdC5nZXRIZWFkZXIoXCJmcm9tXCIpO1xuICAgICAgICB2YXIgdG8gPSByZXNwb25zZS5nZXRIZWFkZXIoXCJ0b1wiKTtcbiAgICAgICAgdmFyIHZpYSA9IHRoaXMucmVxdWVzdC5nZXRIZWFkZXIoXCJ2aWFcIik7XG4gICAgICAgIHZhciByb3V0ZSA9IHRoaXMucmVxdWVzdC5nZXRIZWFkZXIoXCJyb3V0ZVwiKTtcbiAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcm9tIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0bykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZpYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmlhIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjayA9IFwiQUNLIFwiICsgcnVyaSArIFwiIFNJUC8yLjBcXHJcXG5cIjtcbiAgICAgICAgaWYgKHJvdXRlKSB7XG4gICAgICAgICAgICBhY2sgKz0gXCJSb3V0ZTogXCIgKyByb3V0ZSArIFwiXFxyXFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgYWNrICs9IFwiVmlhOiBcIiArIHZpYSArIFwiXFxyXFxuXCI7XG4gICAgICAgIGFjayArPSBcIlRvOiBcIiArIHRvICsgXCJcXHJcXG5cIjtcbiAgICAgICAgYWNrICs9IFwiRnJvbTogXCIgKyBmcm9tICsgXCJcXHJcXG5cIjtcbiAgICAgICAgYWNrICs9IFwiQ2FsbC1JRDogXCIgKyBjYWxsSWQgKyBcIlxcclxcblwiO1xuICAgICAgICBhY2sgKz0gXCJDU2VxOiBcIiArIGNzZXEgKyBcIiBBQ0tcXHJcXG5cIjtcbiAgICAgICAgYWNrICs9IFwiTWF4LUZvcndhcmRzOiA3MFxcclxcblwiO1xuICAgICAgICBhY2sgKz0gXCJDb250ZW50LUxlbmd0aDogMFxcclxcblxcclxcblwiO1xuICAgICAgICAvLyBUT09POiBcIlVzZXItQWdlbnRcIiBoZWFkZXJcbiAgICAgICAgdGhpcy5zZW5kKGFjaykuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBBQ0sgdG8gbm9uLTJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgLSBOZXcgc3RhdGUuXG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZHVlVG9UcmFuc3BvcnRFcnJvciA9PT0gdm9pZCAwKSB7IGR1ZVRvVHJhbnNwb3J0RXJyb3IgPSBmYWxzZTsgfVxuICAgICAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIHZhciBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nOlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZDpcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5DYWxsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hpbGUgbm90IHNwZWxsZWQgb3V0IGluIHRoZSBSRkMsIFRpbWVyIEIgaXMgdGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdGhhdCBhIHNlbmRlclxuICAgICAgICAvLyB3aWxsIHdhaXQgZm9yIGFuIElOVklURSBtZXNzYWdlIHRvIGJlIGFja25vd2xlZGdlZCAoYSBTSVAgcmVzcG9uc2UgbWVzc2FnZSBpcyByZWNlaXZlZCkuXG4gICAgICAgIC8vIFNvIFRpbWVyIEIgc2hvdWxkIGJlIGNsZWFyZWQgd2hlbiB0aGUgdHJhbnNhY3Rpb24gc3RhdGUgcHJvY2VlZHMgZnJvbSBcIkNhbGxpbmdcIi5cbiAgICAgICAgaWYgKHRoaXMuQikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuQik7XG4gICAgICAgICAgICB0aGlzLkIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgLy8gVGltZXJzIGhhdmUgbm8gZWZmZWN0IG9uIFwiUHJvY2VlZGluZ1wiIHN0YXRlLlxuICAgICAgICAgICAgLy8gSW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBTSE9VTEQgTk9UIHJldHJhbnNtaXQgdGhlIHJlcXVlc3QgYW55IGxvbmdlci5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY2xpZW50IHRyYW5zYWN0aW9uIE1VU1Qgc3RhcnQgVGltZXIgRCB3aGVuIGl0IGVudGVycyB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZVxuICAgICAgICAvLyBmb3IgYW55IHJlYXNvbiwgd2l0aCBhIHZhbHVlIG9mIGF0IGxlYXN0IDMyIHNlY29uZHMgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cyxcbiAgICAgICAgLy8gYW5kIGEgdmFsdWUgb2YgemVybyBzZWNvbmRzIGZvciByZWxpYWJsZSB0cmFuc3BvcnRzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguNFxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfRCgpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfRCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSxcbiAgICAgICAgLy8gYW5kIFRpbWVyIE0gTVVTVCBiZSBzdGFydGVkIHdpdGggYSB2YWx1ZSBvZiA2NCpUMS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjRcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuTSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfTSgpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfTSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLCBpdCBNVVNUIGJlIGRlc3Ryb3llZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjdcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlLlxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGltZXIgQSBmaXJlcywgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHJldHJhbnNtaXQgdGhlXG4gICAgICogcmVxdWVzdCBieSBwYXNzaW5nIGl0IHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIsIGFuZCBNVVNUIHJlc2V0IHRoZVxuICAgICAqIHRpbWVyIHdpdGggYSB2YWx1ZSBvZiAyKlQxLlxuICAgICAqIFdoZW4gdGltZXIgQSBmaXJlcyAyKlQxIHNlY29uZHMgbGF0ZXIsIHRoZSByZXF1ZXN0IE1VU1QgYmVcbiAgICAgKiByZXRyYW5zbWl0dGVkIGFnYWluIChhc3N1bWluZyB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGlzIHN0aWxsIGluIHRoaXNcbiAgICAgKiBzdGF0ZSkuIFRoaXMgcHJvY2VzcyBNVVNUIGNvbnRpbnVlIHNvIHRoYXQgdGhlIHJlcXVlc3QgaXNcbiAgICAgKiByZXRyYW5zbWl0dGVkIHdpdGggaW50ZXJ2YWxzIHRoYXQgZG91YmxlIGFmdGVyIGVhY2ggdHJhbnNtaXNzaW9uLlxuICAgICAqIFRoZXNlIHJldHJhbnNtaXNzaW9ucyBTSE9VTEQgb25seSBiZSBkb25lIHdoaWxlIHRoZSBjbGllbnRcbiAgICAgKiB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDYWxsaW5nXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjEuMlxuICAgICAqL1xuICAgIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9BID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGlzIHN0aWxsIGluIHRoZSBcIkNhbGxpbmdcIiBzdGF0ZSB3aGVuIHRpbWVyXG4gICAgICogQiBmaXJlcywgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSB0aGF0IGEgdGltZW91dFxuICAgICAqIGhhcyBvY2N1cnJlZC4gIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCBOT1QgZ2VuZXJhdGUgYW4gQUNLLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4xLjJcbiAgICAgKi9cbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBCIGV4cGlyZWQgZm9yIElOVklURSBjbGllbnQgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNhbGxpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBUaW1lciBEIGZpcmVzIHdoaWxlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsXG4gICAgICogdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIG1vdmUgdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX0QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVGltZXIgRCBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgVGltZXIgTSBmaXJlcyB3aGlsZSB0aGUgY2xpZW50IHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIkFjY2VwdGVkXCJcbiAgICAgKiBzdGF0ZSwgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIG1vdmUgdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC40XG4gICAgICovXG4gICAgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnRpbWVyX00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiVGltZXIgTSBleHBpcmVkIGZvciBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gSW52aXRlQ2xpZW50VHJhbnNhY3Rpb247XG59KGNsaWVudF90cmFuc2FjdGlvbl8xLkNsaWVudFRyYW5zYWN0aW9uKSk7XG5leHBvcnRzLkludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gSW52aXRlQ2xpZW50VHJhbnNhY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdGltZXJzXzEgPSByZXF1aXJlKFwiLi4vdGltZXJzXCIpO1xudmFyIHNlcnZlcl90cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vc2VydmVyLXRyYW5zYWN0aW9uXCIpO1xudmFyIHRyYW5zYWN0aW9uX3N0YXRlXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvbi1zdGF0ZVwiKTtcbi8qKlxuICogSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICogQHB1YmxpY1xuICovXG52YXIgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogVXBvbiBjb25zdHJ1Y3Rpb24sIGEgXCIxMDAgVHJ5aW5nXCIgcmVwbHkgd2lsbCBiZSBpbW1lZGlhdGVseSBzZW50LlxuICAgICAqIEFmdGVyIGNvbnN0cnVjdGlvbiB0aGUgdHJhbnNhY3Rpb24gd2lsbCBiZSBpbiB0aGUgXCJwcm9jZWVkaW5nXCIgc3RhdGUgYW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIGBpZGAgd2lsbCBlcXVhbCB0aGUgYnJhbmNoIHBhcmFtZXRlciBzZXQgaW4gdGhlIFZpYSBoZWFkZXIgb2YgdGhlIGluY29taW5nIHJlcXVlc3QuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIEluY29taW5nIElOVklURSByZXF1ZXN0IGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdXNlciAtIFRoZSB0cmFuc2FjdGlvbiB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRyYW5zcG9ydCwgdXNlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyLCB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZywgXCJzaXAudHJhbnNhY3Rpb24uaXN0XCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RvcFByb2dyZXNzRXh0ZW5zaW9uVGltZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuSCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSCk7XG4gICAgICAgICAgICB0aGlzLkggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuSSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuSSk7XG4gICAgICAgICAgICB0aGlzLkkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuTCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTCk7XG4gICAgICAgICAgICB0aGlzLkwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAvKiogVHJhbnNhY3Rpb24ga2luZC4gRGVwcmVjYXRlZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpc3RcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUmVjZWl2ZSByZXF1ZXN0cyBmcm9tIHRyYW5zcG9ydCBtYXRjaGluZyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBtYXRjaGluZyB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHJlcXVlc3QgcmV0cmFuc21pc3Npb24gaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgbW9zdFxuICAgICAgICAgICAgICAgIC8vIHJlY2VudCBwcm92aXNpb25hbCByZXNwb25zZSB0aGF0IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBUVSBNVVNUIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgbGF5ZXIgZm9yIHJldHJhbnNtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBtZXNzYWdlc18xLkMuSU5WSVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhc3RQcm92aXNpb25hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5sYXN0UHJvdmlzaW9uYWxSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUsIGFueSByZXRyYW5zbWlzc2lvbnMgb2YgdGhlIElOVklURVxuICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkIHdpbGwgbWF0Y2ggdGhpcyB0cmFuc2FjdGlvbiBzdGF0ZSBtYWNoaW5lIGFuZCB3aWxsIGJlXG4gICAgICAgICAgICAgICAgLy8gYWJzb3JiZWQgYnkgdGhlIG1hY2hpbmUgd2l0aG91dCBjaGFuZ2luZyBpdHMgc3RhdGUuIFRoZXNlXG4gICAgICAgICAgICAgICAgLy8gcmV0cmFuc21pc3Npb25zIGFyZSBub3QgcGFzc2VkIG9udG8gdGhlIFRVLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tNy4xXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSBtZXNzYWdlc18xLkMuSU5WSVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gRnVydGhlcm1vcmUsIHdoaWxlIGluIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCBpZiBhIHJlcXVlc3QgcmV0cmFuc21pc3Npb24gaXNcbiAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCwgdGhlIHNlcnZlciBTSE9VTEQgcGFzcyB0aGUgcmVzcG9uc2UgdG8gdGhlIHRyYW5zcG9ydCBmb3IgcmV0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhc3RGaW5hbFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IGZpbmFsIHJlc3BvbnNlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdEZpbmFsUmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcmV0cmFuc21pc3Npb24gb2YgZmluYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBhbiBBQ0sgaXMgcmVjZWl2ZWQgd2hpbGUgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJDb25maXJtZWRcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbmZpcm1lZDpcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGUgXCJDb25maXJtZWRcIiBzdGF0ZSBpcyB0byBhYnNvcmIgYW55IGFkZGl0aW9uYWwgQUNLIG1lc3NhZ2VzIHRoYXQgYXJyaXZlLFxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJlZCBmcm9tIHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgZmluYWwgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUgfHwgcmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5BQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQ6XG4gICAgICAgICAgICAgICAgLy8gRm9yIGdvb2QgbWVhc3VyZSBhYnNvcmIgYW55IGFkZGl0aW9uYWwgbWVzc2FnZXMgdGhhdCBhcnJpdmUgKHNob3VsZCBub3QgaGFwcGVuKS5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5JTlZJVEUgfHwgcmVxdWVzdC5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5BQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIHJlcXVlc3Qgd2hpbGUgaW4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlICsgXCIuXCI7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgcmVzcG9uc2VzIGZyb20gVFUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHN0YXR1c0NvZGUgLSBTdGF0dXMgY29kZSBvZiByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBSZXNwb25zZS5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHN0YXR1c0NvZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc6XG4gICAgICAgICAgICAgICAgLy8gVGhlIFRVIHBhc3NlcyBhbnkgbnVtYmVyIG9mIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyB0byB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24uIFNvIGxvbmcgYXMgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgZWFjaCBvZiB0aGVzZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgLy8gbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi4gVGhleSBhcmUgbm90IHNlbnQgcmVsaWFibHkgYnkgdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gbGF5ZXIgKHRoZXkgYXJlIG5vdCByZXRyYW5zbWl0dGVkIGJ5IGl0KSBhbmQgZG8gbm90IGNhdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBjaGFuZ2UgaW4gdGhlIHN0YXRlIG9mIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0UHJvdmlzaW9uYWxSZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCB0aGUgcHJvZ3Jlc3MgZXh0ZW5zaW9uIHRpbWVyIG9ubHkgZm9yIGEgbm9uLTEwMCBwcm92aXNpb25hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRQcm9ncmVzc0V4dGVuc2lvblRpbWVyKCk7IC8vIEZJWE1FOiByZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQocmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgMXh4IHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYsIHdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgdGhlIFRVIHBhc3NlcyBhIDJ4eCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCBwYXNzIHRoaXNcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uIEl0IGlzIG5vdFxuICAgICAgICAgICAgICAgIC8vIHJldHJhbnNtaXR0ZWQgYnkgdGhlIHNlcnZlciB0cmFuc2FjdGlvbjsgcmV0cmFuc21pc3Npb25zIG9mIDJ4eFxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlcyBhcmUgaGFuZGxlZCBieSB0aGUgVFUuIFRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiB0byB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC41XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMjAwICYmIHN0YXR1c0NvZGUgPD0gMjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEZpbmFsUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgaWYgdGhlIFRVIHBhc3NlcyBhIHJlc3BvbnNlIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBzdGF0dXMgY29kZSBmcm9tIDMwMCB0byA2OTkgdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLCBhbmQgdGhlIHN0YXRlXG4gICAgICAgICAgICAgICAgLy8gbWFjaGluZSBNVVNUIGVudGVyIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4xXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwICYmIHN0YXR1c0NvZGUgPD0gNjk5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEZpbmFsUmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBub24tMnh4IGZpbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5BY2NlcHRlZDpcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSBpbiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlLCBpZiB0aGUgVFUgcGFzc2VzIGEgMnh4IHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCBwYXNzIHRoZSByZXNwb25zZSB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi04LjdcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSAyOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHJlc3BvbnNlKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSBcIiArIHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXNzYWdlID0gXCJJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBzdGF0dXNDb2RlICsgXCIgcmVzcG9uc2UgZnJvbSBUVSB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIi5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJhbnNtaXQgdGhlIGxhc3QgMnh4IHJlc3BvbnNlLiBUaGlzIGlzIGEgbm9vcCBpZiBub3QgaW4gdGhlIFwiYWNjZXB0ZWRcIiBzdGF0ZS5cbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmV0cmFuc21pdEFjY2VwdGVkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQgJiYgdGhpcy5sYXN0RmluYWxSZXNwb25zZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHRoaXMubGFzdEZpbmFsUmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIDJ4eCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmlyc3QsIHRoZSBwcm9jZWR1cmVzIGluIFs0XSBhcmUgZm9sbG93ZWQsIHdoaWNoIGF0dGVtcHQgdG8gZGVsaXZlciB0aGUgcmVzcG9uc2UgdG8gYSBiYWNrdXAuXG4gICAgICogSWYgdGhvc2Ugc2hvdWxkIGFsbCBmYWlsLCBiYXNlZCBvbiB0aGUgZGVmaW5pdGlvbiBvZiBmYWlsdXJlIGluIFs0XSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBTSE9VTERcbiAgICAgKiBpbmZvcm0gdGhlIFRVIHRoYXQgYSBmYWlsdXJlIGhhcyBvY2N1cnJlZCwgYW5kIE1VU1QgcmVtYWluIGluIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC44XG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBGb3IgbG9nZ2luZy4gKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgLSBOZXcgc3RhdGUuXG4gICAgICovXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIHZhciBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkOlxuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbiBhbnkgc3RhdGUgdHJhbnNpdGlvbiwgc3RvcCByZXNlbmRpbmcgcHJvdmlzaW9uYWwgcmVzcG9uc2VzXG4gICAgICAgIHRoaXMuc3RvcFByb2dyZXNzRXh0ZW5zaW9uVGltZXIoKTtcbiAgICAgICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhlIFwiQWNjZXB0ZWRcIiBzdGF0ZSBpcyB0byBhYnNvcmIgcmV0cmFuc21pc3Npb25zIG9mIGFuIGFjY2VwdGVkIElOVklURSByZXF1ZXN0LlxuICAgICAgICAvLyBBbnkgc3VjaCByZXRyYW5zbWlzc2lvbnMgYXJlIGFic29yYmVkIGVudGlyZWx5IHdpdGhpbiB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyBUaGV5IGFyZSBub3QgcGFzc2VkIHVwIHRvIHRoZSBUVSBzaW5jZSBhbnkgZG93bnN0cmVhbSBVQVMgY29yZXMgdGhhdCBhY2NlcHRlZCB0aGUgcmVxdWVzdCBoYXZlXG4gICAgICAgIC8vIHRha2VuIHJlc3BvbnNpYmlsaXR5IGZvciByZWxpYWJpbGl0eSBhbmQgd2lsbCBhbHJlYWR5IHJldHJhbnNtaXQgdGhlaXIgMnh4IHJlc3BvbnNlcyBpZiBuZWNlc3NhcnkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKSB7XG4gICAgICAgICAgICB0aGlzLkwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbWVyX0woKTsgfSwgdGltZXJzXzEuVGltZXJzLlRJTUVSX0wpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUgaXMgZW50ZXJlZCwgdGltZXIgSCBNVVNUIGJlIHNldCB0byBmaXJlIGluIDY0KlQxIHNlY29uZHMgZm9yIGFsbCB0cmFuc3BvcnRzLlxuICAgICAgICAvLyBUaW1lciBIIGRldGVybWluZXMgd2hlbiB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIGFiYW5kb25zIHJldHJhbnNtaXR0aW5nIHRoZSByZXNwb25zZS5cbiAgICAgICAgLy8gSWYgYW4gQUNLIGlzIHJlY2VpdmVkIHdoaWxlIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUsXG4gICAgICAgIC8vIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIkNvbmZpcm1lZFwiIHN0YXRlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMVxuICAgICAgICBpZiAobmV3U3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBNaXNzaW5nIHRpbWVyIEcgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAgICAgICAgIHRoaXMuSCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfSCgpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfSCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHB1cnBvc2Ugb2YgdGhlIFwiQ29uZmlybWVkXCIgc3RhdGUgaXMgdG8gYWJzb3JiIGFueSBhZGRpdGlvbmFsIEFDSyBtZXNzYWdlcyB0aGF0IGFycml2ZSxcbiAgICAgICAgLy8gdHJpZ2dlcmVkIGZyb20gcmV0cmFuc21pc3Npb25zIG9mIHRoZSBmaW5hbCByZXNwb25zZS4gV2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQsIHRpbWVyIElcbiAgICAgICAgLy8gaXMgc2V0IHRvIGZpcmUgaW4gVDQgc2Vjb25kcyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLCBhbmQgemVybyBzZWNvbmRzIGZvciByZWxpYWJsZVxuICAgICAgICAvLyB0cmFuc3BvcnRzLiBPbmNlIHRpbWVyIEkgZmlyZXMsIHRoZSBzZXJ2ZXIgTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVGhpcyB0aW1lciBpcyBub3QgZ2V0dGluZyBzZXQgY29ycmVjdGx5IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMuXG4gICAgICAgICAgICB0aGlzLkkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbWVyX0koKTsgfSwgdGltZXJzXzEuVGltZXJzLlRJTUVSX0kpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9uY2UgdGhlIHRyYW5zYWN0aW9uIGlzIGluIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZSwgaXQgTVVTVCBiZSBkZXN0cm95ZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC43XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGSVhNRTogVUFTIFByb3Zpc2lvbmFsIFJldHJhbnNtaXNzaW9uIFRpbWVyLiBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxuICAgICAqIFRoaXMgaXMgaW4gdGhlIHdyb25nIHBsYWNlLiBUaGlzIGlzIG5vdCBhIHRyYW5zYWN0aW9uIGxldmVsIHRoaW5nLiBJdCdzIGEgVUFTIGxldmVsIHRoaW5nLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdGFydFByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBwcm9ncmVzcyBleHRlbnNpb24gdGltZXIgb25seSBmb3IgdGhlIGZpcnN0IG5vbi0xMDAgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXG4gICAgICAgIGlmICh0aGlzLnByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0V4dGVuc2lvblRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIlByb2dyZXNzIGV4dGVuc2lvbiB0aW1lciBleHBpcmVkIGZvciBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIFwiICsgX3RoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5sYXN0UHJvdmlzaW9uYWxSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHByb3Zpc2lvbmFsIHJlc3BvbnNlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnNlbmQoX3RoaXMubGFzdFByb3Zpc2lvbmFsUmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCByZXRyYW5zbWlzc2lvbiBvZiBwcm92aXNpb25hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCB0aW1lcnNfMS5UaW1lcnMuUFJPVklTSU9OQUxfUkVTUE9OU0VfSU5URVJWQUwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGSVhNRTogVUFTIFByb3Zpc2lvbmFsIFJldHJhbnNtaXNzaW9uIFRpbWVyIGlkLiBTZWUgUkZDIDMyNjEgU2VjdGlvbiAxMy4zLjEuMVxuICAgICAqIFRoaXMgaXMgaW4gdGhlIHdyb25nIHBsYWNlLiBUaGlzIGlzIG5vdCBhIHRyYW5zYWN0aW9uIGxldmVsIHRoaW5nLiBJdCdzIGEgVUFTIGxldmVsIHRoaW5nLlxuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5zdG9wUHJvZ3Jlc3NFeHRlbnNpb25UaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucHJvZ3Jlc3NFeHRlbnNpb25UaW1lcik7XG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzRXh0ZW5zaW9uVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSwgaWYgdGhlIFRVIHBhc3NlcyBhIHJlc3BvbnNlIHdpdGggc3RhdHVzIGNvZGVcbiAgICAgKiBmcm9tIDMwMCB0byA2OTkgdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLCBhbmQgdGhlIHN0YXRlIG1hY2hpbmUgTVVTVCBlbnRlciB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgKiBGb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLCB0aW1lciBHIGlzIHNldCB0byBmaXJlIGluIFQxIHNlY29uZHMsIGFuZCBpcyBub3Qgc2V0IHRvIGZpcmUgZm9yXG4gICAgICogcmVsaWFibGUgdHJhbnNwb3J0cy4gSWYgdGltZXIgRyBmaXJlcywgdGhlIHJlc3BvbnNlIGlzIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIG9uY2VcbiAgICAgKiBtb3JlIGZvciByZXRyYW5zbWlzc2lvbiwgYW5kIHRpbWVyIEcgaXMgc2V0IHRvIGZpcmUgaW4gTUlOKDIqVDEsIFQyKSBzZWNvbmRzLiBGcm9tIHRoZW4gb24sXG4gICAgICogd2hlbiB0aW1lciBHIGZpcmVzLCB0aGUgcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgYWdhaW4gZm9yIHRyYW5zbWlzc2lvbiwgYW5kXG4gICAgICogdGltZXIgRyBpcyByZXNldCB3aXRoIGEgdmFsdWUgdGhhdCBkb3VibGVzLCB1bmxlc3MgdGhhdCB2YWx1ZSBleGNlZWRzIFQyLCBpbiB3aGljaCBjYXNlXG4gICAgICogaXQgaXMgcmVzZXQgd2l0aCB0aGUgdmFsdWUgb2YgVDIuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgdGltZXIgSCBmaXJlcyB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSwgaXQgaW1wbGllcyB0aGF0IHRoZSBBQ0sgd2FzIG5ldmVyIHJlY2VpdmVkLlxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLCBhbmQgTVVTVFxuICAgICAqIGluZGljYXRlIHRvIHRoZSBUVSB0aGF0IGEgdHJhbnNhY3Rpb24gZmFpbHVyZSBoYXMgb2NjdXJyZWQuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBIIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkFDSyB0byBuZWdhdGl2ZSBmaW5hbCByZXNwb25zZSB3YXMgbmV2ZXIgcmVjZWl2ZWQsIHRlcm1pbmF0aW5nIHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogT25jZSB0aW1lciBJIGZpcmVzLCB0aGUgc2VydmVyIE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjFcbiAgICAgKi9cbiAgICBJbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBJIGV4cGlyZWQgZm9yIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24gXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaGVuIFRpbWVyIEwgZmlyZXMgYW5kIHRoZSBzdGF0ZSBtYWNoaW5lIGlzIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUsIHRoZSBtYWNoaW5lIE1VU1RcbiAgICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS4gT25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLFxuICAgICAqIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LiBUaW1lciBMIHJlZmxlY3RzIHRoZSBhbW91bnQgb2YgdGltZSB0aGUgc2VydmVyXG4gICAgICogdHJhbnNhY3Rpb24gY291bGQgcmVjZWl2ZSAyeHggcmVzcG9uc2VzIGZvciByZXRyYW5zbWlzc2lvbiBmcm9tIHRoZVxuICAgICAqIFRVIHdoaWxlIGl0IGlzIHdhaXRpbmcgdG8gcmVjZWl2ZSBhbiBBQ0suXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYwMjYjc2VjdGlvbi03LjFcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguN1xuICAgICAqL1xuICAgIEludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS50aW1lcl9MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyhcIlRpbWVyIEwgZXhwaXJlZCBmb3IgSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvbiBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQWNjZXB0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEludml0ZVNlcnZlclRyYW5zYWN0aW9uO1xufShzZXJ2ZXJfdHJhbnNhY3Rpb25fMS5TZXJ2ZXJUcmFuc2FjdGlvbikpO1xuZXhwb3J0cy5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IEludml0ZVNlcnZlclRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgY2xpZW50X3RyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtdHJhbnNhY3Rpb25cIik7XG52YXIgdHJhbnNhY3Rpb25fc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCIpO1xuLyoqXG4gKiBOb24tSU5WSVRFIENsaWVudCBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBOb24tSU5WSVRFIHRyYW5zYWN0aW9ucyBkbyBub3QgbWFrZSB1c2Ugb2YgQUNLLlxuICogVGhleSBhcmUgc2ltcGxlIHJlcXVlc3QtcmVzcG9uc2UgaW50ZXJhY3Rpb25zLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjJcbiAqIEBwdWJsaWNcbiAqL1xudmFyIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogVXBvbiBjb25zdHJ1Y3Rpb24sIHRoZSBvdXRnb2luZyByZXF1ZXN0J3MgVmlhIGhlYWRlciBpcyB1cGRhdGVkIGJ5IGNhbGxpbmcgYHNldFZpYUhlYWRlcmAuXG4gICAgICogVGhlbiBgdG9TdHJpbmdgIGlzIGNhbGxlZCBvbiB0aGUgb3V0Z29pbmcgcmVxdWVzdCBhbmQgdGhlIG1lc3NhZ2UgaXMgc2VudCB2aWEgdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBBZnRlciBjb25zdHJ1Y3Rpb24gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgaW4gdGhlIFwiY2FsbGluZ1wiIHN0YXRlIGFuZCB0aGUgdHJhbnNhY3Rpb24gaWRcbiAgICAgKiB3aWxsIGVxdWFsIHRoZSBicmFuY2ggcGFyYW1ldGVyIHNldCBpbiB0aGUgVmlhIGhlYWRlciBvZiB0aGUgb3V0Z29pbmcgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIG91dGdvaW5nIE5vbi1JTlZJVEUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdXNlciAtIFRoZSB0cmFuc2FjdGlvbiB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uKHJlcXVlc3QsIHRyYW5zcG9ydCwgdXNlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIsIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcsIFwic2lwLnRyYW5zYWN0aW9uLm5pY3RcIikgfHwgdGhpcztcbiAgICAgICAgLy8gRklYTUU6IFRpbWVyIEUgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cyBub3QgaW1wbGVtZW50ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBcIlRyeWluZ1wiIHN0YXRlIGlzIGVudGVyZWQgd2hlbiB0aGUgVFUgaW5pdGlhdGVzIGEgbmV3IGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiB3aXRoIGEgcmVxdWVzdC4gIFdoZW4gZW50ZXJpbmcgdGhpcyBzdGF0ZSwgdGhlIGNsaWVudFxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBTSE9VTEQgc2V0IHRpbWVyIEYgdG8gZmlyZSBpbiA2NCpUMSBzZWNvbmRzLiBUaGUgcmVxdWVzdFxuICAgICAgICAvLyBNVVNUIGJlIHBhc3NlZCB0byB0aGUgdHJhbnNwb3J0IGxheWVyIGZvciB0cmFuc21pc3Npb24uXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgX3RoaXMuRiA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfRigpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfRik7XG4gICAgICAgIF90aGlzLnNlbmQocmVxdWVzdC50b1N0cmluZygpKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIGluaXRpYWwgb3V0Z29pbmcgcmVxdWVzdC5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICovXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLkYpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkYpO1xuICAgICAgICAgICAgdGhpcy5GID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLkspIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkspO1xuICAgICAgICAgICAgdGhpcy5LID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibmljdFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciBpbmNvbWluZyByZXNwb25zZXMgZnJvbSB0aGUgdHJhbnNwb3J0IHdoaWNoIG1hdGNoIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIGluY29taW5nIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUgfHwgc3RhdHVzQ29kZSA8IDEwMCB8fCBzdGF0dXNDb2RlID4gNjk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXR1cyBjb2RlIFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBwcm92aXNpb25hbCByZXNwb25zZSBpcyByZWNlaXZlZCB3aGlsZSBpbiB0aGUgXCJUcnlpbmdcIiBzdGF0ZSwgdGhlXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIFRVLCBhbmQgdGhlbiB0aGUgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gU0hPVUxEIG1vdmUgdG8gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51c2VyLnJlY2VpdmVSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGZpbmFsIHJlc3BvbnNlIChzdGF0dXMgY29kZXMgMjAwLTY5OSkgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJUcnlpbmdcIiBzdGF0ZSwgdGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSBUVSwgYW5kIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNsaWVudCB0cmFuc2FjdGlvbiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4xLjIuMlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDw9IDY5OSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlVHJhbnNpdGlvbih0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDQwOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlcXVlc3RUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nOlxuICAgICAgICAgICAgICAgIC8vIElmIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLFxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgVFUuIChGcm9tIEZpZ3VyZSA2KVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAxMDAgJiYgc3RhdHVzQ29kZSA8PSAxOTkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlci5yZWNlaXZlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBhIGZpbmFsIHJlc3BvbnNlIChzdGF0dXMgY29kZXMgMjAwLTY5OSkgaXMgcmVjZWl2ZWQgd2hpbGUgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0byB0aGUgVFUsIGFuZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSA0MDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXIucmVjZWl2ZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlIGV4aXN0cyB0byBidWZmZXIgYW55IGFkZGl0aW9uYWwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyByZXRyYW5zbWlzc2lvbnMgdGhhdCBtYXkgYmUgcmVjZWl2ZWQgKHdoaWNoIGlzIHdoeSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gcmVtYWlucyB0aGVyZSBvbmx5IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMpLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIC8vIEZvciBnb29kIG1lYXN1cmUganVzdCBhYnNvcmIgYWRkaXRpb25hbCByZXNwb25zZSByZXRyYW5zbWlzc2lvbnMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBzdGF0dXNDb2RlICsgXCIgcmVzcG9uc2Ugd2hpbGUgaW4gc3RhdGUgXCIgKyB0aGlzLnN0YXRlICsgXCIuXCI7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4obWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgdHJhbnNhY3Rpb24gU0hPVUxEIGluZm9ybSB0aGUgVFUgdGhhdCBhIHRyYW5zcG9ydCBmYWlsdXJlIGhhcyBvY2N1cnJlZCxcbiAgICAgKiBhbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgdHJhbnNpdGlvbiBkaXJlY3RseSB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogVGhlIFRVIHdpbGwgaGFuZGxlIHRoZSBmYWlsIG92ZXIgbWVjaGFuaXNtcyBkZXNjcmliZWQgaW4gWzRdLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS40XG4gICAgICogQHBhcmFtIGVycm9yIC0gVHJhbnNwb3J0IGVycm9yXG4gICAgICovXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlci5vblRyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQsIHRydWUpO1xuICAgIH07XG4gICAgLyoqIEZvciBsb2dnaW5nLiAqL1xuICAgIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLnByb3RvdHlwZS50eXBlVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIm5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uXCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeGVjdXRlIGEgc3RhdGUgdHJhbnNpdGlvbi5cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgLSBOZXcgc3RhdGUuXG4gICAgICovXG4gICAgTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZHVlVG9UcmFuc3BvcnRFcnJvciA9PT0gdm9pZCAwKSB7IGR1ZVRvVHJhbnNwb3J0RXJyb3IgPSBmYWxzZTsgfVxuICAgICAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIHZhciBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkdWVUb1RyYW5zcG9ydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmNlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gZW50ZXJzIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCBpdCBNVVNUIHNldFxuICAgICAgICAvLyBUaW1lciBLIHRvIGZpcmUgaW4gVDQgc2Vjb25kcyBmb3IgdW5yZWxpYWJsZSB0cmFuc3BvcnRzLCBhbmQgemVyb1xuICAgICAgICAvLyBzZWNvbmRzIGZvciByZWxpYWJsZSB0cmFuc3BvcnRzICBUaGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSBleGlzdHMgdG9cbiAgICAgICAgLy8gYnVmZmVyIGFueSBhZGRpdGlvbmFsIHJlc3BvbnNlIHJldHJhbnNtaXNzaW9ucyB0aGF0IG1heSBiZSByZWNlaXZlZFxuICAgICAgICAvLyAod2hpY2ggaXMgd2h5IHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gcmVtYWlucyB0aGVyZSBvbmx5IGZvciB1bnJlbGlhYmxlIHRyYW5zcG9ydHMpLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuRikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkYpO1xuICAgICAgICAgICAgICAgIHRoaXMuRiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuSyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudGltZXJfSygpOyB9LCB0aW1lcnNfMS5UaW1lcnMuVElNRVJfSyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIHRlcm1pbmF0ZWQgc3RhdGUsIGl0IE1VU1QgYmUgZGVzdHJveWVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjEuMi4yXG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZS5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBUaW1lciBGIGZpcmVzIHdoaWxlIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gaXMgc3RpbGwgaW4gdGhlXG4gICAgICogXCJUcnlpbmdcIiBzdGF0ZSwgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiBTSE9VTEQgaW5mb3JtIHRoZSBUVSBhYm91dCB0aGVcbiAgICAgKiB0aW1lb3V0LCBhbmQgdGhlbiBpdCBTSE9VTEQgZW50ZXIgdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAqIElmIHRpbWVyIEYgZmlyZXMgd2hpbGUgaW4gdGhlIFwiUHJvY2VlZGluZ1wiIHN0YXRlLCB0aGUgVFUgTVVTVCBiZSBpbmZvcm1lZCBvZlxuICAgICAqIGEgdGltZW91dCwgYW5kIHRoZSBjbGllbnQgdHJhbnNhY3Rpb24gTVVTVCB0cmFuc2l0aW9uIHRvIHRoZSB0ZXJtaW5hdGVkIHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgKi9cbiAgICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfRiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBGIGV4cGlyZWQgZm9yIG5vbi1JTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UcnlpbmcgfHwgdGhpcy5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXF1ZXN0VGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRlcm1pbmF0ZWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiBUaW1lciBLIGZpcmVzIHdoaWxlIGluIHRoaXMgKENPTVBMRVRFRCkgc3RhdGUsIHRoZSBjbGllbnQgdHJhbnNhY3Rpb25cbiAgICAgKiBNVVNUIHRyYW5zaXRpb24gdG8gdGhlIFwiVGVybWluYXRlZFwiIHN0YXRlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4yLjJcbiAgICAgKi9cbiAgICBOb25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uO1xufShjbGllbnRfdHJhbnNhY3Rpb25fMS5DbGllbnRUcmFuc2FjdGlvbikpO1xuZXhwb3J0cy5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiA9IE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0aW1lcnNfMSA9IHJlcXVpcmUoXCIuLi90aW1lcnNcIik7XG52YXIgc2VydmVyX3RyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItdHJhbnNhY3Rpb25cIik7XG52YXIgdHJhbnNhY3Rpb25fc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uLXN0YXRlXCIpO1xuLyoqXG4gKiBOb24tSU5WSVRFIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICogQHB1YmxpY1xuICovXG52YXIgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQWZ0ZXIgY29uc3RydWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIGluIHRoZSBcInRyeWluZ1wiOiBzdGF0ZSBhbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICogYGlkYCB3aWxsIGVxdWFsIHRoZSBicmFuY2ggcGFyYW1ldGVyIHNldCBpbiB0aGUgVmlhIGhlYWRlciBvZiB0aGUgaW5jb21pbmcgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gSW5jb21pbmcgTm9uLUlOVklURSByZXF1ZXN0IGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0IC0gVGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gdXNlciAtIFRoZSB0cmFuc2FjdGlvbiB1c2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKHJlcXVlc3QsIHRyYW5zcG9ydCwgdXNlcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcmVxdWVzdCwgdHJhbnNwb3J0LCB1c2VyLCB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nLCBcInNpcC50cmFuc2FjdGlvbi5uaXN0XCIpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICovXG4gICAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLkopIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLkopO1xuICAgICAgICAgICAgdGhpcy5KID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJraW5kXCIsIHtcbiAgICAgICAgLyoqIFRyYW5zYWN0aW9uIGtpbmQuIERlcHJlY2F0ZWQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibmlzdFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBSZWNlaXZlIHJlcXVlc3RzIGZyb20gdHJhbnNwb3J0IG1hdGNoaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBSZXF1ZXN0IG1hdGNoaW5nIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlY2VpdmVSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgICAgICAgICAgLy8gT25jZSBpbiB0aGUgXCJUcnlpbmdcIiBzdGF0ZSwgYW55IGZ1cnRoZXIgcmVxdWVzdCByZXRyYW5zbWlzc2lvbnMgYXJlIGRpc2NhcmRlZC5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICAvLyBJZiBhIHJldHJhbnNtaXNzaW9uIG9mIHRoZSByZXF1ZXN0IGlzIHJlY2VpdmVkIHdoaWxlIGluIHRoZSBcIlByb2NlZWRpbmdcIiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyB0aGUgbW9zdCByZWNlbnRseSBzZW50IHByb3Zpc2lvbmFsIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHJldHJhbnNtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxhc3RSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXN0IHJlc3BvbnNlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZCh0aGlzLmxhc3RSZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ1RyYW5zcG9ydEVycm9yKGVycm9yLCBcIkZhaWxlZCB0byBzZW5kIHJldHJhbnNtaXNzaW9uIG9mIHByb3Zpc2lvbmFsIHJlc3BvbnNlLlwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZDpcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSwgdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIHBhc3MgdGhlIGZpbmFsIHJlc3BvbnNlIHRvIHRoZSB0cmFuc3BvcnRcbiAgICAgICAgICAgICAgICAvLyBsYXllciBmb3IgcmV0cmFuc21pc3Npb24gd2hlbmV2ZXIgYSByZXRyYW5zbWlzc2lvbiBvZiB0aGUgcmVxdWVzdCBpcyByZWNlaXZlZC4gQW55IG90aGVyIGZpbmFsIHJlc3BvbnNlc1xuICAgICAgICAgICAgICAgIC8vIHBhc3NlZCBieSB0aGUgVFUgdG8gdGhlIHNlcnZlciB0cmFuc2FjdGlvbiBNVVNUIGJlIGRpc2NhcmRlZCB3aGlsZSBpbiB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5sYXN0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGFzdCByZXNwb25zZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5sYXN0UmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCByZXRyYW5zbWlzc2lvbiBvZiBmaW5hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgcmVzcG9uc2VzIGZyb20gVFUgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHN0YXR1c0NvZGUgLSBTdGF0dXMgY29kZSBvZiByZXNwb25zZS4gMTAxLTE5OSBub3QgYWxsb3dlZCBwZXIgUkZDIDQzMjAuXG4gICAgICogQHBhcmFtIHJlc3BvbnNlIC0gUmVzcG9uc2UgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlID0gZnVuY3Rpb24gKHN0YXR1c0NvZGUsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMTAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbiBTSVAgZWxlbWVudCBNVVNUIE5PVCBzZW5kIGFueSBwcm92aXNpb25hbCByZXNwb25zZSB3aXRoIGFcbiAgICAgICAgLy8gU3RhdHVzLUNvZGUgb3RoZXIgdGhhbiAxMDAgdG8gYSBub24tSU5WSVRFIHJlcXVlc3QuXG4gICAgICAgIC8vIEFuIFNJUCBlbGVtZW50IE1VU1QgTk9UIHJlc3BvbmQgdG8gYSBub24tSU5WSVRFIHJlcXVlc3Qgd2l0aCBhXG4gICAgICAgIC8vIFN0YXR1cy1Db2RlIG9mIDEwMCBvdmVyIGFueSB1bnJlbGlhYmxlIHRyYW5zcG9ydCwgc3VjaCBhcyBVRFAsXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgYW1vdW50IG9mIHRpbWUgaXQgdGFrZXMgYSBjbGllbnQgdHJhbnNhY3Rpb24ncyBUaW1lciBFIHRvIGJlIHJlc2V0IHRvIFQyLlxuICAgICAgICAvLyBBbiBTSVAgZWxlbWVudCBNQVkgcmVzcG9uZCB0byBhIG5vbi1JTlZJVEUgcmVxdWVzdCB3aXRoIGFcbiAgICAgICAgLy8gU3RhdHVzLUNvZGUgb2YgMTAwIG92ZXIgYSByZWxpYWJsZSB0cmFuc3BvcnQgYXQgYW55IHRpbWUuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MzIwI3NlY3Rpb24tNC4xXG4gICAgICAgIGlmIChzdGF0dXNDb2RlID4gMTAwICYmIHN0YXR1c0NvZGUgPD0gMTk5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm92aXNpb25hbCByZXNwb25zZSBvdGhlciB0aGFuIDEwMCBub3QgYWxsb3dlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgaW4gdGhlIFwiVHJ5aW5nXCIgc3RhdGUsIGlmIHRoZSBUVSBwYXNzZXMgYSBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24sIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCBlbnRlciB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlc3BvbnNlIE1VU1QgYmUgcGFzc2VkIHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIgZm9yIHRyYW5zbWlzc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuMlxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPj0gMTAwICYmIHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmQocmVzcG9uc2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nVHJhbnNwb3J0RXJyb3IoZXJyb3IsIFwiRmFpbGVkIHRvIHNlbmQgcHJvdmlzaW9uYWwgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBmaW5hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICAvLyBBbnkgZnVydGhlciBwcm92aXNpb25hbCByZXNwb25zZXMgdGhhdCBhcmUgcmVjZWl2ZWQgZnJvbSB0aGUgVFUgd2hpbGVcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBUVSBwYXNzZXMgYSBmaW5hbCByZXNwb25zZSAoc3RhdHVzIGNvZGVzIDIwMC02OTkpIHRvIHRoZSBzZXJ2ZXIgd2hpbGUgaW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgXCJQcm9jZWVkaW5nXCIgc3RhdGUsIHRoZSB0cmFuc2FjdGlvbiBNVVNUIGVudGVyIHRoZSBcIkNvbXBsZXRlZFwiIHN0YXRlLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVzcG9uc2UgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBmb3IgdHJhbnNtaXNzaW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMi4yXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8PSA2OTkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZVRyYW5zaXRpb24odHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLkNvbXBsZXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZChyZXNwb25zZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dUcmFuc3BvcnRFcnJvcihlcnJvciwgXCJGYWlsZWQgdG8gc2VuZCBmaW5hbCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIC8vIEFueSBvdGhlciBmaW5hbCByZXNwb25zZXMgcGFzc2VkIGJ5IHRoZSBUVSB0byB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gTVVTVCBiZSBkaXNjYXJkZWQgd2hpbGUgaW4gdGhlIFwiQ29tcGxldGVkXCIgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIFwiICsgdGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIk5vbi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIHJlY2VpdmVkIHVuZXhwZWN0ZWQgXCIgKyBzdGF0dXNDb2RlICsgXCIgcmVzcG9uc2UgZnJvbSBUVSB3aGlsZSBpbiBzdGF0ZSBcIiArIHRoaXMuc3RhdGUgKyBcIi5cIjtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpcnN0LCB0aGUgcHJvY2VkdXJlcyBpbiBbNF0gYXJlIGZvbGxvd2VkLCB3aGljaCBhdHRlbXB0IHRvIGRlbGl2ZXIgdGhlIHJlc3BvbnNlIHRvIGEgYmFja3VwLlxuICAgICAqIElmIHRob3NlIHNob3VsZCBhbGwgZmFpbCwgYmFzZWQgb24gdGhlIGRlZmluaXRpb24gb2YgZmFpbHVyZSBpbiBbNF0sIHRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gU0hPVUxEXG4gICAgICogaW5mb3JtIHRoZSBUVSB0aGF0IGEgZmFpbHVyZSBoYXMgb2NjdXJyZWQsIGFuZCBTSE9VTEQgdHJhbnNpdGlvbiB0byB0aGUgdGVybWluYXRlZCBzdGF0ZS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuNFxuICAgICAqL1xuICAgIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLnByb3RvdHlwZS5vblRyYW5zcG9ydEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLnVzZXIub25UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgdGhpcy51c2VyLm9uVHJhbnNwb3J0RXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkLCB0cnVlKTtcbiAgICB9O1xuICAgIC8qKiBGb3IgbG9nZ2luZy4gKi9cbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudHlwZVRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJub24tSU5WSVRFIHNlcnZlciB0cmFuc2FjdGlvblwiO1xuICAgIH07XG4gICAgTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLnN0YXRlVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZHVlVG9UcmFuc3BvcnRFcnJvciA9PT0gdm9pZCAwKSB7IGR1ZVRvVHJhbnNwb3J0RXJyb3IgPSBmYWxzZTsgfVxuICAgICAgICAvLyBBc3NlcnQgdmFsaWQgc3RhdGUgdHJhbnNpdGlvbnMuXG4gICAgICAgIHZhciBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gXCIgKyBfdGhpcy5zdGF0ZSArIFwiIHRvIFwiICsgbmV3U3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Ucnlpbmc6XG4gICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gdHJhbnNhY3Rpb25fc3RhdGVfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZykge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nICYmIHRoaXMuc3RhdGUgIT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRTdGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyAmJiB0aGlzLnN0YXRlICE9PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHVlVG9UcmFuc3BvcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFN0YXRlVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpbnZhbGlkU3RhdGVUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgc2VydmVyIHRyYW5zYWN0aW9uIGVudGVycyB0aGUgXCJDb21wbGV0ZWRcIiBzdGF0ZSwgaXQgTVVTVCBzZXQgVGltZXIgSiB0byBmaXJlXG4gICAgICAgIC8vIGluIDY0KlQxIHNlY29uZHMgZm9yIHVucmVsaWFibGUgdHJhbnNwb3J0cywgYW5kIHplcm8gc2Vjb25kcyBmb3IgcmVsaWFibGUgdHJhbnNwb3J0cy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLkogPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbWVyX0ooKTsgfSwgdGltZXJzXzEuVGltZXJzLlRJTUVSX0opO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgdHJhbnNhY3Rpb24gTVVTVCBiZSBkZXN0cm95ZWQgdGhlIGluc3RhbnQgaXQgZW50ZXJzIHRoZSBcIlRlcm1pbmF0ZWRcIiBzdGF0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgICAgaWYgKG5ld1N0YXRlID09PSB0cmFuc2FjdGlvbl9zdGF0ZV8xLlRyYW5zYWN0aW9uU3RhdGUuVGVybWluYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIHRyYW5zYWN0aW9uIHJlbWFpbnMgaW4gdGhpcyBzdGF0ZSB1bnRpbCBUaW1lciBKIGZpcmVzLFxuICAgICAqIGF0IHdoaWNoIHBvaW50IGl0IE1VU1QgdHJhbnNpdGlvbiB0byB0aGUgXCJUZXJtaW5hdGVkXCIgc3RhdGUuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNy4yLjJcbiAgICAgKi9cbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbi5wcm90b3R5cGUudGltZXJfSiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJUaW1lciBKIGV4cGlyZWQgZm9yIE5PTi1JTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uIFwiICsgdGhpcy5pZCArIFwiLlwiKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVUcmFuc2l0aW9uKHRyYW5zYWN0aW9uX3N0YXRlXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uO1xufShzZXJ2ZXJfdHJhbnNhY3Rpb25fMS5TZXJ2ZXJUcmFuc2FjdGlvbikpO1xuZXhwb3J0cy5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiA9IE5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG4vKipcbiAqIFNlcnZlciBUcmFuc2FjdGlvbi5cbiAqIEByZW1hcmtzXG4gKiBUaGUgc2VydmVyIHRyYW5zYWN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZGVsaXZlcnkgb2YgcmVxdWVzdHMgdG9cbiAqIHRoZSBUVSBhbmQgdGhlIHJlbGlhYmxlIHRyYW5zbWlzc2lvbiBvZiByZXNwb25zZXMuICBJdCBhY2NvbXBsaXNoZXNcbiAqIHRoaXMgdGhyb3VnaCBhIHN0YXRlIG1hY2hpbmUuICBTZXJ2ZXIgdHJhbnNhY3Rpb25zIGFyZSBjcmVhdGVkIGJ5IHRoZVxuICogY29yZSB3aGVuIGEgcmVxdWVzdCBpcyByZWNlaXZlZCwgYW5kIHRyYW5zYWN0aW9uIGhhbmRsaW5nIGlzIGRlc2lyZWRcbiAqIGZvciB0aGF0IHJlcXVlc3QgKHRoaXMgaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjJcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFNlcnZlclRyYW5zYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFNlcnZlclRyYW5zYWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcnZlclRyYW5zYWN0aW9uKF9yZXF1ZXN0LCB0cmFuc3BvcnQsIHVzZXIsIHN0YXRlLCBsb2dnZXJDYXRlZ29yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc3BvcnQsIHVzZXIsIF9yZXF1ZXN0LnZpYUJyYW5jaCwgc3RhdGUsIGxvZ2dlckNhdGVnb3J5KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmVxdWVzdCA9IF9yZXF1ZXN0O1xuICAgICAgICBfdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmVyVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcInJlcXVlc3RcIiwge1xuICAgICAgICAvKiogVGhlIGluY29taW5nIHJlcXVlc3QgdGhlIHRyYW5zYWN0aW9uIGhhbmRsaW5nLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU2VydmVyVHJhbnNhY3Rpb247XG59KHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24pKTtcbmV4cG9ydHMuU2VydmVyVHJhbnNhY3Rpb24gPSBTZXJ2ZXJUcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUcmFuc2FjdGlvbiBzdGF0ZS5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdGUpIHtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiQWNjZXB0ZWRcIl0gPSBcIkFjY2VwdGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0ZVtcIkNhbGxpbmdcIl0gPSBcIkNhbGxpbmdcIjtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiQ29tcGxldGVkXCJdID0gXCJDb21wbGV0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiQ29uZmlybWVkXCJdID0gXCJDb25maXJtZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXRlW1wiUHJvY2VlZGluZ1wiXSA9IFwiUHJvY2VlZGluZ1wiO1xuICAgIFRyYW5zYWN0aW9uU3RhdGVbXCJUZXJtaW5hdGVkXCJdID0gXCJUZXJtaW5hdGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0ZVtcIlRyeWluZ1wiXSA9IFwiVHJ5aW5nXCI7XG59KShUcmFuc2FjdGlvblN0YXRlID0gZXhwb3J0cy5UcmFuc2FjdGlvblN0YXRlIHx8IChleHBvcnRzLlRyYW5zYWN0aW9uU3RhdGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgZXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4uL2V4Y2VwdGlvbnNcIik7XG4vKipcbiAqIFRyYW5zYWN0aW9uLlxuICogQHJlbWFya3NcbiAqIFNJUCBpcyBhIHRyYW5zYWN0aW9uYWwgcHJvdG9jb2w6IGludGVyYWN0aW9ucyBiZXR3ZWVuIGNvbXBvbmVudHMgdGFrZVxuICogcGxhY2UgaW4gYSBzZXJpZXMgb2YgaW5kZXBlbmRlbnQgbWVzc2FnZSBleGNoYW5nZXMuICBTcGVjaWZpY2FsbHksIGFcbiAqIFNJUCB0cmFuc2FjdGlvbiBjb25zaXN0cyBvZiBhIHNpbmdsZSByZXF1ZXN0IGFuZCBhbnkgcmVzcG9uc2VzIHRvXG4gKiB0aGF0IHJlcXVlc3QsIHdoaWNoIGluY2x1ZGUgemVybyBvciBtb3JlIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBhbmRcbiAqIG9uZSBvciBtb3JlIGZpbmFsIHJlc3BvbnNlcy4gIEluIHRoZSBjYXNlIG9mIGEgdHJhbnNhY3Rpb24gd2hlcmUgdGhlXG4gKiByZXF1ZXN0IHdhcyBhbiBJTlZJVEUgKGtub3duIGFzIGFuIElOVklURSB0cmFuc2FjdGlvbiksIHRoZVxuICogdHJhbnNhY3Rpb24gYWxzbyBpbmNsdWRlcyB0aGUgQUNLIG9ubHkgaWYgdGhlIGZpbmFsIHJlc3BvbnNlIHdhcyBub3RcbiAqIGEgMnh4IHJlc3BvbnNlLiAgSWYgdGhlIHJlc3BvbnNlIHdhcyBhIDJ4eCwgdGhlIEFDSyBpcyBub3QgY29uc2lkZXJlZFxuICogcGFydCBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3XG4gKiBAcHVibGljXG4gKi9cbnZhciBUcmFuc2FjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUcmFuc2FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbihfdHJhbnNwb3J0LCBfdXNlciwgX2lkLCBfc3RhdGUsIGxvZ2dlckNhdGVnb3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl90cmFuc3BvcnQgPSBfdHJhbnNwb3J0O1xuICAgICAgICBfdGhpcy5fdXNlciA9IF91c2VyO1xuICAgICAgICBfdGhpcy5faWQgPSBfaWQ7XG4gICAgICAgIF90aGlzLl9zdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgX3RoaXMubG9nZ2VyID0gX3VzZXIubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIobG9nZ2VyQ2F0ZWdvcnksIF9pZCk7XG4gICAgICAgIF90aGlzLmxvZ2dlci5kZWJ1ZyhcIkNvbnN0cnVjdGluZyBcIiArIF90aGlzLnR5cGVUb1N0cmluZygpICsgXCIgd2l0aCBpZCBcIiArIF90aGlzLmlkICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICogT25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gdGhlIFwidGVybWluYXRlZFwiIHN0YXRlLCBpdCBpcyBkZXN0cm95ZWRcbiAgICAgKiBpbW1lZGlhdGVseSBhbmQgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBkaXNwb3NlYC4gSG93ZXZlciwgaWYgYVxuICAgICAqIHRyYW5zYWN0aW9uIG5lZWRzIHRvIGJlIGVuZGVkIHByZW1hdHVyZWx5LCB0aGUgdHJhbnNhY3Rpb24gdXNlciBtYXlcbiAgICAgKiBkbyBzbyBieSBjYWxsaW5nIHRoaXMgbWV0aG9kIChmb3IgZXhhbXBsZSwgcGVyaGFwcyB0aGUgVUEgaXMgc2h1dHRpbmcgZG93bikuXG4gICAgICogTm8gc3RhdGUgdHJhbnNpdGlvbiB3aWxsIG9jY3VyIHVwb24gY2FsbGluZyB0aGlzIG1ldGhvZCwgYWxsIG91dHN0YW5kaW5nXG4gICAgICogdHJhbnNtaXNzaW9uIHRpbWVycyB3aWxsIGJlIGNhbmNlbGxlZCwgYW5kIHVzZSBvZiB0aGUgdHJhbnNhY3Rpb24gYWZ0ZXJcbiAgICAgKiBjYWxsaW5nIGBkaXNwb3NlYCBpcyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKFwiRGVzdHJveWVkIFwiICsgdGhpcy50eXBlVG9TdHJpbmcoKSArIFwiIHdpdGggaWQgXCIgKyB0aGlzLmlkICsgXCIuXCIpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zYWN0aW9uLnByb3RvdHlwZSwgXCJpZFwiLCB7XG4gICAgICAgIC8qKiBUcmFuc2FjdGlvbiBpZC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgIC8qKiBUcmFuc2FjdGlvbiBraW5kLiBEZXByZWNhdGVkLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2luZC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgICAgICAvKiogVHJhbnNhY3Rpb24gc3RhdGUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgIC8qKiBUcmFuc2FjdGlvbiB0cmFuc3BvcnQuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7IHJldHVybiBfc3VwZXIucHJvdG90eXBlLm9uLmNhbGwodGhpcywgbmFtZSwgY2FsbGJhY2spOyB9O1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5sb2dUcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJUcmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgaW4gXCIgKyB0aGlzLnR5cGVUb1N0cmluZygpICsgXCIgd2l0aCBpZCBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGFzcyBtZXNzYWdlIHRvIHRyYW5zcG9ydCBmb3IgdHJhbnNtaXNzaW9uLiBJZiB0cmFuc3BvcnQgZmFpbHMsXG4gICAgICogdGhlIHRyYW5zYWN0aW9uIHVzZXIgaXMgbm90aWZpZWQgYnkgY2FsbGJhY2sgdG8gb25UcmFuc3BvcnRFcnJvcigpLlxuICAgICAqIEByZXR1cm5zXG4gICAgICogUmVqZWN0cyB3aXRoIGBUcmFuc3BvcnRFcnJvcmAgaWYgdHJhbnNwb3J0IGZhaWxzLlxuICAgICAqL1xuICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnNlbmQobWVzc2FnZSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNwb3J0IHJlamVjdHMsIGl0IFNIT1VMRCByZWplY3Qgd2l0aCBhIFRyYW5zcG9ydEVycm9yLlxuICAgICAgICAgICAgLy8gQnV0IHRoZSB0cmFuc3BvcnQgbWF5IGJlIGV4dGVybmFsIGNvZGUsIHNvIHdlIGFyZSBjYXJlZnVsXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2UgY29udmVydCBpdCB0byBhIFRyYW5zcG9ydEVycm9yIGlmIG5lZWQgYmUuXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBleGNlcHRpb25zXzEuVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblRyYW5zcG9ydEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc3BvcnRFcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydEVycm9yID0gbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc3BvcnRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydEVycm9yID0gbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc3BvcnRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMub25UcmFuc3BvcnRFcnJvcih0cmFuc3BvcnRFcnJvcik7XG4gICAgICAgICAgICB0aHJvdyB0cmFuc3BvcnRFcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoXCJTdGF0ZSBjaGFuZ2UgdG8gXFxcIlwiICsgc3RhdGUgKyBcIlxcXCIgb24gXCIgKyB0aGlzLnR5cGVUb1N0cmluZygpICsgXCIgd2l0aCBpZCBcIiArIHRoaXMuaWQgKyBcIi5cIik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmICh0aGlzLl91c2VyLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXIub25TdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwic3RhdGVDaGFuZ2VkXCIpO1xuICAgIH07XG4gICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnR5cGVUb1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwiVW5rbm93blR5cGVcIjtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc2FjdGlvbjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xuLyoqXG4gKiBGSVhNRTogVE9ETzogU2hvdWxkIGJlIGNvbmZpZ3VyYWJsZS92YXJpYWJsZS5cbiAqL1xuZXhwb3J0cy5BbGxvd2VkTWV0aG9kcyA9IFtcbiAgICBtZXNzYWdlc18xLkMuQUNLLFxuICAgIG1lc3NhZ2VzXzEuQy5CWUUsXG4gICAgbWVzc2FnZXNfMS5DLkNBTkNFTCxcbiAgICBtZXNzYWdlc18xLkMuSU5GTyxcbiAgICBtZXNzYWdlc18xLkMuSU5WSVRFLFxuICAgIG1lc3NhZ2VzXzEuQy5NRVNTQUdFLFxuICAgIG1lc3NhZ2VzXzEuQy5OT1RJRlksXG4gICAgbWVzc2FnZXNfMS5DLk9QVElPTlMsXG4gICAgbWVzc2FnZXNfMS5DLlBSQUNLLFxuICAgIG1lc3NhZ2VzXzEuQy5SRUZFUixcbiAgICBtZXNzYWdlc18xLkMuUkVHSVNURVIsXG4gICAgbWVzc2FnZXNfMS5DLlNVQlNDUklCRVxuXTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91c2VyLWFnZW50LWNvcmVcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50c18xID0gcmVxdWlyZShcIi4uL3VzZXItYWdlbnRzXCIpO1xudmFyIGFsbG93ZWRfbWV0aG9kc18xID0gcmVxdWlyZShcIi4vYWxsb3dlZC1tZXRob2RzXCIpO1xuLyoqXG4gKiBUaGlzIGlzIHBvcnRlZCBmcm9tIFVBLkMuQUNDRVBURURfQk9EWV9UWVBFUy5cbiAqIEZJWE1FOiBUT0RPOiBTaG91bGQgYmUgY29uZmlndXJhYmxlL3ZhcmlhYmxlLlxuICovXG52YXIgYWNjZXB0ZWRCb2R5VHlwZXMgPSBbXG4gICAgXCJhcHBsaWNhdGlvbi9zZHBcIixcbiAgICBcImFwcGxpY2F0aW9uL2R0bWYtcmVsYXlcIlxuXTtcbi8qKlxuICogVXNlciBBZ2VudCBDb3JlLlxuICogQHJlbWFya3NcbiAqIENvcmUgZGVzaWduYXRlcyB0aGUgZnVuY3Rpb25zIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB0eXBlXG4gKiBvZiBTSVAgZW50aXR5LCBpLmUuLCBzcGVjaWZpYyB0byBlaXRoZXIgYSBzdGF0ZWZ1bCBvciBzdGF0ZWxlc3NcbiAqIHByb3h5LCBhIHVzZXIgYWdlbnQgb3IgcmVnaXN0cmFyLiAgQWxsIGNvcmVzLCBleGNlcHQgdGhvc2UgZm9yXG4gKiB0aGUgc3RhdGVsZXNzIHByb3h5LCBhcmUgdHJhbnNhY3Rpb24gdXNlcnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqXG4gKiBVQUMgQ29yZTogVGhlIHNldCBvZiBwcm9jZXNzaW5nIGZ1bmN0aW9ucyByZXF1aXJlZCBvZiBhIFVBQyB0aGF0XG4gKiByZXNpZGUgYWJvdmUgdGhlIHRyYW5zYWN0aW9uIGFuZCB0cmFuc3BvcnQgbGF5ZXJzLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi02XG4gKlxuICogVUFTIENvcmU6IFRoZSBzZXQgb2YgcHJvY2Vzc2luZyBmdW5jdGlvbnMgcmVxdWlyZWQgYXQgYSBVQVMgdGhhdFxuICogcmVzaWRlcyBhYm92ZSB0aGUgdHJhbnNhY3Rpb24gYW5kIHRyYW5zcG9ydCBsYXllcnMuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFVzZXJBZ2VudENvcmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IuXG4gICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gLSBDb25maWd1cmF0aW9uLlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIERlbGVnYXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVzZXJBZ2VudENvcmUoY29uZmlndXJhdGlvbiwgZGVsZWdhdGUpIHtcbiAgICAgICAgaWYgKGRlbGVnYXRlID09PSB2b2lkIDApIHsgZGVsZWdhdGUgPSB7fTsgfVxuICAgICAgICAvKiogVUFDcy4gKi9cbiAgICAgICAgdGhpcy51c2VyQWdlbnRDbGllbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogVUFTcy4gKi9cbiAgICAgICAgdGhpcy51c2VyQWdlbnRTZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZGlhbG9ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25maWd1cmF0aW9uLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLnVzZXItYWdlbnQtY29yZVwiKTtcbiAgICB9XG4gICAgLyoqIERlc3RydWN0b3IuICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gICAgLyoqIFJlc2V0LiAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpYWxvZ3MuZm9yRWFjaChmdW5jdGlvbiAoZGlhbG9nKSB7IHJldHVybiBkaWFsb2cuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5kaWFsb2dzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikgeyByZXR1cm4gc3Vic2NyaWJlci5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXNlckFnZW50Q2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh1YWMpIHsgcmV0dXJuIHVhYy5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB0aGlzLnVzZXJBZ2VudENsaWVudHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy51c2VyQWdlbnRTZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHVhYykgeyByZXR1cm4gdWFjLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIHRoaXMudXNlckFnZW50U2VydmVycy5jbGVhcigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudENvcmUucHJvdG90eXBlLCBcImxvZ2dlckZhY3RvcnlcIiwge1xuICAgICAgICAvKiogTG9nZ2VyIGZhY3RvcnkuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5sb2dnZXJGYWN0b3J5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50Q29yZS5wcm90b3R5cGUsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgLyoqIFRyYW5zcG9ydC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jb25maWd1cmF0aW9uLnRyYW5zcG9ydEFjY2Vzc29yKCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2VuZCBJTlZJVEUuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXNlcl9hZ2VudHNfMS5JbnZpdGVVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBNRVNTQUdFLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gT3V0Z29pbmcgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiAocmVxdWVzdCwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1c2VyX2FnZW50c18xLk1lc3NhZ2VVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBQVUJMSVNILlxuICAgICAqIEBwYXJhbSByZXF1ZXN0IC0gT3V0Z29pbmcgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZGVsZWdhdGUgLSBSZXF1ZXN0IGRlbGVnYXRlLlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAocmVxdWVzdCwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1c2VyX2FnZW50c18xLlB1Ymxpc2hVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBSRUdJU1RFUi5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIE91dGdvaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGRlbGVnYXRlIC0gUmVxdWVzdCBkZWxlZ2F0ZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHVzZXJfYWdlbnRzXzEuUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBTVUJTQ1JJQkUuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHJlcXVlc3QsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgdXNlcl9hZ2VudHNfMS5TdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQodGhpcywgcmVxdWVzdCwgZGVsZWdhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBPdXRnb2luZyByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBkZWxlZ2F0ZSAtIFJlcXVlc3QgZGVsZWdhdGUuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IHVzZXJfYWdlbnRzXzEuVXNlckFnZW50Q2xpZW50KHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCB0aGlzLCByZXF1ZXN0LCBkZWxlZ2F0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdXRnb2luZyByZXF1ZXN0IG1lc3NhZ2UgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIC0gTWV0aG9kLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0VVJJIC0gUmVxdWVzdC1VUkkuXG4gICAgICogQHBhcmFtIGZyb21VUkkgLSBGcm9tIFVSSS5cbiAgICAgKiBAcGFyYW0gdG9VUkkgLSBUbyBVUkkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGV4dHJhSGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSBib2R5IC0gTWVzc2FnZSBib2R5LlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENvcmUucHJvdG90eXBlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVxdWVzdFVSSSwgZnJvbVVSSSwgdG9VUkksIG9wdGlvbnMsIGV4dHJhSGVhZGVycywgYm9keSkge1xuICAgICAgICAvLyBkZWZhdWx0IHZhbHVlcyBmcm9tIHVzZXIgYWdlbnQgY29uZmlndXJhdGlvblxuICAgICAgICB2YXIgY2FsbElkUHJlZml4ID0gdGhpcy5jb25maWd1cmF0aW9uLnNpcGpzSWQ7XG4gICAgICAgIHZhciBmcm9tRGlzcGxheU5hbWUgPSB0aGlzLmNvbmZpZ3VyYXRpb24uZGlzcGxheU5hbWU7XG4gICAgICAgIHZhciBmb3JjZVJwb3J0ID0gdGhpcy5jb25maWd1cmF0aW9uLnZpYUZvcmNlUnBvcnQ7XG4gICAgICAgIHZhciBoYWNrVmlhVGNwID0gdGhpcy5jb25maWd1cmF0aW9uLmhhY2tWaWFUY3A7XG4gICAgICAgIHZhciBvcHRpb25UYWdzID0gdGhpcy5jb25maWd1cmF0aW9uLnN1cHBvcnRlZE9wdGlvblRhZ3Muc2xpY2UoKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLlJFR0lTVEVSKSB7XG4gICAgICAgICAgICBvcHRpb25UYWdzLnB1c2goXCJwYXRoXCIsIFwiZ3J1dVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBtZXNzYWdlc18xLkMuSU5WSVRFICYmICh0aGlzLmNvbmZpZ3VyYXRpb24uY29udGFjdC5wdWJHcnV1IHx8IHRoaXMuY29uZmlndXJhdGlvbi5jb250YWN0LnRlbXBHcnV1KSkge1xuICAgICAgICAgICAgb3B0aW9uVGFncy5wdXNoKFwiZ3J1dVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm91dGVTZXQgPSB0aGlzLmNvbmZpZ3VyYXRpb24ucm91dGVTZXQ7XG4gICAgICAgIHZhciB1c2VyQWdlbnRTdHJpbmcgPSB0aGlzLmNvbmZpZ3VyYXRpb24udXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZTtcbiAgICAgICAgdmFyIHZpYUhvc3QgPSB0aGlzLmNvbmZpZ3VyYXRpb24udmlhSG9zdDtcbiAgICAgICAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgY2FsbElkUHJlZml4OiBjYWxsSWRQcmVmaXgsXG4gICAgICAgICAgICBmb3JjZVJwb3J0OiBmb3JjZVJwb3J0LFxuICAgICAgICAgICAgZnJvbURpc3BsYXlOYW1lOiBmcm9tRGlzcGxheU5hbWUsXG4gICAgICAgICAgICBoYWNrVmlhVGNwOiBoYWNrVmlhVGNwLFxuICAgICAgICAgICAgb3B0aW9uVGFnczogb3B0aW9uVGFncyxcbiAgICAgICAgICAgIHJvdXRlU2V0OiByb3V0ZVNldCxcbiAgICAgICAgICAgIHVzZXJBZ2VudFN0cmluZzogdXNlckFnZW50U3RyaW5nLFxuICAgICAgICAgICAgdmlhSG9zdDogdmlhSG9zdCxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbWVyZ2UgcHJvdmlkZWQgb3B0aW9ucyB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB2YXIgcmVxdWVzdE9wdGlvbnMgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgbWVzc2FnZXNfMS5PdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1ldGhvZCwgcmVxdWVzdFVSSSwgZnJvbVVSSSwgdG9VUkksIHJlcXVlc3RPcHRpb25zLCBleHRyYUhlYWRlcnMsIGJvZHkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFuIGluY29taW5nIHJlcXVlc3QgbWVzc2FnZSBmcm9tIHRoZSB0cmFuc3BvcnQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UgZnJvbSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucmVjZWl2ZUluY29taW5nUmVxdWVzdEZyb21UcmFuc3BvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnJlY2VpdmVSZXF1ZXN0RnJvbVRyYW5zcG9ydChtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbmNvbWluZyByZXNwb25zZSBtZXNzYWdlIGZyb20gdGhlIHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UgZnJvbSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucmVjZWl2ZUluY29taW5nUmVzcG9uc2VGcm9tVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlUmVzcG9uc2VGcm9tVHJhbnNwb3J0KG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0ZWxlc3MgVUFTIGlzIGEgVUFTIHRoYXQgZG9lcyBub3QgbWFpbnRhaW4gdHJhbnNhY3Rpb24gc3RhdGUuXG4gICAgICogSXQgcmVwbGllcyB0byByZXF1ZXN0cyBub3JtYWxseSwgYnV0IGRpc2NhcmRzIGFueSBzdGF0ZSB0aGF0IHdvdWxkXG4gICAgICogb3JkaW5hcmlseSBiZSByZXRhaW5lZCBieSBhIFVBUyBhZnRlciBhIHJlc3BvbnNlIGhhcyBiZWVuIHNlbnQuICBJZiBhXG4gICAgICogc3RhdGVsZXNzIFVBUyByZWNlaXZlcyBhIHJldHJhbnNtaXNzaW9uIG9mIGEgcmVxdWVzdCwgaXQgcmVnZW5lcmF0ZXNcbiAgICAgKiB0aGUgcmVzcG9uc2UgYW5kIHJlLXNlbmRzIGl0LCBqdXN0IGFzIGlmIGl0IHdlcmUgcmVwbHlpbmcgdG8gdGhlIGZpcnN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIHJlcXVlc3QuIEEgVUFTIGNhbm5vdCBiZSBzdGF0ZWxlc3MgdW5sZXNzIHRoZSByZXF1ZXN0XG4gICAgICogcHJvY2Vzc2luZyBmb3IgdGhhdCBtZXRob2Qgd291bGQgYWx3YXlzIHJlc3VsdCBpbiB0aGUgc2FtZSByZXNwb25zZVxuICAgICAqIGlmIHRoZSByZXF1ZXN0cyBhcmUgaWRlbnRpY2FsLiBUaGlzIHJ1bGVzIG91dCBzdGF0ZWxlc3MgcmVnaXN0cmFycyxcbiAgICAgKiBmb3IgZXhhbXBsZS4gIFN0YXRlbGVzcyBVQVNzIGRvIG5vdCB1c2UgYSB0cmFuc2FjdGlvbiBsYXllcjsgdGhleVxuICAgICAqIHJlY2VpdmUgcmVxdWVzdHMgZGlyZWN0bHkgZnJvbSB0aGUgdHJhbnNwb3J0IGxheWVyIGFuZCBzZW5kIHJlc3BvbnNlc1xuICAgICAqIGRpcmVjdGx5IHRvIHRoZSB0cmFuc3BvcnQgbGF5ZXIuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuN1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVxdWVzdCBtZXNzYWdlIHRvIHJlcGx5IHRvLlxuICAgICAqIEBwYXJhbSBzdGF0dXNDb2RlIC0gU3RhdHVzIGNvZGUgdG8gcmVwbHkgd2l0aC5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZXBseVN0YXRlbGVzcyA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1c2VyQWdlbnQgPSB0aGlzLmNvbmZpZ3VyYXRpb24udXNlckFnZW50SGVhZGVyRmllbGRWYWx1ZTtcbiAgICAgICAgdmFyIHN1cHBvcnRlZCA9IHRoaXMuY29uZmlndXJhdGlvbi5zdXBwb3J0ZWRPcHRpb25UYWdzUmVzcG9uc2U7XG4gICAgICAgIG9wdGlvbnMgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHVzZXJBZ2VudDogdXNlckFnZW50LCBzdXBwb3J0ZWQ6IHN1cHBvcnRlZCB9KTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbWVzc2FnZXNfMS5jb25zdHJ1Y3RPdXRnb2luZ1Jlc3BvbnNlKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHJlc3BvbnNlLm1lc3NhZ2UpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zcG9ydCByZWplY3RzLCBpdCBTSE9VTEQgcmVqZWN0IHdpdGggYSBUcmFuc3BvcnRFcnJvci5cbiAgICAgICAgICAgIC8vIEJ1dCB0aGUgdHJhbnNwb3J0IG1heSBiZSBleHRlcm5hbCBjb2RlLCBzbyB3ZSBhcmUgY2FyZWZ1bC4uLlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJUcmFuc3BvcnQgZXJyb3Igb2NjdXJyZWQgc2VuZGluZyBzdGF0ZWxlc3MgcmVwbHkgdG8gXCIgKyBtZXNzYWdlLm1ldGhvZCArIFwiIHJlcXVlc3QuXCIpO1xuICAgICAgICAgICAgLy8gVE9ETzogQ3VycmVudGx5IHRoZXJlIGlzIG5vIGhvb2sgdG8gcHJvdmlkZSBub3RpZmljYXRpb24gdGhhdCBhIHRyYW5zcG9ydCBlcnJvciBvY2N1cnJlZFxuICAgICAgICAgICAgLy8gYW5kIHRocm93aW5nIHdvdWxkIHJlc3VsdCBpbiBhbiB1bmNhdWdodCBlcnJvciAoaW4gcHJvbWlzZSksIHNvIHdlIHNpbGVudGx5IGVhdCB0aGUgZXJyb3IuXG4gICAgICAgICAgICAvLyBGdXJ0aGVybW9yZSwgc2lsZW50bHkgZWF0aW5nIHN0YXRlbGVzcyByZXBseSB0cmFuc3BvcnQgZXJyb3JzIGlzIGFyZ3VhYmx5IHdoYXQgd2Ugd2FudCB0byBkbyBoZXJlLlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW4gU2VjdGlvbiAxOC4yLjEsIHJlcGxhY2UgdGhlIGxhc3QgcGFyYWdyYXBoIHdpdGg6XG4gICAgICpcbiAgICAgKiBOZXh0LCB0aGUgc2VydmVyIHRyYW5zcG9ydCBhdHRlbXB0cyB0byBtYXRjaCB0aGUgcmVxdWVzdCB0byBhXG4gICAgICogc2VydmVyIHRyYW5zYWN0aW9uLiAgSXQgZG9lcyBzbyB1c2luZyB0aGUgbWF0Y2hpbmcgcnVsZXMgZGVzY3JpYmVkXG4gICAgICogaW4gU2VjdGlvbiAxNy4yLjMuICBJZiBhIG1hdGNoaW5nIHNlcnZlciB0cmFuc2FjdGlvbiBpcyBmb3VuZCwgdGhlXG4gICAgICogcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhhdCB0cmFuc2FjdGlvbiBmb3IgcHJvY2Vzc2luZy4gIElmIG5vIG1hdGNoXG4gICAgICogaXMgZm91bmQsIHRoZSByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGUgY29yZSwgd2hpY2ggbWF5IGRlY2lkZSB0b1xuICAgICAqIGNvbnN0cnVjdCBhIG5ldyBzZXJ2ZXIgdHJhbnNhY3Rpb24gZm9yIHRoYXQgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMTBcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlUmVxdWVzdEZyb21UcmFuc3BvcnQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyBXaGVuIGEgcmVxdWVzdCBpcyByZWNlaXZlZCBmcm9tIHRoZSBuZXR3b3JrIGJ5IHRoZSBzZXJ2ZXIsIGl0IGhhcyB0b1xuICAgICAgICAvLyBiZSBtYXRjaGVkIHRvIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uLiAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgaW4gdGhlXG4gICAgICAgIC8vIGZvbGxvd2luZyBtYW5uZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBicmFuY2ggcGFyYW1ldGVyIGluIHRoZSB0b3Btb3N0IFZpYSBoZWFkZXIgZmllbGQgb2YgdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gaXMgZXhhbWluZWQuICBJZiBpdCBpcyBwcmVzZW50IGFuZCBiZWdpbnMgd2l0aCB0aGUgbWFnaWMgY29va2llXG4gICAgICAgIC8vIFwiejloRzRiS1wiLCB0aGUgcmVxdWVzdCB3YXMgZ2VuZXJhdGVkIGJ5IGEgY2xpZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIGNvbXBsaWFudCB0byB0aGlzIHNwZWNpZmljYXRpb24uICBUaGVyZWZvcmUsIHRoZSBicmFuY2ggcGFyYW1ldGVyXG4gICAgICAgIC8vIHdpbGwgYmUgdW5pcXVlIGFjcm9zcyBhbGwgdHJhbnNhY3Rpb25zIHNlbnQgYnkgdGhhdCBjbGllbnQuICBUaGVcbiAgICAgICAgLy8gcmVxdWVzdCBtYXRjaGVzIGEgdHJhbnNhY3Rpb24gaWY6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIDEuIHRoZSBicmFuY2ggcGFyYW1ldGVyIGluIHRoZSByZXF1ZXN0IGlzIGVxdWFsIHRvIHRoZSBvbmUgaW4gdGhlXG4gICAgICAgIC8vICAgICAgIHRvcCBWaWEgaGVhZGVyIGZpZWxkIG9mIHRoZSByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGVcbiAgICAgICAgLy8gICAgICAgdHJhbnNhY3Rpb24sIGFuZFxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAyLiB0aGUgc2VudC1ieSB2YWx1ZSBpbiB0aGUgdG9wIFZpYSBvZiB0aGUgcmVxdWVzdCBpcyBlcXVhbCB0byB0aGVcbiAgICAgICAgLy8gICAgICAgb25lIGluIHRoZSByZXF1ZXN0IHRoYXQgY3JlYXRlZCB0aGUgdHJhbnNhY3Rpb24sIGFuZFxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAzLiB0aGUgbWV0aG9kIG9mIHRoZSByZXF1ZXN0IG1hdGNoZXMgdGhlIG9uZSB0aGF0IGNyZWF0ZWQgdGhlXG4gICAgICAgIC8vICAgICAgIHRyYW5zYWN0aW9uLCBleGNlcHQgZm9yIEFDSywgd2hlcmUgdGhlIG1ldGhvZCBvZiB0aGUgcmVxdWVzdFxuICAgICAgICAvLyAgICAgICB0aGF0IGNyZWF0ZWQgdGhlIHRyYW5zYWN0aW9uIGlzIElOVklURS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBtYXRjaGluZyBydWxlIGFwcGxpZXMgdG8gYm90aCBJTlZJVEUgYW5kIG5vbi1JTlZJVEUgdHJhbnNhY3Rpb25zXG4gICAgICAgIC8vIGFsaWtlLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBUaGUgc2VudC1ieSB2YWx1ZSBpcyB1c2VkIGFzIHBhcnQgb2YgdGhlIG1hdGNoaW5nIHByb2Nlc3MgYmVjYXVzZVxuICAgICAgICAvLyAgICB0aGVyZSBjb3VsZCBiZSBhY2NpZGVudGFsIG9yIG1hbGljaW91cyBkdXBsaWNhdGlvbiBvZiBicmFuY2hcbiAgICAgICAgLy8gICAgcGFyYW1ldGVycyBmcm9tIGRpZmZlcmVudCBjbGllbnRzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE3LjIuM1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb25JZCA9IG1lc3NhZ2UudmlhQnJhbmNoOyAvLyBGSVhNRTogQ3VycmVudGx5IG9ubHkgdXNpbmcgcnVsZSAxLi4uXG4gICAgICAgIHZhciB1YXMgPSB0aGlzLnVzZXJBZ2VudFNlcnZlcnMuZ2V0KHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICAvLyBXaGVuIHJlY2VpdmluZyBhbiBBQ0sgdGhhdCBtYXRjaGVzIGFuIGV4aXN0aW5nIElOVklURSBzZXJ2ZXJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gYW5kIHRoYXQgZG9lcyBub3QgY29udGFpbiBhIGJyYW5jaCBwYXJhbWV0ZXIgY29udGFpbmluZ1xuICAgICAgICAvLyB0aGUgbWFnaWMgY29va2llIGRlZmluZWQgaW4gUkZDIDMyNjEsIHRoZSBtYXRjaGluZyB0cmFuc2FjdGlvbiBNVVNUXG4gICAgICAgIC8vIGJlIGNoZWNrZWQgdG8gc2VlIGlmIGl0IGlzIGluIHRoZSBcIkFjY2VwdGVkXCIgc3RhdGUuICBJZiBpdCBpcywgdGhlblxuICAgICAgICAvLyB0aGUgQUNLIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2FjdGlvbiB1c2VyIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYmVpbmcgYWJzb3JiZWQgYnkgdGhlIHRyYW5zYWN0aW9uIHN0YXRlIG1hY2hpbmUuICBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgICAgICAvLyBhcyByZXF1ZXN0cyBmcm9tIFJGQyAyNTQzIGNsaWVudHMgd2lsbCBub3QgaW5jbHVkZSBhIHVuaXF1ZSBicmFuY2hcbiAgICAgICAgLy8gcGFyYW1ldGVyLCBhbmQgdGhlIG1lY2hhbmlzbXMgZm9yIGNhbGN1bGF0aW5nIHRoZSB0cmFuc2FjdGlvbiBJRCBmcm9tXG4gICAgICAgIC8vIHN1Y2ggYSByZXF1ZXN0IHdpbGwgYmUgdGhlIHNhbWUgZm9yIGJvdGggSU5WSVRFIGFuZCBBQ0tzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTZcbiAgICAgICAgLy8gQW55IEFDS3MgcmVjZWl2ZWQgZnJvbSB0aGUgbmV0d29yayB3aGlsZSBpbiB0aGUgXCJBY2NlcHRlZFwiIHN0YXRlIE1VU1QgYmVcbiAgICAgICAgLy8gcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSBUVSBhbmQgbm90IGFic29yYmVkLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTcuMVxuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IG1lc3NhZ2VzXzEuQy5BQ0spIHtcbiAgICAgICAgICAgIGlmICh1YXMgJiYgdWFzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVhcyBpbnN0YW5jZW9mIHVzZXJfYWdlbnRzXzEuSW52aXRlVXNlckFnZW50U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBBQ0tzIG1hdGNoaW5nIGFuIElOVklURSBzZXJ2ZXIgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIHNob3VsZCBuZXZlciBoYXBwZW4gd2l0aCBSRkMgMzI2MSBjb21wbGlhbnQgdXNlciBhZ2VudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdvdWxkIGJlIGEgYnJva2VuIEFDSyB0byBuZWdhdGl2ZSBmaW5hbCByZXNwb25zZSBvciBzb21ldGhpbmcpXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpcyBhcHBhcmVudGx5IGhvdyBSRkMgMjU0MyB1c2VyIGFnZW50cyBkbyB0aGluZ3MuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRpbmcgdGhpcyBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBOb3QgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCBSRkMgMjU0MyAobm8gc3VwcG9ydCBmb3Igc3RyaWN0LXJvdXRpbmcpLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRGlzY2FyZGluZyBvdXQgb2YgZGlhbG9nIEFDSyBhZnRlciAyeHggcmVzcG9uc2Ugc2VudCBvbiB0cmFuc2FjdGlvbiBcIiArIHRyYW5zYWN0aW9uSWQgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIENBTkNFTCBtZXRob2QgcmVxdWVzdHMgdGhhdCB0aGUgVFUgYXQgdGhlIHNlcnZlciBzaWRlIGNhbmNlbCBhXG4gICAgICAgIC8vIHBlbmRpbmcgdHJhbnNhY3Rpb24uICBUaGUgVFUgZGV0ZXJtaW5lcyB0aGUgdHJhbnNhY3Rpb24gdG8gYmVcbiAgICAgICAgLy8gY2FuY2VsbGVkIGJ5IHRha2luZyB0aGUgQ0FOQ0VMIHJlcXVlc3QsIGFuZCB0aGVuIGFzc3VtaW5nIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgbWV0aG9kIGlzIGFueXRoaW5nIGJ1dCBDQU5DRUwgb3IgQUNLIGFuZCBhcHBseWluZyB0aGVcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gbWF0Y2hpbmcgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDE3LjIuMy4gIFRoZSBtYXRjaGluZ1xuICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyB0aGUgb25lIHRvIGJlIGNhbmNlbGxlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi05LjJcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuQ0FOQ0VMKSB7XG4gICAgICAgICAgICBpZiAodWFzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgbWV0aG9kIG9mIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBhcyBsb25nIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vIENBTkNFTCBtYXRjaGVkIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uLCB0aGUgVUFTIGFuc3dlcnMgdGhlIENBTkNFTFxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgaXRzZWxmIHdpdGggYSAyMDAgKE9LKSByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiAyMDAgfSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdCBzdGlsbCBleGlzdHMsIHRoZSBiZWhhdmlvclxuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBVQVMgb24gcmVjZWl2aW5nIGEgQ0FOQ0VMIHJlcXVlc3QgZGVwZW5kcyBvbiB3aGV0aGVyIGl0IGhhcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gc2VudCBhIGZpbmFsIHJlc3BvbnNlIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gSWYgaXQgaGFzLCB0aGUgQ0FOQ0VMXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBoYXMgbm8gZWZmZWN0IG9uIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBub1xuICAgICAgICAgICAgICAgIC8vIGVmZmVjdCBvbiBhbnkgc2Vzc2lvbiBzdGF0ZSwgYW5kIG5vIGVmZmVjdCBvbiB0aGUgcmVzcG9uc2VzIGdlbmVyYXRlZFxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgb3JpZ2luYWwgcmVxdWVzdC4gSWYgdGhlIFVBUyBoYXMgbm90IGlzc3VlZCBhIGZpbmFsIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBpdHMgYmVoYXZpb3IgZGVwZW5kcyBvbiB0aGUgbWV0aG9kIG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsIHJlcXVlc3QuIElmIHRoZSBvcmlnaW5hbCByZXF1ZXN0IHdhcyBhbiBJTlZJVEUsIHRoZSBVQVNcbiAgICAgICAgICAgICAgICAvLyBTSE9VTEQgaW1tZWRpYXRlbHkgcmVzcG9uZCB0byB0aGUgSU5WSVRFIHdpdGggYSA0ODcgKFJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBUZXJtaW5hdGVkKS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICAgICAgICAgIGlmICh1YXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICB1YXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodWFzIGluc3RhbmNlb2YgdXNlcl9hZ2VudHNfMS5JbnZpdGVVc2VyQWdlbnRTZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWNlaXZlQ2FuY2VsKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgQ0FOQ0VMIHJlcXVlc3QgaGFzIG5vIGltcGFjdCBvbiB0aGUgcHJvY2Vzc2luZyBvZlxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbnMgd2l0aCBhbnkgb3RoZXIgbWV0aG9kIGRlZmluZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBVQVMgZGlkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgdHJhbnNhY3Rpb24gZm9yIHRoZSBDQU5DRUxcbiAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIHByb2NlZHVyZSBhYm92ZSwgaXQgU0hPVUxEIHJlc3BvbmQgdG8gdGhlIENBTkNFTFxuICAgICAgICAgICAgICAgIC8vIHdpdGggYSA0ODEgKENhbGwgTGVnL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMlxuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBtYXRjaGluZyBzZXJ2ZXIgdHJhbnNhY3Rpb24gaXMgZm91bmQsIHRoZSByZXF1ZXN0IGlzIHBhc3NlZCB0byB0aGF0XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIGZvciBwcm9jZXNzaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMTBcbiAgICAgICAgaWYgKHVhcykge1xuICAgICAgICAgICAgdWFzLnRyYW5zYWN0aW9uLnJlY2VpdmVSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIG1hdGNoIGlzIGZvdW5kLCB0aGUgcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlIGNvcmUsIHdoaWNoIG1heSBkZWNpZGUgdG9cbiAgICAgICAgLy8gY29uc3RydWN0IGEgbmV3IHNlcnZlciB0cmFuc2FjdGlvbiBmb3IgdGhhdCByZXF1ZXN0LlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjAyNiNzZWN0aW9uLTguMTBcbiAgICAgICAgdGhpcy5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVUFDIGFuZCBVQVMgcHJvY2VkdXJlcyBkZXBlbmQgc3Ryb25nbHkgb24gdHdvIGZhY3RvcnMuICBGaXJzdCwgYmFzZWRcbiAgICAgKiBvbiB3aGV0aGVyIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlIGlzIGluc2lkZSBvciBvdXRzaWRlIG9mIGEgZGlhbG9nLFxuICAgICAqIGFuZCBzZWNvbmQsIGJhc2VkIG9uIHRoZSBtZXRob2Qgb2YgYSByZXF1ZXN0LiAgRGlhbG9ncyBhcmUgZGlzY3Vzc2VkXG4gICAgICogdGhvcm91Z2hseSBpbiBTZWN0aW9uIDEyOyB0aGV5IHJlcHJlc2VudCBhIHBlZXItdG8tcGVlciByZWxhdGlvbnNoaXBcbiAgICAgKiBiZXR3ZWVuIHVzZXIgYWdlbnRzIGFuZCBhcmUgZXN0YWJsaXNoZWQgYnkgc3BlY2lmaWMgU0lQIG1ldGhvZHMsIHN1Y2hcbiAgICAgKiBhcyBJTlZJVEUuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICovXG4gICAgVXNlckFnZW50Q29yZS5wcm90b3R5cGUucmVjZWl2ZVJlcXVlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyA4LjIgVUFTIEJlaGF2aW9yXG4gICAgICAgIC8vIFVBU3MgU0hPVUxEIHByb2Nlc3MgdGhlIHJlcXVlc3RzIGluIHRoZSBvcmRlciBvZiB0aGUgc3RlcHMgdGhhdFxuICAgICAgICAvLyBmb2xsb3cgaW4gdGhpcyBzZWN0aW9uICh0aGF0IGlzLCBzdGFydGluZyB3aXRoIGF1dGhlbnRpY2F0aW9uLCB0aGVuXG4gICAgICAgIC8vIGluc3BlY3RpbmcgdGhlIG1ldGhvZCwgdGhlIGhlYWRlciBmaWVsZHMsIGFuZCBzbyBvbiB0aHJvdWdob3V0IHRoZVxuICAgICAgICAvLyByZW1haW5kZXIgb2YgdGhpcyBzZWN0aW9uKS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjJcbiAgICAgICAgLy8gOC4yLjEgTWV0aG9kIEluc3BlY3Rpb25cbiAgICAgICAgLy8gT25jZSBhIHJlcXVlc3QgaXMgYXV0aGVudGljYXRlZCAob3IgYXV0aGVudGljYXRpb24gaXMgc2tpcHBlZCksIHRoZVxuICAgICAgICAvLyBVQVMgTVVTVCBpbnNwZWN0IHRoZSBtZXRob2Qgb2YgdGhlIHJlcXVlc3QuICBJZiB0aGUgVUFTIHJlY29nbml6ZXNcbiAgICAgICAgLy8gYnV0IGRvZXMgbm90IHN1cHBvcnQgdGhlIG1ldGhvZCBvZiBhIHJlcXVlc3QsIGl0IE1VU1QgZ2VuZXJhdGUgYSA0MDVcbiAgICAgICAgLy8gKE1ldGhvZCBOb3QgQWxsb3dlZCkgcmVzcG9uc2UuICBQcm9jZWR1cmVzIGZvciBnZW5lcmF0aW5nIHJlc3BvbnNlc1xuICAgICAgICAvLyBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gOC4yLjYuICBUaGUgVUFTIE1VU1QgYWxzbyBhZGQgYW4gQWxsb3dcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIHRvIHRoZSA0MDUgKE1ldGhvZCBOb3QgQWxsb3dlZCkgcmVzcG9uc2UuICBUaGUgQWxsb3dcbiAgICAgICAgLy8gaGVhZGVyIGZpZWxkIE1VU1QgbGlzdCB0aGUgc2V0IG9mIG1ldGhvZHMgc3VwcG9ydGVkIGJ5IHRoZSBVQVNcbiAgICAgICAgLy8gZ2VuZXJhdGluZyB0aGUgbWVzc2FnZS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMVxuICAgICAgICBpZiAoYWxsb3dlZF9tZXRob2RzXzEuQWxsb3dlZE1ldGhvZHMuaW5kZXhPZihtZXNzYWdlLm1ldGhvZCkgPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDUsXG4gICAgICAgICAgICAgICAgZXh0cmFIZWFkZXJzOiBbYWxsb3dIZWFkZXJdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyA4LjIuMiBIZWFkZXIgSW5zcGVjdGlvblxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yXG4gICAgICAgIGlmICghbWVzc2FnZS5ydXJpKSB7IC8vIEZJWE1FOiBBIHJlcXVlc3QgbWVzc2FnZSBzaG91bGQgYWx3YXlzIGhhdmUgYW4gcnVyaVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdC1VUkkgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA4LjIuMi4xIFRvIGFuZCBSZXF1ZXN0LVVSSVxuICAgICAgICAvLyBJZiB0aGUgUmVxdWVzdC1VUkkgdXNlcyBhIHNjaGVtZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBVQVMsIGl0IFNIT1VMRFxuICAgICAgICAvLyByZWplY3QgdGhlIHJlcXVlc3Qgd2l0aCBhIDQxNiAoVW5zdXBwb3J0ZWQgVVJJIFNjaGVtZSkgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuMVxuICAgICAgICBpZiAobWVzc2FnZS5ydXJpLnNjaGVtZSAhPT0gXCJzaXBcIikge1xuICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxNiB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyA4LjIuMi4xIFRvIGFuZCBSZXF1ZXN0LVVSSVxuICAgICAgICAvLyBJZiB0aGUgUmVxdWVzdC1VUkkgZG9lcyBub3QgaWRlbnRpZnkgYW4gYWRkcmVzcyB0aGF0IHRoZVxuICAgICAgICAvLyBVQVMgaXMgd2lsbGluZyB0byBhY2NlcHQgcmVxdWVzdHMgZm9yLCBpdCBTSE9VTEQgcmVqZWN0XG4gICAgICAgIC8vIHRoZSByZXF1ZXN0IHdpdGggYSA0MDQgKE5vdCBGb3VuZCkgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjIuMVxuICAgICAgICB2YXIgcnVyaSA9IG1lc3NhZ2UucnVyaTtcbiAgICAgICAgdmFyIHJ1cmlNYXRjaGVzID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICAgICAgcmV0dXJuICEhdXJpICYmIHVyaS51c2VyID09PSBydXJpLnVzZXI7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghcnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLmFvcikgJiZcbiAgICAgICAgICAgICEocnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QudXJpKSB8fFxuICAgICAgICAgICAgICAgIHJ1cmlNYXRjaGVzKHRoaXMuY29uZmlndXJhdGlvbi5jb250YWN0LnB1YkdydXUpIHx8XG4gICAgICAgICAgICAgICAgcnVyaU1hdGNoZXModGhpcy5jb25maWd1cmF0aW9uLmNvbnRhY3QudGVtcEdydXUpKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlJlcXVlc3QtVVJJIGRvZXMgbm90IHBvaW50IHRvIHVzLlwiKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCAhPT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gOC4yLjIuMSBUbyBhbmQgUmVxdWVzdC1VUklcbiAgICAgICAgLy8gT3RoZXIgcG90ZW50aWFsIHNvdXJjZXMgb2YgcmVjZWl2ZWQgUmVxdWVzdC1VUklzIGluY2x1ZGVcbiAgICAgICAgLy8gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkcyBvZiByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIHNlbnQgYnkgdGhlIFVBXG4gICAgICAgIC8vIHRoYXQgZXN0YWJsaXNoIG9yIHJlZnJlc2ggZGlhbG9ncy5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMi4xXG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLklOVklURSkge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmhhc0hlYWRlcihcIkNvbnRhY3RcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgICAgICAgICByZWFzb25QaHJhc2U6IFwiTWlzc2luZyBDb250YWN0IEhlYWRlclwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDguMi4yLjIgTWVyZ2VkIFJlcXVlc3RzXG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGhhcyBubyB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCwgdGhlIFVBUyBjb3JlIE1VU1RcbiAgICAgICAgLy8gY2hlY2sgdGhlIHJlcXVlc3QgYWdhaW5zdCBvbmdvaW5nIHRyYW5zYWN0aW9ucy4gIElmIHRoZSBGcm9tIHRhZyxcbiAgICAgICAgLy8gQ2FsbC1JRCwgYW5kIENTZXEgZXhhY3RseSBtYXRjaCB0aG9zZSBhc3NvY2lhdGVkIHdpdGggYW4gb25nb2luZ1xuICAgICAgICAvLyB0cmFuc2FjdGlvbiwgYnV0IHRoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIHRoYXQgdHJhbnNhY3Rpb24gKGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSBtYXRjaGluZyBydWxlcyBpbiBTZWN0aW9uIDE3LjIuMyksIHRoZSBVQVMgY29yZSBTSE9VTERcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSA0ODIgKExvb3AgRGV0ZWN0ZWQpIHJlc3BvbnNlIGFuZCBwYXNzIGl0IHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIFRoZSBzYW1lIHJlcXVlc3QgaGFzIGFycml2ZWQgYXQgdGhlIFVBUyBtb3JlIHRoYW4gb25jZSwgZm9sbG93aW5nXG4gICAgICAgIC8vICAgIGRpZmZlcmVudCBwYXRocywgbW9zdCBsaWtlbHkgZHVlIHRvIGZvcmtpbmcuICBUaGUgVUFTIHByb2Nlc3Nlc1xuICAgICAgICAvLyAgICB0aGUgZmlyc3Qgc3VjaCByZXF1ZXN0IHJlY2VpdmVkIGFuZCByZXNwb25kcyB3aXRoIGEgNDgyIChMb29wXG4gICAgICAgIC8vICAgIERldGVjdGVkKSB0byB0aGUgcmVzdCBvZiB0aGVtLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi4yLjJcbiAgICAgICAgaWYgKCFtZXNzYWdlLnRvVGFnKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb25JZCA9IG1lc3NhZ2UudmlhQnJhbmNoO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVzZXJBZ2VudFNlcnZlcnMuaGFzKHRyYW5zYWN0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1lcmdlZFJlcXVlc3QgPSBBcnJheS5mcm9tKHRoaXMudXNlckFnZW50U2VydmVycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgLnNvbWUoZnVuY3Rpb24gKHVhcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdWFzLnRyYW5zYWN0aW9uLnJlcXVlc3QuZnJvbVRhZyA9PT0gbWVzc2FnZS5mcm9tVGFnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMudHJhbnNhY3Rpb24ucmVxdWVzdC5jYWxsSWQgPT09IG1lc3NhZ2UuY2FsbElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMudHJhbnNhY3Rpb24ucmVxdWVzdC5jc2VxID09PSBtZXNzYWdlLmNzZXE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlZFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBseVN0YXRlbGVzcyhtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ4MiB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA4LjIuMi4zIFJlcXVpcmVcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjIuMi4zXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gOC4yLjMgQ29udGVudCBQcm9jZXNzaW5nXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjNcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyA4LjIuNCBBcHBseWluZyBFeHRlbnNpb25zXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjRcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyA4LjIuNSBQcm9jZXNzaW5nIHRoZSBSZXF1ZXN0XG4gICAgICAgIC8vIEFzc3VtaW5nIGFsbCBvZiB0aGUgY2hlY2tzIGluIHRoZSBwcmV2aW91cyBzdWJzZWN0aW9ucyBhcmUgcGFzc2VkLFxuICAgICAgICAvLyB0aGUgVUFTIHByb2Nlc3NpbmcgYmVjb21lcyBtZXRob2Qtc3BlY2lmaWMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjVcbiAgICAgICAgLy8gVGhlIFVBUyB3aWxsIHJlY2VpdmUgdGhlIHJlcXVlc3QgZnJvbSB0aGUgdHJhbnNhY3Rpb24gbGF5ZXIuICBJZiB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBoYXMgYSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCwgdGhlIFVBUyBjb3JlIGNvbXB1dGVzIHRoZVxuICAgICAgICAvLyBkaWFsb2cgaWRlbnRpZmllciBjb3JyZXNwb25kaW5nIHRvIHRoZSByZXF1ZXN0IGFuZCBjb21wYXJlcyBpdCB3aXRoXG4gICAgICAgIC8vIGV4aXN0aW5nIGRpYWxvZ3MuICBJZiB0aGVyZSBpcyBhIG1hdGNoLCB0aGlzIGlzIGEgbWlkLWRpYWxvZyByZXF1ZXN0LlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBVQVMgZmlyc3QgYXBwbGllcyB0aGUgc2FtZSBwcm9jZXNzaW5nIHJ1bGVzIGZvclxuICAgICAgICAvLyByZXF1ZXN0cyBvdXRzaWRlIG9mIGEgZGlhbG9nLCBkaXNjdXNzZWQgaW4gU2VjdGlvbiA4LjIuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuMi4yXG4gICAgICAgIGlmIChtZXNzYWdlLnRvVGFnKSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVJbnNpZGVEaWFsb2dSZXF1ZXN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlT3V0c2lkZURpYWxvZ1JlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25jZSBhIGRpYWxvZyBoYXMgYmVlbiBlc3RhYmxpc2hlZCBiZXR3ZWVuIHR3byBVQXMsIGVpdGhlciBvZiB0aGVtXG4gICAgICogTUFZIGluaXRpYXRlIG5ldyB0cmFuc2FjdGlvbnMgYXMgbmVlZGVkIHdpdGhpbiB0aGUgZGlhbG9nLiAgVGhlIFVBXG4gICAgICogc2VuZGluZyB0aGUgcmVxdWVzdCB3aWxsIHRha2UgdGhlIFVBQyByb2xlIGZvciB0aGUgdHJhbnNhY3Rpb24uICBUaGVcbiAgICAgKiBVQSByZWNlaXZpbmcgdGhlIHJlcXVlc3Qgd2lsbCB0YWtlIHRoZSBVQVMgcm9sZS4gIE5vdGUgdGhhdCB0aGVzZSBtYXlcbiAgICAgKiBiZSBkaWZmZXJlbnQgcm9sZXMgdGhhbiB0aGUgVUFzIGhlbGQgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbiB0aGF0XG4gICAgICogZXN0YWJsaXNoZWQgdGhlIGRpYWxvZy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlSW5zaWRlRGlhbG9nUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBhcmUgbWF0Y2hlZCB0byBzdWNoIFNVQlNDUklCRSByZXF1ZXN0cyBpZiB0aGV5XG4gICAgICAgIC8vIGNvbnRhaW4gdGhlIHNhbWUgXCJDYWxsLUlEXCIsIGEgXCJUb1wiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciB0aGF0XG4gICAgICAgIC8vIG1hdGNoZXMgdGhlIFwiRnJvbVwiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciBvZiB0aGUgU1VCU0NSSUJFXG4gICAgICAgIC8vIHJlcXVlc3QsIGFuZCB0aGUgc2FtZSBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkLiAgUnVsZXMgZm9yIGNvbXBhcmlzb25zIG9mXG4gICAgICAgIC8vIHRoZSBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkcyBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gOC4yLjEuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuTk9USUZZKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IG1lc3NhZ2UucGFyc2VIZWFkZXIoXCJFdmVudFwiKTtcbiAgICAgICAgICAgIGlmICghZXZlbnRfMSB8fCAhZXZlbnRfMS5ldmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRklYTUU6IFN1YnNjcmliZXIgaWQgc2hvdWxkIGFsc28gbWF0Y2hpbmcgb24gZXZlbnQgaWQuXG4gICAgICAgICAgICB2YXIgc3Vic2NyaWJlcklkID0gbWVzc2FnZS5jYWxsSWQgKyBtZXNzYWdlLnRvVGFnICsgZXZlbnRfMS5ldmVudDtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVycy5nZXQoc3Vic2NyaWJlcklkKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyB1c2VyX2FnZW50c18xLk5vdGlmeVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm9uTm90aWZ5KHVhcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlcXVlc3RzIHNlbnQgd2l0aGluIGEgZGlhbG9nLCBhcyBhbnkgb3RoZXIgcmVxdWVzdHMsIGFyZSBhdG9taWMuICBJZlxuICAgICAgICAvLyBhIHBhcnRpY3VsYXIgcmVxdWVzdCBpcyBhY2NlcHRlZCBieSB0aGUgVUFTLCBhbGwgdGhlIHN0YXRlIGNoYW5nZXNcbiAgICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIGl0IGFyZSBwZXJmb3JtZWQuICBJZiB0aGUgcmVxdWVzdCBpcyByZWplY3RlZCwgbm9uZVxuICAgICAgICAvLyBvZiB0aGUgc3RhdGUgY2hhbmdlcyBhcmUgcGVyZm9ybWVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICBOb3RlIHRoYXQgc29tZSByZXF1ZXN0cywgc3VjaCBhcyBJTlZJVEVzLCBhZmZlY3Qgc2V2ZXJhbCBwaWVjZXMgb2ZcbiAgICAgICAgLy8gICAgc3RhdGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBVQVMgd2lsbCByZWNlaXZlIHRoZSByZXF1ZXN0IGZyb20gdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgSWYgdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgaGFzIGEgdGFnIGluIHRoZSBUbyBoZWFkZXIgZmllbGQsIHRoZSBVQVMgY29yZSBjb21wdXRlcyB0aGVcbiAgICAgICAgLy8gZGlhbG9nIGlkZW50aWZpZXIgY29ycmVzcG9uZGluZyB0byB0aGUgcmVxdWVzdCBhbmQgY29tcGFyZXMgaXQgd2l0aFxuICAgICAgICAvLyBleGlzdGluZyBkaWFsb2dzLiAgSWYgdGhlcmUgaXMgYSBtYXRjaCwgdGhpcyBpcyBhIG1pZC1kaWFsb2cgcmVxdWVzdC5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMi4yLjJcbiAgICAgICAgdmFyIGRpYWxvZ0lkID0gbWVzc2FnZS5jYWxsSWQgKyBtZXNzYWdlLnRvVGFnICsgbWVzc2FnZS5mcm9tVGFnO1xuICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5kaWFsb2dzLmdldChkaWFsb2dJZCk7XG4gICAgICAgIGlmIChkaWFsb2cpIHtcbiAgICAgICAgICAgIC8vIFtTaXAtaW1wbGVtZW50b3JzXSBSZWcuIFNJUCByZWludml0ZSwgVVBEQVRFIGFuZCBPUFRJT05TXG4gICAgICAgICAgICAvLyBZb3UgZ290IHRoZSBxdWVzdGlvbiByaWdodC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBBbmQgeW91IGdvdCB0aGUgcmlnaHQgYW5zd2VyIHRvby4gOi0pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBUaGFua3MsXG4gICAgICAgICAgICAvLyAgIFBhdWxcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBSb2JlcnQgU3BhcmtzIHdyb3RlOlxuICAgICAgICAgICAgLy8gPiBTbyBJJ3ZlIGxvc3QgdHJhY2sgb2YgdGhlIHF1ZXN0aW9uIGR1cmluZyB0aGUgbXVzaW5nLlxuICAgICAgICAgICAgLy8gPlxuICAgICAgICAgICAgLy8gPiBJIF90aGlua18gdGhlIGZ1bmRhbWVudGFsIHF1ZXN0aW9uIGJlaW5nIGFza2VkIGlzIHRoaXM6XG4gICAgICAgICAgICAvLyA+XG4gICAgICAgICAgICAvLyA+IElzIGFuIGVuZHBvaW50IHJlcXVpcmVkIHRvIHJlamVjdCAod2l0aCBhIDQ4MSkgYW4gT1BUSU9OUyByZXF1ZXN0IHRoYXRcbiAgICAgICAgICAgIC8vID4gYXJyaXZlcyB3aXRoIGF0IHRvLXRhZyBidXQgZG9lcyBub3QgbWF0Y2ggYW55IGV4aXN0aW5nIGRpYWxvZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vID4gKEFzc3VtaW5nIHNvbWUgZWFybGllciByZXF1aXJlbWVudCBoYXNuJ3QgZm9yY2VkIGFub3RoZXIgZXJyb3IgY29kZSkuIE9yXG4gICAgICAgICAgICAvLyA+IGlzIGl0IE9LIGlmIGl0IGp1c3Qgc2VuZHNcbiAgICAgICAgICAgIC8vID4gYSAyMDAgT0sgYW55aG93LlxuICAgICAgICAgICAgLy8gPlxuICAgICAgICAgICAgLy8gPiBNeSB0YWtlIG9uIHRoZSBjb2xsZWN0aW9uIG9mIHNwZWNzIGlzIHRoYXQgaXRzIF9ub3RfIG9rIGZvciBpdCB0byBzZW5kXG4gICAgICAgICAgICAvLyA+IHRoZSAyMDAgT0sgYW55aG93IGFuZCB0aGF0IGl0IGlzIHJlcXVpcmVkIHRvIHNlbmRcbiAgICAgICAgICAgIC8vID4gdGhlIDQ4MS4gSSBiYXNlIHRoaXMgcHJpbWFyaWx5IG9uIHRoZXNlIHNlbnRlbmNlcyBmcm9tIDExLjIgaW4gMzI2MTpcbiAgICAgICAgICAgIC8vID5cbiAgICAgICAgICAgIC8vID4gICAgVGhlIHJlc3BvbnNlIHRvIGFuIE9QVElPTlMgaXMgY29uc3RydWN0ZWQgdXNpbmcgdGhlIHN0YW5kYXJkIHJ1bGVzXG4gICAgICAgICAgICAvLyA+ICAgIGZvciBhIFNJUCByZXNwb25zZSBhcyBkaXNjdXNzZWQgaW4gU2VjdGlvbiA4LjIuNi4gIFRoZSByZXNwb25zZSBjb2RlXG4gICAgICAgICAgICAvLyA+ICAgIGNob3NlbiBNVVNUIGJlIHRoZSBzYW1lIHRoYXQgd291bGQgaGF2ZSBiZWVuIGNob3NlbiBoYWQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIC8vID4gICAgYmVlbiBhbiBJTlZJVEUuXG4gICAgICAgICAgICAvLyA+XG4gICAgICAgICAgICAvLyA+IERpZCBJIG1pc3MgdGhlIHBvaW50IG9mIHRoZSBxdWVzdGlvbj9cbiAgICAgICAgICAgIC8vID5cbiAgICAgICAgICAgIC8vID4gT24gTWF5IDE1LCAyMDA4LCBhdCAxMjo0OCBQTSwgUGF1bCBLeXppdmF0IHdyb3RlOlxuICAgICAgICAgICAgLy8gPlxuICAgICAgICAgICAgLy8gPj4gW0luY2x1ZGluZyBSb2JlcnQgaW4gaG9wZXMgb2YgZ2V0dGluZyBoaXMgaW5zaWdodCBvbiB0aGlzLl1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbGlzdHMuY3MuY29sdW1iaWEuZWR1L3BpcGVybWFpbC9zaXAtaW1wbGVtZW50b3JzLzIwMDgtTWF5LzAxOTE3OC5odG1sXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gUmVxdWVzdHMgdGhhdCBkbyBub3QgY2hhbmdlIGluIGFueSB3YXkgdGhlIHN0YXRlIG9mIGEgZGlhbG9nIG1heSBiZVxuICAgICAgICAgICAgLy8gcmVjZWl2ZWQgd2l0aGluIGEgZGlhbG9nIChmb3IgZXhhbXBsZSwgYW4gT1BUSU9OUyByZXF1ZXN0KS4gIFRoZXkgYXJlXG4gICAgICAgICAgICAvLyBwcm9jZXNzZWQgYXMgaWYgdGhleSBoYWQgYmVlbiByZWNlaXZlZCBvdXRzaWRlIHRoZSBkaWFsb2cuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBtZXNzYWdlc18xLkMuT1BUSU9OUykge1xuICAgICAgICAgICAgICAgIHZhciBhbGxvd0hlYWRlciA9IFwiQWxsb3c6IFwiICsgYWxsb3dlZF9tZXRob2RzXzEuQWxsb3dlZE1ldGhvZHMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgYWNjZXB0SGVhZGVyID0gXCJBY2NlcHQ6IFwiICsgYWNjZXB0ZWRCb2R5VHlwZXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgICAgICBleHRyYUhlYWRlcnM6IFthbGxvd0hlYWRlciwgYWNjZXB0SGVhZGVyXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhc3MgdGhlIGluY29taW5nIHJlcXVlc3QgdG8gdGhlIGRpYWxvZyBmb3IgZnVydGhlciBoYW5kbGluZy5cbiAgICAgICAgICAgIGRpYWxvZy5yZWNlaXZlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgYmVoYXZpb3JzIG9mIGEgc3RhdGVsZXNzIFVBUyBhcmUgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIC8vIG8gIEEgc3RhdGVsZXNzIFVBUyBNVVNUIGlnbm9yZSBBQ0sgcmVxdWVzdHMuXG4gICAgICAgIC8vIC4uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi43XG4gICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gbWVzc2FnZXNfMS5DLkFDSykge1xuICAgICAgICAgICAgLy8gSWYgYSBmaW5hbCByZXNwb25zZSB0byBhbiBJTlZJVEUgd2FzIHNlbnQgc3RhdGVsZXNzbHksXG4gICAgICAgICAgICAvLyB0aGUgY29ycmVzcG9uZGluZyBBQ0s6XG4gICAgICAgICAgICAvLyAtIHdpbGwgbm90IG1hdGNoIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyAtIG1heSBoYXZlIHRhZyBpbiB0aGUgVG8gaGVhZGVyIGZpZWxkXG4gICAgICAgICAgICAvLyAtIG5vdCBub3QgbWF0Y2ggYW55IGV4aXN0aW5nIGRpYWxvZ3NcbiAgICAgICAgICAgIC8vIEFic29yYiB1bm1hdGNoZWQgQUNLcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBoYXMgYSB0YWcgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCwgYnV0IHRoZSBkaWFsb2dcbiAgICAgICAgLy8gaWRlbnRpZmllciBkb2VzIG5vdCBtYXRjaCBhbnkgZXhpc3RpbmcgZGlhbG9ncywgdGhlIFVBUyBtYXkgaGF2ZVxuICAgICAgICAvLyBjcmFzaGVkIGFuZCByZXN0YXJ0ZWQsIG9yIGl0IG1heSBoYXZlIHJlY2VpdmVkIGEgcmVxdWVzdCBmb3IgYVxuICAgICAgICAvLyBkaWZmZXJlbnQgKHBvc3NpYmx5IGZhaWxlZCkgVUFTICh0aGUgVUFTcyBjYW4gY29uc3RydWN0IHRoZSBUbyB0YWdzXG4gICAgICAgIC8vIHNvIHRoYXQgYSBVQVMgY2FuIGlkZW50aWZ5IHRoYXQgdGhlIHRhZyB3YXMgZm9yIGEgVUFTIGZvciB3aGljaCBpdCBpc1xuICAgICAgICAvLyBwcm92aWRpbmcgcmVjb3ZlcnkpLiAgQW5vdGhlciBwb3NzaWJpbGl0eSBpcyB0aGF0IHRoZSBpbmNvbWluZ1xuICAgICAgICAvLyByZXF1ZXN0IGhhcyBiZWVuIHNpbXBseSBtaXMtcm91dGVkLiAgQmFzZWQgb24gdGhlIFRvIHRhZywgdGhlIFVBUyBNQVlcbiAgICAgICAgLy8gZWl0aGVyIGFjY2VwdCBvciByZWplY3QgdGhlIHJlcXVlc3QuICBBY2NlcHRpbmcgdGhlIHJlcXVlc3QgZm9yXG4gICAgICAgIC8vIGFjY2VwdGFibGUgVG8gdGFncyBwcm92aWRlcyByb2J1c3RuZXNzLCBzbyB0aGF0IGRpYWxvZ3MgY2FuIHBlcnNpc3RcbiAgICAgICAgLy8gZXZlbiB0aHJvdWdoIGNyYXNoZXMuICBVQXMgd2lzaGluZyB0byBzdXBwb3J0IHRoaXMgY2FwYWJpbGl0eSBtdXN0XG4gICAgICAgIC8vIHRha2UgaW50byBjb25zaWRlcmF0aW9uIHNvbWUgaXNzdWVzIHN1Y2ggYXMgY2hvb3NpbmcgbW9ub3RvbmljYWxseVxuICAgICAgICAvLyBpbmNyZWFzaW5nIENTZXEgc2VxdWVuY2UgbnVtYmVycyBldmVuIGFjcm9zcyByZWJvb3RzLCByZWNvbnN0cnVjdGluZ1xuICAgICAgICAvLyB0aGUgcm91dGUgc2V0LCBhbmQgYWNjZXB0aW5nIG91dC1vZi1yYW5nZSBSVFAgdGltZXN0YW1wcyBhbmQgc2VxdWVuY2VcbiAgICAgICAgLy8gbnVtYmVycy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlIFVBUyB3aXNoZXMgdG8gcmVqZWN0IHRoZSByZXF1ZXN0IGJlY2F1c2UgaXQgZG9lcyBub3Qgd2lzaCB0b1xuICAgICAgICAvLyByZWNyZWF0ZSB0aGUgZGlhbG9nLCBpdCBNVVNUIHJlc3BvbmQgdG8gdGhlIHJlcXVlc3Qgd2l0aCBhIDQ4MVxuICAgICAgICAvLyAoQ2FsbC9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCkgc3RhdHVzIGNvZGUgYW5kIHBhc3MgdGhhdCB0byB0aGVcbiAgICAgICAgLy8gc2VydmVyIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjIuMlxuICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBc3N1bWluZyBhbGwgb2YgdGhlIGNoZWNrcyBpbiB0aGUgcHJldmlvdXMgc3Vic2VjdGlvbnMgYXJlIHBhc3NlZCxcbiAgICAgKiB0aGUgVUFTIHByb2Nlc3NpbmcgYmVjb21lcyBtZXRob2Qtc3BlY2lmaWMuXG4gICAgICogIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4yLjVcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlcXVlc3QgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlT3V0c2lkZURpYWxvZ1JlcXVlc3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5BQ0s6XG4gICAgICAgICAgICAgICAgLy8gQWJzb3JiIHN0cmF5IG91dCBvZiBkaWFsb2cgQUNLc1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuQllFOlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBCWUUgZG9lcyBub3QgbWF0Y2ggYW4gZXhpc3RpbmcgZGlhbG9nLCB0aGUgVUFTIGNvcmUgU0hPVUxEXG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYSA0ODEgKENhbGwvVHJhbnNhY3Rpb24gRG9lcyBOb3QgRXhpc3QpIHJlc3BvbnNlIGFuZCBwYXNzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB0byB0aGUgc2VydmVyIHRyYW5zYWN0aW9uLiBUaGlzIHJ1bGUgbWVhbnMgdGhhdCBhIEJZRSBzZW50XG4gICAgICAgICAgICAgICAgLy8gd2l0aG91dCB0YWdzIGJ5IGEgVUFDIHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNS4xLjJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDgxIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuQ0FOQ0VMOlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgb3V0IG9mIGRpYWxvZyByZXF1ZXN0IG1ldGhvZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuSU5GTzpcbiAgICAgICAgICAgICAgICAvLyBVc2Ugb2YgdGhlIElORk8gbWV0aG9kIGRvZXMgbm90IGNvbnN0aXR1dGUgYSBzZXBhcmF0ZSBkaWFsb2cgdXNhZ2UuXG4gICAgICAgICAgICAgICAgLy8gSU5GTyBtZXNzYWdlcyBhcmUgYWx3YXlzIHBhcnQgb2YsIGFuZCBzaGFyZSB0aGUgZmF0ZSBvZiwgYW4gaW52aXRlXG4gICAgICAgICAgICAgICAgLy8gZGlhbG9nIHVzYWdlIFtSRkM1MDU3XS4gIElORk8gbWVzc2FnZXMgY2Fubm90IGJlIHNlbnQgYXMgcGFydCBvZlxuICAgICAgICAgICAgICAgIC8vIG90aGVyIGRpYWxvZyB1c2FnZXMsIG9yIG91dHNpZGUgYW4gZXhpc3RpbmcgZGlhbG9nLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDg2I3NlY3Rpb24tMVxuICAgICAgICAgICAgICAgIHRoaXMucmVwbHlTdGF0ZWxlc3MobWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDUgfSk7IC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLklOVklURTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyB1c2VyX2FnZW50c18xLkludml0ZVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkludml0ZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uSW52aXRlKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLk1FU1NBR0U6XG4gICAgICAgICAgICAgICAgLy8gTUVTU0FHRSByZXF1ZXN0cyBhcmUgZGlzY291cmFnZWQgaW5zaWRlIGEgZGlhbG9nLiAgSW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICAgICAgLy8gYXJlIHJlc3RyaWN0ZWQgZnJvbSBjcmVhdGluZyBhIHVzYWdlIGZvciB0aGUgcHVycG9zZSBvZiBjYXJyeWluZyBhXG4gICAgICAgICAgICAgICAgLy8gc2VxdWVuY2Ugb2YgTUVTU0FHRSByZXF1ZXN0cyAodGhvdWdoIHNvbWUgaW1wbGVtZW50YXRpb25zIHVzZSBpdCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gd2F5LCBhZ2FpbnN0IHRoZSBzdGFuZGFyZCByZWNvbW1lbmRhdGlvbikuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUwNTcjc2VjdGlvbi01LjNcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgdXNlcl9hZ2VudHNfMS5NZXNzYWdlVXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTWVzc2FnZSh1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5hY2NlcHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuQy5OT1RJRlk6XG4gICAgICAgICAgICAgICAgLy8gT2Jzb2xldGVkIGJ5OiBSRkMgNjY2NVxuICAgICAgICAgICAgICAgIC8vIElmIGFueSBub24tU1VCU0NSSUJFIG1lY2hhbmlzbXMgYXJlIGRlZmluZWQgdG8gY3JlYXRlIHN1YnNjcmlwdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBwYXJ0aWVzIGRlZmluaW5nIHRob3NlIG1lY2hhbmlzbXMgdG9cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCBjb3JyZWxhdGlvbiBvZiBhIE5PVElGWSBtZXNzYWdlIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGlzIHBvc3NpYmxlLiAgRGVzaWduZXJzIG9mIHN1Y2ggbWVjaGFuaXNtcyBhcmUgYWxzb1xuICAgICAgICAgICAgICAgIC8vIHdhcm5lZCB0byBtYWtlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiBzZW5kaW5nIGEgTk9USUZZIG1lc3NhZ2UgdG8gYVxuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmliZXIgd2hvIGlzIGF3YXJlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGFuZCBzZW5kaW5nIGEgTk9USUZZXG4gICAgICAgICAgICAgICAgLy8gbWVzc2FnZSB0byBhbiB1bnN1c3BlY3Rpbmcgbm9kZS4gIFRoZSBsYXR0ZXIgYmVoYXZpb3IgaXMgaW52YWxpZCwgYW5kXG4gICAgICAgICAgICAgICAgLy8gTVVTVCByZWNlaXZlIGEgXCI0ODEgU3Vic2NyaXB0aW9uIGRvZXMgbm90IGV4aXN0XCIgcmVzcG9uc2UgKHVubGVzc1xuICAgICAgICAgICAgICAgIC8vIHNvbWUgb3RoZXIgNDAwLSBvciA1MDAtY2xhc3MgZXJyb3IgY29kZSBpcyBtb3JlIGFwcGxpY2FibGUpLCBhc1xuICAgICAgICAgICAgICAgIC8vIGRlc2NyaWJlZCBpbiBzZWN0aW9uIDMuMi40LiAgSW4gb3RoZXIgd29yZHMsIGtub3dsZWRnZSBvZiBhXG4gICAgICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9uIG11c3QgZXhpc3QgaW4gYm90aCB0aGUgc3Vic2NyaWJlciBhbmQgdGhlIG5vdGlmaWVyIHRvIGJlXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQsIGV2ZW4gaWYgaW5zdGFsbGVkIHZpYSBhIG5vbi1TVUJTQ1JJQkUgbWVjaGFuaXNtLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjY1I3NlY3Rpb24tMy4yXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBOT1RJRlkgcmVxdWVzdHMgYXJlIHNlbnQgdG8gaW5mb3JtIHN1YnNjcmliZXJzIG9mIGNoYW5nZXMgaW4gc3RhdGUgdG9cbiAgICAgICAgICAgICAgICAvLyB3aGljaCB0aGUgc3Vic2NyaWJlciBoYXMgYSBzdWJzY3JpcHRpb24uICBTdWJzY3JpcHRpb25zIGFyZSBjcmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdGhlIFNVQlNDUklCRSBtZXRob2QuICBJbiBsZWdhY3kgaW1wbGVtZW50YXRpb25zLCBpdCBpc1xuICAgICAgICAgICAgICAgIC8vIHBvc3NpYmxlIHRoYXQgb3RoZXIgbWVhbnMgb2Ygc3Vic2NyaXB0aW9uIGNyZWF0aW9uIGhhdmUgYmVlbiB1c2VkLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBhbGxvdyB0aGUgY3JlYXRpb24gb2ZcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb25zIGV4Y2VwdCB0aHJvdWdoIFNVQlNDUklCRSByZXF1ZXN0cyBhbmQgKGZvciBiYWNrd2FyZHMtXG4gICAgICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSkgUkVGRVIgcmVxdWVzdHMgW1JGQzM1MTVdLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tMy4yXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IHVzZXJfYWdlbnRzXzEuTm90aWZ5VXNlckFnZW50U2VydmVyKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uTm90aWZ5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDA1IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLk9QVElPTlM6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMS4yXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsb3dIZWFkZXIgPSBcIkFsbG93OiBcIiArIGFsbG93ZWRfbWV0aG9kc18xLkFsbG93ZWRNZXRob2RzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2NlcHRIZWFkZXIgPSBcIkFjY2VwdDogXCIgKyBhY2NlcHRlZEJvZHlUeXBlcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGx5U3RhdGVsZXNzKG1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhSGVhZGVyczogW2FsbG93SGVhZGVyLCBhY2NlcHRIZWFkZXJdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLlJFRkVSOlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNTE1I3NlY3Rpb24tMi40LjJcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1YXMgPSBuZXcgdXNlcl9hZ2VudHNfMS5SZWZlclVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlZmVyID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWZlcih1YXMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0MDUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBtZXNzYWdlc18xLkMuUkVHSVNURVI6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMC4zXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdWFzID0gbmV3IHVzZXJfYWdlbnRzXzEuUmVnaXN0ZXJVc2VyQWdlbnRTZXJ2ZXIodGhpcywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWdpc3RlciA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVnaXN0ZXIodWFzKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDA1IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5DLlNVQlNDUklCRTpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhcyA9IG5ldyB1c2VyX2FnZW50c18xLlN1YnNjcmliZVVzZXJBZ2VudFNlcnZlcih0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblN1YnNjcmliZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uU3Vic2NyaWJlKHVhcykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4MCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgb3V0IG9mIGRpYWxvZyByZXF1ZXN0IG1ldGhvZCBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3BvbnNlcyBhcmUgZmlyc3QgcHJvY2Vzc2VkIGJ5IHRoZSB0cmFuc3BvcnQgbGF5ZXIgYW5kIHRoZW4gcGFzc2VkXG4gICAgICogdXAgdG8gdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgVGhlIHRyYW5zYWN0aW9uIGxheWVyIHBlcmZvcm1zIGl0c1xuICAgICAqIHByb2Nlc3NpbmcgYW5kIHRoZW4gcGFzc2VzIHRoZSByZXNwb25zZSB1cCB0byB0aGUgVFUuICBUaGUgbWFqb3JpdHlcbiAgICAgKiBvZiByZXNwb25zZSBwcm9jZXNzaW5nIGluIHRoZSBUVSBpcyBtZXRob2Qgc3BlY2lmaWMuICBIb3dldmVyLCB0aGVyZVxuICAgICAqIGFyZSBzb21lIGdlbmVyYWwgYmVoYXZpb3JzIGluZGVwZW5kZW50IG9mIHRoZSBtZXRob2QuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuM1xuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gSW5jb21pbmcgcmVzcG9uc2UgbWVzc2FnZSBmcm9tIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRDb3JlLnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2VGcm9tVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gOC4xLjMuMSBUcmFuc2FjdGlvbiBMYXllciBFcnJvcnNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAgICAgIC8vIEhhbmRsZWQgYnkgdHJhbnNhY3Rpb24gbGF5ZXIgY2FsbGJhY2tzLlxuICAgICAgICAvLyA4LjEuMy4yIFVucmVjb2duaXplZCBSZXNwb25zZXNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy4xXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gOC4xLjMuMyBWaWFzXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuM1xuICAgICAgICBpZiAobWVzc2FnZS5nZXRIZWFkZXJzKFwidmlhXCIpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJNb3JlIHRoYW4gb25lIFZpYSBoZWFkZXIgZmllbGQgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UsIGRyb3BwaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIDguMS4zLjQgUHJvY2Vzc2luZyAzeHggUmVzcG9uc2VzXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuNFxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDguMS4zLjUgUHJvY2Vzc2luZyA0eHggUmVzcG9uc2VzXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuNVxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIFdoZW4gdGhlIHRyYW5zcG9ydCBsYXllciBpbiB0aGUgY2xpZW50IHJlY2VpdmVzIGEgcmVzcG9uc2UsIGl0IGhhcyB0b1xuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggY2xpZW50IHRyYW5zYWN0aW9uIHdpbGwgaGFuZGxlIHRoZSByZXNwb25zZSwgc28gdGhhdFxuICAgICAgICAvLyB0aGUgcHJvY2Vzc2luZyBvZiBTZWN0aW9ucyAxNy4xLjEgYW5kIDE3LjEuMiBjYW4gdGFrZSBwbGFjZS4gIFRoZVxuICAgICAgICAvLyBicmFuY2ggcGFyYW1ldGVyIGluIHRoZSB0b3AgVmlhIGhlYWRlciBmaWVsZCBpcyB1c2VkIGZvciB0aGlzXG4gICAgICAgIC8vIHB1cnBvc2UuICBBIHJlc3BvbnNlIG1hdGNoZXMgYSBjbGllbnQgdHJhbnNhY3Rpb24gdW5kZXIgdHdvXG4gICAgICAgIC8vIGNvbmRpdGlvbnM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgIDEuICBJZiB0aGUgcmVzcG9uc2UgaGFzIHRoZSBzYW1lIHZhbHVlIG9mIHRoZSBicmFuY2ggcGFyYW1ldGVyIGluXG4gICAgICAgIC8vICAgICAgICB0aGUgdG9wIFZpYSBoZWFkZXIgZmllbGQgYXMgdGhlIGJyYW5jaCBwYXJhbWV0ZXIgaW4gdGhlIHRvcFxuICAgICAgICAvLyAgICAgICAgVmlhIGhlYWRlciBmaWVsZCBvZiB0aGUgcmVxdWVzdCB0aGF0IGNyZWF0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAyLiAgSWYgdGhlIG1ldGhvZCBwYXJhbWV0ZXIgaW4gdGhlIENTZXEgaGVhZGVyIGZpZWxkIG1hdGNoZXMgdGhlXG4gICAgICAgIC8vICAgICAgICBtZXRob2Qgb2YgdGhlIHJlcXVlc3QgdGhhdCBjcmVhdGVkIHRoZSB0cmFuc2FjdGlvbi4gIFRoZVxuICAgICAgICAvLyAgICAgICAgbWV0aG9kIGlzIG5lZWRlZCBzaW5jZSBhIENBTkNFTCByZXF1ZXN0IGNvbnN0aXR1dGVzIGFcbiAgICAgICAgLy8gICAgICAgIGRpZmZlcmVudCB0cmFuc2FjdGlvbiwgYnV0IHNoYXJlcyB0aGUgc2FtZSB2YWx1ZSBvZiB0aGUgYnJhbmNoXG4gICAgICAgIC8vICAgICAgICBwYXJhbWV0ZXIuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTcuMS4zXG4gICAgICAgIHZhciB1c2VyQWdlbnRDbGllbnRJZCA9IG1lc3NhZ2UudmlhQnJhbmNoICsgbWVzc2FnZS5tZXRob2Q7XG4gICAgICAgIHZhciB1c2VyQWdlbnRDbGllbnQgPSB0aGlzLnVzZXJBZ2VudENsaWVudHMuZ2V0KHVzZXJBZ2VudENsaWVudElkKTtcbiAgICAgICAgLy8gVGhlIGNsaWVudCB0cmFuc3BvcnQgdXNlcyB0aGUgbWF0Y2hpbmcgcHJvY2VkdXJlcyBvZiBTZWN0aW9uXG4gICAgICAgIC8vIDE3LjEuMyB0byBhdHRlbXB0IHRvIG1hdGNoIHRoZSByZXNwb25zZSB0byBhbiBleGlzdGluZ1xuICAgICAgICAvLyB0cmFuc2FjdGlvbi4gIElmIHRoZXJlIGlzIGEgbWF0Y2gsIHRoZSByZXNwb25zZSBNVVNUIGJlIHBhc3NlZCB0b1xuICAgICAgICAvLyB0aGF0IHRyYW5zYWN0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgZWxlbWVudCBvdGhlciB0aGFuIGEgc3RhdGVsZXNzXG4gICAgICAgIC8vIHByb3h5IE1VU1Qgc2lsZW50bHkgZGlzY2FyZCB0aGUgcmVzcG9uc2UuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MDI2I3NlY3Rpb24tOC45XG4gICAgICAgIGlmICh1c2VyQWdlbnRDbGllbnQpIHtcbiAgICAgICAgICAgIHVzZXJBZ2VudENsaWVudC50cmFuc2FjdGlvbi5yZWNlaXZlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRGlzY2FyZGluZyB1bm1hdGNoZWQgXCIgKyBtZXNzYWdlLnN0YXR1c0NvZGUgKyBcIiByZXNwb25zZSB0byBcIiArIG1lc3NhZ2UubWV0aG9kICsgXCIgXCIgKyB1c2VyQWdlbnRDbGllbnRJZCArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFVzZXJBZ2VudENvcmU7XG59KCkpO1xuZXhwb3J0cy5Vc2VyQWdlbnRDb3JlID0gVXNlckFnZW50Q29yZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBCWUUgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgQnllVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJ5ZVVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCeWVVc2VyQWdlbnRDbGllbnQoZGlhbG9nLCBkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5CWUUsIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIGRpYWxvZy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ5ZVVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuQnllVXNlckFnZW50Q2xpZW50ID0gQnllVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBCWUUgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgQnllVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEJ5ZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCeWVVc2VyQWdlbnRTZXJ2ZXIoZGlhbG9nLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEJ5ZVVzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuQnllVXNlckFnZW50U2VydmVyID0gQnllVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBDQU5DRUwgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgQ2FuY2VsVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENhbmNlbFVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYW5jZWxVc2VyQWdlbnRDbGllbnQoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENhbmNlbFVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuQ2FuY2VsVXNlckFnZW50Q2xpZW50ID0gQ2FuY2VsVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2J5ZS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ieWUtdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FuY2VsLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZm8tdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5mby11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnZpdGUtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW52aXRlLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2UtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVzc2FnZS11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ub3RpZnktdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbm90aWZ5LXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3B1Ymxpc2gtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJhY2stdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJhY2stdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmUtaW52aXRlLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlLWludml0ZS11c2VyLWFnZW50LXNlcnZlclwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZS1zdWJzY3JpYmUtdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmUtc3Vic2NyaWJlLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlZmVyLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlZmVyLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlZ2lzdGVyLXVzZXItYWdlbnQtY2xpZW50XCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlZ2lzdGVyLXVzZXItYWdlbnQtc2VydmVyXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N1YnNjcmliZS11c2VyLWFnZW50LWNsaWVudFwiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdWJzY3JpYmUtdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIElORk8gVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgSW5mb1VzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbmZvVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZm9Vc2VyQWdlbnRDbGllbnQoZGlhbG9nLCBkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5JTkZPLCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBJbmZvVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5JbmZvVXNlckFnZW50Q2xpZW50ID0gSW5mb1VzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKTtcbi8qKlxuICogSU5GTyBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbmZvVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEluZm9Vc2VyQWdlbnRTZXJ2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mb1VzZXJBZ2VudFNlcnZlcihkaWFsb2csIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW5mb1VzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuSW5mb1VzZXJBZ2VudFNlcnZlciA9IEluZm9Vc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGRpYWxvZ3NfMSA9IHJlcXVpcmUoXCIuLi9kaWFsb2dzXCIpO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuLi9zZXNzaW9uXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIElOVklURSBVQUMuXG4gKiBAcmVtYXJrc1xuICogMTMgSW5pdGlhdGluZyBhIFNlc3Npb25cbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTNcbiAqIDEzLjEgT3ZlcnZpZXdcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMVxuICogMTMuMiBVQUMgUHJvY2Vzc2luZ1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yXG4gKiBAcHVibGljXG4gKi9cbnZhciBJbnZpdGVVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW52aXRlVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludml0ZVVzZXJBZ2VudENsaWVudChjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLmNvbmZpcm1lZERpYWxvZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIF90aGlzLmVhcmx5RGlhbG9ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnZpdGVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBVQUMgY29yZSBjb25zaWRlcnMgdGhlIElOVklURSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQgNjQqVDEgc2Vjb25kc1xuICAgICAgICAvLyBhZnRlciB0aGUgcmVjZXB0aW9uIG9mIHRoZSBmaXJzdCAyeHggcmVzcG9uc2UuICBBdCB0aGlzIHBvaW50IGFsbCB0aGVcbiAgICAgICAgLy8gZWFybHkgZGlhbG9ncyB0aGF0IGhhdmUgbm90IHRyYW5zaXRpb25lZCB0byBlc3RhYmxpc2hlZCBkaWFsb2dzIGFyZVxuICAgICAgICAvLyB0ZXJtaW5hdGVkLiAgT25jZSB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uIGlzIGNvbnNpZGVyZWQgY29tcGxldGVkIGJ5XG4gICAgICAgIC8vIHRoZSBVQUMgY29yZSwgbm8gbW9yZSBuZXcgMnh4IHJlc3BvbnNlcyBhcmUgZXhwZWN0ZWQgdG8gYXJyaXZlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiwgYWZ0ZXIgYWNrbm93bGVkZ2luZyBhbnkgMnh4IHJlc3BvbnNlIHRvIGFuIElOVklURSwgdGhlIFVBQyBkb2VzXG4gICAgICAgIC8vIG5vdCB3YW50IHRvIGNvbnRpbnVlIHdpdGggdGhhdCBkaWFsb2csIHRoZW4gdGhlIFVBQyBNVVNUIHRlcm1pbmF0ZVxuICAgICAgICAvLyB0aGUgZGlhbG9nIGJ5IHNlbmRpbmcgYSBCWUUgcmVxdWVzdCBhcyBkZXNjcmliZWQgaW4gU2VjdGlvbiAxNS5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuNFxuICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChlYXJseURpYWxvZykgeyByZXR1cm4gZWFybHlEaWFsb2cuZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuY2xlYXIoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UgZm9yIHRyYW5zcG9ydCBlcnJvciB3aGlsZSBzZW5kaW5nIEFDSy5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUcmFuc3BvcnQgZXJyb3JcbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLm9uVHJhbnNwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuQ2FsbGluZykge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvci5jYWxsKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBub3QgaW4gJ2NhbGxpbmcnIHN0YXRlLCB0aGUgdHJhbnNwb3J0IGVycm9yIG9jY3VycmVkIHdoaWxlIHNlbmRpbmcgYW4gQUNLLlxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJVc2VyIGFnZW50IGNsaWVudCByZXF1ZXN0IHRyYW5zcG9ydCBlcnJvciB3aGlsZSBzZW5kaW5nIEFDSy5cIik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmNlIHRoZSBJTlZJVEUgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBJTlZJVEUgY2xpZW50IHRyYW5zYWN0aW9uLCB0aGVcbiAgICAgKiBVQUMgd2FpdHMgZm9yIHJlc3BvbnNlcyBmb3IgdGhlIElOVklURS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMlxuICAgICAqIEBwYXJhbSBpbmNvbWluZ1Jlc3BvbnNlIC0gSW5jb21pbmcgcmVzcG9uc2UgdG8gSU5WSVRFIHJlcXVlc3QuXG4gICAgICovXG4gICAgSW52aXRlVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuYXV0aGVudGljYXRpb25HdWFyZChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlID8gbWVzc2FnZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uVHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIC9eMVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAvLyBaZXJvLCBvbmUgb3IgbXVsdGlwbGUgcHJvdmlzaW9uYWwgcmVzcG9uc2VzIG1heSBhcnJpdmUgYmVmb3JlIG9uZSBvclxuICAgICAgICAgICAgICAgIC8vIG1vcmUgZmluYWwgcmVzcG9uc2VzIGFyZSByZWNlaXZlZC4gIFByb3Zpc2lvbmFsIHJlc3BvbnNlcyBmb3IgYW5cbiAgICAgICAgICAgICAgICAvLyBJTlZJVEUgcmVxdWVzdCBjYW4gY3JlYXRlIFwiZWFybHkgZGlhbG9nc1wiLiAgSWYgYSBwcm92aXNpb25hbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIC8vIGhhcyBhIHRhZyBpbiB0aGUgVG8gZmllbGQsIGFuZCBpZiB0aGUgZGlhbG9nIElEIG9mIHRoZSByZXNwb25zZSBkb2VzXG4gICAgICAgICAgICAgICAgLy8gbm90IG1hdGNoIGFuIGV4aXN0aW5nIGRpYWxvZywgb25lIGlzIGNvbnN0cnVjdGVkIHVzaW5nIHRoZSBwcm9jZWR1cmVzXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbiBTZWN0aW9uIDEyLjEuMi5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlYXJseSBkaWFsb2cgd2lsbCBvbmx5IGJlIG5lZWRlZCBpZiB0aGUgVUFDIG5lZWRzIHRvIHNlbmQgYVxuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgdG8gaXRzIHBlZXIgd2l0aGluIHRoZSBkaWFsb2cgYmVmb3JlIHRoZSBpbml0aWFsIElOVklURVxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGNvbXBsZXRlcy4gIEhlYWRlciBmaWVsZHMgcHJlc2VudCBpbiBhIHByb3Zpc2lvbmFsXG4gICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UgYXJlIGFwcGxpY2FibGUgYXMgbG9uZyBhcyB0aGUgZGlhbG9nIGlzIGluIHRoZSBlYXJseSBzdGF0ZVxuICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgYW4gQWxsb3cgaGVhZGVyIGZpZWxkIGluIGEgcHJvdmlzaW9uYWwgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAvLyBjb250YWlucyB0aGUgbWV0aG9kcyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBkaWFsb2cgd2hpbGUgdGhpcyBpcyBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBlYXJseSBzdGF0ZSkuXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuMVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlzaW9uYWwgd2l0aG91dCB0byB0YWcsIG5vIGRpYWxvZyB0byBjcmVhdGUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS50b1RhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIk5vbi0xMDAgMXh4IElOVklURSByZXNwb25zZSByZWNlaXZlZCB3aXRob3V0IGEgdG8gdGFnLCBkcm9wcGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBkaWFsb2cgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFsb2dTdGF0ZSA9IGRpYWxvZ3NfMS5EaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yVXNlckFnZW50Q2xpZW50KHRoaXMubWVzc2FnZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmUgZXhpc3RpbmcgZWFybHkgZGlhbG9nIG9yIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXJseURpYWxvZyA9IHRoaXMuZWFybHlEaWFsb2dzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZWFybHlEaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlYXJseURpYWxvZyA9IG5ldyBkaWFsb2dzXzEuU2Vzc2lvbkRpYWxvZyh0cmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBkaWFsb2dTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9ncy5zZXQoZWFybHlEaWFsb2cuaWQsIGVhcmx5RGlhbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBHdWFyZCBhZ2FpbnN0IG91dCBvZiBvcmRlciByZWxpYWJsZSBwcm92aXNpb25hbCByZXNwb25zZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHdoZXJlIHRoZSByc2VxIHRyYWNraW5nIGlzIGRvbmUuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZWFybHlEaWFsb2cucmVsaWFibGVTZXF1ZW5jZUd1YXJkKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiMXh4IElOVklURSByZWxpYWJsZSByZXNwb25zZSByZWNlaXZlZCBvdXQgb2Ygb3JkZXIsIGRyb3BwaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBvZmZlciBpcyBpbiBhbiBJTlZJVEUsIHRoZSBhbnN3ZXIgTVVTVCBiZSBpbiBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbGlhYmxlIG5vbi1mYWlsdXJlIG1lc3NhZ2UgZnJvbSBVQVMgYmFjayB0byBVQUMgd2hpY2ggaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gY29ycmVsYXRlZCB0byB0aGF0IElOVklURS4gIEZvciB0aGlzIHNwZWNpZmljYXRpb24sIHRoYXQgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGUgZmluYWwgMnh4IHJlc3BvbnNlIHRvIHRoYXQgSU5WSVRFLiAgVGhhdCBzYW1lIGV4YWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuc3dlciBNQVkgYWxzbyBiZSBwbGFjZWQgaW4gYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBzZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHByaW9yIHRvIHRoZSBhbnN3ZXIuICBUaGUgVUFDIE1VU1QgdHJlYXQgdGhlIGZpcnN0IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVzY3JpcHRpb24gaXQgcmVjZWl2ZXMgYXMgdGhlIGFuc3dlciwgYW5kIE1VU1QgaWdub3JlIGFueVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGRlc2NyaXB0aW9ucyBpbiBzdWJzZXF1ZW50IHJlc3BvbnNlcyB0byB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAvLyBJTlZJVEUuXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4xXG4gICAgICAgICAgICAgICAgICAgIGlmIChlYXJseURpYWxvZy5zaWduYWxpbmdTdGF0ZSA9PT0gc2Vzc2lvbl8xLlNpZ25hbGluZ1N0YXRlLkluaXRpYWwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHJlc3BvbnNlIHRvIGRlbGVnYXRlLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vzc2lvbl8yID0gZWFybHlEaWFsb2c7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHNlc3Npb25fMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmFjazogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dGdvaW5nUHJhY2tSZXF1ZXN0ID0gc2Vzc2lvbl8yLnByYWNrKHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRnb2luZ1ByYWNrUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIC9eMlswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAvLyBNdWx0aXBsZSAyeHggcmVzcG9uc2VzIG1heSBhcnJpdmUgYXQgdGhlIFVBQyBmb3IgYSBzaW5nbGUgSU5WSVRFXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBkdWUgdG8gYSBmb3JraW5nIHByb3h5LiAgRWFjaCByZXNwb25zZSBpcyBkaXN0aW5ndWlzaGVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gdGhlIHRhZyBwYXJhbWV0ZXIgaW4gdGhlIFRvIGhlYWRlciBmaWVsZCwgYW5kIGVhY2ggcmVwcmVzZW50cyBhXG4gICAgICAgICAgICAgICAgLy8gZGlzdGluY3QgZGlhbG9nLCB3aXRoIGEgZGlzdGluY3QgZGlhbG9nIGlkZW50aWZpZXIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlhbG9nIGlkZW50aWZpZXIgaW4gdGhlIDJ4eCByZXNwb25zZSBtYXRjaGVzIHRoZSBkaWFsb2dcbiAgICAgICAgICAgICAgICAvLyBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGRpYWxvZywgdGhlIGRpYWxvZyBNVVNUIGJlIHRyYW5zaXRpb25lZCB0b1xuICAgICAgICAgICAgICAgIC8vIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlLCBhbmQgdGhlIHJvdXRlIHNldCBmb3IgdGhlIGRpYWxvZyBNVVNUIGJlXG4gICAgICAgICAgICAgICAgLy8gcmVjb21wdXRlZCBiYXNlZCBvbiB0aGUgMnh4IHJlc3BvbnNlIHVzaW5nIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAxMi4yLjEuMi4gIE90aGVyd2lzZSwgYSBuZXcgZGlhbG9nIGluIHRoZSBcImNvbmZpcm1lZFwiIHN0YXRlIE1VU1QgYmVcbiAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDEyLjEuMi5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGRpYWxvZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWxvZ1N0YXRlID0gZGlhbG9nc18xLkRpYWxvZy5pbml0aWFsRGlhbG9nU3RhdGVGb3JVc2VyQWdlbnRDbGllbnQodGhpcy5tZXNzYWdlLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogQ3VycmVudGx5IG91ciB0cmFuc2FjdGlvbiBsYXllciBpcyBjYWNoaW5nIHRoZSAyeHggQUNLcyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxpbmcgcmV0cmFuc21pc3Npb25zIG9mIHRoZSBBQ0sgd2hpY2ggaXMgYW4gYXBwcm9hY2ggd2hpY2ggaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHRvIHNwZWMuIEluIGFueSBldmVudCwgdGhpcyBibG9jayBpcyBpbnRlbmRlZCB0byBwcm92aWRlIGEgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlYyBpbXBsZW1lbnRhdGlvbiBvZiBBQ0sgcmV0cmFuc21pc3Npb25zLCBidXQgaXQgc2hvdWxkIG5vdCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBoaXQgY3VycmVudGx5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhbG9nID0gdGhpcy5jb25maXJtZWREaWFsb2dzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWFsb2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9uY2UgdGhlIEFDSyBoYXMgYmVlbiBjb25zdHJ1Y3RlZCwgdGhlIHByb2NlZHVyZXMgb2YgWzRdIGFyZSB1c2VkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MsIHBvcnQgYW5kIHRyYW5zcG9ydC4gIEhvd2V2ZXIsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpcyBwYXNzZWQgdG8gdGhlIHRyYW5zcG9ydCBsYXllciBkaXJlY3RseSBmb3IgdHJhbnNtaXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYSBjbGllbnQgdHJhbnNhY3Rpb24uICBUaGlzIGlzIGJlY2F1c2UgdGhlIFVBQyBjb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVzIHJldHJhbnNtaXNzaW9ucyBvZiB0aGUgQUNLLCBub3QgdGhlIHRyYW5zYWN0aW9uIGxheWVyLiAgVGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBQ0sgTVVTVCBiZSBwYXNzZWQgdG8gdGhlIGNsaWVudCB0cmFuc3BvcnQgZXZlcnkgdGltZSBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXRyYW5zbWlzc2lvbiBvZiB0aGUgMnh4IGZpbmFsIHJlc3BvbnNlIHRoYXQgdHJpZ2dlcmVkIHRoZSBBQ0tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFycml2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdBY2tSZXF1ZXN0ID0gdGhpcy5jb25maXJtZWREaWFsb2dBY2tzLmdldChkaWFsb2dTdGF0ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0Z29pbmdBY2tSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgdHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNrUmVzcG9uc2Uob3V0Z29pbmdBY2tSZXF1ZXN0Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgd2FpdGluZyBmb3IgYW4gQUNLLCBkcm9wIHRoZSByZXRyYW5zbWlzc2lvbiBvZiB0aGUgMnh4IGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkaWFsb2cgaWRlbnRpZmllciBpbiB0aGUgMnh4IHJlc3BvbnNlIG1hdGNoZXMgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpZGVudGlmaWVyIG9mIGFuIGV4aXN0aW5nIGRpYWxvZywgdGhlIGRpYWxvZyBNVVNUIGJlIHRyYW5zaXRpb25lZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgXCJjb25maXJtZWRcIiBzdGF0ZSwgYW5kIHRoZSByb3V0ZSBzZXQgZm9yIHRoZSBkaWFsb2cgTVVTVCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvbXB1dGVkIGJhc2VkIG9uIHRoZSAyeHggcmVzcG9uc2UgdXNpbmcgdGhlIHByb2NlZHVyZXMgb2YgU2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyAxMi4yLjEuMi4gT3RoZXJ3aXNlLCBhIG5ldyBkaWFsb2cgaW4gdGhlIFwiY29uZmlybWVkXCIgc3RhdGUgTVVTVCBiZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdHJ1Y3RlZCB1c2luZyB0aGUgcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDEyLjEuMi5cbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjIuNFxuICAgICAgICAgICAgICAgICAgICBkaWFsb2cgPSB0aGlzLmVhcmx5RGlhbG9ncy5nZXQoZGlhbG9nU3RhdGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlhbG9nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cuY29uZmlybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnJlY29tcHV0ZVJvdXRlU2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuZGVsZXRlKGRpYWxvZy5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ3Muc2V0KGRpYWxvZy5pZCwgZGlhbG9nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZUNsaWVudFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIG5vdCBpbnN0YW5jZSBvZiBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cgPSBuZXcgZGlhbG9nc18xLlNlc3Npb25EaWFsb2codHJhbnNhY3Rpb24sIHRoaXMuY29yZSwgZGlhbG9nU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2dzLnNldChkaWFsb2cuaWQsIGRpYWxvZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGluaXRpYWwgb2ZmZXIgaXMgaW4gYW4gSU5WSVRFLCB0aGUgYW5zd2VyIE1VU1QgYmUgaW4gYVxuICAgICAgICAgICAgICAgICAgICAvLyByZWxpYWJsZSBub24tZmFpbHVyZSBtZXNzYWdlIGZyb20gVUFTIGJhY2sgdG8gVUFDIHdoaWNoIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlbGF0ZWQgdG8gdGhhdCBJTlZJVEUuICBGb3IgdGhpcyBzcGVjaWZpY2F0aW9uLCB0aGF0IGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgdGhlIGZpbmFsIDJ4eCByZXNwb25zZSB0byB0aGF0IElOVklURS4gIFRoYXQgc2FtZSBleGFjdFxuICAgICAgICAgICAgICAgICAgICAvLyBhbnN3ZXIgTUFZIGFsc28gYmUgcGxhY2VkIGluIGFueSBwcm92aXNpb25hbCByZXNwb25zZXMgc2VudFxuICAgICAgICAgICAgICAgICAgICAvLyBwcmlvciB0byB0aGUgYW5zd2VyLiAgVGhlIFVBQyBNVVNUIHRyZWF0IHRoZSBmaXJzdCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlc2NyaXB0aW9uIGl0IHJlY2VpdmVzIGFzIHRoZSBhbnN3ZXIsIGFuZCBNVVNUIGlnbm9yZSBhbnlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiBkZXNjcmlwdGlvbnMgaW4gc3Vic2VxdWVudCByZXNwb25zZXMgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gSU5WSVRFLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZUxvY2FsT2ZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vzc2lvbiBJbml0aWF0ZWQhIDopXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uXzMgPSBkaWFsb2c7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBVQUMgY29yZSBNVVNUIGdlbmVyYXRlIGFuIEFDSyByZXF1ZXN0IGZvciBlYWNoIDJ4eCByZWNlaXZlZCBmcm9tXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBsYXllci4gIFRoZSBoZWFkZXIgZmllbGRzIG9mIHRoZSBBQ0sgYXJlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIHdheSBhcyBmb3IgYW55IHJlcXVlc3Qgc2VudCB3aXRoaW4gYSBkaWFsb2cgKHNlZSBTZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIDEyKSB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIENTZXEgYW5kIHRoZSBoZWFkZXIgZmllbGRzIHJlbGF0ZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0aGVudGljYXRpb24uICBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBNVVNUIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBJTlZJVEUgYmVpbmcgYWNrbm93bGVkZ2VkLCBidXQgdGhlIENTZXEgbWV0aG9kIE1VU1RcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgQUNLLiAgVGhlIEFDSyBNVVNUIGNvbnRhaW4gdGhlIHNhbWUgY3JlZGVudGlhbHMgYXMgdGhlIElOVklURS4gIElmXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSAyeHggY29udGFpbnMgYW4gb2ZmZXIgKGJhc2VkIG9uIHRoZSBydWxlcyBhYm92ZSksIHRoZSBBQ0sgTVVTVFxuICAgICAgICAgICAgICAgICAgICAvLyBjYXJyeSBhbiBhbnN3ZXIgaW4gaXRzIGJvZHkuICBJZiB0aGUgb2ZmZXIgaW4gdGhlIDJ4eCByZXNwb25zZSBpcyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXB0YWJsZSwgdGhlIFVBQyBjb3JlIE1VU1QgZ2VuZXJhdGUgYSB2YWxpZCBhbnN3ZXIgaW4gdGhlIEFDSyBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBzZW5kIGEgQllFIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi40XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25BY2NlcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbjogc2Vzc2lvbl8zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjazogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG91dGdvaW5nQWNrUmVxdWVzdCA9IHNlc3Npb25fMy5hY2sob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3Muc2V0KHNlc3Npb25fMy5pZCwgb3V0Z29pbmdBY2tSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGdvaW5nQWNrUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdXRnb2luZ0Fja1JlcXVlc3QgPSBzZXNzaW9uXzMuYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1lZERpYWxvZ0Fja3Muc2V0KHNlc3Npb25fMy5pZCwgb3V0Z29pbmdBY2tSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIC9eM1swLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAvLyAxMi4zIFRlcm1pbmF0aW9uIG9mIGEgRGlhbG9nXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbmRlcGVuZGVudCBvZiB0aGUgbWV0aG9kLCBpZiBhIHJlcXVlc3Qgb3V0c2lkZSBvZiBhIGRpYWxvZyBnZW5lcmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBhIG5vbi0yeHggZmluYWwgcmVzcG9uc2UsIGFueSBlYXJseSBkaWFsb2dzIGNyZWF0ZWQgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyB0byB0aGF0IHJlcXVlc3QgYXJlIHRlcm1pbmF0ZWQuICBUaGUgbWVjaGFuaXNtXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRlcm1pbmF0aW5nIGNvbmZpcm1lZCBkaWFsb2dzIGlzIG1ldGhvZCBzcGVjaWZpYy4gIEluIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uLCB0aGUgQllFIG1ldGhvZCB0ZXJtaW5hdGVzIGEgc2Vzc2lvbiBhbmQgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBpdC4gIFNlZSBTZWN0aW9uIDE1IGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuM1xuICAgICAgICAgICAgICAgIC8vIEFsbCBlYXJseSBkaWFsb2dzIGFyZSBjb25zaWRlcmVkIHRlcm1pbmF0ZWQgdXBvbiByZWNlcHRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbm9uLTJ4eCBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyIGhhdmluZyByZWNlaXZlZCB0aGUgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSB0aGUgVUFDIGNvcmVcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlcnMgdGhlIElOVklURSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQuICBUaGUgSU5WSVRFIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGhhbmRsZXMgdGhlIGdlbmVyYXRpb24gb2YgQUNLcyBmb3IgdGhlIHJlc3BvbnNlIChzZWVcbiAgICAgICAgICAgICAgICAvLyBTZWN0aW9uIDE3KS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4zXG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuZm9yRWFjaChmdW5jdGlvbiAoZWFybHlEaWFsb2cpIHsgcmV0dXJuIGVhcmx5RGlhbG9nLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvLyBBIDN4eCByZXNwb25zZSBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSBDb250YWN0IGhlYWRlciBmaWVsZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBwcm92aWRpbmcgbmV3IGFkZHJlc3NlcyB3aGVyZSB0aGUgY2FsbGVlIG1pZ2h0IGJlIHJlYWNoYWJsZS5cbiAgICAgICAgICAgICAgICAvLyBEZXBlbmRpbmcgb24gdGhlIHN0YXR1cyBjb2RlIG9mIHRoZSAzeHggcmVzcG9uc2UgKHNlZSBTZWN0aW9uIDIxLjMpLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBVQUMgTUFZIGNob29zZSB0byB0cnkgdGhvc2UgbmV3IGFkZHJlc3Nlcy5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4yXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgL15bNC02XVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICAvLyAxMi4zIFRlcm1pbmF0aW9uIG9mIGEgRGlhbG9nXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbmRlcGVuZGVudCBvZiB0aGUgbWV0aG9kLCBpZiBhIHJlcXVlc3Qgb3V0c2lkZSBvZiBhIGRpYWxvZyBnZW5lcmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBhIG5vbi0yeHggZmluYWwgcmVzcG9uc2UsIGFueSBlYXJseSBkaWFsb2dzIGNyZWF0ZWQgdGhyb3VnaFxuICAgICAgICAgICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlcyB0byB0aGF0IHJlcXVlc3QgYXJlIHRlcm1pbmF0ZWQuICBUaGUgbWVjaGFuaXNtXG4gICAgICAgICAgICAgICAgLy8gZm9yIHRlcm1pbmF0aW5nIGNvbmZpcm1lZCBkaWFsb2dzIGlzIG1ldGhvZCBzcGVjaWZpYy4gIEluIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpY2F0aW9uLCB0aGUgQllFIG1ldGhvZCB0ZXJtaW5hdGVzIGEgc2Vzc2lvbiBhbmQgdGhlIGRpYWxvZ1xuICAgICAgICAgICAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCBpdC4gIFNlZSBTZWN0aW9uIDE1IGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTIuM1xuICAgICAgICAgICAgICAgIC8vIEFsbCBlYXJseSBkaWFsb2dzIGFyZSBjb25zaWRlcmVkIHRlcm1pbmF0ZWQgdXBvbiByZWNlcHRpb24gb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbm9uLTJ4eCBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEFmdGVyIGhhdmluZyByZWNlaXZlZCB0aGUgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSB0aGUgVUFDIGNvcmVcbiAgICAgICAgICAgICAgICAvLyBjb25zaWRlcnMgdGhlIElOVklURSB0cmFuc2FjdGlvbiBjb21wbGV0ZWQuICBUaGUgSU5WSVRFIGNsaWVudFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uIGhhbmRsZXMgdGhlIGdlbmVyYXRpb24gb2YgQUNLcyBmb3IgdGhlIHJlc3BvbnNlIChzZWVcbiAgICAgICAgICAgICAgICAvLyBTZWN0aW9uIDE3KS5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMi4zXG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuZm9yRWFjaChmdW5jdGlvbiAoZWFybHlEaWFsb2cpIHsgcmV0dXJuIGVhcmx5RGlhbG9nLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZ3MuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAvLyBBIHNpbmdsZSBub24tMnh4IGZpbmFsIHJlc3BvbnNlIG1heSBiZSByZWNlaXZlZCBmb3IgdGhlIElOVklURS4gIDR4eCxcbiAgICAgICAgICAgICAgICAvLyA1eHggYW5kIDZ4eCByZXNwb25zZXMgbWF5IGNvbnRhaW4gYSBDb250YWN0IGhlYWRlciBmaWVsZCB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRpbmcgdGhlIGxvY2F0aW9uIHdoZXJlIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIGZvdW5kLiAgU3Vic2VxdWVudCBmaW5hbCByZXNwb25zZXMgKHdoaWNoIHdvdWxkIG9ubHkgYXJyaXZlXG4gICAgICAgICAgICAgICAgLy8gdW5kZXIgZXJyb3IgY29uZGl0aW9ucykgTVVTVCBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMi4yLjNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uUmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWplY3QoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGVjdXRpbmcgd2hhdCBzaG91bGQgYmUgYW4gdW5yZWFjaGFibGUgY29kZSBwYXRoIHJlY2VpdmluZyBcIiArIHN0YXR1c0NvZGUgKyBcIiByZXNwb25zZS5cIik7XG4gICAgfTtcbiAgICByZXR1cm4gSW52aXRlVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5JbnZpdGVVc2VyQWdlbnRDbGllbnQgPSBJbnZpdGVVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIGRpYWxvZ3NfMSA9IHJlcXVpcmUoXCIuLi9kaWFsb2dzXCIpO1xudmFyIGV4Y2VwdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9leGNlcHRpb25zXCIpO1xudmFyIHNlc3Npb25fMSA9IHJlcXVpcmUoXCIuLi9zZXNzaW9uXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciBhbGxvd2VkX21ldGhvZHNfMSA9IHJlcXVpcmUoXCIuLi91c2VyLWFnZW50LWNvcmUvYWxsb3dlZC1tZXRob2RzXCIpO1xudmFyIHVzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKTtcbi8qKlxuICogSU5WSVRFIFVBUy5cbiAqIEByZW1hcmtzXG4gKiAxMyBJbml0aWF0aW5nIGEgU2Vzc2lvblxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xM1xuICogMTMuMSBPdmVydmlld1xuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4xXG4gKiAxMy4zIFVBUyBQcm9jZXNzaW5nXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjNcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEludml0ZVVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52aXRlVXNlckFnZW50U2VydmVyKGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW52aXRlVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lYXJseURpYWxvZykge1xuICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAxMy4zLjEuNCBUaGUgSU5WSVRFIGlzIEFjY2VwdGVkXG4gICAgICogVGhlIFVBUyBjb3JlIGdlbmVyYXRlcyBhIDJ4eCByZXNwb25zZS4gIFRoaXMgcmVzcG9uc2UgZXN0YWJsaXNoZXMgYVxuICAgICAqIGRpYWxvZywgYW5kIHRoZXJlZm9yZSBmb2xsb3dzIHRoZSBwcm9jZWR1cmVzIG9mIFNlY3Rpb24gMTIuMS4xIGluXG4gICAgICogYWRkaXRpb24gdG8gdGhvc2Ugb2YgU2VjdGlvbiA4LjIuNi5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBY2NlcHQgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgSW52aXRlVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDIwMCB9OyB9XG4gICAgICAgIGlmICghdGhpcy5hY2NlcHRhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGVFcnJvcih0aGlzLm1lc3NhZ2UubWV0aG9kICsgXCIgbm90IGFjY2VwdGFibGUgaW4gc3RhdGUgXCIgKyB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlICsgXCIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcmVzcG9uc2UgZXN0YWJsaXNoZXMgYSBkaWFsb2cuLi5cbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuNFxuICAgICAgICBpZiAoIXRoaXMuY29uZmlybWVkRGlhbG9nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lYXJseURpYWxvZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFybHlEaWFsb2cuY29uZmlybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkRGlhbG9nID0gdGhpcy5lYXJseURpYWxvZztcbiAgICAgICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2FjdGlvbiBub3QgaW5zdGFuY2Ugb2YgSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBkaWFsb2dzXzEuRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclVzZXJBZ2VudFNlcnZlcih0aGlzLm1lc3NhZ2UsIHRoaXMudG9UYWcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkRGlhbG9nID0gbmV3IGRpYWxvZ3NfMS5TZXNzaW9uRGlhbG9nKHRyYW5zYWN0aW9uLCB0aGlzLmNvcmUsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgVUFTIHJlc3BvbmRzIHRvIGEgcmVxdWVzdCB3aXRoIGEgcmVzcG9uc2UgdGhhdCBlc3RhYmxpc2hlcyBhXG4gICAgICAgIC8vIGRpYWxvZyAoc3VjaCBhcyBhIDJ4eCB0byBJTlZJVEUpLCB0aGUgVUFTIE1VU1QgY29weSBhbGwgUmVjb3JkLVJvdXRlXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCB2YWx1ZXMgZnJvbSB0aGUgcmVxdWVzdCBpbnRvIHRoZSByZXNwb25zZSAoaW5jbHVkaW5nIHRoZVxuICAgICAgICAvLyBVUklzLCBVUkkgcGFyYW1ldGVycywgYW5kIGFueSBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMsXG4gICAgICAgIC8vIHdoZXRoZXIgdGhleSBhcmUga25vd24gb3IgdW5rbm93biB0byB0aGUgVUFTKSBhbmQgTVVTVCBtYWludGFpbiB0aGVcbiAgICAgICAgLy8gb3JkZXIgb2YgdGhvc2UgdmFsdWVzLiAgVGhlIFVBUyBNVVNUIGFkZCBhIENvbnRhY3QgaGVhZGVyIGZpZWxkIHRvXG4gICAgICAgIC8vIHRoZSByZXNwb25zZS4gIFRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBjb250YWlucyBhbiBhZGRyZXNzIHdoZXJlIHRoZVxuICAgICAgICAvLyBVQVMgd291bGQgbGlrZSB0byBiZSBjb250YWN0ZWQgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMgaW4gdGhlIGRpYWxvZ1xuICAgICAgICAvLyAod2hpY2ggaW5jbHVkZXMgdGhlIEFDSyBmb3IgYSAyeHggcmVzcG9uc2UgaW4gdGhlIGNhc2Ugb2YgYW4gSU5WSVRFKS5cbiAgICAgICAgLy8gR2VuZXJhbGx5LCB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoaXMgVVJJIGlzIHRoZSBJUCBhZGRyZXNzIG9yIEZRRE4gb2ZcbiAgICAgICAgLy8gdGhlIGhvc3QuICBUaGUgVVJJIHByb3ZpZGVkIGluIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBNVVNUIGJlIGEgU0lQXG4gICAgICAgIC8vIG9yIFNJUFMgVVJJLiAgSWYgdGhlIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgdGhlIGRpYWxvZyBjb250YWluZWQgYVxuICAgICAgICAvLyBTSVBTIFVSSSBpbiB0aGUgUmVxdWVzdC1VUkkgb3IgaW4gdGhlIHRvcCBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkXG4gICAgICAgIC8vIHZhbHVlLCBpZiB0aGVyZSB3YXMgYW55LCBvciB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgaWYgdGhlcmUgd2FzIG5vXG4gICAgICAgIC8vIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQsIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gTVVTVCBiZSBhIFNJUFMgVVJJLiAgVGhlIFVSSSBTSE9VTEQgaGF2ZSBnbG9iYWwgc2NvcGUgKHRoYXQgaXMsIHRoZVxuICAgICAgICAvLyBzYW1lIFVSSSBjYW4gYmUgdXNlZCBpbiBtZXNzYWdlcyBvdXRzaWRlIHRoaXMgZGlhbG9nKS4gIFRoZSBzYW1lIHdheSxcbiAgICAgICAgLy8gdGhlIHNjb3BlIG9mIHRoZSBVUkkgaW4gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIG9mIHRoZSBJTlZJVEUgaXMgbm90XG4gICAgICAgIC8vIGxpbWl0ZWQgdG8gdGhpcyBkaWFsb2cgZWl0aGVyLiAgSXQgY2FuIHRoZXJlZm9yZSBiZSB1c2VkIGluIG1lc3NhZ2VzXG4gICAgICAgIC8vIHRvIHRoZSBVQUMgZXZlbiBvdXRzaWRlIHRoaXMgZGlhbG9nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgcmVjb3JkUm91dGVIZWFkZXIgPSB0aGlzLm1lc3NhZ2VcbiAgICAgICAgICAgIC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChoZWFkZXIpIHsgcmV0dXJuIFwiUmVjb3JkLVJvdXRlOiBcIiArIGhlYWRlcjsgfSk7XG4gICAgICAgIHZhciBjb250YWN0SGVhZGVyID0gXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3QudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gQSAyeHggcmVzcG9uc2UgdG8gYW4gSU5WSVRFIFNIT1VMRCBjb250YWluIHRoZSBBbGxvdyBoZWFkZXIgZmllbGQgYW5kXG4gICAgICAgIC8vIHRoZSBTdXBwb3J0ZWQgaGVhZGVyIGZpZWxkLCBhbmQgTUFZIGNvbnRhaW4gdGhlIEFjY2VwdCBoZWFkZXIgZmllbGQuXG4gICAgICAgIC8vIEluY2x1ZGluZyB0aGVzZSBoZWFkZXIgZmllbGRzIGFsbG93cyB0aGUgVUFDIHRvIGRldGVybWluZSB0aGVcbiAgICAgICAgLy8gZmVhdHVyZXMgYW5kIGV4dGVuc2lvbnMgc3VwcG9ydGVkIGJ5IHRoZSBVQVMgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY2FsbCwgd2l0aG91dCBwcm9iaW5nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBUaGlzIHNob3VsZCBub3QgYmUgaGFyZCBjb2RlZC5cbiAgICAgICAgdmFyIGFsbG93SGVhZGVyID0gXCJBbGxvdzogXCIgKyBhbGxvd2VkX21ldGhvZHNfMS5BbGxvd2VkTWV0aG9kcy50b1N0cmluZygpO1xuICAgICAgICAvLyBGSVhNRTogVE9ETzogU3VwcG9ydGVkIGhlYWRlciAoc2VlIHJlcGx5KCkpXG4gICAgICAgIC8vIEZJWE1FOiBUT0RPOiBBY2NlcHQgaGVhZGVyXG4gICAgICAgIC8vIElmIHRoZSBJTlZJVEUgcmVxdWVzdCBjb250YWluZWQgYW4gb2ZmZXIsIGFuZCB0aGUgVUFTIGhhZCBub3QgeWV0XG4gICAgICAgIC8vIHNlbnQgYW4gYW5zd2VyLCB0aGUgMnh4IE1VU1QgY29udGFpbiBhbiBhbnN3ZXIuICBJZiB0aGUgSU5WSVRFIGRpZFxuICAgICAgICAvLyBub3QgY29udGFpbiBhbiBvZmZlciwgdGhlIDJ4eCBNVVNUIGNvbnRhaW4gYW4gb2ZmZXIgaWYgdGhlIFVBUyBoYWRcbiAgICAgICAgLy8gbm90IHlldCBzZW50IGFuIG9mZmVyLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgIGlmICghb3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGUgPT09IHNlc3Npb25fMS5TaWduYWxpbmdTdGF0ZS5TdGFibGUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSB0aGlzLmNvbmZpcm1lZERpYWxvZy5hbnN3ZXI7IC8vIHJlc2VuZCB0aGUgYW5zd2VyIHNlbnQgaW4gcHJvdmlzaW9uYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uZmlybWVkRGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSW5pdGlhbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkRGlhbG9nLnNpZ25hbGluZ1N0YXRlID09PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuSGF2ZVJlbW90ZU9mZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgbXVzdCBoYXZlIGEgYm9keS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zdGF0dXNDb2RlID0gb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDIwMDtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycyB8fCBbXTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMgPSBvcHRpb25zLmV4dHJhSGVhZGVycy5jb25jYXQocmVjb3JkUm91dGVIZWFkZXIpO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycy5wdXNoKGFsbG93SGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChjb250YWN0SGVhZGVyKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gX3N1cGVyLnByb3RvdHlwZS5hY2NlcHQuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLmNvbmZpcm1lZERpYWxvZztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVzcG9uc2UpLCB7IHNlc3Npb246IHNlc3Npb24gfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlXG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIC8vIE9uY2UgdGhlIFVBUyBoYXMgc2VudCBvciByZWNlaXZlZCBhbiBhbnN3ZXIgdG8gdGhlIGluaXRpYWxcbiAgICAgICAgICAgIC8vIG9mZmVyLCBpdCBNVVNUIE5PVCBnZW5lcmF0ZSBzdWJzZXF1ZW50IG9mZmVycyBpbiBhbnkgcmVzcG9uc2VzXG4gICAgICAgICAgICAvLyB0byB0aGUgaW5pdGlhbCBJTlZJVEUuICBUaGlzIG1lYW5zIHRoYXQgYSBVQVMgYmFzZWQgb24gdGhpc1xuICAgICAgICAgICAgLy8gc3BlY2lmaWNhdGlvbiBhbG9uZSBjYW4gbmV2ZXIgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgdW50aWxcbiAgICAgICAgICAgIC8vIGNvbXBsZXRpb24gb2YgdGhlIGluaXRpYWwgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjIuMVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlybWVkRGlhbG9nLnNpZ25hbGluZ1N0YXRlICE9PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maXJtZWREaWFsb2cuc2lnbmFsaW5nU3RhdGVUcmFuc2l0aW9uKG9wdGlvbnMuYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDEzLjMuMS4xIFByb2dyZXNzXG4gICAgICogSWYgdGhlIFVBUyBpcyBub3QgYWJsZSB0byBhbnN3ZXIgdGhlIGludml0YXRpb24gaW1tZWRpYXRlbHksIGl0IGNhblxuICAgICAqIGNob29zZSB0byBpbmRpY2F0ZSBzb21lIGtpbmQgb2YgcHJvZ3Jlc3MgdG8gdGhlIFVBQyAoZm9yIGV4YW1wbGUsIGFuXG4gICAgICogaW5kaWNhdGlvbiB0aGF0IGEgcGhvbmUgaXMgcmluZ2luZykuICBUaGlzIGlzIGFjY29tcGxpc2hlZCB3aXRoIGFcbiAgICAgKiBwcm92aXNpb25hbCByZXNwb25zZSBiZXR3ZWVuIDEwMSBhbmQgMTk5LiAgVGhlc2UgcHJvdmlzaW9uYWxcbiAgICAgKiByZXNwb25zZXMgZXN0YWJsaXNoIGVhcmx5IGRpYWxvZ3MgYW5kIHRoZXJlZm9yZSBmb2xsb3cgdGhlIHByb2NlZHVyZXNcbiAgICAgKiBvZiBTZWN0aW9uIDEyLjEuMSBpbiBhZGRpdGlvbiB0byB0aG9zZSBvZiBTZWN0aW9uIDguMi42LiAgQSBVQVMgTUFZXG4gICAgICogc2VuZCBhcyBtYW55IHByb3Zpc2lvbmFsIHJlc3BvbnNlcyBhcyBpdCBsaWtlcy4gIEVhY2ggb2YgdGhlc2UgTVVTVFxuICAgICAqIGluZGljYXRlIHRoZSBzYW1lIGRpYWxvZyBJRC4gIEhvd2V2ZXIsIHRoZXNlIHdpbGwgbm90IGJlIGRlbGl2ZXJlZFxuICAgICAqIHJlbGlhYmx5LlxuICAgICAqXG4gICAgICogSWYgdGhlIFVBUyBkZXNpcmVzIGFuIGV4dGVuZGVkIHBlcmlvZCBvZiB0aW1lIHRvIGFuc3dlciB0aGUgSU5WSVRFLFxuICAgICAqIGl0IHdpbGwgbmVlZCB0byBhc2sgZm9yIGFuIFwiZXh0ZW5zaW9uXCIgaW4gb3JkZXIgdG8gcHJldmVudCBwcm94aWVzXG4gICAgICogZnJvbSBjYW5jZWxpbmcgdGhlIHRyYW5zYWN0aW9uLiAgQSBwcm94eSBoYXMgdGhlIG9wdGlvbiBvZiBjYW5jZWxpbmdcbiAgICAgKiBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgaXMgYSBnYXAgb2YgMyBtaW51dGVzIGJldHdlZW4gcmVzcG9uc2VzIGluIGFcbiAgICAgKiB0cmFuc2FjdGlvbi4gIFRvIHByZXZlbnQgY2FuY2VsbGF0aW9uLCB0aGUgVUFTIE1VU1Qgc2VuZCBhIG5vbi0xMDBcbiAgICAgKiBwcm92aXNpb25hbCByZXNwb25zZSBhdCBldmVyeSBtaW51dGUsIHRvIGhhbmRsZSB0aGUgcG9zc2liaWxpdHkgb2ZcbiAgICAgKiBsb3N0IHByb3Zpc2lvbmFsIHJlc3BvbnNlcy5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS4xXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBQcm9ncmVzcyBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfTsgfVxuICAgICAgICBpZiAoIXRoaXMucHJvZ3Jlc3NhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGVFcnJvcih0aGlzLm1lc3NhZ2UubWV0aG9kICsgXCIgbm90IHByb2dyZXNzYWJsZSBpbiBzdGF0ZSBcIiArIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyByZXNwb25zZSBlc3RhYmxpc2hlcyBhIGRpYWxvZy4uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEzLjMuMS40XG4gICAgICAgIGlmICghdGhpcy5lYXJseURpYWxvZykge1xuICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbm90IGluc3RhbmNlIG9mIEludml0ZUNsaWVudFRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGRpYWxvZ3NfMS5EaWFsb2cuaW5pdGlhbERpYWxvZ1N0YXRlRm9yVXNlckFnZW50U2VydmVyKHRoaXMubWVzc2FnZSwgdGhpcy50b1RhZywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmVhcmx5RGlhbG9nID0gbmV3IGRpYWxvZ3NfMS5TZXNzaW9uRGlhbG9nKHRyYW5zYWN0aW9uLCB0aGlzLmNvcmUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGEgVUFTIHJlc3BvbmRzIHRvIGEgcmVxdWVzdCB3aXRoIGEgcmVzcG9uc2UgdGhhdCBlc3RhYmxpc2hlcyBhXG4gICAgICAgIC8vIGRpYWxvZyAoc3VjaCBhcyBhIDJ4eCB0byBJTlZJVEUpLCB0aGUgVUFTIE1VU1QgY29weSBhbGwgUmVjb3JkLVJvdXRlXG4gICAgICAgIC8vIGhlYWRlciBmaWVsZCB2YWx1ZXMgZnJvbSB0aGUgcmVxdWVzdCBpbnRvIHRoZSByZXNwb25zZSAoaW5jbHVkaW5nIHRoZVxuICAgICAgICAvLyBVUklzLCBVUkkgcGFyYW1ldGVycywgYW5kIGFueSBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMsXG4gICAgICAgIC8vIHdoZXRoZXIgdGhleSBhcmUga25vd24gb3IgdW5rbm93biB0byB0aGUgVUFTKSBhbmQgTVVTVCBtYWludGFpbiB0aGVcbiAgICAgICAgLy8gb3JkZXIgb2YgdGhvc2UgdmFsdWVzLiAgVGhlIFVBUyBNVVNUIGFkZCBhIENvbnRhY3QgaGVhZGVyIGZpZWxkIHRvXG4gICAgICAgIC8vIHRoZSByZXNwb25zZS4gIFRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBjb250YWlucyBhbiBhZGRyZXNzIHdoZXJlIHRoZVxuICAgICAgICAvLyBVQVMgd291bGQgbGlrZSB0byBiZSBjb250YWN0ZWQgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHMgaW4gdGhlIGRpYWxvZ1xuICAgICAgICAvLyAod2hpY2ggaW5jbHVkZXMgdGhlIEFDSyBmb3IgYSAyeHggcmVzcG9uc2UgaW4gdGhlIGNhc2Ugb2YgYW4gSU5WSVRFKS5cbiAgICAgICAgLy8gR2VuZXJhbGx5LCB0aGUgaG9zdCBwb3J0aW9uIG9mIHRoaXMgVVJJIGlzIHRoZSBJUCBhZGRyZXNzIG9yIEZRRE4gb2ZcbiAgICAgICAgLy8gdGhlIGhvc3QuICBUaGUgVVJJIHByb3ZpZGVkIGluIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBNVVNUIGJlIGEgU0lQXG4gICAgICAgIC8vIG9yIFNJUFMgVVJJLiAgSWYgdGhlIHJlcXVlc3QgdGhhdCBpbml0aWF0ZWQgdGhlIGRpYWxvZyBjb250YWluZWQgYVxuICAgICAgICAvLyBTSVBTIFVSSSBpbiB0aGUgUmVxdWVzdC1VUkkgb3IgaW4gdGhlIHRvcCBSZWNvcmQtUm91dGUgaGVhZGVyIGZpZWxkXG4gICAgICAgIC8vIHZhbHVlLCBpZiB0aGVyZSB3YXMgYW55LCBvciB0aGUgQ29udGFjdCBoZWFkZXIgZmllbGQgaWYgdGhlcmUgd2FzIG5vXG4gICAgICAgIC8vIFJlY29yZC1Sb3V0ZSBoZWFkZXIgZmllbGQsIHRoZSBDb250YWN0IGhlYWRlciBmaWVsZCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gTVVTVCBiZSBhIFNJUFMgVVJJLiAgVGhlIFVSSSBTSE9VTEQgaGF2ZSBnbG9iYWwgc2NvcGUgKHRoYXQgaXMsIHRoZVxuICAgICAgICAvLyBzYW1lIFVSSSBjYW4gYmUgdXNlZCBpbiBtZXNzYWdlcyBvdXRzaWRlIHRoaXMgZGlhbG9nKS4gIFRoZSBzYW1lIHdheSxcbiAgICAgICAgLy8gdGhlIHNjb3BlIG9mIHRoZSBVUkkgaW4gdGhlIENvbnRhY3QgaGVhZGVyIGZpZWxkIG9mIHRoZSBJTlZJVEUgaXMgbm90XG4gICAgICAgIC8vIGxpbWl0ZWQgdG8gdGhpcyBkaWFsb2cgZWl0aGVyLiAgSXQgY2FuIHRoZXJlZm9yZSBiZSB1c2VkIGluIG1lc3NhZ2VzXG4gICAgICAgIC8vIHRvIHRoZSBVQUMgZXZlbiBvdXRzaWRlIHRoaXMgZGlhbG9nLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTEyLjEuMVxuICAgICAgICB2YXIgcmVjb3JkUm91dGVIZWFkZXIgPSB0aGlzLm1lc3NhZ2VcbiAgICAgICAgICAgIC5nZXRIZWFkZXJzKFwicmVjb3JkLXJvdXRlXCIpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChoZWFkZXIpIHsgcmV0dXJuIFwiUmVjb3JkLVJvdXRlOiBcIiArIGhlYWRlcjsgfSk7XG4gICAgICAgIHZhciBjb250YWN0SGVhZGVyID0gXCJDb250YWN0OiBcIiArIHRoaXMuY29yZS5jb25maWd1cmF0aW9uLmNvbnRhY3Q7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMgfHwgW107XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gb3B0aW9ucy5leHRyYUhlYWRlcnMuY29uY2F0KHJlY29yZFJvdXRlSGVhZGVyKTtcbiAgICAgICAgb3B0aW9ucy5leHRyYUhlYWRlcnMucHVzaChjb250YWN0SGVhZGVyKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gX3N1cGVyLnByb3RvdHlwZS5wcm9ncmVzcy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZWFybHlEaWFsb2c7XG4gICAgICAgIHZhciByZXN1bHQgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHJlc3BvbnNlKSwgeyBzZXNzaW9uOiBzZXNzaW9uIH0pO1xuICAgICAgICAvLyBVcGRhdGUgZGlhbG9nIHNpZ25hbGluZyBzdGF0ZVxuICAgICAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICAvLyBPbmNlIHRoZSBVQVMgaGFzIHNlbnQgb3IgcmVjZWl2ZWQgYW4gYW5zd2VyIHRvIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAvLyBvZmZlciwgaXQgTVVTVCBOT1QgZ2VuZXJhdGUgc3Vic2VxdWVudCBvZmZlcnMgaW4gYW55IHJlc3BvbnNlc1xuICAgICAgICAgICAgLy8gdG8gdGhlIGluaXRpYWwgSU5WSVRFLiAgVGhpcyBtZWFucyB0aGF0IGEgVUFTIGJhc2VkIG9uIHRoaXNcbiAgICAgICAgICAgIC8vIHNwZWNpZmljYXRpb24gYWxvbmUgY2FuIG5ldmVyIGdlbmVyYXRlIHN1YnNlcXVlbnQgb2ZmZXJzIHVudGlsXG4gICAgICAgICAgICAvLyBjb21wbGV0aW9uIG9mIHRoZSBpbml0aWFsIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4yLjFcbiAgICAgICAgICAgIGlmICh0aGlzLmVhcmx5RGlhbG9nLnNpZ25hbGluZ1N0YXRlICE9PSBzZXNzaW9uXzEuU2lnbmFsaW5nU3RhdGUuU3RhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYXJseURpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24ob3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogMTMuMy4xLjIgVGhlIElOVklURSBpcyBSZWRpcmVjdGVkXG4gICAgICogSWYgdGhlIFVBUyBkZWNpZGVzIHRvIHJlZGlyZWN0IHRoZSBjYWxsLCBhIDN4eCByZXNwb25zZSBpcyBzZW50LiAgQVxuICAgICAqIDMwMCAoTXVsdGlwbGUgQ2hvaWNlcyksIDMwMSAoTW92ZWQgUGVybWFuZW50bHkpIG9yIDMwMiAoTW92ZWRcbiAgICAgKiBUZW1wb3JhcmlseSkgcmVzcG9uc2UgU0hPVUxEIGNvbnRhaW4gYSBDb250YWN0IGhlYWRlciBmaWVsZFxuICAgICAqIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgVVJJcyBvZiBuZXcgYWRkcmVzc2VzIHRvIGJlIHRyaWVkLiAgVGhlXG4gICAgICogcmVzcG9uc2UgaXMgcGFzc2VkIHRvIHRoZSBJTlZJVEUgc2VydmVyIHRyYW5zYWN0aW9uLCB3aGljaCB3aWxsIGRlYWxcbiAgICAgKiB3aXRoIGl0cyByZXRyYW5zbWlzc2lvbnMuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xMy4zLjEuMlxuICAgICAqIEBwYXJhbSBjb250YWN0cyAtIENvbnRhY3RzIHRvIHJlZGlyZWN0IHRvLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVkaXJlY3Qgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgSW52aXRlVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIChjb250YWN0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDMwMiB9OyB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlZGlyZWN0LmNhbGwodGhpcywgY29udGFjdHMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogMTMuMy4xLjMgVGhlIElOVklURSBpcyBSZWplY3RlZFxuICAgICAqIEEgY29tbW9uIHNjZW5hcmlvIG9jY3VycyB3aGVuIHRoZSBjYWxsZWUgaXMgY3VycmVudGx5IG5vdCB3aWxsaW5nIG9yXG4gICAgICogYWJsZSB0byB0YWtlIGFkZGl0aW9uYWwgY2FsbHMgYXQgdGhpcyBlbmQgc3lzdGVtLiAgQSA0ODYgKEJ1c3kgSGVyZSlcbiAgICAgKiBTSE9VTEQgYmUgcmV0dXJuZWQgaW4gc3VjaCBhIHNjZW5hcmlvLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMTMuMy4xLjNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlamVjdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogNDg2IH07IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVqZWN0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gSW52aXRlVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5JbnZpdGVVc2VyQWdlbnRTZXJ2ZXIgPSBJbnZpdGVVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIE1FU1NBR0UgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgTWVzc2FnZVVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNZXNzYWdlVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VVc2VyQWdlbnRDbGllbnQoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLk1lc3NhZ2VVc2VyQWdlbnRDbGllbnQgPSBNZXNzYWdlVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBNRVNTQUdFIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIE1lc3NhZ2VVc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWVzc2FnZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlVXNlckFnZW50U2VydmVyKGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBNZXNzYWdlVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5NZXNzYWdlVXNlckFnZW50U2VydmVyID0gTWVzc2FnZVVzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBOT1RJRlkgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgTm90aWZ5VXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vdGlmeVVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RpZnlVc2VyQWdlbnRDbGllbnQoZGlhbG9nLCBkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5OT1RJRlksIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5vdGlmeVVzZXJBZ2VudENsaWVudDtcbn0odXNlcl9hZ2VudF9jbGllbnRfMS5Vc2VyQWdlbnRDbGllbnQpKTtcbmV4cG9ydHMuTm90aWZ5VXNlckFnZW50Q2xpZW50ID0gTm90aWZ5VXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBOT1RJRlkgVUFTLlxuICogQHB1YmxpY1xuICovXG52YXIgTm90aWZ5VXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE5vdGlmeVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBOT1RJRlkgVUFTIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBkaWFsb2dPckNvcmUgLSBEaWFsb2cgZm9yIGluIGRpYWxvZyBOT1RJRlksIFVzZXJBZ2VudENvcmUgZm9yIG91dCBvZiBkaWFsb2cgTk9USUZZIChkZXByZWNhdGVkKS5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIE5PVElGWSByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTm90aWZ5VXNlckFnZW50U2VydmVyKGRpYWxvZ09yQ29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVzZXJBZ2VudENvcmUgPSBpbnN0YW5jZU9mRGlhbG9nKGRpYWxvZ09yQ29yZSkgP1xuICAgICAgICAgICAgZGlhbG9nT3JDb3JlLnVzZXJBZ2VudENvcmUgOlxuICAgICAgICAgICAgZGlhbG9nT3JDb3JlO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCB1c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTm90aWZ5VXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5Ob3RpZnlVc2VyQWdlbnRTZXJ2ZXIgPSBOb3RpZnlVc2VyQWdlbnRTZXJ2ZXI7XG5mdW5jdGlvbiBpbnN0YW5jZU9mRGlhbG9nKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QudXNlckFnZW50Q29yZSAhPT0gdW5kZWZpbmVkO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIFBSQUNLIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByYWNrVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByYWNrVXNlckFnZW50Q2xpZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByYWNrVXNlckFnZW50Q2xpZW50KGRpYWxvZywgZGVsZWdhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBkaWFsb2cuY3JlYXRlT3V0Z29pbmdSZXF1ZXN0TWVzc2FnZShtZXNzYWdlc18xLkMuUFJBQ0ssIG9wdGlvbnMpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIGRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByYWNrVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5QcmFja1VzZXJBZ2VudENsaWVudCA9IFByYWNrVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBQUkFDSyBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBQcmFja1VzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcmFja1VzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmFja1VzZXJBZ2VudFNlcnZlcihkaWFsb2csIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgX3RoaXMuZGlhbG9nID0gZGlhbG9nO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGlhbG9nIHNpZ25hbGluZyBzdGF0ZSBvbiBhIDJ4eCByZXNwb25zZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFByYWNrVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDIwMCB9OyB9XG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihvcHRpb25zLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmFjY2VwdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFByYWNrVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5QcmFja1VzZXJBZ2VudFNlcnZlciA9IFByYWNrVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBQVUJMSVNIIFVBQy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFB1Ymxpc2hVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHVibGlzaFVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQdWJsaXNoVXNlckFnZW50Q2xpZW50KGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBQdWJsaXNoVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5QdWJsaXNoVXNlckFnZW50Q2xpZW50ID0gUHVibGlzaFVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtY2xpZW50XCIpO1xuLyoqXG4gKiBSZS1JTlZJVEUgVUFDLlxuICogQHJlbWFya3NcbiAqIDE0IE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0XG4gKiAxNC4xIFVBQyBCZWhhdmlvclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4xXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZUludml0ZVVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZUludml0ZVVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUludml0ZVVzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLklOVklURSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihtZXNzYWdlKTtcbiAgICAgICAgLy8gRklYTUU6IFRPRE86IG5leHQgbGluZSBvYnZpb3VzbHkgbmVlZHMgdG8gYmUgaW1wcm92ZWQuLi5cbiAgICAgICAgZGlhbG9nLnJlaW52aXRlVXNlckFnZW50Q2xpZW50ID0gX3RoaXM7IC8vIGxldCB0aGUgZGlhbG9nIGtub3cgcmUtaW52aXRlIHJlcXVlc3Qgc2VudFxuICAgICAgICBfdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVJbnZpdGVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5hdXRoZW50aWNhdGlvbkd1YXJkKG1lc3NhZ2UsIHRoaXMuZGlhbG9nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlID8gbWVzc2FnZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uVHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb246IHRoaXMuZGlhbG9nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJhY2s6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIHdpdGggb2ZmZXIvYW5zd2VyIGluIGJvZHlcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uQWNjZXB0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiB0aGlzLmRpYWxvZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjazogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3V0Z29pbmdBY2tSZXF1ZXN0ID0gX3RoaXMuZGlhbG9nLmFjayhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0Z29pbmdBY2tSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIC9eM1swLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSB1bmRlZmluZWQ7IC8vIEFDSyB3YXMgaGFuZGxlZCBieSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUmVkaXJlY3QoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL15bNC02XVswLTldezJ9JC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cucmVpbnZpdGVVc2VyQWdlbnRDbGllbnQgPSB1bmRlZmluZWQ7IC8vIEFDSyB3YXMgaGFuZGxlZCBieSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlamVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIFVBIHJlY2VpdmVzIGEgbm9uLTJ4eCBmaW5hbCByZXNwb25zZSB0byBhIHJlLUlOVklURSwgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1ldGVycyBNVVNUIHJlbWFpbiB1bmNoYW5nZWQsIGFzIGlmIG5vIHJlLUlOVklURSBoYWQgYmVlbiBpc3N1ZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCwgYXMgc3RhdGVkIGluIFNlY3Rpb24gMTIuMi4xLjIsIGlmIHRoZSBub24tMnh4IGZpbmFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIGlzIGEgNDgxIChDYWxsL1RyYW5zYWN0aW9uIERvZXMgTm90IEV4aXN0KSwgb3IgYSA0MDhcbiAgICAgICAgICAgICAgICAgICAgLy8gKFJlcXVlc3QgVGltZW91dCksIG9yIG5vIHJlc3BvbnNlIGF0IGFsbCBpcyByZWNlaXZlZCBmb3IgdGhlIHJlLVxuICAgICAgICAgICAgICAgICAgICAvLyBJTlZJVEUgKHRoYXQgaXMsIGEgdGltZW91dCBpcyByZXR1cm5lZCBieSB0aGUgSU5WSVRFIGNsaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiksIHRoZSBVQUMgd2lsbCB0ZXJtaW5hdGUgdGhlIGRpYWxvZy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBVQUMgcmVjZWl2ZXMgYSA0OTEgcmVzcG9uc2UgdG8gYSByZS1JTlZJVEUsIGl0IFNIT1VMRCBzdGFydCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHRpbWVyIHdpdGggYSB2YWx1ZSBUIGNob3NlbiBhcyBmb2xsb3dzOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAxLiBJZiB0aGUgVUFDIGlzIHRoZSBvd25lciBvZiB0aGUgQ2FsbC1JRCBvZiB0aGUgZGlhbG9nIElEXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIChtZWFuaW5nIGl0IGdlbmVyYXRlZCB0aGUgdmFsdWUpLCBUIGhhcyBhIHJhbmRvbWx5IGNob3NlbiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBiZXR3ZWVuIDIuMSBhbmQgNCBzZWNvbmRzIGluIHVuaXRzIG9mIDEwIG1zLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAyLiBJZiB0aGUgVUFDIGlzIG5vdCB0aGUgb3duZXIgb2YgdGhlIENhbGwtSUQgb2YgdGhlIGRpYWxvZyBJRCwgVFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBoYXMgYSByYW5kb21seSBjaG9zZW4gdmFsdWUgb2YgYmV0d2VlbiAwIGFuZCAyIHNlY29uZHMgaW4gdW5pdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgb2YgMTAgbXMuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHRpbWVyIGZpcmVzLCB0aGUgVUFDIFNIT1VMRCBhdHRlbXB0IHRoZSByZS1JTlZJVEUgb25jZSBtb3JlLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBzdGlsbCBkZXNpcmVzIGZvciB0aGF0IHNlc3Npb24gbW9kaWZpY2F0aW9uIHRvIHRha2UgcGxhY2UuICBGb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhhbXBsZSwgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgaHVuZyB1cCB3aXRoIGEgQllFLCB0aGUgcmUtSU5WSVRFXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIG5vdCB0YWtlIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0LjFcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFRPRE86IFRoZSBhYm92ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RhdHVzIGNvZGUgXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlSW52aXRlVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5SZUludml0ZVVzZXJBZ2VudENsaWVudCA9IFJlSW52aXRlVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBSZS1JTlZJVEUgVUFTLlxuICogQHJlbWFya3NcbiAqIDE0IE1vZGlmeWluZyBhbiBFeGlzdGluZyBTZXNzaW9uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTE0XG4gKiAxNC4yIFVBUyBCZWhhdmlvclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0xNC4yXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZUludml0ZVVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZUludml0ZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUludml0ZVVzZXJBZ2VudFNlcnZlcihkaWFsb2csIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBkaWFsb2cudXNlckFnZW50Q29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIGRpYWxvZy5yZWludml0ZVVzZXJBZ2VudFNlcnZlciA9IF90aGlzO1xuICAgICAgICBfdGhpcy5kaWFsb2cgPSBkaWFsb2c7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIG9uIGEgMnh4IHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMjAwIH07IH1cbiAgICAgICAgLy8gRklYTUU6IFRoZSBuZXh0IHR3byBsaW5lcyBTSE9VTEQgZ28gYXdheSwgYnV0IEkgc3VwcG9zZSBpdCdzIHRlY2huaWNhbGx5IGhhcm1sZXNzLi4uXG4gICAgICAgIC8vIFRoZXNlIGFyZSBoZXJlIGJlY2F1c2Ugc29tZSB2ZXJzaW9ucyBvZiBTSVAuanMgcHJpb3IgdG8gMC4xMy44IHNldCB0aGUgcm91dGUgc2V0XG4gICAgICAgIC8vIG9mIGFsbCBpbiBkaWFsb2cgQUNLcyBiYXNlZCBvbiB0aGUgUmVjb3JkLVJvdXRlIGhlYWRlcnMgaW4gdGhlIGFzc29jaWF0ZWQgMnh4XG4gICAgICAgIC8vIHJlc3BvbnNlLiBXaGlsZSB0aGlzIHdvcmtlZCBmb3IgZGlhbG9nIGZvcm1pbmcgMnh4IHJlc3BvbnNlcywgaXQgd2FzIHRlY2huaWNhbGx5XG4gICAgICAgIC8vIGJyb2tlbiBmb3IgcmUtSU5WSVRFIEFDS1MgYXMgaXQgb25seSB3b3JrZWQgaWYgdGhlIFVBUyBwb3B1bGF0ZWQgdGhlIFJlY29yZC1Sb3V0ZVxuICAgICAgICAvLyBoZWFkZXJzIGluIHRoZSByZS1JTlZJVEUgMnh4IHJlc3BvbnNlICh3aGljaCBpcyBub3QgcmVxdWlyZWQgYW5kIGEgd2FzdGUgb2YgYmFuZHdpZHRoXG4gICAgICAgIC8vIGFzIHRoZSBzaG91bGQgYmUgaWdub3JlZCBpZiBwcmVzZW50IGluIHJlLUlOVklURSBBQ0tTKSBhbmQgdGhlIFVBUyBwb3B1bGF0ZWRcbiAgICAgICAgLy8gdGhlIFJlY29yZC1Sb3V0ZSBoZWFkZXJzIHdpdGggdGhlIGNvcnJlY3QgdmFsdWVzICh3b3VsZCBiZSB3ZWlyZCBub3QgdG9vLCBidXQuLi4pLlxuICAgICAgICAvLyBBbnl3YXksIGZvciBub3cgdGhlIHRlY2huaWNhbGx5IHVzZWxlc3MgUmVjb3JkLVJvdXRlIGhlYWRlcnMgYXJlIGJlaW5nIGFkZGVkXG4gICAgICAgIC8vIHRvIG1haW50YWluIFwiYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcIiB3aXRoIHRoZSBvbGRlciBicm9rZW4gdmVyc2lvbnMgb2YgU0lQLmpzLlxuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdO1xuICAgICAgICBvcHRpb25zLmV4dHJhSGVhZGVycyA9IG9wdGlvbnMuZXh0cmFIZWFkZXJzLmNvbmNhdCh0aGlzLmRpYWxvZy5yb3V0ZVNldC5tYXAoZnVuY3Rpb24gKHJvdXRlKSB7IHJldHVybiBcIlJlY29yZC1Sb3V0ZTogXCIgKyByb3V0ZTsgfSkpO1xuICAgICAgICAvLyBTZW5kIGFuZCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAgICAgIHZhciByZXNwb25zZSA9IF9zdXBlci5wcm90b3R5cGUuYWNjZXB0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5kaWFsb2c7XG4gICAgICAgIHZhciByZXN1bHQgPSB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIHJlc3BvbnNlKSwgeyBzZXNzaW9uOiBzZXNzaW9uIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgZGlhbG9nIHNpZ25hbGluZyBzdGF0ZSB3aXRoIG9mZmVyL2Fuc3dlciBpbiBib2R5XG4gICAgICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVRyYW5zaXRpb24ob3B0aW9ucy5ib2R5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgZGlhbG9nXG4gICAgICAgIHRoaXMuZGlhbG9nLnJlQ29uZmlybSgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlIG9uIGEgMXh4IHJlc3BvbnNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUHJvZ3Jlc3Mgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfTsgfVxuICAgICAgICAvLyBTZW5kIGFuZCByZXR1cm4gdGhlIHJlc3BvbnNlXG4gICAgICAgIHZhciByZXNwb25zZSA9IF9zdXBlci5wcm90b3R5cGUucHJvZ3Jlc3MuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLmRpYWxvZztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRzbGliXzEuX19hc3NpZ24odHNsaWJfMS5fX2Fzc2lnbih7fSwgcmVzcG9uc2UpLCB7IHNlc3Npb246IHNlc3Npb24gfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBkaWFsb2cgc2lnbmFsaW5nIHN0YXRlXG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLnNpZ25hbGluZ1N0YXRlVHJhbnNpdGlvbihvcHRpb25zLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBOb3QgWWV0IFN1cHBvcnRlZFxuICAgICAqIEBwYXJhbSBjb250YWN0cyAtIENvbnRhY3RzIHRvIHJlZGlyZWN0IHRvLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVkaXJlY3Qgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgUmVJbnZpdGVVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKGNvbnRhY3RzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogMzAyIH07IH1cbiAgICAgICAgdGhpcy5kaWFsb2cuc2lnbmFsaW5nU3RhdGVSb2xsYmFjaygpO1xuICAgICAgICB0aGlzLmRpYWxvZy5yZWludml0ZVVzZXJBZ2VudFNlcnZlciA9IHVuZGVmaW5lZDsgLy8gQUNLIHdpbGwgYmUgaGFuZGxlZCBieSB0cmFuc2FjdGlvblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmltcGxlbWVudGVkLlwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIDMuMSBCYWNrZ3JvdW5kIG9uIFJlLUlOVklURSBIYW5kbGluZyBieSBVQVNzXG4gICAgICogQW4gZXJyb3IgcmVzcG9uc2UgdG8gYSByZS1JTlZJVEUgaGFzIHRoZSBmb2xsb3dpbmcgc2VtYW50aWNzLiAgQXNcbiAgICAgKiBzcGVjaWZpZWQgaW4gU2VjdGlvbiAxMi4yLjIgb2YgUkZDIDMyNjEgW1JGQzMyNjFdLCBpZiBhIHJlLUlOVklURSBpc1xuICAgICAqIHJlamVjdGVkLCBubyBzdGF0ZSBjaGFuZ2VzIGFyZSBwZXJmb3JtZWQuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYxNDEjc2VjdGlvbi0zLjFcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlamVjdCBvcHRpb25zIGJ1Y2tldC5cbiAgICAgKi9cbiAgICBSZUludml0ZVVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiA0ODggfTsgfVxuICAgICAgICB0aGlzLmRpYWxvZy5zaWduYWxpbmdTdGF0ZVJvbGxiYWNrKCk7XG4gICAgICAgIHRoaXMuZGlhbG9nLnJlaW52aXRlVXNlckFnZW50U2VydmVyID0gdW5kZWZpbmVkOyAvLyBBQ0sgd2lsbCBiZSBoYW5kbGVkIGJ5IHRyYW5zYWN0aW9uXG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlamVjdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlSW52aXRlVXNlckFnZW50U2VydmVyO1xufSh1c2VyX2FnZW50X3NlcnZlcl8xLlVzZXJBZ2VudFNlcnZlcikpO1xuZXhwb3J0cy5SZUludml0ZVVzZXJBZ2VudFNlcnZlciA9IFJlSW52aXRlVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIFJlLVNVQlNDUklCRSBVQUMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZVN1YnNjcmliZVVzZXJBZ2VudENsaWVudChkaWFsb2csIGRlbGVnYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtZXNzYWdlID0gZGlhbG9nLmNyZWF0ZU91dGdvaW5nUmVxdWVzdE1lc3NhZ2UobWVzc2FnZXNfMS5DLlNVQlNDUklCRSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGlhbG9nID0gZGlhbG9nO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS53YWl0Tm90aWZ5U3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVE9ETzogUGxhY2Vob2xkZXIuIE5vdCB1dGlsaXplZCBjdXJyZW50bHkuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgYSByZXNwb25zZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgJiYgbWVzc2FnZS5zdGF0dXNDb2RlID49IDIwMCAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgICAgIC8vICBUaGUgXCJFeHBpcmVzXCIgaGVhZGVyIGZpZWxkIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRVxuICAgICAgICAgICAgLy8gIHJlcXVlc3QgaW5kaWNhdGVzIHRoZSBhY3R1YWwgZHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzdWJzY3JpcHRpb24gd2lsbFxuICAgICAgICAgICAgLy8gIHJlbWFpbiBhY3RpdmUgKHVubGVzcyByZWZyZXNoZWQpLiAgVGhlIHJlY2VpdmVkIHZhbHVlIG1pZ2h0IGJlXG4gICAgICAgICAgICAvLyAgc21hbGxlciB0aGFuIHRoZSB2YWx1ZSBpbmRpY2F0ZWQgaW4gdGhlIFNVQlNDUklCRSByZXF1ZXN0IGJ1dCBjYW5ub3RcbiAgICAgICAgICAgIC8vICBiZSBsYXJnZXI7IHNlZSBTZWN0aW9uIDQuMi4xIGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgICAgICB2YXIgZXhwaXJlcyA9IG1lc3NhZ2UuZ2V0SGVhZGVyKFwiRXhwaXJlc1wiKTtcbiAgICAgICAgICAgIGlmICghZXhwaXJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFeHBpcmVzIGhlYWRlciBtaXNzaW5nIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQgPSBOdW1iZXIoZXhwaXJlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlhbG9nLnN1YnNjcmlwdGlvbkV4cGlyZXMgPiBzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cuc3Vic2NyaXB0aW9uRXhwaXJlcyA9IHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzQ29kZSAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPj0gNDAwICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA8IDcwMCkge1xuICAgICAgICAgICAgLy8gSWYgYSBTVUJTQ1JJQkUgcmVxdWVzdCB0byByZWZyZXNoIGEgc3Vic2NyaXB0aW9uIHJlY2VpdmVzIGEgNDA0LCA0MDUsXG4gICAgICAgICAgICAvLyA0MTAsIDQxNiwgNDgwLTQ4NSwgNDg5LCA1MDEsIG9yIDYwNCByZXNwb25zZSwgdGhlIHN1YnNjcmliZXIgTVVTVFxuICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIHN1YnNjcmlwdGlvbiB0ZXJtaW5hdGVkLiAgKFNlZSBbUkZDNTA1N10gZm9yIGZ1cnRoZXJcbiAgICAgICAgICAgIC8vIGRldGFpbHMgYW5kIG5vdGVzIGFib3V0IHRoZSBlZmZlY3Qgb2YgZXJyb3IgY29kZXMgb24gZGlhbG9ncyBhbmRcbiAgICAgICAgICAgIC8vIHVzYWdlcyB3aXRoaW4gZGlhbG9nLCBzdWNoIGFzIHN1YnNjcmlwdGlvbnMpLiAgSWYgdGhlIHN1YnNjcmliZXJcbiAgICAgICAgICAgIC8vIHdpc2hlcyB0byByZS1zdWJzY3JpYmUgdG8gdGhlIHN0YXRlLCBoZSBkb2VzIHNvIGJ5IGNvbXBvc2luZyBhblxuICAgICAgICAgICAgLy8gdW5yZWxhdGVkIGluaXRpYWwgU1VCU0NSSUJFIHJlcXVlc3Qgd2l0aCBhIGZyZXNobHkgZ2VuZXJhdGVkIENhbGwtSURcbiAgICAgICAgICAgIC8vIGFuZCBhIG5ldywgdW5pcXVlIFwiRnJvbVwiIHRhZyAoc2VlIFNlY3Rpb24gNC4xLjIuMSkuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjJcbiAgICAgICAgICAgIHZhciBlcnJvckNvZGVzID0gWzQwNCwgNDA1LCA0MTAsIDQxNiwgNDgwLCA0ODEsIDQ4MiwgNDgzLCA0ODQsIDQ4NSwgNDg5LCA1MDEsIDYwNF07XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2Rlcy5pbmRleE9mKG1lc3NhZ2Uuc3RhdHVzQ29kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFsb2cudGVybWluYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhIFNVQlNDUklCRSByZXF1ZXN0IHRvIHJlZnJlc2ggYSBzdWJzY3JpcHRpb24gZmFpbHMgd2l0aCBhbnkgZXJyb3JcbiAgICAgICAgICAgIC8vIGNvZGUgb3RoZXIgdGhhbiB0aG9zZSBsaXN0ZWQgYWJvdmUsIHRoZSBvcmlnaW5hbCBzdWJzY3JpcHRpb24gaXNcbiAgICAgICAgICAgIC8vIHN0aWxsIGNvbnNpZGVyZWQgdmFsaWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgbW9zdCByZWNlbnRseSBrbm93blxuICAgICAgICAgICAgLy8gXCJFeHBpcmVzXCIgdmFsdWUgYXMgbmVnb3RpYXRlZCBieSB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBTVUJTQ1JJQkVcbiAgICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLCBvciBhcyBjb21tdW5pY2F0ZWQgYnkgYSBOT1RJRlkgcmVxdWVzdCBpbiBpdHNcbiAgICAgICAgICAgIC8vIFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIgaGVhZGVyIGZpZWxkIFwiZXhwaXJlc1wiIHBhcmFtZXRlci5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjIuMlxuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUucmVjZWl2ZVJlc3BvbnNlLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlJlU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50ID0gUmVTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIFJlLVNVQlNDUklCRSBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZVN1YnNjcmliZVVzZXJBZ2VudFNlcnZlcihkaWFsb2csIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgZGlhbG9nLnVzZXJBZ2VudENvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLlJlU3Vic2NyaWJlVXNlckFnZW50U2VydmVyID0gUmVTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIG1lc3NhZ2VzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogUkVGRVIgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgUmVmZXJVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVmZXJVc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmZXJVc2VyQWdlbnRDbGllbnQoZGlhbG9nLCBkZWxlZ2F0ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGRpYWxvZy5jcmVhdGVPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5SRUZFUiwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGRpYWxvZy51c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVmZXJVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlJlZmVyVXNlckFnZW50Q2xpZW50ID0gUmVmZXJVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X3NlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1zZXJ2ZXJcIik7XG4vKipcbiAqIFJFRkVSIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlZmVyVXNlckFnZW50U2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlZmVyVXNlckFnZW50U2VydmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIFJFRkVSIFVBUyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gZGlhbG9nT3JDb3JlIC0gRGlhbG9nIGZvciBpbiBkaWFsb2cgUkVGRVIsIFVzZXJBZ2VudENvcmUgZm9yIG91dCBvZiBkaWFsb2cgUkVGRVIuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBJbmNvbWluZyBSRUZFUiByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJVc2VyQWdlbnRTZXJ2ZXIoZGlhbG9nT3JDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXNlckFnZW50Q29yZSA9IGluc3RhbmNlT2ZTZXNzaW9uRGlhbG9nKGRpYWxvZ09yQ29yZSkgP1xuICAgICAgICAgICAgZGlhbG9nT3JDb3JlLnVzZXJBZ2VudENvcmUgOlxuICAgICAgICAgICAgZGlhbG9nT3JDb3JlO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCB1c2VyQWdlbnRDb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVmZXJVc2VyQWdlbnRTZXJ2ZXI7XG59KHVzZXJfYWdlbnRfc2VydmVyXzEuVXNlckFnZW50U2VydmVyKSk7XG5leHBvcnRzLlJlZmVyVXNlckFnZW50U2VydmVyID0gUmVmZXJVc2VyQWdlbnRTZXJ2ZXI7XG5mdW5jdGlvbiBpbnN0YW5jZU9mU2Vzc2lvbkRpYWxvZyhvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0LnVzZXJBZ2VudENvcmUgIT09IHVuZGVmaW5lZDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfY2xpZW50XzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LWNsaWVudFwiKTtcbi8qKlxuICogUkVHSVNURVIgVUFDLlxuICogQHB1YmxpY1xuICovXG52YXIgUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVnaXN0ZXJVc2VyQWdlbnRDbGllbnQoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJlZ2lzdGVyVXNlckFnZW50Q2xpZW50O1xufSh1c2VyX2FnZW50X2NsaWVudF8xLlVzZXJBZ2VudENsaWVudCkpO1xuZXhwb3J0cy5SZWdpc3RlclVzZXJBZ2VudENsaWVudCA9IFJlZ2lzdGVyVXNlckFnZW50Q2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG52YXIgdXNlcl9hZ2VudF9zZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXItYWdlbnQtc2VydmVyXCIpO1xuLyoqXG4gKiBSRUdJU1RFUiBVQVMuXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWdpc3RlclVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWdpc3RlclVzZXJBZ2VudFNlcnZlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWdpc3RlclVzZXJBZ2VudFNlcnZlcihjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbiwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWdpc3RlclVzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuUmVnaXN0ZXJVc2VyQWdlbnRTZXJ2ZXIgPSBSZWdpc3RlclVzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgc3Vic2NyaXB0aW9uX2RpYWxvZ18xID0gcmVxdWlyZShcIi4uL2RpYWxvZ3Mvc3Vic2NyaXB0aW9uLWRpYWxvZ1wiKTtcbnZhciBzdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9zdWJzY3JpcHRpb25cIik7XG52YXIgdGltZXJzXzEgPSByZXF1aXJlKFwiLi4vdGltZXJzXCIpO1xudmFyIHRyYW5zYWN0aW9uc18xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uc1wiKTtcbnZhciB1c2VyX2FnZW50X2NsaWVudF8xID0gcmVxdWlyZShcIi4vdXNlci1hZ2VudC1jbGllbnRcIik7XG4vKipcbiAqIFNVQlNDUklCRSBVQUMuXG4gKiBAcmVtYXJrc1xuICogNC4xLiAgU3Vic2NyaWJlciBCZWhhdmlvclxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjFcbiAqXG4gKiBVc2VyIGFnZW50IGNsaWVudCBmb3IgaW5zdGFsbGF0aW9uIG9mIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiBwZXIgU1VCU0NSSUJFIHJlcXVlc3QuXG4gKiBUT0RPOiBTdXBwb3J0IGZvciBpbnN0YWxsYXRpb24gb2YgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyBvbiBmb3JrZWQgU1VCU0NSSUJFIHJlcXVlc3RzLlxuICogQHB1YmxpY1xuICovXG52YXIgU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN1YnNjcmliZVVzZXJBZ2VudENsaWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQoY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gR2V0IGV2ZW50IGZyb20gcmVxdWVzdCBtZXNzYWdlLlxuICAgICAgICB2YXIgZXZlbnQgPSBtZXNzYWdlLmdldEhlYWRlcihcIkV2ZW50XCIpO1xuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGV4cGlyZXMgZnJvbSByZXF1ZXN0IG1lc3NhZ2UuXG4gICAgICAgIHZhciBleHBpcmVzID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJFeHBpcmVzXCIpO1xuICAgICAgICBpZiAoIWV4cGlyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGlyZXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICAvLyBGSVhNRTogU3Vic2NyaWJlciBpZCBzaG91bGQgYWxzbyBiZSBtYXRjaGluZyBvbiBldmVudCBpZC5cbiAgICAgICAgX3RoaXMuc3Vic2NyaWJlcklkID0gbWVzc2FnZS5jYWxsSWQgKyBtZXNzYWdlLmZyb21UYWcgKyBldmVudDtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uRXhwaXJlc1JlcXVlc3RlZCA9IF90aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPSBOdW1iZXIoZXhwaXJlcyk7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbkV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuTm90aWZ5V2FpdDtcbiAgICAgICAgLy8gU3RhcnQgd2FpdGluZyBmb3IgYSBOT1RJRlkgd2UgY2FuIHVzZSB0byBjcmVhdGUgYSBzdWJzY3JpcHRpb24uXG4gICAgICAgIF90aGlzLndhaXROb3RpZnlTdGFydCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3RydWN0b3IuXG4gICAgICogTm90ZSB0aGF0IFRpbWVyIE4gbWF5IGxpdmUgb24gd2FpdGluZyBmb3IgYW4gaW5pdGlhbCBOT1RJRlkgYW5kXG4gICAgICogdGhlIGRlbGVnYXRlIG1heSBzdGlsbCByZWNlaXZlIHRoYXQgTk9USUZZLiBJZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRoYXQgYmVoYXZpb3IgdGhlbiBlaXRoZXIgY2xlYXIgdGhlIGRlbGVnYXRlIHNvIHRoZSBkZWxlZ2F0ZVxuICAgICAqIGRvZXNuJ3QgZ2V0IGNhbGxlZCAoYSAyMDAgd2lsbCBiZSBzZW50IGluIHJlc3BvbnNlIHRvIHRoZSBOT1RJRlkpXG4gICAgICogb3IgY2FsbCBgd2FpdE5vdGlmeVN0b3BgIHdoaWNoIHdpbGwgY2xlYXIgVGltZXIgTiBhbmQgcmVtb3ZlIHRoaXNcbiAgICAgKiBVQUMgZnJvbSB0aGUgY29yZSAoYSA0ODEgd2lsbCBiZSBzZW50IGluIHJlc3BvbnNlIHRvIHRoZSBOT1RJRlkpLlxuICAgICAqL1xuICAgIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgb3V0IG9mIGRpYWxvZyBOT1RJRlkgYXNzb2NpYXRlZCB3aXRoIFNVQlNDUklCRSByZXF1ZXN0LlxuICAgICAqIFRoaXMgaXMgdGhlIGZpcnN0IE5PVElGWSByZWNlaXZlZCBhZnRlciB0aGUgU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHVhcyAtIFVzZXIgYWdlbnQgc2VydmVyIGhhbmRsaW5nIHRoZSBzdWJzY3JpcHRpb24gY3JlYXRpbmcgTk9USUZZLlxuICAgICAqL1xuICAgIFN1YnNjcmliZVVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUub25Ob3RpZnkgPSBmdW5jdGlvbiAodWFzKSB7XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBhcmUgbWF0Y2hlZCB0byBzdWNoIFNVQlNDUklCRSByZXF1ZXN0cyBpZiB0aGV5XG4gICAgICAgIC8vIGNvbnRhaW4gdGhlIHNhbWUgXCJDYWxsLUlEXCIsIGEgXCJUb1wiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciB0aGF0XG4gICAgICAgIC8vIG1hdGNoZXMgdGhlIFwiRnJvbVwiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciBvZiB0aGUgU1VCU0NSSUJFXG4gICAgICAgIC8vIHJlcXVlc3QsIGFuZCB0aGUgc2FtZSBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkLiAgUnVsZXMgZm9yIGNvbXBhcmlzb25zIG9mXG4gICAgICAgIC8vIHRoZSBcIkV2ZW50XCIgaGVhZGVyIGZpZWxkcyBhcmUgZGVzY3JpYmVkIGluIFNlY3Rpb24gOC4yLjEuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC40LjFcbiAgICAgICAgdmFyIGV2ZW50ID0gdWFzLm1lc3NhZ2UucGFyc2VIZWFkZXIoXCJFdmVudFwiKS5ldmVudDtcbiAgICAgICAgaWYgKCFldmVudCB8fCBldmVudCAhPT0gdGhpcy5zdWJzY3JpcHRpb25FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkZhaWxlZCB0byBwYXJzZSBldmVudC5cIik7XG4gICAgICAgICAgICB1YXMucmVqZWN0KHsgc3RhdHVzQ29kZTogNDg5IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVElGWSByZXF1ZXN0cyBNVVNUIGNvbnRhaW4gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBoZWFkZXIgZmllbGRzIHRoYXRcbiAgICAgICAgLy8gaW5kaWNhdGUgdGhlIHN0YXR1cyBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4zXG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25TdGF0ZSA9IHVhcy5tZXNzYWdlLnBhcnNlSGVhZGVyKFwiU3Vic2NyaXB0aW9uLVN0YXRlXCIpO1xuICAgICAgICBpZiAoIXN1YnNjcmlwdGlvblN0YXRlIHx8ICFzdWJzY3JpcHRpb25TdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkZhaWxlZCB0byBwYXJzZSBzdWJzY3JpcHRpb24gc3RhdGUuXCIpO1xuICAgICAgICAgICAgdWFzLnJlamVjdCh7IHN0YXR1c0NvZGU6IDQ4OSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBzdWJzY3JpcHRpb24gc3RhdGUuXG4gICAgICAgIHZhciBzdGF0ZSA9IHN1YnNjcmlwdGlvblN0YXRlLnN0YXRlO1xuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFjdGl2ZVwiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkludmFsaWQgc3Vic2NyaXB0aW9uIHN0YXRlIFwiICsgc3RhdGUpO1xuICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpYWxvZ3MgdXNhZ2VzIGFyZSBjcmVhdGVkIHVwb24gY29tcGxldGlvbiBvZiBhIE5PVElGWSB0cmFuc2FjdGlvblxuICAgICAgICAvLyBmb3IgYSBuZXcgc3Vic2NyaXB0aW9uLCB1bmxlc3MgdGhlIE5PVElGWSByZXF1ZXN0IGNvbnRhaW5zIGFcbiAgICAgICAgLy8gXCJTdWJzY3JpcHRpb24tU3RhdGVcIiBvZiBcInRlcm1pbmF0ZWQuXCJcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjQuMVxuICAgICAgICBpZiAoc3RhdGUgIT09IFwidGVybWluYXRlZFwiKSB7XG4gICAgICAgICAgICAvLyBUaGUgQ29udGFjdCBoZWFkZXIgZmllbGQgTVVTVCBiZSBwcmVzZW50IGFuZCBjb250YWluIGV4YWN0bHkgb25lIFNJUFxuICAgICAgICAgICAgLy8gb3IgU0lQUyBVUkkgaW4gYW55IHJlcXVlc3QgdGhhdCBjYW4gcmVzdWx0IGluIHRoZSBlc3RhYmxpc2htZW50IG9mIGFcbiAgICAgICAgICAgIC8vIGRpYWxvZy5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjEuOFxuICAgICAgICAgICAgdmFyIGNvbnRhY3QgPSB1YXMubWVzc2FnZS5wYXJzZUhlYWRlcihcImNvbnRhY3RcIik7XG4gICAgICAgICAgICBpZiAoIWNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiRmFpbGVkIHRvIHBhcnNlIGNvbnRhY3QuXCIpO1xuICAgICAgICAgICAgICAgIHVhcy5yZWplY3QoeyBzdGF0dXNDb2RlOiA0ODkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluIGFjY29yZGFuY2Ugd2l0aCB0aGUgcnVsZXMgZm9yIHByb3h5aW5nIG5vbi1JTlZJVEUgcmVxdWVzdHMgYXNcbiAgICAgICAgLy8gZGVmaW5lZCBpbiBbUkZDMzI2MV0sIHN1Y2Nlc3NmdWwgU1VCU0NSSUJFIHJlcXVlc3RzIHdpbGwgcmVjZWl2ZSBvbmx5XG4gICAgICAgIC8vIG9uZSAyMDAtY2xhc3MgcmVzcG9uc2U7IGhvd2V2ZXIsIGR1ZSB0byBmb3JraW5nLCB0aGUgc3Vic2NyaXB0aW9uIG1heVxuICAgICAgICAvLyBoYXZlIGJlZW4gYWNjZXB0ZWQgYnkgbXVsdGlwbGUgbm9kZXMuICBUaGUgc3Vic2NyaWJlciBNVVNUIHRoZXJlZm9yZVxuICAgICAgICAvLyBiZSBwcmVwYXJlZCB0byByZWNlaXZlIE5PVElGWSByZXF1ZXN0cyB3aXRoIFwiRnJvbTpcIiB0YWdzIHRoYXQgZGlmZmVyXG4gICAgICAgIC8vIGZyb20gdGhlIFwiVG86XCIgdGFnIHJlY2VpdmVkIGluIHRoZSBTVUJTQ1JJQkUgMjAwLWNsYXNzIHJlc3BvbnNlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBtdWx0aXBsZSBOT1RJRlkgcmVxdWVzdHMgYXJlIHJlY2VpdmVkIGluIGRpZmZlcmVudCBkaWFsb2dzIGluXG4gICAgICAgIC8vIHJlc3BvbnNlIHRvIGEgc2luZ2xlIFNVQlNDUklCRSByZXF1ZXN0LCBlYWNoIGRpYWxvZyByZXByZXNlbnRzIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IGRlc3RpbmF0aW9uIHRvIHdoaWNoIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdCB3YXMgZm9ya2VkLlxuICAgICAgICAvLyBTdWJzY3JpYmVyIGhhbmRsaW5nIGluIHN1Y2ggc2l0dWF0aW9ucyB2YXJpZXMgYnkgZXZlbnQgcGFja2FnZTsgc2VlXG4gICAgICAgIC8vIFNlY3Rpb24gNS40LjkgZm9yIGRldGFpbHMuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NjY1I3NlY3Rpb24tNC4xLjRcbiAgICAgICAgLy8gRWFjaCBldmVudCBwYWNrYWdlIE1VU1Qgc3BlY2lmeSB3aGV0aGVyIGZvcmtlZCBTVUJTQ1JJQkUgcmVxdWVzdHMgYXJlXG4gICAgICAgIC8vIGFsbG93ZWQgdG8gaW5zdGFsbCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBzdWNoIGJlaGF2aW9yIGlzIG5vdCBhbGxvd2VkLCB0aGUgZmlyc3QgcG90ZW50aWFsIGRpYWxvZy1cbiAgICAgICAgLy8gZXN0YWJsaXNoaW5nIG1lc3NhZ2Ugd2lsbCBjcmVhdGUgYSBkaWFsb2cuICBBbGwgc3Vic2VxdWVudCBOT1RJRllcbiAgICAgICAgLy8gcmVxdWVzdHMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBTVUJTQ1JJQkUgcmVxdWVzdCAoaS5lLiwgaGF2ZVxuICAgICAgICAvLyBtYXRjaGluZyBcIlRvXCIsIFwiRnJvbVwiLCBcIkNhbGwtSURcIiwgYW5kIFwiRXZlbnRcIiBoZWFkZXIgZmllbGRzLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIFwiRnJvbVwiIGhlYWRlciBmaWVsZCBcInRhZ1wiIHBhcmFtZXRlciBhbmQgXCJFdmVudFwiIGhlYWRlciBmaWVsZCBcImlkXCJcbiAgICAgICAgLy8gcGFyYW1ldGVyKSBidXQgdGhhdCBkbyBub3QgbWF0Y2ggdGhlIGRpYWxvZyB3b3VsZCBiZSByZWplY3RlZCB3aXRoIGFcbiAgICAgICAgLy8gNDgxIHJlc3BvbnNlLiAgTm90ZSB0aGF0IHRoZSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gdGhlIFNVQlNDUklCRVxuICAgICAgICAvLyByZXF1ZXN0IGNhbiBhcnJpdmUgYWZ0ZXIgYSBtYXRjaGluZyBOT1RJRlkgcmVxdWVzdCBoYXMgYmVlbiByZWNlaXZlZDtcbiAgICAgICAgLy8gc3VjaCByZXNwb25zZXMgbWlnaHQgbm90IGNvcnJlbGF0ZSB0byB0aGUgc2FtZSBkaWFsb2cgZXN0YWJsaXNoZWQgYnlcbiAgICAgICAgLy8gdGhlIE5PVElGWSByZXF1ZXN0LiAgRXhjZXB0IGFzIHJlcXVpcmVkIHRvIGNvbXBsZXRlIHRoZSBTVUJTQ1JJQkVcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24sIHN1Y2ggbm9uLW1hdGNoaW5nIDIwMC1jbGFzcyByZXNwb25zZXMgYXJlIGlnbm9yZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIGluc3RhbGxpbmcgb2YgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyBieSB3YXkgb2YgYSBzaW5nbGUgZm9ya2VkXG4gICAgICAgIC8vIFNVQlNDUklCRSByZXF1ZXN0IGlzIGFsbG93ZWQsIHRoZSBzdWJzY3JpYmVyIGVzdGFibGlzaGVzIGEgbmV3IGRpYWxvZ1xuICAgICAgICAvLyB0b3dhcmRzIGVhY2ggbm90aWZpZXIgYnkgcmV0dXJuaW5nIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIGVhY2hcbiAgICAgICAgLy8gTk9USUZZIHJlcXVlc3QuICBFYWNoIGRpYWxvZyBpcyB0aGVuIGhhbmRsZWQgYXMgaXRzIG93biBlbnRpdHkgYW5kIGlzXG4gICAgICAgIC8vIHJlZnJlc2hlZCBpbmRlcGVuZGVudGx5IG9mIHRoZSBvdGhlciBkaWFsb2dzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgYXJlIGFsbG93ZWQsIHRoZSBldmVudFxuICAgICAgICAvLyBwYWNrYWdlIE1VU1Qgc3BlY2lmeSB3aGV0aGVyIG1lcmdpbmcgb2YgdGhlIG5vdGlmaWNhdGlvbnMgdG8gZm9ybSBhXG4gICAgICAgIC8vIHNpbmdsZSBzdGF0ZSBpcyByZXF1aXJlZCwgYW5kIGhvdyBzdWNoIG1lcmdpbmcgaXMgdG8gYmUgcGVyZm9ybWVkLlxuICAgICAgICAvLyBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhhdCBzb21lIGV2ZW50IHBhY2thZ2VzIG1heSBiZSBkZWZpbmVkIGluXG4gICAgICAgIC8vIHN1Y2ggYSB3YXkgdGhhdCBlYWNoIGRpYWxvZyBpcyB0aWVkIHRvIGEgbXV0dWFsbHkgZXhjbHVzaXZlIHN0YXRlXG4gICAgICAgIC8vIHRoYXQgaXMgdW5hZmZlY3RlZCBieSB0aGUgb3RoZXIgZGlhbG9nczsgdGhpcyBNVVNUIGJlIGNsZWFybHkgc3RhdGVkXG4gICAgICAgIC8vIGlmIGl0IGlzIHRoZSBjYXNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTUuNC45XG4gICAgICAgIC8vICoqKiBOT1RFOiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIG9ubHkgZm9yIGV2ZW50IHBhY2thZ2VzIHdoaWNoXG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBmb3JrZWQgcmVxdWVzdHMgdG8gaW5zdGFsbCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAvLyBBcyBzdWNoIGFuZCBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIHNwZWNpZmljYXRpb24sIHdlIHN0b3Agd2FpdGluZ1xuICAgICAgICAvLyBhbmQgYW55IGZ1dHVyZSBOT1RJRlkgcmVxdWVzdHMgd2lsbCBiZSByZWplY3RlZCB3aXRoIGEgNDgxLlxuICAgICAgICBpZiAodGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpYWxvZyBhbHJlYWR5IGNyZWF0ZWQuIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBpbnN0YWxsIG9mIHNpbmdsZSBzdWJzY3JpcHRpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXROb3RpZnlTdG9wKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBleHBpcmVzLlxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMgPVxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uU3RhdGUuZXhwaXJlcyA/XG4gICAgICAgICAgICAgICAgTWF0aC5taW4odGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzLCBNYXRoLm1heChzdWJzY3JpcHRpb25TdGF0ZS5leHBpcmVzLCAwKSkgOlxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcztcbiAgICAgICAgLy8gVXBkYXRlIHN1YnNjcmlwdGlvbiBzdGF0ZS5cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuUGVuZGluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhY3RpdmVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuQWN0aXZlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInRlcm1pbmF0ZWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblN0YXRlID0gc3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uU3RhdGUuVGVybWluYXRlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIHN0YXRlIFwiICsgc3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGlhbG9ncyB1c2FnZXMgYXJlIGNyZWF0ZWQgdXBvbiBjb21wbGV0aW9uIG9mIGEgTk9USUZZIHRyYW5zYWN0aW9uXG4gICAgICAgIC8vIGZvciBhIG5ldyBzdWJzY3JpcHRpb24sIHVubGVzcyB0aGUgTk9USUZZIHJlcXVlc3QgY29udGFpbnMgYVxuICAgICAgICAvLyBcIlN1YnNjcmlwdGlvbi1TdGF0ZVwiIG9mIFwidGVybWluYXRlZC5cIlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvblN0YXRlICE9PSBzdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBkaWFsb2cgdXNhZ2UgaXMgZXN0YWJsaXNoZWQgYnkgdGhlIE5PVElGWSByZXF1ZXN0LCB0aGVcbiAgICAgICAgICAgIC8vIHJvdXRlIHNldCBhdCB0aGUgc3Vic2NyaWJlciBpcyB0YWtlbiBmcm9tIHRoZSBOT1RJRlkgcmVxdWVzdCBpdHNlbGYsXG4gICAgICAgICAgICAvLyBhcyBvcHBvc2VkIHRvIHRoZSByb3V0ZSBzZXQgcHJlc2VudCBpbiB0aGUgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIHRoZVxuICAgICAgICAgICAgLy8gU1VCU0NSSUJFIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuNC4xXG4gICAgICAgICAgICB2YXIgZGlhbG9nU3RhdGUgPSBzdWJzY3JpcHRpb25fZGlhbG9nXzEuU3Vic2NyaXB0aW9uRGlhbG9nLmluaXRpYWxEaWFsb2dTdGF0ZUZvclN1YnNjcmlwdGlvbih0aGlzLm1lc3NhZ2UsIHVhcy5tZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbiBJbml0aWF0ZWQhIDopXG4gICAgICAgICAgICB0aGlzLmRpYWxvZyA9IG5ldyBzdWJzY3JpcHRpb25fZGlhbG9nXzEuU3Vic2NyaXB0aW9uRGlhbG9nKHRoaXMuc3Vic2NyaXB0aW9uRXZlbnQsIHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcywgdGhpcy5zdWJzY3JpcHRpb25TdGF0ZSwgdGhpcy5jb3JlLCBkaWFsb2dTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZWdhdGUuXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Ob3RpZnkpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdWFzO1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRoaXMuZGlhbG9nO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeSh7IHJlcXVlc3Q6IHJlcXVlc3QsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdWFzLmFjY2VwdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLndhaXROb3RpZnlTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLk4pIHtcbiAgICAgICAgICAgIC8vIEFkZCBvdXJzZWx2ZXMgdG8gdGhlIGNvcmUncyBzdWJzY3JpYmVyIG1hcC5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBjb3JlIHRvIHJvdXRlIG91dCBvZiBkaWFsb2cgTk9USUZZIG1lc3NhZ2VzIHRvIHVzLlxuICAgICAgICAgICAgdGhpcy5jb3JlLnN1YnNjcmliZXJzLnNldCh0aGlzLnN1YnNjcmliZXJJZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLk4gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRpbWVyX04oKTsgfSwgdGltZXJzXzEuVGltZXJzLlRJTUVSX04pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLndhaXROb3RpZnlTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5OKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgb3Vyc2VsdmVzIHRvIHRoZSBjb3JlJ3Mgc3Vic2NyaWJlciBtYXAuXG4gICAgICAgICAgICAvLyBBbnkgZnV0dXJlIG91dCBvZiBkaWFsb2cgTk9USUZZIG1lc3NhZ2VzIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhIDQ4MS5cbiAgICAgICAgICAgIHRoaXMuY29yZS5zdWJzY3JpYmVycy5kZWxldGUodGhpcy5zdWJzY3JpYmVySWQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuTik7XG4gICAgICAgICAgICB0aGlzLk4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgYSByZXNwb25zZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU3Vic2NyaWJlVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXV0aGVudGljYXRpb25HdWFyZChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgJiYgbWVzc2FnZS5zdGF0dXNDb2RlID49IDIwMCAmJiBtZXNzYWdlLnN0YXR1c0NvZGUgPCAzMDApIHtcbiAgICAgICAgICAgIC8vICBUaGUgXCJFeHBpcmVzXCIgaGVhZGVyIGZpZWxkIGluIGEgMjAwLWNsYXNzIHJlc3BvbnNlIHRvIFNVQlNDUklCRVxuICAgICAgICAgICAgLy8gIHJlcXVlc3QgaW5kaWNhdGVzIHRoZSBhY3R1YWwgZHVyYXRpb24gZm9yIHdoaWNoIHRoZSBzdWJzY3JpcHRpb24gd2lsbFxuICAgICAgICAgICAgLy8gIHJlbWFpbiBhY3RpdmUgKHVubGVzcyByZWZyZXNoZWQpLiAgVGhlIHJlY2VpdmVkIHZhbHVlIG1pZ2h0IGJlXG4gICAgICAgICAgICAvLyAgc21hbGxlciB0aGFuIHRoZSB2YWx1ZSBpbmRpY2F0ZWQgaW4gdGhlIFNVQlNDUklCRSByZXF1ZXN0IGJ1dCBjYW5ub3RcbiAgICAgICAgICAgIC8vICBiZSBsYXJnZXI7IHNlZSBTZWN0aW9uIDQuMi4xIGZvciBkZXRhaWxzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY2NjUjc2VjdGlvbi00LjEuMi4xXG4gICAgICAgICAgICAvLyBUaGUgXCJFeHBpcmVzXCIgdmFsdWVzIHByZXNlbnQgaW4gU1VCU0NSSUJFIDIwMC1jbGFzcyByZXNwb25zZXMgYmVoYXZlXG4gICAgICAgICAgICAvLyBpbiB0aGUgc2FtZSB3YXkgYXMgdGhleSBkbyBpbiBSRUdJU1RFUiByZXNwb25zZXM6IHRoZSBzZXJ2ZXIgTUFZXG4gICAgICAgICAgICAvLyBzaG9ydGVuIHRoZSBpbnRlcnZhbCBidXQgTVVTVCBOT1QgbGVuZ3RoZW4gaXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICAgSWYgdGhlIGR1cmF0aW9uIHNwZWNpZmllZCBpbiBhIFNVQlNDUklCRSByZXF1ZXN0IGlzIHVuYWNjZXB0YWJseVxuICAgICAgICAgICAgLy8gICAgc2hvcnQsIHRoZSBub3RpZmllciBtYXkgYmUgYWJsZSB0byBzZW5kIGEgNDIzIHJlc3BvbnNlLCBhc1xuICAgICAgICAgICAgLy8gICAgZGVzY3JpYmVkIGVhcmxpZXIgaW4gdGhpcyBzZWN0aW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDIwMC1jbGFzcyByZXNwb25zZXMgdG8gU1VCU0NSSUJFIHJlcXVlc3RzIHdpbGwgbm90IGdlbmVyYWxseSBjb250YWluXG4gICAgICAgICAgICAvLyBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGJleW9uZCBzdWJzY3JpcHRpb24gZHVyYXRpb247IHRoZWlyIHByaW1hcnlcbiAgICAgICAgICAgIC8vIHB1cnBvc2UgaXMgdG8gc2VydmUgYXMgYSByZWxpYWJpbGl0eSBtZWNoYW5pc20uICBTdGF0ZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBiZSBjb21tdW5pY2F0ZWQgdmlhIGEgc3Vic2VxdWVudCBOT1RJRlkgcmVxdWVzdCBmcm9tIHRoZVxuICAgICAgICAgICAgLy8gbm90aWZpZXIuXG4gICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMi4xLjFcbiAgICAgICAgICAgIHZhciBleHBpcmVzID0gbWVzc2FnZS5nZXRIZWFkZXIoXCJFeHBpcmVzXCIpO1xuICAgICAgICAgICAgaWYgKCFleHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIkV4cGlyZXMgaGVhZGVyIG1pc3NpbmcgaW4gYSAyMDAtY2xhc3MgcmVzcG9uc2UgdG8gU1VCU0NSSUJFXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkV4cGlyZXNSZWNlaXZlZCA9IE51bWJlcihleHBpcmVzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkID4gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJFeHBpcmVzIGhlYWRlciBpbiBhIDIwMC1jbGFzcyByZXNwb25zZSB0byBTVUJTQ1JJQkUgd2l0aCBhIGhpZ2hlciB2YWx1ZSB0aGFuIHRoZSBvbmUgaW4gdGhlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25FeHBpcmVzUmVjZWl2ZWQgPCB0aGlzLnN1YnNjcmlwdGlvbkV4cGlyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzID0gc3Vic2NyaXB0aW9uRXhwaXJlc1JlY2VpdmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgTk9USUZZIGFycml2ZWQgYmVmb3JlIDIwMC1jbGFzcyByZXNwb25zZSBhIGRpYWxvZyBtYXkgaGF2ZSBiZWVuIGNyZWF0ZWQuXG4gICAgICAgICAgICAvLyBVcGRhdGVkIHRoZSBkaWFsb2dzIGV4cGlyYXRpb24gb25seSBpZiB0aGlzIGluZGljYXRlcyBlYXJsaWVyIGV4cGlyYXRpb24uXG4gICAgICAgICAgICBpZiAodGhpcy5kaWFsb2cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaWFsb2cuc3Vic2NyaXB0aW9uRXhwaXJlcyA+IHRoaXMuc3Vic2NyaXB0aW9uRXhwaXJlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5zdWJzY3JpcHRpb25FeHBpcmVzID0gdGhpcy5zdWJzY3JpcHRpb25FeHBpcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlICYmIG1lc3NhZ2Uuc3RhdHVzQ29kZSA+PSAzMDAgJiYgbWVzc2FnZS5zdGF0dXNDb2RlIDwgNzAwKSB7XG4gICAgICAgICAgICB0aGlzLndhaXROb3RpZnlTdG9wKCk7IC8vIE5vIE5PVElGWSB3aWxsIGJlIHNlbnQgYWZ0ZXIgYSBuZWdhdGl2ZSBmaW5hbCByZXNwb25zZS5cbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlY2VpdmVSZXNwb25zZS5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVG8gZW5zdXJlIHRoYXQgc3Vic2NyaWJlcnMgZG8gbm90IHdhaXQgaW5kZWZpbml0ZWx5IGZvciBhXG4gICAgICogc3Vic2NyaXB0aW9uIHRvIGJlIGVzdGFibGlzaGVkLCBhIHN1YnNjcmliZXIgc3RhcnRzIGEgVGltZXIgTiwgc2V0IHRvXG4gICAgICogNjQqVDEsIHdoZW4gaXQgc2VuZHMgYSBTVUJTQ1JJQkUgcmVxdWVzdC4gIElmIHRoaXMgVGltZXIgTiBleHBpcmVzXG4gICAgICogcHJpb3IgdG8gdGhlIHJlY2VpcHQgb2YgYSBOT1RJRlkgcmVxdWVzdCwgdGhlIHN1YnNjcmliZXIgY29uc2lkZXJzXG4gICAgICogdGhlIHN1YnNjcmlwdGlvbiBmYWlsZWQsIGFuZCBjbGVhbnMgdXAgYW55IHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiBzdWJzY3JpcHRpb24gYXR0ZW1wdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjY2NSNzZWN0aW9uLTQuMS4yLjRcbiAgICAgKi9cbiAgICBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLnRpbWVyX04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJUaW1lciBOIGV4cGlyZWQgZm9yIFNVQlNDUklCRSB1c2VyIGFnZW50IGNsaWVudC4gVGltZWQgb3V0IHdhaXRpbmcgZm9yIE5PVElGWS5cIik7XG4gICAgICAgIHRoaXMud2FpdE5vdGlmeVN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vbk5vdGlmeVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25Ob3RpZnlUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVVc2VyQWdlbnRDbGllbnQ7XG59KHVzZXJfYWdlbnRfY2xpZW50XzEuVXNlckFnZW50Q2xpZW50KSk7XG5leHBvcnRzLlN1YnNjcmliZVVzZXJBZ2VudENsaWVudCA9IFN1YnNjcmliZVVzZXJBZ2VudENsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xudmFyIHVzZXJfYWdlbnRfc2VydmVyXzEgPSByZXF1aXJlKFwiLi91c2VyLWFnZW50LXNlcnZlclwiKTtcbi8qKlxuICogU1VCU0NSSUJFIFVBUy5cbiAqIEBwdWJsaWNcbiAqL1xudmFyIFN1YnNjcmliZVVzZXJBZ2VudFNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJzY3JpYmVVc2VyQWdlbnRTZXJ2ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlVXNlckFnZW50U2VydmVyKGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uLCBjb3JlLCBtZXNzYWdlLCBkZWxlZ2F0ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN1YnNjcmliZVVzZXJBZ2VudFNlcnZlcjtcbn0odXNlcl9hZ2VudF9zZXJ2ZXJfMS5Vc2VyQWdlbnRTZXJ2ZXIpKTtcbmV4cG9ydHMuU3Vic2NyaWJlVXNlckFnZW50U2VydmVyID0gU3Vic2NyaWJlVXNlckFnZW50U2VydmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWVzc2FnZXNfMSA9IHJlcXVpcmUoXCIuLi9tZXNzYWdlc1wiKTtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi90cmFuc2FjdGlvbnNcIik7XG4vKipcbiAqIFVzZXIgQWdlbnQgQ2xpZW50IChVQUMpLlxuICogQHJlbWFya3NcbiAqIEEgdXNlciBhZ2VudCBjbGllbnQgaXMgYSBsb2dpY2FsIGVudGl0eVxuICogdGhhdCBjcmVhdGVzIGEgbmV3IHJlcXVlc3QsIGFuZCB0aGVuIHVzZXMgdGhlIGNsaWVudFxuICogdHJhbnNhY3Rpb24gc3RhdGUgbWFjaGluZXJ5IHRvIHNlbmQgaXQuICBUaGUgcm9sZSBvZiBVQUMgbGFzdHNcbiAqIG9ubHkgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGF0IHRyYW5zYWN0aW9uLiAgSW4gb3RoZXIgd29yZHMsIGlmXG4gKiBhIHBpZWNlIG9mIHNvZnR3YXJlIGluaXRpYXRlcyBhIHJlcXVlc3QsIGl0IGFjdHMgYXMgYSBVQUMgZm9yXG4gKiB0aGUgZHVyYXRpb24gb2YgdGhhdCB0cmFuc2FjdGlvbi4gIElmIGl0IHJlY2VpdmVzIGEgcmVxdWVzdFxuICogbGF0ZXIsIGl0IGFzc3VtZXMgdGhlIHJvbGUgb2YgYSB1c2VyIGFnZW50IHNlcnZlciBmb3IgdGhlXG4gKiBwcm9jZXNzaW5nIG9mIHRoYXQgdHJhbnNhY3Rpb24uXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTZcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFVzZXJBZ2VudENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVc2VyQWdlbnRDbGllbnQodHJhbnNhY3Rpb25Db25zdHJ1Y3RvciwgY29yZSwgbWVzc2FnZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbkNvbnN0cnVjdG9yID0gdHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLmNoYWxsZW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IHRoaXMubG9nZ2VyRmFjdG9yeS5nZXRMb2dnZXIoXCJzaXAudXNlci1hZ2VudC1jbGllbnRcIik7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBVc2VyQWdlbnRDbGllbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24uZGlzcG9zZSgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUsIFwibG9nZ2VyRmFjdG9yeVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29yZS5sb2dnZXJGYWN0b3J5O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZSwgXCJ0cmFuc2FjdGlvblwiLCB7XG4gICAgICAgIC8qKiBUaGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmVxdWVzdC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2luY2UgcmVxdWVzdHMgb3RoZXIgdGhhbiBJTlZJVEUgYXJlIHJlc3BvbmRlZCB0byBpbW1lZGlhdGVseSwgc2VuZGluZyBhXG4gICAgICogQ0FOQ0VMIGZvciBhIG5vbi1JTlZJVEUgcmVxdWVzdCB3b3VsZCBhbHdheXMgY3JlYXRlIGEgcmFjZSBjb25kaXRpb24uXG4gICAgICogQSBDQU5DRUwgcmVxdWVzdCBTSE9VTEQgTk9UIGJlIHNlbnQgdG8gY2FuY2VsIGEgcmVxdWVzdCBvdGhlciB0aGFuIElOVklURS5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ2FuY2VsIG9wdGlvbnMgYnVja2V0LlxuICAgICAqL1xuICAgIFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UudG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1lc3NhZ2UuZnJvbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJvbSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvY2VkdXJlcyBhcmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDQU5DRUwgcmVxdWVzdC4gIFRoZVxuICAgICAgICAvLyBSZXF1ZXN0LVVSSSwgQ2FsbC1JRCwgVG8sIHRoZSBudW1lcmljIHBhcnQgb2YgQ1NlcSwgYW5kIEZyb20gaGVhZGVyXG4gICAgICAgIC8vIGZpZWxkcyBpbiB0aGUgQ0FOQ0VMIHJlcXVlc3QgTVVTVCBiZSBpZGVudGljYWwgdG8gdGhvc2UgaW4gdGhlXG4gICAgICAgIC8vIHJlcXVlc3QgYmVpbmcgY2FuY2VsbGVkLCBpbmNsdWRpbmcgdGFncy4gIEEgQ0FOQ0VMIGNvbnN0cnVjdGVkIGJ5IGFcbiAgICAgICAgLy8gY2xpZW50IE1VU1QgaGF2ZSBvbmx5IGEgc2luZ2xlIFZpYSBoZWFkZXIgZmllbGQgdmFsdWUgbWF0Y2hpbmcgdGhlXG4gICAgICAgIC8vIHRvcCBWaWEgdmFsdWUgaW4gdGhlIHJlcXVlc3QgYmVpbmcgY2FuY2VsbGVkLiAgVXNpbmcgdGhlIHNhbWUgdmFsdWVzXG4gICAgICAgIC8vIGZvciB0aGVzZSBoZWFkZXIgZmllbGRzIGFsbG93cyB0aGUgQ0FOQ0VMIHRvIGJlIG1hdGNoZWQgd2l0aCB0aGVcbiAgICAgICAgLy8gcmVxdWVzdCBpdCBjYW5jZWxzIChTZWN0aW9uIDkuMiBpbmRpY2F0ZXMgaG93IHN1Y2ggbWF0Y2hpbmcgb2NjdXJzKS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIG1ldGhvZCBwYXJ0IG9mIHRoZSBDU2VxIGhlYWRlciBmaWVsZCBNVVNUIGhhdmUgYSB2YWx1ZVxuICAgICAgICAvLyBvZiBDQU5DRUwuICBUaGlzIGFsbG93cyBpdCB0byBiZSBpZGVudGlmaWVkIGFuZCBwcm9jZXNzZWQgYXMgYVxuICAgICAgICAvLyB0cmFuc2FjdGlvbiBpbiBpdHMgb3duIHJpZ2h0IChTZWUgU2VjdGlvbiAxNykuXG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4xXG4gICAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5jb3JlLm1ha2VPdXRnb2luZ1JlcXVlc3RNZXNzYWdlKG1lc3NhZ2VzXzEuQy5DQU5DRUwsIHRoaXMubWVzc2FnZS5ydXJpLCB0aGlzLm1lc3NhZ2UuZnJvbS51cmksIHRoaXMubWVzc2FnZS50by51cmksIHtcbiAgICAgICAgICAgIHRvVGFnOiB0aGlzLm1lc3NhZ2UudG9UYWcsXG4gICAgICAgICAgICBmcm9tVGFnOiB0aGlzLm1lc3NhZ2UuZnJvbVRhZyxcbiAgICAgICAgICAgIGNhbGxJZDogdGhpcy5tZXNzYWdlLmNhbGxJZCxcbiAgICAgICAgICAgIGNzZXE6IHRoaXMubWVzc2FnZS5jc2VxXG4gICAgICAgIH0sIG9wdGlvbnMuZXh0cmFIZWFkZXJzKTtcbiAgICAgICAgLy8gVE9ETzogUmV2aXNpdCB0aGlzLlxuICAgICAgICAvLyBUaGUgQ0FOQ0VMIG5lZWRzIHRvIHVzZSB0aGUgc2FtZSBicmFuY2ggcGFyYW1ldGVyIHNvIHRoYXRcbiAgICAgICAgLy8gaXQgbWF0Y2hlcyB0aGUgSU5WSVRFIHRyYW5zYWN0aW9uLCBidXQgdGhpcyBpcyBhIGhhY2t5IHdheSB0byBkbyB0aGlzLlxuICAgICAgICAvLyBPciBhdCB0aGUgdmVyeSBsZWFzdCBub3Qgd2VsbCBkb2N1bWVudGVkLiBJZiB0aGUgdGhlIGJyYW5jaCBwYXJhbWV0ZXJcbiAgICAgICAgLy8gaXMgc2V0IG9uIHRoZSBvdXRnb2luZyByZXF1ZXN0LCB0aGUgdHJhbnNhY3Rpb24gd2lsbCB1c2UgaXQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgdHJhbnNhY3Rpb24gd2lsbCBtYWtlIGEgbmV3IG9uZS5cbiAgICAgICAgbWVzc2FnZS5icmFuY2ggPSB0aGlzLm1lc3NhZ2UuYnJhbmNoO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlLmhlYWRlcnMuUm91dGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVycy5Sb3V0ZSA9IHRoaXMubWVzc2FnZS5oZWFkZXJzLlJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2V0SGVhZGVyKFwiUmVhc29uXCIsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm8gcHJvdmlzaW9uYWwgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQsIHRoZSBDQU5DRUwgcmVxdWVzdCBNVVNUXG4gICAgICAgIC8vIE5PVCBiZSBzZW50OyByYXRoZXIsIHRoZSBjbGllbnQgTVVTVCB3YWl0IGZvciB0aGUgYXJyaXZhbCBvZiBhXG4gICAgICAgIC8vIHByb3Zpc2lvbmFsIHJlc3BvbnNlIGJlZm9yZSBzZW5kaW5nIHRoZSByZXF1ZXN0LiBJZiB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gcmVxdWVzdCBoYXMgZ2VuZXJhdGVkIGEgZmluYWwgcmVzcG9uc2UsIHRoZSBDQU5DRUwgU0hPVUxEIE5PVCBiZVxuICAgICAgICAvLyBzZW50LCBhcyBpdCBpcyBhbiBlZmZlY3RpdmUgbm8tb3AsIHNpbmNlIENBTkNFTCBoYXMgbm8gZWZmZWN0IG9uXG4gICAgICAgIC8vIHJlcXVlc3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGdlbmVyYXRlZCBhIGZpbmFsIHJlc3BvbnNlLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTkuMVxuICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nKSB7XG4gICAgICAgICAgICB2YXIgdWFjID0gbmV3IFVzZXJBZ2VudENsaWVudCh0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbiwgdGhpcy5jb3JlLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24ub25jZShcInN0YXRlQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyYW5zYWN0aW9uICYmIF90aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhYyA9IG5ldyBVc2VyQWdlbnRDbGllbnQodHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sIF90aGlzLmNvcmUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgYSA0MDEgKFVuYXV0aG9yaXplZCkgb3IgNDA3IChQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZClcbiAgICAgKiByZXNwb25zZSBpcyByZWNlaXZlZCwgdGhlIFVBQyBTSE9VTEQgZm9sbG93IHRoZSBhdXRob3JpemF0aW9uXG4gICAgICogcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDIyLjIgYW5kIFNlY3Rpb24gMjIuMyB0byByZXRyeSB0aGUgcmVxdWVzdCB3aXRoXG4gICAgICogY3JlZGVudGlhbHMuXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi04LjEuMy41XG4gICAgICogMjIgVXNhZ2Ugb2YgSFRUUCBBdXRoZW50aWNhdGlvblxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjJcbiAgICAgKiAyMi4xIEZyYW1ld29ya1xuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tMjIuMVxuICAgICAqIDIyLjIgVXNlci10by1Vc2VyIEF1dGhlbnRpY2F0aW9uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMi4yXG4gICAgICogMjIuMyBQcm94eS10by1Vc2VyIEF1dGhlbnRpY2F0aW9uXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi0yMi4zXG4gICAgICpcbiAgICAgKiBGSVhNRTogVGhpcyBcImd1YXJkIGZvciBhbmQgcmV0cnkgdGhlIHJlcXVlc3Qgd2l0aCBjcmVkZW50aWFsc1wiXG4gICAgICogaW1wbGVtZW50YXRpb24gaXMgbm90IGNvbXBsZXRlIGFuZCBhdCBiZXN0IG1pbmltYWxseSBwYXNzYWJsZS5cbiAgICAgKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgaW5jb21pbmcgcmVzcG9uc2UgdG8gZ3VhcmQuXG4gICAgICogQHBhcmFtIGRpYWxvZyAtIElmIGRlZmluZWQsIHRoZSBkaWFsb2cgd2l0aGluIHdoaWNoIHRoZSByZXNwb25zZSB3YXMgcmVjZWl2ZWQuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcHJvZ3JhbSBleGVjdXRpb24gaXMgdG8gY29udGludWUgaW4gdGhlIGJyYW5jaCBpbiBxdWVzdGlvbi5cbiAgICAgKiAgICAgICAgICBPdGhlcndpc2UgdGhlIHJlcXVlc3QgaXMgcmV0cmllZCB3aXRoIGNyZWRlbnRpYWxzIGFuZCBjdXJyZW50IHJlcXVlc3QgcHJvY2Vzc2luZyBtdXN0IHN0b3AuXG4gICAgICovXG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5hdXRoZW50aWNhdGlvbkd1YXJkID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRpYWxvZykge1xuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG1lc3NhZ2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKCFzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBzdGF0dXMgY29kZSB1bmRlZmluZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgNDAxIChVbmF1dGhvcml6ZWQpIG9yIDQwNyAoUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQpXG4gICAgICAgIC8vIHJlc3BvbnNlIGlzIHJlY2VpdmVkLCB0aGUgVUFDIFNIT1VMRCBmb2xsb3cgdGhlIGF1dGhvcml6YXRpb25cbiAgICAgICAgLy8gcHJvY2VkdXJlcyBvZiBTZWN0aW9uIDIyLjIgYW5kIFNlY3Rpb24gMjIuMyB0byByZXRyeSB0aGUgcmVxdWVzdCB3aXRoXG4gICAgICAgIC8vIGNyZWRlbnRpYWxzLlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMS4zLjVcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDQwMSAmJiBzdGF0dXNDb2RlICE9PSA0MDcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBhbmQgcGFyc2UgdGhlIGFwcHJvcHJpYXRlIFdXVy1BdXRoZW50aWNhdGUgb3IgUHJveHktQXV0aGVudGljYXRlIGhlYWRlci5cbiAgICAgICAgdmFyIGNoYWxsZW5nZTtcbiAgICAgICAgdmFyIGF1dGhvcml6YXRpb25IZWFkZXJOYW1lO1xuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNDAxKSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2UgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwid3d3LWF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgICAgICAgIGF1dGhvcml6YXRpb25IZWFkZXJOYW1lID0gXCJhdXRob3JpemF0aW9uXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFsbGVuZ2UgPSBtZXNzYWdlLnBhcnNlSGVhZGVyKFwicHJveHktYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgYXV0aG9yaXphdGlvbkhlYWRlck5hbWUgPSBcInByb3h5LWF1dGhvcml6YXRpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJpZnkgaXQgc2VlbXMgYSB2YWxpZCBjaGFsbGVuZ2UuXG4gICAgICAgIGlmICghY2hhbGxlbmdlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKHN0YXR1c0NvZGUgKyBcIiB3aXRoIHdyb25nIG9yIG1pc3NpbmcgY2hhbGxlbmdlLCBjYW5ub3QgYXV0aGVudGljYXRlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXZvaWQgaW5maW5pdGUgYXV0aGVudGljYXRpb25zLlxuICAgICAgICBpZiAodGhpcy5jaGFsbGVuZ2VkICYmICh0aGlzLnN0YWxlIHx8IGNoYWxsZW5nZS5zdGFsZSAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oc3RhdHVzQ29kZSArIFwiIGFwcGFyZW50bHkgaW4gYXV0aGVudGljYXRpb24gbG9vcCwgY2Fubm90IGF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjcmVkZW50aWFscy5cbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gdGhpcy5jb3JlLmNvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRpb25GYWN0b3J5KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIG9idGFpbiBjcmVkZW50aWFscywgY2Fubm90IGF1dGhlbnRpY2F0ZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY2hhbGxlbmdlIGlzIHJlYWxseSB2YWxpZC5cbiAgICAgICAgaWYgKCF0aGlzLmNyZWRlbnRpYWxzLmF1dGhlbnRpY2F0ZSh0aGlzLm1lc3NhZ2UsIGNoYWxsZW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChjaGFsbGVuZ2Uuc3RhbGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHJlc3BvbnNlIHRvIG91dCBvZiBkaWFsb2cgcmVxdWVzdCwgYXNzdW1lIGluY3JlbWVudGluZyB0aGUgQ1NlcSB3aWxsIHN1ZmZpY2UuXG4gICAgICAgIHZhciBjc2VxID0gdGhpcy5tZXNzYWdlLmNzZXEgKz0gMTtcbiAgICAgICAgLy8gSWYgcmVzcG9uc2UgdG8gaW4gZGlhbG9nIHJlcXVlc3QsIGdldCBhIHZhbGlkIG5leHQgQ1NlcSBudW1iZXIuXG4gICAgICAgIGlmIChkaWFsb2cgJiYgZGlhbG9nLmxvY2FsU2VxdWVuY2VOdW1iZXIpIHtcbiAgICAgICAgICAgIGRpYWxvZy5pbmNyZW1lbnRMb2NhbFNlcXVlbmNlTnVtYmVyKCk7XG4gICAgICAgICAgICBjc2VxID0gdGhpcy5tZXNzYWdlLmNzZXEgPSBkaWFsb2cubG9jYWxTZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKFwiY3NlcVwiLCBjc2VxICsgXCIgXCIgKyB0aGlzLm1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlLnNldEhlYWRlcihhdXRob3JpemF0aW9uSGVhZGVyTmFtZSwgdGhpcy5jcmVkZW50aWFscy50b1N0cmluZygpKTtcbiAgICAgICAgLy8gQ2FsbGluZyBpbml0IChhZ2Fpbikgd2lsbCBzd2FwIG91dCBvdXIgZXhpc3RpbmcgY2xpZW50IHRyYW5zYWN0aW9uIHdpdGggYSBuZXcgb25lLlxuICAgICAgICAvLyBGSVhNRTogSEFDSzogQW4gYXNzdW1wdGlvbiBpcyBiZWluZyBtYWRlIGhlcmUgdGhhdCB0aGVyZSBpcyBub3RoaW5nIHRoYXQgbmVlZHMgdG9cbiAgICAgICAgLy8gYmUgY2xlYW5lZCB1cCBiZXlvbmQgdGhlIGNsaWVudCB0cmFuc2FjdGlvbiB3aGljaCBpcyBiZWluZyByZXBsYWNlZC4gRm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIGl0IGlzIGFzc3VtZWQgdGhhdCBubyBlYXJseSBkaWFsb2dzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogOC4xLjMuMSBUcmFuc2FjdGlvbiBMYXllciBFcnJvcnNcbiAgICAgKiBJbiBzb21lIGNhc2VzLCB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIHRyYW5zYWN0aW9uIGxheWVyIHdpbGxcbiAgICAgKiBub3QgYmUgYSBTSVAgbWVzc2FnZSwgYnV0IHJhdGhlciBhIHRyYW5zYWN0aW9uIGxheWVyIGVycm9yLiAgV2hlbiBhXG4gICAgICogdGltZW91dCBlcnJvciBpcyByZWNlaXZlZCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllciwgaXQgTVVTVCBiZVxuICAgICAqIHRyZWF0ZWQgYXMgaWYgYSA0MDggKFJlcXVlc3QgVGltZW91dCkgc3RhdHVzIGNvZGUgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICogSWYgYSBmYXRhbCB0cmFuc3BvcnQgZXJyb3IgaXMgcmVwb3J0ZWQgYnkgdGhlIHRyYW5zcG9ydCBsYXllclxuICAgICAqIChnZW5lcmFsbHksIGR1ZSB0byBmYXRhbCBJQ01QIGVycm9ycyBpbiBVRFAgb3IgY29ubmVjdGlvbiBmYWlsdXJlcyBpblxuICAgICAqIFRDUCksIHRoZSBjb25kaXRpb24gTVVTVCBiZSB0cmVhdGVkIGFzIGEgNTAzIChTZXJ2aWNlIFVuYXZhaWxhYmxlKVxuICAgICAqIHN0YXR1cyBjb2RlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuMVxuICAgICAqL1xuICAgIFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUub25SZXF1ZXN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlVzZXIgYWdlbnQgY2xpZW50IHJlcXVlc3QgdGltZWQgb3V0LiBHZW5lcmF0aW5nIGludGVybmFsIDQwOCBSZXF1ZXN0IFRpbWVvdXQuXCIpO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBtZXNzYWdlc18xLkluY29taW5nUmVzcG9uc2VNZXNzYWdlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzQ29kZSA9IDQwODtcbiAgICAgICAgbWVzc2FnZS5yZWFzb25QaHJhc2UgPSBcIlJlcXVlc3QgVGltZW91dFwiO1xuICAgICAgICB0aGlzLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogOC4xLjMuMSBUcmFuc2FjdGlvbiBMYXllciBFcnJvcnNcbiAgICAgKiBJbiBzb21lIGNhc2VzLCB0aGUgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIHRyYW5zYWN0aW9uIGxheWVyIHdpbGxcbiAgICAgKiBub3QgYmUgYSBTSVAgbWVzc2FnZSwgYnV0IHJhdGhlciBhIHRyYW5zYWN0aW9uIGxheWVyIGVycm9yLiAgV2hlbiBhXG4gICAgICogdGltZW91dCBlcnJvciBpcyByZWNlaXZlZCBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllciwgaXQgTVVTVCBiZVxuICAgICAqIHRyZWF0ZWQgYXMgaWYgYSA0MDggKFJlcXVlc3QgVGltZW91dCkgc3RhdHVzIGNvZGUgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICogSWYgYSBmYXRhbCB0cmFuc3BvcnQgZXJyb3IgaXMgcmVwb3J0ZWQgYnkgdGhlIHRyYW5zcG9ydCBsYXllclxuICAgICAqIChnZW5lcmFsbHksIGR1ZSB0byBmYXRhbCBJQ01QIGVycm9ycyBpbiBVRFAgb3IgY29ubmVjdGlvbiBmYWlsdXJlcyBpblxuICAgICAqIFRDUCksIHRoZSBjb25kaXRpb24gTVVTVCBiZSB0cmVhdGVkIGFzIGEgNTAzIChTZXJ2aWNlIFVuYXZhaWxhYmxlKVxuICAgICAqIHN0YXR1cyBjb2RlLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOC4xLjMuMVxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRyYW5zcG9ydCBlcnJvclxuICAgICAqL1xuICAgIFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUub25UcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoXCJVc2VyIGFnZW50IGNsaWVudCByZXF1ZXN0IHRyYW5zcG9ydCBlcnJvci4gR2VuZXJhdGluZyBpbnRlcm5hbCA1MDMgU2VydmljZSBVbmF2YWlsYWJsZS5cIik7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IG1lc3NhZ2VzXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2UoKTtcbiAgICAgICAgbWVzc2FnZS5zdGF0dXNDb2RlID0gNTAzO1xuICAgICAgICBtZXNzYWdlLnJlYXNvblBocmFzZSA9IFwiU2VydmljZSBVbmF2YWlsYWJsZVwiO1xuICAgICAgICB0aGlzLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY2VpdmUgYSByZXNwb25zZSBmcm9tIHRoZSB0cmFuc2FjdGlvbiBsYXllci5cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEluY29taW5nIHJlc3BvbnNlIG1lc3NhZ2UuXG4gICAgICovXG4gICAgVXNlckFnZW50Q2xpZW50LnByb3RvdHlwZS5yZWNlaXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXV0aGVudGljYXRpb25HdWFyZChtZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0dXNDb2RlID0gbWVzc2FnZS5zdGF0dXNDb2RlID8gbWVzc2FnZS5zdGF0dXNDb2RlLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICBpZiAoIXN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHN0YXR1cyBjb2RlIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlIC9eMTAwJC8udGVzdChzdGF0dXNDb2RlKTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZSAmJiB0aGlzLmRlbGVnYXRlLm9uVHJ5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25UcnlpbmcoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14xWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLm9uUHJvZ3Jlc3MoeyBtZXNzYWdlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgL14yWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25BY2NlcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vbkFjY2VwdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXjNbMC05XXsyfSQvLnRlc3Qoc3RhdHVzQ29kZSk6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUgJiYgdGhpcy5kZWxlZ2F0ZS5vblJlZGlyZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25SZWRpcmVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAvXls0LTZdWzAtOV17Mn0kLy50ZXN0KHN0YXR1c0NvZGUpOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25SZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5vblJlamVjdCh7IG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXR1cyBjb2RlIFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXJBZ2VudENsaWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2UgYXJlIHRoZSB0cmFuc2FjdGlvbiB1c2VyLlxuICAgICAgICB2YXIgdXNlciA9IHtcbiAgICAgICAgICAgIGxvZ2dlckZhY3Rvcnk6IHRoaXMubG9nZ2VyRmFjdG9yeSxcbiAgICAgICAgICAgIG9uUmVxdWVzdFRpbWVvdXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uUmVxdWVzdFRpbWVvdXQoKTsgfSxcbiAgICAgICAgICAgIG9uU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGVybWluYXRlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjb3JlLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb3JlLnVzZXJBZ2VudENsaWVudHMuZGVsZXRlKHVzZXJBZ2VudENsaWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IEhBQ0s6IE91ciB0cmFuc2FjdGlvbiBtYXkgaGF2ZSBiZWVuIHN3YXBwZWQgb3V0IHdpdGggYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvc3QgYXV0aGVudGljYXRpb24gKHNlZSBhYm92ZSksIHNvIG1ha2Ugc3VyZSB0byBvbmx5IHRvIGRpc3Bvc2Ugb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gb3Vyc2VsdmVzIGlmIHRoaXMgdGVybWluYXRpbmcgdHJhbnNhY3Rpb24gaXMgb3VyIGN1cnJlbnQgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbiA9PT0gX3RoaXMuX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25UcmFuc3BvcnRFcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBfdGhpcy5vblRyYW5zcG9ydEVycm9yKGVycm9yKTsgfSxcbiAgICAgICAgICAgIHJlY2VpdmVSZXNwb25zZTogZnVuY3Rpb24gKG1lc3NhZ2UpIHsgcmV0dXJuIF90aGlzLnJlY2VpdmVSZXNwb25zZShtZXNzYWdlKTsgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gd2l0aCB1cyBhcyB0aGUgdXNlci5cbiAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IHRoaXMudHJhbnNhY3Rpb25Db25zdHJ1Y3Rvcih0aGlzLm1lc3NhZ2UsIHRoaXMuY29yZS50cmFuc3BvcnQsIHVzZXIpO1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyB0cmFuc2FjdGlvbiB0byB0aGUgY29yZS5cbiAgICAgICAgdmFyIHVzZXJBZ2VudENsaWVudElkID0gdHJhbnNhY3Rpb24uaWQgKyB0cmFuc2FjdGlvbi5yZXF1ZXN0Lm1ldGhvZDtcbiAgICAgICAgdGhpcy5jb3JlLnVzZXJBZ2VudENsaWVudHMuc2V0KHVzZXJBZ2VudENsaWVudElkLCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBVc2VyQWdlbnRDbGllbnQ7XG59KCkpO1xuZXhwb3J0cy5Vc2VyQWdlbnRDbGllbnQgPSBVc2VyQWdlbnRDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBleGNlcHRpb25zXzEgPSByZXF1aXJlKFwiLi4vZXhjZXB0aW9uc1wiKTtcbnZhciBtZXNzYWdlc18xID0gcmVxdWlyZShcIi4uL21lc3NhZ2VzXCIpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vbWVzc2FnZXMvdXRpbHNcIik7XG52YXIgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNhY3Rpb25zXCIpO1xuLyoqXG4gKiBVc2VyIEFnZW50IFNlcnZlciAoVUFTKS5cbiAqIEByZW1hcmtzXG4gKiBBIHVzZXIgYWdlbnQgc2VydmVyIGlzIGEgbG9naWNhbCBlbnRpdHlcbiAqIHRoYXQgZ2VuZXJhdGVzIGEgcmVzcG9uc2UgdG8gYSBTSVAgcmVxdWVzdC4gIFRoZSByZXNwb25zZVxuICogYWNjZXB0cywgcmVqZWN0cywgb3IgcmVkaXJlY3RzIHRoZSByZXF1ZXN0LiAgVGhpcyByb2xlIGxhc3RzXG4gKiBvbmx5IGZvciB0aGUgZHVyYXRpb24gb2YgdGhhdCB0cmFuc2FjdGlvbi4gIEluIG90aGVyIHdvcmRzLCBpZlxuICogYSBwaWVjZSBvZiBzb2Z0d2FyZSByZXNwb25kcyB0byBhIHJlcXVlc3QsIGl0IGFjdHMgYXMgYSBVQVMgZm9yXG4gKiB0aGUgZHVyYXRpb24gb2YgdGhhdCB0cmFuc2FjdGlvbi4gIElmIGl0IGdlbmVyYXRlcyBhIHJlcXVlc3RcbiAqIGxhdGVyLCBpdCBhc3N1bWVzIHRoZSByb2xlIG9mIGEgdXNlciBhZ2VudCBjbGllbnQgZm9yIHRoZVxuICogcHJvY2Vzc2luZyBvZiB0aGF0IHRyYW5zYWN0aW9uLlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMyNjEjc2VjdGlvbi02XG4gKiBAcHVibGljXG4gKi9cbnZhciBVc2VyQWdlbnRTZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXNlckFnZW50U2VydmVyKHRyYW5zYWN0aW9uQ29uc3RydWN0b3IsIGNvcmUsIG1lc3NhZ2UsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25Db25zdHJ1Y3RvciA9IHRyYW5zYWN0aW9uQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMuY29yZSA9IGNvcmU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSB0aGlzLmxvZ2dlckZhY3RvcnkuZ2V0TG9nZ2VyKFwic2lwLnVzZXItYWdlbnQtc2VydmVyXCIpO1xuICAgICAgICB0aGlzLnRvVGFnID0gbWVzc2FnZS50b1RhZyA/IG1lc3NhZ2UudG9UYWcgOiB1dGlsc18xLm5ld1RhZygpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLCBcImxvZ2dlckZhY3RvcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvcmUubG9nZ2VyRmFjdG9yeTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwidHJhbnNhY3Rpb25cIiwge1xuICAgICAgICAvKiogVGhlIHRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlcXVlc3QuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAyMDAgfTsgfVxuICAgICAgICBpZiAoIXRoaXMuYWNjZXB0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlRXJyb3IodGhpcy5tZXNzYWdlLm1ldGhvZCArIFwiIG5vdCBhY2NlcHRhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAyMDAgfHwgc3RhdHVzQ29kZSA+IDI5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBzdGF0dXNDb2RlOiAxODAgfTsgfVxuICAgICAgICBpZiAoIXRoaXMucHJvZ3Jlc3NhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGVFcnJvcih0aGlzLm1lc3NhZ2UubWV0aG9kICsgXCIgbm90IHByb2dyZXNzYWJsZSBpbiBzdGF0ZSBcIiArIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgMTAxIHx8IHN0YXR1c0NvZGUgPiAxOTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN0YXR1c0NvZGU6IFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5yZWRpcmVjdCA9IGZ1bmN0aW9uIChjb250YWN0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7IHN0YXR1c0NvZGU6IDMwMiB9OyB9XG4gICAgICAgIGlmICghdGhpcy5yZWRpcmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZUVycm9yKHRoaXMubWVzc2FnZS5tZXRob2QgKyBcIiBub3QgcmVkaXJlY3RhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzQ29kZSA9IG9wdGlvbnMuc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPCAzMDAgfHwgc3RhdHVzQ29kZSA+IDM5OSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgc3RhdHVzQ29kZTogXCIgKyBzdGF0dXNDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFjdEhlYWRlcnMgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgY29udGFjdHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGFjdCkgeyByZXR1cm4gY29udGFjdEhlYWRlcnMucHVzaChcIkNvbnRhY3Q6IFwiICsgY29udGFjdC50b1N0cmluZygpKTsgfSk7XG4gICAgICAgIG9wdGlvbnMuZXh0cmFIZWFkZXJzID0gKG9wdGlvbnMuZXh0cmFIZWFkZXJzIHx8IFtdKS5jb25jYXQoY29udGFjdEhlYWRlcnMpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHsgc3RhdHVzQ29kZTogNDgwIH07IH1cbiAgICAgICAgaWYgKCF0aGlzLnJlamVjdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZUVycm9yKHRoaXMubWVzc2FnZS5tZXRob2QgKyBcIiBub3QgcmVqZWN0YWJsZSBpbiBzdGF0ZSBcIiArIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXR1c0NvZGUgPSBvcHRpb25zLnN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChzdGF0dXNDb2RlIDwgNDAwIHx8IHN0YXR1c0NvZGUgPiA2OTkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHN0YXR1c0NvZGU6IFwiICsgc3RhdHVzQ29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3BvbnNlID0gdGhpcy5yZXBseShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS50cnlpbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMudHJ5aW5nYWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlRXJyb3IodGhpcy5tZXNzYWdlLm1ldGhvZCArIFwiIG5vdCB0cnlpbmdhYmxlIGluIHN0YXRlIFwiICsgdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlcGx5KHsgc3RhdHVzQ29kZTogMTAwIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgVUFTIGRpZCBub3QgZmluZCBhIG1hdGNoaW5nIHRyYW5zYWN0aW9uIGZvciB0aGUgQ0FOQ0VMXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBwcm9jZWR1cmUgYWJvdmUsIGl0IFNIT1VMRCByZXNwb25kIHRvIHRoZSBDQU5DRUxcbiAgICAgKiB3aXRoIGEgNDgxIChDYWxsIExlZy9UcmFuc2FjdGlvbiBEb2VzIE5vdCBFeGlzdCkuICBJZiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3Qgc3RpbGwgZXhpc3RzLCB0aGUgYmVoYXZpb3Igb2YgdGhlIFVBUyBvblxuICAgICAqIHJlY2VpdmluZyBhIENBTkNFTCByZXF1ZXN0IGRlcGVuZHMgb24gd2hldGhlciBpdCBoYXMgYWxyZWFkeSBzZW50IGFcbiAgICAgKiBmaW5hbCByZXNwb25zZSBmb3IgdGhlIG9yaWdpbmFsIHJlcXVlc3QuICBJZiBpdCBoYXMsIHRoZSBDQU5DRUxcbiAgICAgKiByZXF1ZXN0IGhhcyBubyBlZmZlY3Qgb24gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIG9yaWdpbmFsIHJlcXVlc3QsIG5vXG4gICAgICogZWZmZWN0IG9uIGFueSBzZXNzaW9uIHN0YXRlLCBhbmQgbm8gZWZmZWN0IG9uIHRoZSByZXNwb25zZXMgZ2VuZXJhdGVkXG4gICAgICogZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LiAgSWYgdGhlIFVBUyBoYXMgbm90IGlzc3VlZCBhIGZpbmFsIHJlc3BvbnNlXG4gICAgICogZm9yIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBpdHMgYmVoYXZpb3IgZGVwZW5kcyBvbiB0aGUgbWV0aG9kIG9mIHRoZVxuICAgICAqIG9yaWdpbmFsIHJlcXVlc3QuICBJZiB0aGUgb3JpZ2luYWwgcmVxdWVzdCB3YXMgYW4gSU5WSVRFLCB0aGUgVUFTXG4gICAgICogU0hPVUxEIGltbWVkaWF0ZWx5IHJlc3BvbmQgdG8gdGhlIElOVklURSB3aXRoIGEgNDg3IChSZXF1ZXN0XG4gICAgICogVGVybWluYXRlZCkuICBBIENBTkNFTCByZXF1ZXN0IGhhcyBubyBpbXBhY3Qgb24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAgICAgKiB0cmFuc2FjdGlvbnMgd2l0aCBhbnkgb3RoZXIgbWV0aG9kIGRlZmluZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uLlxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMjYxI3NlY3Rpb24tOS4yXG4gICAgICogQHBhcmFtIHJlcXVlc3QgLSBJbmNvbWluZyBDQU5DRUwgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLnJlY2VpdmVDYW5jZWwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgQ0FOQ0VMIGlzIGJlaW5nIGhhbmRsZWQgYXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgICAgIC8vIE5vIFVBUyBpcyBjcmVhdGVkIHRvIGhhbmRsZSB0aGUgQ0FOQ0VMIGFuZCB0aGUgcmVzcG9uc2UgdG9cbiAgICAgICAgLy8gaXQgQ0FOQ0VMIGlzIGJlaW5nIGhhbmRsZWQgc3RhdGVsZXNzbHkgYnkgdGhlIHVzZXIgYWdlbnQgY29yZS5cbiAgICAgICAgLy8gQXMgc3VjaCwgdGhlcmUgaXMgY3VycmVudGx5IG5vIHdheSB0byBleHRlcm5hbGx5IGltcGFjdCB0aGVcbiAgICAgICAgLy8gcmVzcG9uc2UgdG8gdGhlIGEgQ0FOQ0VMIHJlcXVlc3QuXG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlICYmIHRoaXMuZGVsZWdhdGUub25DYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUub25DYW5jZWwobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLCBcImFjY2VwdGFibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLkFjY2VwdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuUHJvY2VlZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHRyYW5zYWN0aW9uIHR5cGUuXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXNlckFnZW50U2VydmVyLnByb3RvdHlwZSwgXCJwcm9ncmVzc2FibGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uIGluc3RhbmNlb2YgdHJhbnNhY3Rpb25zXzEuSW52aXRlU2VydmVyVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5zdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5Qcm9jZWVkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQzMjAjc2VjdGlvbi00LjFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNhY3Rpb24gdHlwZS5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVc2VyQWdlbnRTZXJ2ZXIucHJvdG90eXBlLCBcInJlZGlyZWN0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwicmVqZWN0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlRyeWluZyB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUsIFwidHJ5aW5nYWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB0cmFuc2FjdGlvbnNfMS5JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnN0YXRlID09PSB0cmFuc2FjdGlvbnNfMS5UcmFuc2FjdGlvblN0YXRlLlByb2NlZWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHRyYW5zYWN0aW9uc18xLk5vbkludml0ZVNlcnZlclRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24uc3RhdGUgPT09IHRyYW5zYWN0aW9uc18xLlRyYW5zYWN0aW9uU3RhdGUuVHJ5aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2FjdGlvbiB0eXBlLlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogV2hlbiBhIFVBUyB3aXNoZXMgdG8gY29uc3RydWN0IGEgcmVzcG9uc2UgdG8gYSByZXF1ZXN0LCBpdCBmb2xsb3dzXG4gICAgICogdGhlIGdlbmVyYWwgcHJvY2VkdXJlcyBkZXRhaWxlZCBpbiB0aGUgZm9sbG93aW5nIHN1YnNlY3Rpb25zLlxuICAgICAqIEFkZGl0aW9uYWwgYmVoYXZpb3JzIHNwZWNpZmljIHRvIHRoZSByZXNwb25zZSBjb2RlIGluIHF1ZXN0aW9uLCB3aGljaFxuICAgICAqIGFyZSBub3QgZGV0YWlsZWQgaW4gdGhpcyBzZWN0aW9uLCBtYXkgYWxzbyBiZSByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIE9uY2UgYWxsIHByb2NlZHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjcmVhdGlvbiBvZiBhIHJlc3BvbnNlIGhhdmVcbiAgICAgKiBiZWVuIGNvbXBsZXRlZCwgdGhlIFVBUyBoYW5kcyB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgc2VydmVyXG4gICAgICogdHJhbnNhY3Rpb24gZnJvbSB3aGljaCBpdCByZWNlaXZlZCB0aGUgcmVxdWVzdC5cbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzI2MSNzZWN0aW9uLTguMi42XG4gICAgICogQHBhcmFtIHN0YXR1c0NvZGUgLSBTdGF0dXMgY29kZSB0byByZXBseSB3aXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVwbHkgb3B0aW9ucyBidWNrZXQuXG4gICAgICovXG4gICAgVXNlckFnZW50U2VydmVyLnByb3RvdHlwZS5yZXBseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy50b1RhZyAmJiBvcHRpb25zLnN0YXR1c0NvZGUgIT09IDEwMCkge1xuICAgICAgICAgICAgb3B0aW9ucy50b1RhZyA9IHRoaXMudG9UYWc7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51c2VyQWdlbnQgPSBvcHRpb25zLnVzZXJBZ2VudCB8fCB0aGlzLmNvcmUuY29uZmlndXJhdGlvbi51c2VyQWdlbnRIZWFkZXJGaWVsZFZhbHVlO1xuICAgICAgICBvcHRpb25zLnN1cHBvcnRlZCA9IG9wdGlvbnMuc3VwcG9ydGVkIHx8IHRoaXMuY29yZS5jb25maWd1cmF0aW9uLnN1cHBvcnRlZE9wdGlvblRhZ3NSZXNwb25zZTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbWVzc2FnZXNfMS5jb25zdHJ1Y3RPdXRnb2luZ1Jlc3BvbnNlKHRoaXMubWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24ucmVjZWl2ZVJlc3BvbnNlKG9wdGlvbnMuc3RhdHVzQ29kZSwgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuICAgIFVzZXJBZ2VudFNlcnZlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV2UgYXJlIHRoZSB0cmFuc2FjdGlvbiB1c2VyLlxuICAgICAgICB2YXIgdXNlciA9IHtcbiAgICAgICAgICAgIGxvZ2dlckZhY3Rvcnk6IHRoaXMubG9nZ2VyRmFjdG9yeSxcbiAgICAgICAgICAgIG9uU3RhdGVDaGFuZ2U6IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gdHJhbnNhY3Rpb25zXzEuVHJhbnNhY3Rpb25TdGF0ZS5UZXJtaW5hdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdGVybWluYXRlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjb3JlLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb3JlLnVzZXJBZ2VudFNlcnZlcnMuZGVsZXRlKHVzZXJBZ2VudFNlcnZlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblRyYW5zcG9ydEVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRlbGVnYXRlICYmIF90aGlzLmRlbGVnYXRlLm9uVHJhbnNwb3J0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGVsZWdhdGUub25UcmFuc3BvcnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2dnZXIuZXJyb3IoXCJVc2VyIGFnZW50IHNlcnZlciByZXNwb25zZSB0cmFuc3BvcnQgZXJyb3IuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHRyYW5zYWN0aW9uIHdpdGggdXMgYXMgdGhlIHVzZXIuXG4gICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IG5ldyB0aGlzLnRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcy5tZXNzYWdlLCB0aGlzLmNvcmUudHJhbnNwb3J0LCB1c2VyKTtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgdHJhbnNhY3Rpb24gdG8gdGhlIGNvcmUuXG4gICAgICAgIHZhciB1c2VyQWdlbnRTZXJ2ZXJJZCA9IHRyYW5zYWN0aW9uLmlkO1xuICAgICAgICB0aGlzLmNvcmUudXNlckFnZW50U2VydmVycy5zZXQodHJhbnNhY3Rpb24uaWQsIHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVzZXJBZ2VudFNlcnZlcjtcbn0oKSk7XG5leHBvcnRzLlVzZXJBZ2VudFNlcnZlciA9IFVzZXJBZ2VudFNlcnZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gdHNsaW50OmRpc2FibGU6aW50ZXJmYWNlLW5hbWVcbi8vIHRzbGludDpkaXNhYmxlOiB0cmFpbGluZy1jb21tYVxuLy8gdHNsaW50OmRpc2FibGU6IG9iamVjdC1saXRlcmFsLXNvcnQta2V5c1xuLy8gdHNsaW50OmRpc2FibGU6IG1heC1saW5lLWxlbmd0aFxuLy8gdHNsaW50OmRpc2FibGU6IG9ubHktYXJyb3ctZnVuY3Rpb25zXG4vLyB0c2xpbnQ6ZGlzYWJsZTogb25lLXZhcmlhYmxlLXBlci1kZWNsYXJhdGlvblxuLy8gdHNsaW50OmRpc2FibGU6IG5vLWNvbnNlY3V0aXZlLWJsYW5rLWxpbmVzXG4vLyB0c2xpbnQ6ZGlzYWJsZTogYWxpZ25cbi8vIHRzbGludDpkaXNhYmxlOiByYWRpeFxuLy8gdHNsaW50OmRpc2FibGU6IHF1b3RlbWFya1xuLy8gdHNsaW50OmRpc2FibGU6IHNlbWljb2xvblxuLy8gdHNsaW50OmRpc2FibGU6IG9iamVjdC1saXRlcmFsLXNob3J0aGFuZFxuLy8gdHNsaW50OmRpc2FibGU6IHZhcmlhYmxlLW5hbWVcbi8vIHRzbGludDpkaXNhYmxlOiBuby12YXIta2V5d29yZFxuLy8gdHNsaW50OmRpc2FibGU6IHdoaXRlc3BhY2Vcbi8vIHRzbGludDpkaXNhYmxlOiBjdXJseVxuLy8gdHNsaW50OmRpc2FibGU6IHByZWZlci1jb25zdFxuLy8gdHNsaW50OmRpc2FibGU6IG9iamVjdC1saXRlcmFsLWtleS1xdW90ZXNcbi8vIHRzbGludDpkaXNhYmxlOiBuby1zdHJpbmctbGl0ZXJhbFxuLy8gdHNsaW50OmRpc2FibGU6IG9uZS1saW5lXG4vLyB0c2xpbnQ6ZGlzYWJsZTogbm8tdW51c2VkLWV4cHJlc3Npb25cbi8vIHRzbGludDpkaXNhYmxlOiBzcGFjZS1iZWZvcmUtZnVuY3Rpb24tcGFyZW5cbi8vIHRzbGludDpkaXNhYmxlOiBhcnJvdy1yZXR1cm4tc2hvcnRoYW5kXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vIEdlbmVyYXRlZCBieSBQRUcuanMgdi4gMC4xMC4wICh0cy1wZWdqcyBwbHVnaW4gdi4gMC4yLjYgKVxuLy9cbi8vIGh0dHBzOi8vcGVnanMub3JnLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9tZXRhZGV2cHJvL3RzLXBlZ2pzXG52YXIgbmFtZV9hZGRyX2hlYWRlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvbWVzc2FnZXMvbmFtZS1hZGRyLWhlYWRlclwiKTtcbnZhciB1cmlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL21lc3NhZ2VzL3VyaVwiKTtcbnZhciBTeW50YXhFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTeW50YXhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIGxvY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBfdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgICBfdGhpcy5mb3VuZCA9IGZvdW5kO1xuICAgICAgICBfdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICBfdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBTeW50YXhFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTeW50YXhFcnJvci5idWlsZE1lc3NhZ2UgPSBmdW5jdGlvbiAoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIGhleChjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGl0ZXJhbEVzY2FwZShzKSB7XG4gICAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgXCJcXFxcXFxcIlwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MEZdL2csIGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gXCJcXFxceDBcIiArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzRXNjYXBlKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXF0vZywgXCJcXFxcXVwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXF4vZywgXCJcXFxcXlwiKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiXFxcXC1cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIFwiXFxcXHgwXCIgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg3Ri1cXHg5Rl0vZywgZnVuY3Rpb24gKGNoKSB7IHJldHVybiBcIlxcXFx4XCIgKyBoZXgoY2gpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV4cGVjdGF0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibGl0ZXJhbFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBsaXRlcmFsRXNjYXBlKGV4cGVjdGF0aW9uLnRleHQpICsgXCJcXFwiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGFzc0VzY2FwZShwYXJ0WzBdKSArIFwiLVwiICsgY2xhc3NFc2NhcGUocGFydFsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNsYXNzRXNjYXBlKHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgKGV4cGVjdGF0aW9uLmludmVydGVkID8gXCJeXCIgOiBcIlwiKSArIGVzY2FwZWRQYXJ0cyArIFwiXVwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW5kIG9mIGlucHV0XCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm90aGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBlY3RhdGlvbi5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGVjdGVkKGV4cGVjdGVkMSkge1xuICAgICAgICAgICAgdmFyIGRlc2NyaXB0aW9ucyA9IGV4cGVjdGVkMS5tYXAoZGVzY3JpYmVFeHBlY3RhdGlvbik7XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjcmlwdGlvbnNbaSAtIDFdICE9PSBkZXNjcmlwdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uc1tqXSA9IGRlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbnMubGVuZ3RoID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoZGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgXCIsIG9yIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVzY3JpYmVGb3VuZChmb3VuZDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDEgPyBcIlxcXCJcIiArIGxpdGVyYWxFc2NhcGUoZm91bmQxKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbiAgICB9O1xuICAgIHJldHVybiBTeW50YXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbmZ1bmN0aW9uIHBlZyRwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG4gICAgdmFyIHBlZyRGQUlMRUQgPSB7fTtcbiAgICB2YXIgcGVnJHN0YXJ0UnVsZUluZGljZXMgPSB7IENvbnRhY3Q6IDExOSwgTmFtZV9BZGRyX0hlYWRlcjogMTU2LCBSZWNvcmRfUm91dGU6IDE3NiwgUmVxdWVzdF9SZXNwb25zZTogODEsIFNJUF9VUkk6IDQ1LCBTdWJzY3JpcHRpb25fU3RhdGU6IDE4NiwgU3VwcG9ydGVkOiAxOTEsIFJlcXVpcmU6IDE4MiwgVmlhOiAxOTQsIGFic29sdXRlVVJJOiA4NCwgQ2FsbF9JRDogMTE4LCBDb250ZW50X0Rpc3Bvc2l0aW9uOiAxMzAsIENvbnRlbnRfTGVuZ3RoOiAxMzUsIENvbnRlbnRfVHlwZTogMTM2LCBDU2VxOiAxNDYsIGRpc3BsYXlOYW1lOiAxMjIsIEV2ZW50OiAxNDksIEZyb206IDE1MSwgaG9zdDogNTIsIE1heF9Gb3J3YXJkczogMTU0LCBNaW5fU0U6IDIxMywgUHJveHlfQXV0aGVudGljYXRlOiAxNTcsIHF1b3RlZF9zdHJpbmc6IDQwLCBSZWZlcl9UbzogMTc4LCBSZXBsYWNlczogMTc5LCBTZXNzaW9uX0V4cGlyZXM6IDIxMCwgc3R1bl9VUkk6IDIxNywgVG86IDE5MiwgdHVybl9VUkk6IDIyMywgdXVpZDogMjI2LCBXV1dfQXV0aGVudGljYXRlOiAyMDksIGNoYWxsZW5nZTogMTU4LCBzaXBmcmFnOiAyMzAsIFJlZmVycmVkX0J5OiAyMzEgfTtcbiAgICB2YXIgcGVnJHN0YXJ0UnVsZUluZGV4ID0gMTE5O1xuICAgIHZhciBwZWckY29uc3RzID0gW1xuICAgICAgICBcIlxcclxcblwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiXFxyXFxuXCIsIGZhbHNlKSxcbiAgICAgICAgL15bMC05XS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIC9eW2EtekEtWl0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bMC05YS1mQS1GXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiOVwiXSwgW1wiYVwiLCBcImZcIl0sIFtcIkFcIiwgXCJGXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFwwLVxceEZGXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXDBcIiwgXCJcXHhGRlwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIC9eW1wiXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtcIlxcXCJcIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIFwiIFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiIFwiLCBmYWxzZSksXG4gICAgICAgIFwiXFx0XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXHRcIiwgZmFsc2UpLFxuICAgICAgICAvXlthLXpBLVowLTldLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJ6XCJdLCBbXCJBXCIsIFwiWlwiXSwgW1wiMFwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICBcIjtcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjtcIiwgZmFsc2UpLFxuICAgICAgICBcIi9cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi9cIiwgZmFsc2UpLFxuICAgICAgICBcIj9cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj9cIiwgZmFsc2UpLFxuICAgICAgICBcIjpcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIjpcIiwgZmFsc2UpLFxuICAgICAgICBcIkBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkBcIiwgZmFsc2UpLFxuICAgICAgICBcIiZcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiZcIiwgZmFsc2UpLFxuICAgICAgICBcIj1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj1cIiwgZmFsc2UpLFxuICAgICAgICBcIitcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIitcIiwgZmFsc2UpLFxuICAgICAgICBcIiRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiRcIiwgZmFsc2UpLFxuICAgICAgICBcIixcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIixcIiwgZmFsc2UpLFxuICAgICAgICBcIi1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi1cIiwgZmFsc2UpLFxuICAgICAgICBcIl9cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIl9cIiwgZmFsc2UpLFxuICAgICAgICBcIi5cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi5cIiwgZmFsc2UpLFxuICAgICAgICBcIiFcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiFcIiwgZmFsc2UpLFxuICAgICAgICBcIn5cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIn5cIiwgZmFsc2UpLFxuICAgICAgICBcIipcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIipcIiwgZmFsc2UpLFxuICAgICAgICBcIidcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIidcIiwgZmFsc2UpLFxuICAgICAgICBcIihcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIihcIiwgZmFsc2UpLFxuICAgICAgICBcIilcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIilcIiwgZmFsc2UpLFxuICAgICAgICBcIiVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIiVcIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIiBcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gJzonOyB9LFxuICAgICAgICAvXlshLX5dLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIiFcIiwgXCJ+XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFx4ODAtXFx1RkZGRl0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXFx4ODBcIiwgXCJcXHVGRkZGXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFx4ODAtXFx4QkZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIlxceDgwXCIsIFwiXFx4QkZcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICAvXlthLWZdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcImFcIiwgXCJmXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgXCJgXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJgXCIsIGZhbHNlKSxcbiAgICAgICAgXCI8XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI8XCIsIGZhbHNlKSxcbiAgICAgICAgXCI+XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI+XCIsIGZhbHNlKSxcbiAgICAgICAgXCJcXFxcXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJcXFxcXCIsIGZhbHNlKSxcbiAgICAgICAgXCJbXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJbXCIsIGZhbHNlKSxcbiAgICAgICAgXCJdXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJdXCIsIGZhbHNlKSxcbiAgICAgICAgXCJ7XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ7XCIsIGZhbHNlKSxcbiAgICAgICAgXCJ9XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ9XCIsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIqXCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiL1wiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIj1cIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCIoXCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiKVwiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIj5cIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCI8XCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiLFwiOyB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBcIjtcIjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCI6XCI7IH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiXFxcIlwiOyB9LFxuICAgICAgICAvXlshLSddLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIiFcIiwgXCInXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bKi1bXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIqXCIsIFwiW1wiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIC9eW1xcXS1+XS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJdXCIsIFwiflwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uIChjb250ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvXlsjLVtdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIiNcIiwgXCJbXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFwwLVxcdF0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiXFwwXCIsIFwiXFx0XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bXFx4MEItXFxmXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXHgwQlwiLCBcIlxcZlwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIC9eW1xceDBFLVxceDdGXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJcXHgwRVwiLCBcIlxceDdGXCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaSA9IG5ldyB1cmlfMS5VUkkob3B0aW9ucy5kYXRhLnNjaGVtZSwgb3B0aW9ucy5kYXRhLnVzZXIsIG9wdGlvbnMuZGF0YS5ob3N0LCBvcHRpb25zLmRhdGEucG9ydCk7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEudXNlcjtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5wb3J0O1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IHVyaV8xLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuc2NoZW1lO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51c2VyO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBvcnQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTSVBfVVJJJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic2lwc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwic2lwc1wiLCB0cnVlKSxcbiAgICAgICAgXCJzaXBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInNpcFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHVyaV9zY2hlbWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWUgPSB1cmlfc2NoZW1lO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXNlciA9IGRlY29kZVVSSUNvbXBvbmVudCh0ZXh0KCkuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhc3N3b3JkID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdCA9IHRleHQoKTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRhdGEuaG9zdDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmhvc3RfdHlwZSA9ICdkb21haW4nO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgL15bYS16QS1aMC05X1xcLV0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiYVwiLCBcInpcIl0sIFtcIkFcIiwgXCJaXCJdLCBbXCIwXCIsIFwiOVwiXSwgXCJfXCIsIFwiLVwiXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgL15bYS16QS1aMC05XFwtXS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCJhXCIsIFwielwiXSwgW1wiQVwiLCBcIlpcIl0sIFtcIjBcIiwgXCI5XCJdLCBcIi1cIl0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcIjo6XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCI6OlwiLCBmYWxzZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0X3R5cGUgPSAnSVB2Nic7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdF90eXBlID0gJ0lQdjQnO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIyNVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMjVcIiwgZmFsc2UpLFxuICAgICAgICAvXlswLTVdLyxcbiAgICAgICAgcGVnJGNsYXNzRXhwZWN0YXRpb24oW1tcIjBcIiwgXCI1XCJdXSwgZmFsc2UsIGZhbHNlKSxcbiAgICAgICAgXCIyXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIyXCIsIGZhbHNlKSxcbiAgICAgICAgL15bMC00XS8sXG4gICAgICAgIHBlZyRjbGFzc0V4cGVjdGF0aW9uKFtbXCIwXCIsIFwiNFwiXV0sIGZhbHNlLCBmYWxzZSksXG4gICAgICAgIFwiMVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiMVwiLCBmYWxzZSksXG4gICAgICAgIC9eWzEtOV0vLFxuICAgICAgICBwZWckY2xhc3NFeHBlY3RhdGlvbihbW1wiMVwiLCBcIjlcIl1dLCBmYWxzZSwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAocG9ydCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KHBvcnQuam9pbignJykpO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHBvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIFwidHJhbnNwb3J0PVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHJhbnNwb3J0PVwiLCB0cnVlKSxcbiAgICAgICAgXCJ1ZHBcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInVkcFwiLCB0cnVlKSxcbiAgICAgICAgXCJ0Y3BcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRjcFwiLCB0cnVlKSxcbiAgICAgICAgXCJzY3RwXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzY3RwXCIsIHRydWUpLFxuICAgICAgICBcInRsc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGxzXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1sndHJhbnNwb3J0J10gPSB0cmFuc3BvcnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJ1c2VyPVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidXNlcj1cIiwgdHJ1ZSksXG4gICAgICAgIFwicGhvbmVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInBob25lXCIsIHRydWUpLFxuICAgICAgICBcImlwXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJpcFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zWyd1c2VyJ10gPSB1c2VyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwibWV0aG9kPVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibWV0aG9kPVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ21ldGhvZCddID0gbWV0aG9kO1xuICAgICAgICB9LFxuICAgICAgICBcInR0bD1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInR0bD1cIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICh0dGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnBhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWyd0dGwnXSA9IHR0bDtcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYWRkcj1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm1hZGRyPVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKG1hZGRyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfcGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtc1snbWFkZHInXSA9IG1hZGRyO1xuICAgICAgICB9LFxuICAgICAgICBcImxyXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJsclwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEudXJpX3BhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX3BhcmFtcyA9IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXNbJ2xyJ10gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfcGFyYW1zW3BhcmFtLnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChobmFtZSwgaHZhbHVlKSB7XG4gICAgICAgICAgICBobmFtZSA9IGhuYW1lLmpvaW4oJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBodmFsdWUgPSBodmFsdWUuam9pbignJyk7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS51cmlfaGVhZGVycylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzW2huYW1lXSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0gPSBbaHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS51cmlfaGVhZGVyc1tobmFtZV0ucHVzaChodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICAvLyBsb3RzIG9mIHRlc3RzIGZhaWwgaWYgdGhpcyBpc24ndCBndWFyZGVkLi4uXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdSZWZlcl9UbycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEudXJpID0gbmV3IHVyaV8xLlVSSShvcHRpb25zLmRhdGEuc2NoZW1lLCBvcHRpb25zLmRhdGEudXNlciwgb3B0aW9ucy5kYXRhLmhvc3QsIG9wdGlvbnMuZGF0YS5wb3J0LCBvcHRpb25zLmRhdGEudXJpX3BhcmFtcywgb3B0aW9ucy5kYXRhLnVyaV9oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnNjaGVtZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5ob3N0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEuaG9zdF90eXBlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmRhdGEucG9ydDtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnVyaV9wYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiLy9cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi8vXCIsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNjaGVtZSA9IHRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlNJUFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnNpcF92ZXJzaW9uID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcIklOVklURVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiSU5WSVRFXCIsIGZhbHNlKSxcbiAgICAgICAgXCJBQ0tcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkFDS1wiLCBmYWxzZSksXG4gICAgICAgIFwiVlhBQ0hcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlZYQUNIXCIsIGZhbHNlKSxcbiAgICAgICAgXCJPUFRJT05TXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJPUFRJT05TXCIsIGZhbHNlKSxcbiAgICAgICAgXCJCWUVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIkJZRVwiLCBmYWxzZSksXG4gICAgICAgIFwiQ0FOQ0VMXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJDQU5DRUxcIiwgZmFsc2UpLFxuICAgICAgICBcIlJFR0lTVEVSXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJSRUdJU1RFUlwiLCBmYWxzZSksXG4gICAgICAgIFwiU1VCU0NSSUJFXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJTVUJTQ1JJQkVcIiwgZmFsc2UpLFxuICAgICAgICBcIk5PVElGWVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiTk9USUZZXCIsIGZhbHNlKSxcbiAgICAgICAgXCJSRUZFUlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiUkVGRVJcIiwgZmFsc2UpLFxuICAgICAgICBcIlBVQkxJU0hcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIlBVQkxJU0hcIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEubWV0aG9kID0gdGV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGF0YS5tZXRob2Q7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChzdGF0dXNfY29kZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXR1c19jb2RlID0gcGFyc2VJbnQoc3RhdHVzX2NvZGUuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucmVhc29uX3BocmFzZSA9IHRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCh7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICdvZmZzZXQnOiBsb2NhdGlvbigpLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAncGFyc2VkJzogaGVhZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZSA9IHRleHQoKS50cmltKCk7XG4gICAgICAgICAgICBpZiAoZGlzcGxheU5hbWVbMF0gPT09ICdcXFwiJykge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWUuc3Vic3RyaW5nKDEsIGRpc3BsYXlOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIFwicVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kYXRhLnBhcmFtcylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zID0ge307XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucGFyYW1zWydxJ10gPSBxO1xuICAgICAgICB9LFxuICAgICAgICBcImV4cGlyZXNcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImV4cGlyZXNcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChleHBpcmVzKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS5wYXJhbXMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBhcmFtc1snZXhwaXJlcyddID0gZXhwaXJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGRlbHRhX3NlY29uZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChkZWx0YV9zZWNvbmRzLmpvaW4oJycpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCIwXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIwXCIsIGZhbHNlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGV4dCgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRhdGEucGFyYW1zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5wYXJhbXNbcGFyYW0udG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZW5kZXJcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlbmRlclwiLCB0cnVlKSxcbiAgICAgICAgXCJzZXNzaW9uXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJzZXNzaW9uXCIsIHRydWUpLFxuICAgICAgICBcImljb25cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImljb25cIiwgdHJ1ZSksXG4gICAgICAgIFwiYWxlcnRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImFsZXJ0XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdDb250ZW50X0Rpc3Bvc2l0aW9uJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50eXBlID0gdGV4dCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaGFuZGxpbmdcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImhhbmRsaW5nXCIsIHRydWUpLFxuICAgICAgICBcIm9wdGlvbmFsXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJvcHRpb25hbFwiLCB0cnVlKSxcbiAgICAgICAgXCJyZXF1aXJlZFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVxdWlyZWRcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHBhcnNlSW50KGxlbmd0aC5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IHRleHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0ZXh0XCIsIHRydWUpLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJpbWFnZVwiLCB0cnVlKSxcbiAgICAgICAgXCJhdWRpb1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYXVkaW9cIiwgdHJ1ZSksXG4gICAgICAgIFwidmlkZW9cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInZpZGVvXCIsIHRydWUpLFxuICAgICAgICBcImFwcGxpY2F0aW9uXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhcHBsaWNhdGlvblwiLCB0cnVlKSxcbiAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtZXNzYWdlXCIsIHRydWUpLFxuICAgICAgICBcIm11bHRpcGFydFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibXVsdGlwYXJ0XCIsIHRydWUpLFxuICAgICAgICBcIngtXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ4LVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKGNzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZSA9IHBhcnNlSW50KGNzZXFfdmFsdWUuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXhwaXJlcykgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YSA9IGV4cGlyZXM7IH0sXG4gICAgICAgIGZ1bmN0aW9uIChldmVudF90eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuZXZlbnQgPSBldmVudF90eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIHZhciB0YWcgPSBvcHRpb25zLmRhdGEudGFnO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG5hbWVfYWRkcl9oZWFkZXJfMS5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJywgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0YWdcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRhZ1wiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHRhZykgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YS50YWcgPSB0YWc7IH0sXG4gICAgICAgIGZ1bmN0aW9uIChmb3J3YXJkcykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gcGFyc2VJbnQoZm9yd2FyZHMuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAobWluX2V4cGlyZXMpIHsgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9OyBvcHRpb25zLmRhdGEgPSBtaW5fZXhwaXJlczsgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG5hbWVfYWRkcl9oZWFkZXJfMS5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICB9LFxuICAgICAgICBcImRpZ2VzdFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiRGlnZXN0XCIsIHRydWUpLFxuICAgICAgICBcInJlYWxtXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZWFsbVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHJlYWxtKSB7IG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTsgb3B0aW9ucy5kYXRhLnJlYWxtID0gcmVhbG07IH0sXG4gICAgICAgIFwiZG9tYWluXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJkb21haW5cIiwgdHJ1ZSksXG4gICAgICAgIFwibm9uY2VcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm5vbmNlXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAobm9uY2UpIHsgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9OyBvcHRpb25zLmRhdGEubm9uY2UgPSBub25jZTsgfSxcbiAgICAgICAgXCJvcGFxdWVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIm9wYXF1ZVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKG9wYXF1ZSkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YS5vcGFxdWUgPSBvcGFxdWU7IH0sXG4gICAgICAgIFwic3RhbGVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInN0YWxlXCIsIHRydWUpLFxuICAgICAgICBcInRydWVcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRydWVcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9OyBvcHRpb25zLmRhdGEuc3RhbGUgPSB0cnVlOyB9LFxuICAgICAgICBcImZhbHNlXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJmYWxzZVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkgeyBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07IG9wdGlvbnMuZGF0YS5zdGFsZSA9IGZhbHNlOyB9LFxuICAgICAgICBcImFsZ29yaXRobVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYWxnb3JpdGhtXCIsIHRydWUpLFxuICAgICAgICBcIm1kNVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiTUQ1XCIsIHRydWUpLFxuICAgICAgICBcIm1kNS1zZXNzXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJNRDUtc2Vzc1wiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKGFsZ29yaXRobSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmFsZ29yaXRobSA9IGFsZ29yaXRobS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9LFxuICAgICAgICBcInFvcFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicW9wXCIsIHRydWUpLFxuICAgICAgICBcImF1dGgtaW50XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhdXRoLWludFwiLCB0cnVlKSxcbiAgICAgICAgXCJhdXRoXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJhdXRoXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocW9wX3ZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucW9wIHx8IChvcHRpb25zLmRhdGEucW9wID0gW10pO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnFvcC5wdXNoKHFvcF92YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHJhY2tfdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZSA9IHBhcnNlSW50KHJhY2tfdmFsdWUuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGg7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBsZW5ndGggPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyW2lkeF0ucGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBvcHRpb25zLmRhdGEubXVsdGlfaGVhZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXI7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm11bHRpX2hlYWRlciA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgbmFtZV9hZGRyX2hlYWRlcl8xLk5hbWVBZGRySGVhZGVyKG9wdGlvbnMuZGF0YS51cmksIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZSwgb3B0aW9ucy5kYXRhLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS51cmk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGF0YS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5kYXRhLnBhcmFtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5tdWx0aV9oZWFkZXIucHVzaCh7ICdwb3NpdGlvbic6IHBlZyRjdXJyUG9zLFxuICAgICAgICAgICAgICAgICdvZmZzZXQnOiBsb2NhdGlvbigpLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAncGFyc2VkJzogaGVhZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG5hbWVfYWRkcl9oZWFkZXJfMS5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zLmRhdGEucmVwbGFjZXNfZnJvbV90YWcgJiYgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX3RvX3RhZykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0ge1xuICAgICAgICAgICAgICAgIGNhbGxfaWQ6IG9wdGlvbnMuZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJmcm9tLXRhZ1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZnJvbS10YWdcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChmcm9tX3RhZykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlcGxhY2VzX2Zyb21fdGFnID0gZnJvbV90YWc7XG4gICAgICAgIH0sXG4gICAgICAgIFwidG8tdGFnXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ0by10YWdcIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uICh0b190YWcpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5yZXBsYWNlc190b190YWcgPSB0b190YWc7XG4gICAgICAgIH0sXG4gICAgICAgIFwiZWFybHktb25seVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZWFybHktb25seVwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmVhcmx5X29ubHkgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoaGVhZCwgcikgeyByZXR1cm4gcjsgfSxcbiAgICAgICAgZnVuY3Rpb24gKGhlYWQsIHRhaWwpIHsgcmV0dXJuIGxpc3QoaGVhZCwgdGFpbCk7IH0sXG4gICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlID09PSAnUmVxdWlyZScpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHJzZXFfdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS52YWx1ZSA9IHBhcnNlSW50KHJzZXFfdmFsdWUuam9pbignJykpO1xuICAgICAgICB9LFxuICAgICAgICBcImFjdGl2ZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYWN0aXZlXCIsIHRydWUpLFxuICAgICAgICBcInBlbmRpbmdcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInBlbmRpbmdcIiwgdHJ1ZSksXG4gICAgICAgIFwidGVybWluYXRlZFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidGVybWluYXRlZFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnN0YXRlID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcInJlYXNvblwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVhc29uXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlYXNvbiAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKGV4cGlyZXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwaXJlcyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmV4cGlyZXMgPSBleHBpcmVzO1xuICAgICAgICB9LFxuICAgICAgICBcInJldHJ5X2FmdGVyXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZXRyeV9hZnRlclwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHJldHJ5X2FmdGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldHJ5X2FmdGVyICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmV0cnlfYWZ0ZXIgPSByZXRyeV9hZnRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWFjdGl2YXRlZFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiZGVhY3RpdmF0ZWRcIiwgdHJ1ZSksXG4gICAgICAgIFwicHJvYmF0aW9uXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJwcm9iYXRpb25cIiwgdHJ1ZSksXG4gICAgICAgIFwicmVqZWN0ZWRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJlamVjdGVkXCIsIHRydWUpLFxuICAgICAgICBcInRpbWVvdXRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInRpbWVvdXRcIiwgdHJ1ZSksXG4gICAgICAgIFwiZ2l2ZXVwXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJnaXZldXBcIiwgdHJ1ZSksXG4gICAgICAgIFwibm9yZXNvdXJjZVwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwibm9yZXNvdXJjZVwiLCB0cnVlKSxcbiAgICAgICAgXCJpbnZhcmlhbnRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcImludmFyaWFudFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydFJ1bGUgPT09ICdTdXBwb3J0ZWQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdmFsdWUgfHwgW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIHZhciB0YWcgPSBvcHRpb25zLmRhdGEudGFnO1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gbmV3IG5hbWVfYWRkcl9oZWFkZXJfMS5OYW1lQWRkckhlYWRlcihvcHRpb25zLmRhdGEudXJpLCBvcHRpb25zLmRhdGEuZGlzcGxheU5hbWUsIG9wdGlvbnMuZGF0YS5wYXJhbXMpO1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zZXRQYXJhbSgndGFnJywgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0dGxcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInR0bFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHZpYV90dGxfdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS50dGwgPSB2aWFfdHRsX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcIm1hZGRyXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJtYWRkclwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHZpYV9tYWRkcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLm1hZGRyID0gdmlhX21hZGRyO1xuICAgICAgICB9LFxuICAgICAgICBcInJlY2VpdmVkXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJyZWNlaXZlZFwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHZpYV9yZWNlaXZlZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnJlY2VpdmVkID0gdmlhX3JlY2VpdmVkO1xuICAgICAgICB9LFxuICAgICAgICBcImJyYW5jaFwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYnJhbmNoXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmlhX2JyYW5jaCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmJyYW5jaCA9IHZpYV9icmFuY2g7XG4gICAgICAgIH0sXG4gICAgICAgIFwicnBvcnRcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInJwb3J0XCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAocmVzcG9uc2VfcG9ydCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZV9wb3J0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucnBvcnQgPSByZXNwb25zZV9wb3J0LmpvaW4oJycpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAodmlhX3Byb3RvY29sKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEucHJvdG9jb2wgPSB2aWFfcHJvdG9jb2w7XG4gICAgICAgIH0sXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJVRFBcIiwgdHJ1ZSksXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJUQ1BcIiwgdHJ1ZSksXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJUTFNcIiwgdHJ1ZSksXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJTQ1RQXCIsIHRydWUpLFxuICAgICAgICBmdW5jdGlvbiAodmlhX3RyYW5zcG9ydCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHZpYV90cmFuc3BvcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5ob3N0ID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAodmlhX3NlbnRfYnlfcG9ydCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnBvcnQgPSBwYXJzZUludCh2aWFfc2VudF9ieV9wb3J0LmpvaW4oJycpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKHR0bCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR0bC5qb2luKCcnKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZGVsdGFTZWNvbmRzID0gZGVsdGFTZWNvbmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInJlZnJlc2hlclwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwicmVmcmVzaGVyXCIsIGZhbHNlKSxcbiAgICAgICAgXCJ1YXNcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInVhc1wiLCBmYWxzZSksXG4gICAgICAgIFwidWFjXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJ1YWNcIiwgZmFsc2UpLFxuICAgICAgICBmdW5jdGlvbiAoZW5kcG9pbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ1Nlc3Npb25fRXhwaXJlcycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEucmVmcmVzaGVyID0gZW5kcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChkZWx0YVNlY29uZHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0YXJ0UnVsZSA9PT0gJ01pbl9TRScpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSBkZWx0YVNlY29uZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3R1bnNcIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInN0dW5zXCIsIHRydWUpLFxuICAgICAgICBcInN0dW5cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcInN0dW5cIiwgdHJ1ZSksXG4gICAgICAgIGZ1bmN0aW9uIChzY2hlbWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgZGF0YToge30gfTtcbiAgICAgICAgICAgIG9wdGlvbnMuZGF0YS5zY2hlbWUgPSBzY2hlbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IGRhdGE6IHt9IH07XG4gICAgICAgICAgICBvcHRpb25zLmRhdGEuaG9zdCA9IGhvc3Q7XG4gICAgICAgIH0sXG4gICAgICAgIFwiP3RyYW5zcG9ydD1cIixcbiAgICAgICAgcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIj90cmFuc3BvcnQ9XCIsIGZhbHNlKSxcbiAgICAgICAgXCJ0dXJuc1wiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHVybnNcIiwgdHJ1ZSksXG4gICAgICAgIFwidHVyblwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwidHVyblwiLCB0cnVlKSxcbiAgICAgICAgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBkYXRhOiB7fSB9O1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gdGV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICBcIlJlZmVycmVkLUJ5XCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJSZWZlcnJlZC1CeVwiLCBmYWxzZSksXG4gICAgICAgIFwiYlwiLFxuICAgICAgICBwZWckbGl0ZXJhbEV4cGVjdGF0aW9uKFwiYlwiLCBmYWxzZSksXG4gICAgICAgIFwiY2lkXCIsXG4gICAgICAgIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCJjaWRcIiwgZmFsc2UpXG4gICAgXTtcbiAgICB2YXIgcGVnJGJ5dGVjb2RlID0gW1xuICAgICAgICBwZWckZGVjb2RlKFwiMiBcXFwiXFxcIjYgNyFcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0XFxcIlxcXCJcXFwiNSE3I1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjQkXFxcIlxcXCI1ITclXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNCZcXFwiXFxcIjUhNydcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Jy4jICY7KFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjQoXFxcIlxcXCI1ITcpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNCpcXFwiXFxcIjUhNytcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyLFxcXCJcXFwiNiw3LVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjIuXFxcIlxcXCI2LjcvXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNDBcXFwiXFxcIjUhNzFcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyMlxcXCJcXFwiNjI3My5cXHg4OSAmMjRcXFwiXFxcIjY0NzUufSAmMjZcXFwiXFxcIjY2NzcucSAmMjhcXFwiXFxcIjY4NzkuZSAmMjpcXFwiXFxcIjY6NzsuWSAmMjxcXFwiXFxcIjY8Nz0uTSAmMj5cXFwiXFxcIjY+Nz8uQSAmMkBcXFwiXFxcIjZAN0EuNSAmMkJcXFwiXFxcIjZCN0MuKSAmMkRcXFwiXFxcIjZEN0VcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7KS4jICY7LFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJGXFxcIlxcXCI2RjdHLn0gJjJIXFxcIlxcXCI2SDdJLnEgJjJKXFxcIlxcXCI2SjdLLmUgJjJMXFxcIlxcXCI2TDdNLlkgJjJOXFxcIlxcXCI2TjdPLk0gJjJQXFxcIlxcXCI2UDdRLkEgJjJSXFxcIlxcXCI2UjdTLjUgJjJUXFxcIlxcXCI2VDdVLikgJjJWXFxcIlxcXCI2VjdXXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSUyWFxcXCJcXFwiNlg3WS81IzsjLywkOyMvIyQrIykoIycjKFxcXCInIyYnIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlJDskMCMqOyQmLywjOyAvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvPSMkOyQvJiMwIyo7JCYmJiMvJyQ4XFxcIjpaXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjsuLlxcXCIgJlxcXCJcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDsnLiMgJjsoMCkqOycuIyAmOygmLz8jMjhcXFwiXFxcIjY4NzkvMCQ7Ly8nJDgjOlsjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlJDsyLyYjMCMqOzImJiYjL2cjJCUkOy4wIyo7LiYvLCM7Mi8jJCtcXFwiKShcXFwiJyMmJyMwPSolJDsuMCMqOy4mLywjOzIvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyMvXFxcIiEmLClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI0XFxcXFxcXCJcXFwiNSE3XS4jICY7M1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjReXFxcIlxcXCI1ITdfXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNGBcXFwiXFxcIjUhN2FcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7IS4pICY0YlxcXCJcXFwiNSE3Y1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOykuXFx4OTUgJjJGXFxcIlxcXCI2RjdHLlxceDg5ICYySlxcXCJcXFwiNko3Sy59ICYyTFxcXCJcXFwiNkw3TS5xICYyWFxcXCJcXFwiNlg3WS5lICYyUFxcXCJcXFwiNlA3US5ZICYySFxcXCJcXFwiNkg3SS5NICYyQFxcXCJcXFwiNkA3QS5BICYyZFxcXCJcXFwiNmQ3ZS41ICYyUlxcXCJcXFwiNlI3Uy4pICYyTlxcXCJcXFwiNk43Ty9cXHg5RSMwXFx4OUIqOykuXFx4OTUgJjJGXFxcIlxcXCI2RjdHLlxceDg5ICYySlxcXCJcXFwiNko3Sy59ICYyTFxcXCJcXFwiNkw3TS5xICYyWFxcXCJcXFwiNlg3WS5lICYyUFxcXCJcXFwiNlA3US5ZICYySFxcXCJcXFwiNkg3SS5NICYyQFxcXCJcXFwiNkA3QS5BICYyZFxcXCJcXFwiNmQ3ZS41ICYyUlxcXCJcXFwiNlI3Uy4pICYyTlxcXCJcXFwiNk43TyYmJiMvXFxcIiEmLClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDspLlxceDg5ICYyRlxcXCJcXFwiNkY3Ry59ICYyTFxcXCJcXFwiNkw3TS5xICYyWFxcXCJcXFwiNlg3WS5lICYyUFxcXCJcXFwiNlA3US5ZICYySFxcXCJcXFwiNkg3SS5NICYyQFxcXCJcXFwiNkA3QS5BICYyZFxcXCJcXFwiNmQ3ZS41ICYyUlxcXCJcXFwiNlI3Uy4pICYyTlxcXCJcXFwiNk43Ty9cXHg5MiMwXFx4OEYqOykuXFx4ODkgJjJGXFxcIlxcXCI2RjdHLn0gJjJMXFxcIlxcXCI2TDdNLnEgJjJYXFxcIlxcXCI2WDdZLmUgJjJQXFxcIlxcXCI2UDdRLlkgJjJIXFxcIlxcXCI2SDdJLk0gJjJAXFxcIlxcXCI2QDdBLkEgJjJkXFxcIlxcXCI2ZDdlLjUgJjJSXFxcIlxcXCI2UjdTLikgJjJOXFxcIlxcXCI2TjdPJiYmIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJUXFxcIlxcXCI2VDdVLlxceEUzICYyVlxcXCJcXFwiNlY3Vy5cXHhENyAmMmZcXFwiXFxcIjZmN2cuXFx4Q0IgJjJoXFxcIlxcXCI2aDdpLlxceEJGICYyOlxcXCJcXFwiNjo3Oy5cXHhCMyAmMkRcXFwiXFxcIjZEN0UuXFx4QTcgJjIyXFxcIlxcXCI2MjczLlxceDlCICYyOFxcXCJcXFwiNjg3OS5cXHg4RiAmMmpcXFwiXFxcIjZqN2suXFx4ODMgJjsmLn0gJjI0XFxcIlxcXCI2NDc1LnEgJjJsXFxcIlxcXCI2bDdtLmUgJjJuXFxcIlxcXCI2bjdvLlkgJjI2XFxcIlxcXCI2Njc3Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJwXFxcIlxcXCI2cDdxLjUgJjJyXFxcIlxcXCI2cjdzLikgJjsnLiMgJjsoXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7KS5cXHUwMTJCICYyRlxcXCJcXFwiNkY3Ry5cXHUwMTFGICYySlxcXCJcXFwiNko3Sy5cXHUwMTEzICYyTFxcXCJcXFwiNkw3TS5cXHUwMTA3ICYyWFxcXCJcXFwiNlg3WS5cXHhGQiAmMlBcXFwiXFxcIjZQN1EuXFx4RUYgJjJIXFxcIlxcXCI2SDdJLlxceEUzICYyQFxcXCJcXFwiNkA3QS5cXHhENyAmMmRcXFwiXFxcIjZkN2UuXFx4Q0IgJjJSXFxcIlxcXCI2UjdTLlxceEJGICYyTlxcXCJcXFwiNk43Ty5cXHhCMyAmMlRcXFwiXFxcIjZUN1UuXFx4QTcgJjJWXFxcIlxcXCI2VjdXLlxceDlCICYyZlxcXCJcXFwiNmY3Zy5cXHg4RiAmMmhcXFwiXFxcIjZoN2kuXFx4ODMgJjI4XFxcIlxcXCI2ODc5LncgJjJqXFxcIlxcXCI2ajdrLmsgJjsmLmUgJjI0XFxcIlxcXCI2NDc1LlkgJjJsXFxcIlxcXCI2bDdtLk0gJjJuXFxcIlxcXCI2bjdvLkEgJjI2XFxcIlxcXCI2Njc3LjUgJjJwXFxcIlxcXCI2cDdxLikgJjJyXFxcIlxcXCI2cjdzL1xcdTAxMzQjMFxcdTAxMzEqOykuXFx1MDEyQiAmMkZcXFwiXFxcIjZGN0cuXFx1MDExRiAmMkpcXFwiXFxcIjZKN0suXFx1MDExMyAmMkxcXFwiXFxcIjZMN00uXFx1MDEwNyAmMlhcXFwiXFxcIjZYN1kuXFx4RkIgJjJQXFxcIlxcXCI2UDdRLlxceEVGICYySFxcXCJcXFwiNkg3SS5cXHhFMyAmMkBcXFwiXFxcIjZAN0EuXFx4RDcgJjJkXFxcIlxcXCI2ZDdlLlxceENCICYyUlxcXCJcXFwiNlI3Uy5cXHhCRiAmMk5cXFwiXFxcIjZON08uXFx4QjMgJjJUXFxcIlxcXCI2VDdVLlxceEE3ICYyVlxcXCJcXFwiNlY3Vy5cXHg5QiAmMmZcXFwiXFxcIjZmN2cuXFx4OEYgJjJoXFxcIlxcXCI2aDdpLlxceDgzICYyOFxcXCJcXFwiNjg3OS53ICYyalxcXCJcXFwiNmo3ay5rICY7Ji5lICYyNFxcXCJcXFwiNjQ3NS5ZICYybFxcXCJcXFwiNmw3bS5NICYyblxcXCJcXFwiNm43by5BICYyNlxcXCJcXFwiNjY3Ny41ICYycFxcXCJcXFwiNnA3cS4pICYyclxcXCJcXFwiNnI3cyYmJiMvXFxcIiEmLClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyUFxcXCJcXFwiNlA3US8wJDsvLyckOCM6dCMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLz8jMjRcXFwiXFxcIjY0NzUvMCQ7Ly8nJDgjOnUjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly8/IzI+XFxcIlxcXCI2Pjc/LzAkOy8vJyQ4Izp2IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyVFxcXCJcXFwiNlQ3VS8wJDsvLyckOCM6dyMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLz8jMlZcXFwiXFxcIjZWN1cvMCQ7Ly8nJDgjOngjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyaFxcXCJcXFwiNmg3aS8wIzsvLyckOFxcXCI6eVxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vNiMyZlxcXCJcXFwiNmY3Zy8nJDhcXFwiOnpcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLz8jMkRcXFwiXFxcIjZEN0UvMCQ7Ly8nJDgjOnsjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly8/IzIyXFxcIlxcXCI2MjczLzAkOy8vJyQ4Izp8IyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOy8vPyMyOFxcXCJcXFwiNjg3OS8wJDsvLyckOCM6fSMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsvLzAjOyYvJyQ4XFxcIjp+XFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ji8wIzsvLyckOFxcXCI6flxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOz0vVCMkO0cuKSAmO0suIyAmO0YwLyo7Ry4pICY7Sy4jICY7RiYvLCQ7Pi8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiNFxceDdGXFxcIlxcXCI1ITdcXHg4MC5BICY0XFx4ODFcXFwiXFxcIjUhN1xceDgyLjUgJjRcXHg4M1xcXCJcXFwiNSE3XFx4ODQuKSAmOzMuIyAmOy5cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTsvL1EjOyYvSCQkO0ouIyAmO0swKSo7Si4jICY7SyYvLCQ7Ji8jJCskKSgkJyMoIycjKFxcXCInIyYnIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ly9dIzsmL1QkJSQ7Si4jICY7SzApKjtKLiMgJjtLJi9cXFwiISYsKS8xJDsmLygkOCQ6XFx4ODUkISEpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOy4uRyAmMkxcXFwiXFxcIjZMN00uOyAmNFxceDg2XFxcIlxcXCI1ITdcXHg4Ny4vICY0XFx4ODNcXFwiXFxcIjUhN1xceDg0LiMgJjszXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJqXFxcIlxcXCI2ajdrL0ojNFxceDg4XFxcIlxcXCI1ITdcXHg4OS41ICY0XFx4OEFcXFwiXFxcIjUhN1xceDhCLikgJjRcXHg4Q1xcXCJcXFwiNSE3XFx4OEQvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtOL00jMjhcXFwiXFxcIjY4NzkvPiQ7Ty5cXFwiICZcXFwiLzAkO1MvJyQ4JDpcXHg4RSQgKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ti9kIzI4XFxcIlxcXCI2ODc5L1UkO08uXFxcIiAmXFxcIi9HJDtTLz4kO18vNSQ7bC5cXFwiICZcXFwiLyckOCY6XFx4OEYmICkoJicjKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4OTBcXFwiXFxcIjUkN1xceDkxLikgJjNcXHg5MlxcXCJcXFwiNSM3XFx4OTMvJyA4ITpcXHg5NCEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1AvXSMlMjhcXFwiXFxcIjY4NzkvLCM7Ui8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi82JDI6XFxcIlxcXCI2Ojc7LyckOCM6XFx4OTUjICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQ7Ky4pICY7LS4jICY7US8yIzAvKjsrLikgJjstLiMgJjtRJiYmI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjI8XFxcIlxcXCI2PDc9LnEgJjI+XFxcIlxcXCI2Pjc/LmUgJjJAXFxcIlxcXCI2QDdBLlkgJjJCXFxcIlxcXCI2QjdDLk0gJjJEXFxcIlxcXCI2RDdFLkEgJjIyXFxcIlxcXCI2MjczLjUgJjI2XFxcIlxcXCI2Njc3LikgJjI0XFxcIlxcXCI2NDc1XCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7Ky5fICY7LS5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RTBlKjsrLl8gJjstLlkgJjI8XFxcIlxcXCI2PDc9Lk0gJjI+XFxcIlxcXCI2Pjc/LkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJCXFxcIlxcXCI2QjdDLikgJjJEXFxcIlxcXCI2RDdFJi8mIDghOlxceDk2ISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtUL0ojJTI4XFxcIlxcXCI2ODc5LywjO14vIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtVLikgJjtcXFxcLiMgJjtYLyYgOCE6XFx4OTchIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJCU7Vi8yIzJKXFxcIlxcXCI2SjdLLyMkK1xcXCIpKFxcXCInIyYnIzA8KiU7Vi8yIzJKXFxcIlxcXCI2SjdLLyMkK1xcXCIpKFxcXCInIyYnIyYvRCM7Vy87JDJKXFxcIlxcXCI2SjdLLlxcXCIgJlxcXCIvJyQ4IzpcXHg5OCMgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDRcXHg5OVxcXCJcXFwiNSE3XFx4OUEvLCMwKSo0XFx4OTlcXFwiXFxcIjUhN1xceDlBJiYmI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU0JFxcXCJcXFwiNSE3JS8/IyQ0XFx4OUJcXFwiXFxcIjUhN1xceDlDMCkqNFxceDlCXFxcIlxcXCI1ITdcXHg5QyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJsXFxcIlxcXCI2bDdtLz8jO1kvNiQyblxcXCJcXFwiNm43by8nJDgjOlxceDlEIyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTtaL1xceEIzIzI4XFxcIlxcXCI2ODc5L1xceEE0JDtaL1xceDlCJDI4XFxcIlxcXCI2ODc5L1xceDhDJDtaL1xceDgzJDI4XFxcIlxcXCI2ODc5L3QkO1ovayQyOFxcXCJcXFwiNjg3OS9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrLSkoLScjKCwnIygrJyMoKicjKCknIygoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDc5MCAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xceEE0IztaL1xceDlCJDI4XFxcIlxcXCI2ODc5L1xceDhDJDtaL1xceDgzJDI4XFxcIlxcXCI2ODc5L3QkO1ovayQyOFxcXCJcXFwiNjg3OS9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrLCkoLCcjKCsnIygqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNkY5ICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvXFx4OEMjO1ovXFx4ODMkMjhcXFwiXFxcIjY4NzkvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsqKSgqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNjdBICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvdCM7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsoKSgoJyMoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDYxMyAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL1xcXFwjO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsmKSgmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLlxcdTA1QzQgJiUyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9EIztaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCskKSgkJyMoIycjKFxcXCInIyYnIy5cXHUwNThEICYlMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvLCM7Wy8jJCtcXFwiKShcXFwiJyMmJyMuXFx1MDU2RSAmJTJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGLywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcdTA1NEYgJiU7Wi9cXHg5QiMyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9cXHg4QyQ7Wi9cXHg4MyQyOFxcXCJcXFwiNjg3OS90JDtaL2skMjhcXFwiXFxcIjY4NzkvXFxcXCQ7Wi9TJDI4XFxcIlxcXCI2ODc5L0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKyspKCsnIygqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNEM3ICYlO1ovXFx4QUEjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4ODMkMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvdCQ7Wi9rJDI4XFxcIlxcXCI2ODc5L1xcXFwkO1ovUyQyOFxcXCJcXFwiNjg3OS9EJDtaLzskMjhcXFwiXFxcIjY4NzkvLCQ7Wy8jJCsqKSgqJyMoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwNDMwICYlO1ovXFx4QjkjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4OTIkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvayQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri9cXFxcJDtaL1MkMjhcXFwiXFxcIjY4NzkvRCQ7Wi87JDI4XFxcIlxcXCI2ODc5LywkO1svIyQrKSkoKScjKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMzhBICYlO1ovXFx4QzgjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4QTEkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIveiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9TJDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGL0QkO1ovOyQyOFxcXCJcXFwiNjg3OS8sJDtbLyMkKygpKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMkQ1ICYlO1ovXFx4RDcjJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4QjAkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvXFx4ODkkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvYiQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi87JDJcXHg5RVxcXCJcXFwiNlxceDlFN1xceDlGLywkO1svIyQrJykoJycjKCYnIyglJyMoJCcjKCMnIyhcXFwiJyMmJyMuXFx1MDIxMSAmJTtaL1xceEZFIyUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEQ3JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceEIwJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL1xceDg5JCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiL2IkJTI4XFxcIlxcXCI2ODc5LywjO1ovIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvOyQyXFx4OUVcXFwiXFxcIjZcXHg5RTdcXHg5Ri8sJDtaLyMkKygpKCgnIygnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnIy5cXHUwMTI2ICYlO1ovXFx1MDExQyMlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhGNSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhDRSQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHhBNyQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9cXHg4MCQlMjhcXFwiXFxcIjY4NzkvLCM7Wi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi9ZJCUyOFxcXCJcXFwiNjg3OS8sIztaLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLzIkMlxceDlFXFxcIlxcXCI2XFx4OUU3XFx4OUYvIyQrKCkoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjLyYgOCE6XFx4QTAhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOyMvTSM7Iy5cXFwiICZcXFwiLz8kOyMuXFxcIiAmXFxcIi8xJDsjLlxcXCIgJlxcXCIvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1ovOyMyOFxcXCJcXFwiNjg3OS8sJDtaLyMkKyMpKCMnIyhcXFwiJyMmJyMuIyAmO1xcXFxcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO10vbyMySlxcXCJcXFwiNko3Sy9gJDtdL1ckMkpcXFwiXFxcIjZKN0svSCQ7XS8/JDJKXFxcIlxcXCI2SjdLLzAkO10vJyQ4JzpcXHhBMScgKSgnJyMoJicjKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyXFx4QTJcXFwiXFxcIjZcXHhBMjdcXHhBMy8yIzRcXHhBNFxcXCJcXFwiNSE3XFx4QTUvIyQrXFxcIikoXFxcIicjJicjLlxceDk4ICYlMlxceEE2XFxcIlxcXCI2XFx4QTY3XFx4QTcvOyM0XFx4QThcXFwiXFxcIjUhN1xceEE5LywkOyEvIyQrIykoIycjKFxcXCInIyYnIy5qICYlMlxceEFBXFxcIlxcXCI2XFx4QUE3XFx4QUIvNSM7IS8sJDshLyMkKyMpKCMnIyhcXFwiJyMmJyMuQiAmJTRcXHhBQ1xcXCJcXFwiNSE3XFx4QUQvLCM7IS8jJCtcXFwiKShcXFwiJyMmJyMuIyAmOyFcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTshLlxcXCIgJlxcXCIvWyM7IS5cXFwiICZcXFwiL00kOyEuXFxcIiAmXFxcIi8/JDshLlxcXCIgJlxcXCIvMSQ7IS5cXFwiICZcXFwiLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnIy8nIDghOlxceEFFISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQlMjJcXFwiXFxcIjYyNzMvLCM7YC8jJCtcXFwiKShcXFwiJyMmJyMwPColMjJcXFwiXFxcIjYyNzMvLCM7YC8jJCtcXFwiKShcXFwiJyMmJyMmXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO2EuQSAmO2IuOyAmO2MuNSAmO2QuLyAmO2UuKSAmO2YuIyAmO2dcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEFGXFxcIlxcXCI1KjdcXHhCMC9hIzNcXHhCMVxcXCJcXFwiNSM3XFx4QjIuRyAmM1xceEIzXFxcIlxcXCI1IzdcXHhCNC47ICYzXFx4QjVcXFwiXFxcIjUkN1xceEI2Li8gJjNcXHhCN1xcXCJcXFwiNSM3XFx4QjguIyAmOzYvKCQ4XFxcIjpcXHhCOVxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhCQVxcXCJcXFwiNSU3XFx4QkIvSSMzXFx4QkNcXFwiXFxcIjUlN1xceEJELi8gJjNcXHhCRVxcXCJcXFwiNVxcXCI3XFx4QkYuIyAmOzYvKCQ4XFxcIjpcXHhDMFxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhDMVxcXCJcXFwiNSc3XFx4QzIvMSM7XFx4OTAvKCQ4XFxcIjpcXHhDM1xcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhDNFxcXCJcXFwiNSQ3XFx4QzUvMSM7XFx4RjAvKCQ4XFxcIjpcXHhDNlxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhDN1xcXCJcXFwiNSY3XFx4QzgvMSM7VC8oJDhcXFwiOlxceEM5XFxcIiEgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceENBXFxcIlxcXCI1XFxcIjdcXHhDQi9OIyUyPlxcXCJcXFwiNj43Py8sIzs2LyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyckOFxcXCI6XFx4Q0NcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtoL1AjJTI+XFxcIlxcXCI2Pjc/LywjO2kvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvKSQ4XFxcIjpcXHhDRFxcXCJcXFwiISApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkO2ovJiMwIyo7aiYmJiMvXFxcIiEmLClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDtqLyYjMCMqO2omJiYjL1xcXCIhJiwpXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO2suKSAmOysuIyAmOy1cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIybFxcXCJcXFwiNmw3bS5lICYyblxcXCJcXFwiNm43by5ZICYyNFxcXCJcXFwiNjQ3NS5NICYyOFxcXCJcXFwiNjg3OS5BICYyPFxcXCJcXFwiNjw3PS41ICYyQFxcXCJcXFwiNkA3QS4pICYyQlxcXCJcXFwiNkI3Q1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyNlxcXCJcXFwiNjY3Ny9uIzttL2UkJCUyPFxcXCJcXFwiNjw3PS8sIzttLyMkK1xcXCIpKFxcXCInIyYnIzA8KiUyPFxcXCJcXFwiNjw3PS8sIzttLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7bi9BIzI+XFxcIlxcXCI2Pjc/LzIkO28vKSQ4IzpcXHhDRSNcXFwiXFxcIiApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkO3AuKSAmOysuIyAmOy0vMiMwLyo7cC4pICY7Ky4jICY7LSYmJiNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkO3AuKSAmOysuIyAmOy0wLyo7cC4pICY7Ky4jICY7LSZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIybFxcXCJcXFwiNmw3bS5lICYyblxcXCJcXFwiNm43by5ZICYyNFxcXCJcXFwiNjQ3NS5NICYyNlxcXCJcXFwiNjY3Ny5BICYyOFxcXCJcXFwiNjg3OS41ICYyQFxcXCJcXFwiNkA3QS4pICYyQlxcXCJcXFwiNkI3Q1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHg5MS4jICY7clwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OTAvRyM7Jy8+JDtzLzUkOycvLCQ7XFx4ODQvIyQrJSkoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO00uIyAmO3RcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDdGL0UjMjhcXFwiXFxcIjY4NzkvNiQ7dS4jICY7eC8nJDgjOlxceENGIyApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO3YuIyAmO3cvSiMlMjZcXFwiXFxcIjY2NzcvLCM7XFx4ODMvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTJcXHhEMFxcXCJcXFwiNlxceEQwN1xceEQxLzojO1xceDgwLzEkO3cuXFxcIiAmXFxcIi8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTI0XFxcIlxcXCI2NDc1LywjO3svIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTt6LzMjJDt5MCMqO3kmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjsqLikgJjsrLiMgJjstXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOysuXFx4OEYgJjstLlxceDg5ICYyMlxcXCJcXFwiNjI3My59ICYyNlxcXCJcXFwiNjY3Ny5xICYyOFxcXCJcXFwiNjg3OS5lICYyOlxcXCJcXFwiNjo3Oy5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7fC9lIyQlMjRcXFwiXFxcIjY0NzUvLCM7fC8jJCtcXFwiKShcXFwiJyMmJyMwPColMjRcXFwiXFxcIjY0NzUvLCM7fC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkO34wIyo7fiYvZSMkJTIyXFxcIlxcXCI2MjczLywjO30vIyQrXFxcIikoXFxcIicjJicjMDwqJTIyXFxcIlxcXCI2MjczLywjO30vIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIkO34wIyo7fiZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Ky53ICY7LS5xICYyOFxcXCJcXFwiNjg3OS5lICYyOlxcXCJcXFwiNjo3Oy5ZICYyPFxcXCJcXFwiNjw3PS5NICYyPlxcXCJcXFwiNj43Py5BICYyQFxcXCJcXFwiNkA3QS41ICYyQlxcXCJcXFwiNkI3Qy4pICYyRFxcXCJcXFwiNkQ3RVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlO1xcXCIvXFx4ODcjJDtcXFwiLkcgJjshLkEgJjJAXFxcIlxcXCI2QDdBLjUgJjJGXFxcIlxcXCI2RjdHLikgJjJKXFxcIlxcXCI2SjdLME0qO1xcXCIuRyAmOyEuQSAmMkBcXFwiXFxcIjZAN0EuNSAmMkZcXFwiXFxcIjZGN0cuKSAmMkpcXFwiXFxcIjZKN0smLyMkK1xcXCIpKFxcXCInIyYnIy8mIDghOlxceEQyISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceDgxLiMgJjtcXHg4MlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlO08vMiMyOlxcXCJcXFwiNjo3Oy8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8sIztTLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDsrLlxceDgzICY7LS59ICYyQlxcXCJcXFwiNkI3Qy5xICYyRFxcXCJcXFwiNkQ3RS5lICYyMlxcXCJcXFwiNjI3My5ZICYyOFxcXCJcXFwiNjg3OS5NICYyOlxcXCJcXFwiNjo3Oy5BICYyPFxcXCJcXFwiNjw3PS41ICYyPlxcXCJcXFwiNj43Py4pICYyQFxcXCJcXFwiNkA3QS9cXHg4QyMwXFx4ODkqOysuXFx4ODMgJjstLn0gJjJCXFxcIlxcXCI2QjdDLnEgJjJEXFxcIlxcXCI2RDdFLmUgJjIyXFxcIlxcXCI2MjczLlkgJjI4XFxcIlxcXCI2ODc5Lk0gJjI6XFxcIlxcXCI2Ojc7LkEgJjI8XFxcIlxcXCI2PDc9LjUgJjI+XFxcIlxcXCI2Pjc/LikgJjJAXFxcIlxcXCI2QDdBJiYmI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiQ7eTAjKjt5JlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4OTJcXFwiXFxcIjUjN1xceEQzL3EjMjRcXFwiXFxcIjY0NzUvYiQkOyEvJiMwIyo7ISYmJiMvTCQySlxcXCJcXFwiNko3Sy89JCQ7IS8mIzAjKjshJiYmIy8nJDglOlxceEQ0JSApKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhENVxcXCJcXFwiNlxceEQ1N1xceEQ2XCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEQ3XFxcIlxcXCI2XFx4RDc3XFx4RDhcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RDlcXFwiXFxcIjZcXHhEOTdcXHhEQVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhEQlxcXCJcXFwiNlxceERCN1xceERDXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEREXFxcIlxcXCI2XFx4REQ3XFx4REVcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4REZcXFwiXFxcIjZcXHhERjdcXHhFMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhFMVxcXCJcXFwiNlxceEUxN1xceEUyXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEUzXFxcIlxcXCI2XFx4RTM3XFx4RTRcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIyXFx4RTVcXFwiXFxcIjZcXHhFNTdcXHhFNlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJcXHhFN1xcXCJcXFwiNlxceEU3N1xceEU4XCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiMlxceEU5XFxcIlxcXCI2XFx4RTk3XFx4RUFcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDg1LlkgJjtcXHg4Ni5TICY7XFx4ODguTSAmO1xceDg5LkcgJjtcXHg4QS5BICY7XFx4OEIuOyAmO1xceDhDLjUgJjtcXHg4Ri4vICY7XFx4OEQuKSAmO1xceDhFLiMgJjs2LyYgOCE6XFx4RUIhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDg0L0cjOycvPiQ7XFx4OTIvNSQ7Jy8sJDtcXHg5NC8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDkzLycgOCE6XFx4RUMhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTshLzUjOyEvLCQ7IS8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSQ7Ki5BICY7Ky47ICY7LS41ICY7My4vICY7NC4pICY7Jy4jICY7KDBHKjsqLkEgJjsrLjsgJjstLjUgJjszLi8gJjs0LikgJjsnLiMgJjsoJi8mIDghOlxceEVEISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhCNi9ZIyQlO0EvLCM7XFx4QjYvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEI2LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs5L04jJTI6XFxcIlxcXCI2Ojc7LywjOzkvIyQrXFxcIikoXFxcIicjJicjLlxcXCIgJlxcXCIvJyQ4XFxcIjpcXHhFRVxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzouYyAmJTtcXHg5OC9ZIyQlO0EvLCM7XFx4OTgvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceDk4LyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrXFxcIikoXFxcIicjJicjLyYgOCE6XFx4RUYhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO0wuIyAmO1xceDk5L10jJCU7Qi8sIztcXHg5Qi8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4OUIvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxceEYwXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OUEuXFxcIiAmXFxcIi8+IztALzUkO00vLCQ7Py8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOzYvWSMkJTsuLywjOzYvIyQrXFxcIikoXFxcIicjJicjMDYqJTsuLywjOzYvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyMuIyAmO0gvJyA4ITpcXHhGMSEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4OUMuKSAmO1xceDlELiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4RjJcXFwiXFxcIjUhN1xceEYzLzojOzwvMSQ7XFx4OUYvKCQ4IzpcXHhGNCMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4RjVcXFwiXFxcIjUnN1xceEY2LzojOzwvMSQ7XFx4OUUvKCQ4IzpcXHhGNyMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHhGOCEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMlxceEY5XFxcIlxcXCI2XFx4Rjk3XFx4RkEvbyMlMkpcXFwiXFxcIjZKN0svTSM7IS5cXFwiICZcXFwiLz8kOyEuXFxcIiAmXFxcIi8xJDshLlxcXCIgJlxcXCIvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyMuXFxcIiAmXFxcIi8nJDhcXFwiOlxceEZCXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ni9KIyU7PC8sIztcXHhBMS8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8pJDhcXFwiOlxceEZDXFxcIlxcXCIhICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOzYuKSAmO1QuIyAmO0hcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEEzL1kjJCU7Qi8sIztcXHhBNC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTQvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEZEXFxcIlxcXCI1JjdcXHhGRS5HICYzXFx4RkZcXFwiXFxcIjUnN1xcdTAxMDAuOyAmM1xcdTAxMDFcXFwiXFxcIjUkN1xcdTAxMDIuLyAmM1xcdTAxMDNcXFwiXFxcIjUlN1xcdTAxMDQuIyAmOzYvJiA4ITpcXHUwMTA1ISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEE1LiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEwNlxcXCJcXFwiNSg3XFx1MDEwNy9NIzs8L0QkM1xcdTAxMDhcXFwiXFxcIjUoN1xcdTAxMDkuLyAmM1xcdTAxMEFcXFwiXFxcIjUoN1xcdTAxMEIuIyAmOzYvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ni9ZIyQlO0EvLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTBDISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4QTkvJiA4ITpcXHUwMTBEISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhBQS9rIzs7L2IkO1xceEFGL1kkJCU7Qi8sIztcXHhCMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QjAvIyQrXFxcIikoXFxcIicjJicjJi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhBQi4jICY7XFx4QUNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIzXFx1MDEwRVxcXCJcXFwiNSQ3XFx1MDEwRi5TICYzXFx1MDExMFxcXCJcXFwiNSU3XFx1MDExMS5HICYzXFx1MDExMlxcXCJcXFwiNSU3XFx1MDExMy47ICYzXFx1MDExNFxcXCJcXFwiNSU3XFx1MDExNS4vICYzXFx1MDExNlxcXCJcXFwiNSs3XFx1MDExNy4jICY7XFx4QURcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIzXFx1MDExOFxcXCJcXFwiNSc3XFx1MDExOS4vICYzXFx1MDExQVxcXCJcXFwiNSk3XFx1MDExQi4jICY7XFx4QURcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7Ni4jICY7XFx4QUVcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMUNcXFwiXFxcIjVcXFwiN1xcdTAxMUQvLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4QUQuIyAmOzZcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzYvNSM7PC8sJDtcXHhCMS8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOzYuIyAmO0hcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEIzLzUjOy4vLCQ7XFx4OTAvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTFFISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OUUvJyA4ITpcXHUwMTFGISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4QjYvXiMkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLygkOFxcXCI6XFx1MDEyMFxcXCIhISkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7Ny9lIyQlMkpcXFwiXFxcIjZKN0svLCM7Ny8jJCtcXFwiKShcXFwiJyMmJyMwPColMkpcXFwiXFxcIjZKN0svLCM7Ny8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnIy9cXFwiISYsKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7TC4jICY7XFx4OTkvXSMkJTtCLywjO1xceEI4LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhCOC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDEyMVxcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4QjkuIyAmO1xceEEwXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTIyXFxcIlxcXCI1IzdcXHUwMTIzLzojOzwvMSQ7Ni8oJDgjOlxcdTAxMjQjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDshLyYjMCMqOyEmJiYjLycgOCE6XFx1MDEyNSEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDlFLycgOCE6XFx1MDEyNiEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJDtcXHg5QTAjKjtcXHg5QSYveCM7QC9vJDtNL2YkOz8vXSQkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyckOCU6XFx1MDEyNyUgKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFx4QkVcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMjhcXFwiXFxcIjUmN1xcdTAxMjkvayM7Li9iJDtcXHhDMS9ZJCQlO0EvLCM7XFx4QzEvIyQrXFxcIikoXFxcIicjJicjMDYqJTtBLywjO1xceEMxLyMkK1xcXCIpKFxcXCInIyYnIyYvIyQrJCkoJCcjKCMnIyhcXFwiJyMmJyMuIyAmO1xceEJGXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs2L2sjOy4vYiQ7XFx4QzAvWSQkJTtBLywjO1xceEMwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhDMC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTs2LzsjOzwvMiQ7Ni4jICY7SC8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEMyLkcgJjtcXHhDNC5BICY7XFx4QzYuOyAmO1xceEM4LjUgJjtcXHhDOS4vICY7XFx4Q0EuKSAmO1xceENCLiMgJjtcXHhDMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEyQVxcXCJcXFwiNSU3XFx1MDEyQi81Izs8LywkO1xceEMzLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO0kvJyA4ITpcXHUwMTJDISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEyRFxcXCJcXFwiNSY3XFx1MDEyRS9cXHg5NyM7PC9cXHg4RSQ7RC9cXHg4NSQ7XFx4QzUvfCQkJSQ7Jy8mIzAjKjsnJiYmIy8sIztcXHhDNS8jJCtcXFwiKShcXFwiJyMmJyMwQyolJDsnLyYjMCMqOycmJiYjLywjO1xceEM1LyMkK1xcXCIpKFxcXCInIyYnIyYvLCQ7RS8jJCsmKSgmJyMoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO3QuIyAmO3dcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMkZcXFwiXFxcIjUlN1xcdTAxMzAvNSM7PC8sJDtcXHhDNy8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtJLycgOCE6XFx1MDEzMSEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxMzJcXFwiXFxcIjUmN1xcdTAxMzMvOiM7PC8xJDtJLygkOCM6XFx1MDEzNCMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDEzNVxcXCJcXFwiNSU3XFx1MDEzNi9dIzs8L1QkJTNcXHUwMTM3XFxcIlxcXCI1JDdcXHUwMTM4LyYgOCE6XFx1MDEzOSEgKS40ICYlM1xcdTAxM0FcXFwiXFxcIjUlN1xcdTAxM0IvJiA4ITpcXHUwMTNDISApLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxM0RcXFwiXFxcIjUpN1xcdTAxM0UvUiM7PC9JJDNcXHUwMTNGXFxcIlxcXCI1IzdcXHUwMTQwLi8gJjNcXHUwMTQxXFxcIlxcXCI1KDdcXHUwMTQyLiMgJjs2LygkOCM6XFx1MDE0MyMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE0NFxcXCJcXFwiNSM3XFx1MDE0NS9cXHg5MyM7PC9cXHg4QSQ7RC9cXHg4MSQlO1xceENDL2UjJCUyRFxcXCJcXFwiNkQ3RS8sIztcXHhDQy8jJCtcXFwiKShcXFwiJyMmJyMwPColMkRcXFwiXFxcIjZEN0UvLCM7XFx4Q0MvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyMvLCQ7RS8jJCslKSglJyMoJCcjKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxNDZcXFwiXFxcIjUoN1xcdTAxNDcuLyAmM1xcdTAxNDhcXFwiXFxcIjUkN1xcdTAxNDkuIyAmOzYvJyA4ITpcXHUwMTRBISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7Ni9ZIyQlO0EvLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7Ni8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4Q0YvRyM7Li8+JDtcXHhDRi81JDsuLywkO1xceDkwLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTRCISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RDEvXSMkJTtBLywjO1xceEQxLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhEMS8jJCtcXFwiKShcXFwiJyMmJyMmLyckOFxcXCI6XFx1MDE0Q1xcXCIgKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceDk5L10jJCU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxNERcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtMLk8gJjtcXHg5OS5JICYlO0AuXFxcIiAmXFxcIi86Izt0LzEkOz8uXFxcIiAmXFxcIi8jJCsjKSgjJyMoXFxcIicjJicjL10jJCU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8nJDhcXFwiOlxcdTAxNEVcXFwiICkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhENC9dIyQlO0IvLCM7XFx4RDUvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEQ1LyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTRGXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OTYvJiA4ITpcXHUwMTUwISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTUxXFxcIlxcXCI1KDdcXHUwMTUyLzojOzwvMSQ7Ni8oJDgjOlxcdTAxNTMjISApKCMnIyhcXFwiJyMmJyMuZyAmJTNcXHUwMTU0XFxcIlxcXCI1JjdcXHUwMTU1LzojOzwvMSQ7Ni8oJDgjOlxcdTAxNTYjISApKCMnIyhcXFwiJyMmJyMuOiAmJTNcXHUwMTU3XFxcIlxcXCI1KjdcXHUwMTU4LyYgOCE6XFx1MDE1OSEgKS4jICY7XFx4QTBcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTs2L2sjJCU7QS8yIzs2LykkOFxcXCI6XFx1MDE1QVxcXCJcXFwiJCApKFxcXCInIyYnIzA8KiU7QS8yIzs2LykkOFxcXCI6XFx1MDE1QVxcXCJcXFwiJCApKFxcXCInIyYnIyYvKSQ4XFxcIjpcXHUwMTVCXFxcIlxcXCIhICkoXFxcIicjJicjLlxcXCIgJlxcXCIvJyA4ITpcXHUwMTVDISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RDgvWSMkJTtBLywjO1xceEQ4LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7QS8sIztcXHhEOC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OTkvWSMkJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUkOyEvJiMwIyo7ISYmJiMvJyA4ITpcXHUwMTVEISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4REIvWSMkJTtCLywjO1xceERDLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhEQy8jJCtcXFwiKShcXFwiJyMmJyMmLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE1RVxcXCJcXFwiNSY3XFx1MDE1Ri47ICYzXFx1MDE2MFxcXCJcXFwiNSc3XFx1MDE2MS4vICYzXFx1MDE2MlxcXCJcXFwiNSo3XFx1MDE2My4jICY7Ni8mIDghOlxcdTAxNjQhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxNjVcXFwiXFxcIjUmN1xcdTAxNjYvOiM7PC8xJDtcXHhERC8oJDgjOlxcdTAxNjcjISApKCMnIyhcXFwiJyMmJyMufSAmJTNcXHhGNVxcXCJcXFwiNSc3XFx4RjYvOiM7PC8xJDtcXHg5RS8oJDgjOlxcdTAxNjgjISApKCMnIyhcXFwiJyMmJyMuUCAmJTNcXHUwMTY5XFxcIlxcXCI1KzdcXHUwMTZBLzojOzwvMSQ7XFx4OUUvKCQ4IzpcXHUwMTZCIyEgKSgjJyMoXFxcIicjJicjLiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjNcXHUwMTZDXFxcIlxcXCI1KzdcXHUwMTZELmsgJjNcXHUwMTZFXFxcIlxcXCI1KTdcXHUwMTZGLl8gJjNcXHUwMTcwXFxcIlxcXCI1KDdcXHUwMTcxLlMgJjNcXHUwMTcyXFxcIlxcXCI1JzdcXHUwMTczLkcgJjNcXHUwMTc0XFxcIlxcXCI1JjdcXHUwMTc1LjsgJjNcXHUwMTc2XFxcIlxcXCI1KjdcXHUwMTc3Li8gJjNcXHUwMTc4XFxcIlxcXCI1KTdcXHUwMTc5LiMgJjs2XCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiOzEuXFxcIiAmXFxcIlwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUlOzYvayMkJTtBLzIjOzYvKSQ4XFxcIjpcXHUwMTVBXFxcIlxcXCIkICkoXFxcIicjJicjMDwqJTtBLzIjOzYvKSQ4XFxcIjpcXHUwMTVBXFxcIlxcXCIkICkoXFxcIicjJicjJi8pJDhcXFwiOlxcdTAxNUJcXFwiXFxcIiEgKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8nIDghOlxcdTAxN0EhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtMLiMgJjtcXHg5OS9dIyQlO0IvLCM7XFx4RTEvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEUxLyMkK1xcXCIpKFxcXCInIyYnIyYvJyQ4XFxcIjpcXHUwMTdCXFxcIiApKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhCOS4jICY7XFx4QTBcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEUzL1kjJCU7QS8sIztcXHhFMy8jJCtcXFwiKShcXFwiJyMmJyMwNiolO0EvLCM7XFx4RTMvIyQrXFxcIikoXFxcIicjJicjJi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEVBL2sjOy4vYiQ7XFx4RUQvWSQkJTtCLywjO1xceEU0LyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhFNC8jJCtcXFwiKShcXFwiJyMmJyMmLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEU1LjsgJjtcXHhFNi41ICY7XFx4RTcuLyAmO1xceEU4LikgJjtcXHhFOS4jICY7XFx4QTBcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxN0NcXFwiXFxcIjUjN1xcdTAxN0QvOiM7PC8xJDtcXHhGMC8oJDgjOlxcdTAxN0UjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxN0ZcXFwiXFxcIjUlN1xcdTAxODAvOiM7PC8xJDtULygkOCM6XFx1MDE4MSMhICkoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDE4MlxcXCJcXFwiNSg3XFx1MDE4My9GIzs8Lz0kO1xcXFwuKSAmO1kuIyAmO1gvKCQ4IzpcXHUwMTg0IyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHUwMTg1XFxcIlxcXCI1JjdcXHUwMTg2LzojOzwvMSQ7Ni8oJDgjOlxcdTAxODcjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxODhcXFwiXFxcIjUlN1xcdTAxODkvQSM7PC84JCQ7ITAjKjshJi8oJDgjOlxcdTAxOEEjISApKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEVCL0cjOzsvPiQ7Ni81JDs7LywkO1xceEVDLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx4OTJcXFwiXFxcIjUjN1xceEQzLiMgJjs2LycgOCE6XFx1MDE4QiEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xceEIxXFxcIlxcXCI1IzdcXHUwMThDLkcgJjNcXHhCM1xcXCJcXFwiNSM3XFx1MDE4RC47ICYzXFx4QjdcXFwiXFxcIjUjN1xcdTAxOEUuLyAmM1xceEI1XFxcIlxcXCI1JDdcXHUwMThGLiMgJjs2LycgOCE6XFx1MDE5MCEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xceEVFL0QjJTtDLywjO1xceEVGLyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyMkK1xcXCIpKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7VS4pICY7XFxcXC4jICY7WC8mIDghOlxcdTAxOTEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlJTshLlxcXCIgJlxcXCIvWyM7IS5cXFwiICZcXFwiL00kOyEuXFxcIiAmXFxcIi8/JDshLlxcXCIgJlxcXCIvMSQ7IS5cXFwiICZcXFwiLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnIy8nIDghOlxcdTAxOTIhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJSU7IS8/IzshLlxcXCIgJlxcXCIvMSQ7IS5cXFwiICZcXFwiLyMkKyMpKCMnIyhcXFwiJyMmJyMvJyA4ITpcXHUwMTkzISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHhCRVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4OUUvXiMkJTtCLywjO1xceEYzLyMkK1xcXCIpKFxcXCInIyYnIzA2KiU7Qi8sIztcXHhGMy8jJCtcXFwiKShcXFwiJyMmJyMmLygkOFxcXCI6XFx1MDE5NFxcXCIhISkoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiO1xceEY0LiMgJjtcXHhBMFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyXFx1MDE5NVxcXCJcXFwiNlxcdTAxOTU3XFx1MDE5Ni9MIzs8L0MkMlxcdTAxOTdcXFwiXFxcIjZcXHUwMTk3N1xcdTAxOTguKSAmMlxcdTAxOTlcXFwiXFxcIjZcXHUwMTk5N1xcdTAxOUEvKCQ4IzpcXHUwMTlCIyEgKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHg5RS9eIyQlO0IvLCM7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjMDYqJTtCLywjO1xceEEwLyMkK1xcXCIpKFxcXCInIyYnIyYvKCQ4XFxcIjpcXHUwMTlDXFxcIiEhKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlOzYvNSM7MC8sJDtcXHhGNy8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDsyLikgJjs0LiMgJjsuMC8qOzIuKSAmOzQuIyAmOy4mXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJDslMCMqOyUmXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHhGQS87IzI4XFxcIlxcXCI2ODc5LywkO1xceEZCLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlM1xcdTAxOURcXFwiXFxcIjUlN1xcdTAxOUUuKSAmM1xcdTAxOUZcXFwiXFxcIjUkN1xcdTAxQTAvJyA4ITpcXHUwMUExISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx4RkMvSiMlMjhcXFwiXFxcIjY4NzkvLCM7Xi8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCtcXFwiKShcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xcXFwuKSAmO1guIyAmO1xceDgyLycgOCE6XFx1MDFBMiEhIClcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCI7XFxcIi5TICY7IS5NICYyRlxcXCJcXFwiNkY3Ry5BICYySlxcXCJcXFwiNko3Sy41ICYySFxcXCJcXFwiNkg3SS4pICYyTlxcXCJcXFwiNk43T1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjJMXFxcIlxcXCI2TDdNLlxceDk1ICYyQlxcXCJcXFwiNkI3Qy5cXHg4OSAmMjxcXFwiXFxcIjY8Nz0ufSAmMlJcXFwiXFxcIjZSN1MucSAmMlRcXFwiXFxcIjZUN1UuZSAmMlZcXFwiXFxcIjZWN1cuWSAmMlBcXFwiXFxcIjZQN1EuTSAmMkBcXFwiXFxcIjZAN0EuQSAmMkRcXFwiXFxcIjZEN0UuNSAmMjJcXFwiXFxcIjYyNzMuKSAmMj5cXFwiXFxcIjY+Nz9cIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlO1xcdTAxMDAvYiMyOFxcXCJcXFwiNjg3OS9TJDtcXHhGQi9KJCUyXFx1MDFBM1xcXCJcXFwiNlxcdTAxQTM3XFx1MDFBNC8sIztcXHhFQy8jJCtcXFwiKShcXFwiJyMmJyMuXFxcIiAmXFxcIi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUzXFx1MDFBNVxcXCJcXFwiNSU3XFx1MDFBNi4pICYzXFx1MDFBN1xcXCJcXFwiNSQ3XFx1MDFBOC8nIDghOlxcdTAxQTEhISApXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTNcXHhCMVxcXCJcXFwiNSM3XFx4QjIuNiAmM1xceEIzXFxcIlxcXCI1IzdcXHhCNC4qICYkOyswIyo7KyYvJyA4ITpcXHUwMUE5ISEgKVwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7XFx1MDEwNC9cXHg4NyMyRlxcXCJcXFwiNkY3Ry94JDtcXHUwMTAzL28kMkZcXFwiXFxcIjZGN0cvYCQ7XFx1MDEwMy9XJDJGXFxcIlxcXCI2RjdHL0gkO1xcdTAxMDMvPyQyRlxcXCJcXFwiNkY3Ry8wJDtcXHUwMTA1LyckOCk6XFx1MDFBQSkgKSgpJyMoKCcjKCcnIygmJyMoJScjKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTsjLz4jOyMvNSQ7Iy8sJDsjLyMkKyQpKCQnIygjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHUwMTAzLywjO1xcdTAxMDMvIyQrXFxcIikoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtcXHUwMTAzLzUjO1xcdTAxMDMvLCQ7XFx1MDEwMy8jJCsjKSgjJyMoXFxcIicjJicjXCIpLFxuICAgICAgICBwZWckZGVjb2RlKFwiJTtxL1QjJDttMCMqO20mL0QkJTsgLywjO1xceEY4LyMkK1xcXCIpKFxcXCInIyYnIy5cXFwiICZcXFwiLyMkKyMpKCMnIyhcXFwiJyMmJyNcIiksXG4gICAgICAgIHBlZyRkZWNvZGUoXCIlMlxcdTAxQUJcXFwiXFxcIjZcXHUwMUFCN1xcdTAxQUMuKSAmMlxcdTAxQURcXFwiXFxcIjZcXHUwMUFEN1xcdTAxQUUvdyM7MC9uJDtcXHUwMTA4L2UkJCU7Qi8yIztcXHUwMTA5LiMgJjtcXHhBMC8jJCtcXFwiKShcXFwiJyMmJyMwPColO0IvMiM7XFx1MDEwOS4jICY7XFx4QTAvIyQrXFxcIikoXFxcIicjJicjJi8jJCskKSgkJyMoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIjtcXHg5OS4jICY7TFwiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiUyXFx1MDFBRlxcXCJcXFwiNlxcdTAxQUY3XFx1MDFCMC81Izs8LywkO1xcdTAxMEEvIyQrIykoIycjKFxcXCInIyYnI1wiKSxcbiAgICAgICAgcGVnJGRlY29kZShcIiU7RC9TIzssL0okMjpcXFwiXFxcIjY6NzsvOyQ7LC4jICY7VC8sJDtFLyMkKyUpKCUnIygkJyMoIycjKFxcXCInIyYnI1wiKVxuICAgIF07XG4gICAgdmFyIHBlZyRjdXJyUG9zID0gMDtcbiAgICB2YXIgcGVnJHNhdmVkUG9zID0gMDtcbiAgICB2YXIgcGVnJHBvc0RldGFpbHNDYWNoZSA9IFt7IGxpbmU6IDEsIGNvbHVtbjogMSB9XTtcbiAgICB2YXIgcGVnJG1heEZhaWxQb3MgPSAwO1xuICAgIHZhciBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgdmFyIHBlZyRzaWxlbnRGYWlscyA9IDA7XG4gICAgdmFyIHBlZyRyZXN1bHQ7XG4gICAgaWYgKG9wdGlvbnMuc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUluZGljZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcGVnJHN0YXJ0UnVsZUluZGV4ID0gcGVnJHN0YXJ0UnVsZUluZGljZXNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uLCBsb2NhdGlvbjEpIHtcbiAgICAgICAgbG9jYXRpb24xID0gbG9jYXRpb24xICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbG9jYXRpb24xXG4gICAgICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihbcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pXSwgaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpLCBsb2NhdGlvbjEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBsb2NhdGlvbjEpIHtcbiAgICAgICAgbG9jYXRpb24xID0gbG9jYXRpb24xICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbG9jYXRpb24xXG4gICAgICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJHNhdmVkUG9zLCBwZWckY3VyclBvcyk7XG4gICAgICAgIHRocm93IHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dDEsIGlnbm9yZUNhc2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHRleHQ6IHRleHQxLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRjbGFzc0V4cGVjdGF0aW9uKHBhcnRzLCBpbnZlcnRlZCwgaWdub3JlQ2FzZSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImNsYXNzXCIsIHBhcnRzOiBwYXJ0cywgaW52ZXJ0ZWQ6IGludmVydGVkLCBpZ25vcmVDYXNlOiBpZ25vcmVDYXNlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRhbnlFeHBlY3RhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZW5kXCIgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJG90aGVyRXhwZWN0YXRpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgICAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXTtcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCFwZWckcG9zRGV0YWlsc0NhY2hlW3BdKSB7XG4gICAgICAgICAgICAgICAgcC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcF07XG4gICAgICAgICAgICBkZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgIGxpbmU6IGRldGFpbHMubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXSA9IGRldGFpbHM7XG4gICAgICAgICAgICByZXR1cm4gZGV0YWlscztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZUxvY2F0aW9uKHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhzdGFydFBvcyk7XG4gICAgICAgIHZhciBlbmRQb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKGVuZFBvcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIG9mZnNldDogc3RhcnRQb3MsXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFBvc0RldGFpbHMuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICAgICAgICAgICAgbGluZTogZW5kUG9zRGV0YWlscy5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kUG9zRGV0YWlscy5jb2x1bW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQxKSB7XG4gICAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZFNpbXBsZUVycm9yKG1lc3NhZ2UsIGxvY2F0aW9uMSkge1xuICAgICAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UsIFtdLCBcIlwiLCBsb2NhdGlvbjEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckYnVpbGRTdHJ1Y3R1cmVkRXJyb3IoZXhwZWN0ZWQxLCBmb3VuZCwgbG9jYXRpb24xKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlKGV4cGVjdGVkMSwgZm91bmQpLCBleHBlY3RlZDEsIGZvdW5kLCBsb2NhdGlvbjEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWckZGVjb2RlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKSAtIDMyOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlUnVsZShpbmRleCkge1xuICAgICAgICB2YXIgYmMgPSBwZWckYnl0ZWNvZGVbaW5kZXhdO1xuICAgICAgICB2YXIgaXAgPSAwO1xuICAgICAgICB2YXIgaXBzID0gW107XG4gICAgICAgIHZhciBlbmQgPSBiYy5sZW5ndGg7XG4gICAgICAgIHZhciBlbmRzID0gW107XG4gICAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgd2hpbGUgKGlwIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChiY1tpcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRGQUlMRUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suc3BsaWNlKC0yLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnB1c2goc3RhY2sucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAxXSwgYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChpbnB1dC5zdWJzdHJpbmcoc3RhY2sucG9wKCksIHBlZyRjdXJyUG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwcy5wdXNoKGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGlwICsgMyArIGJjW2lwICsgMV0gKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDMgKyBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRzLnB1c2goZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcHMucHVzaChpcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAyICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMiArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyAzICsgYmNbaXAgKyAxXSArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMyArIGJjW2lwICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpID09PSBwZWckY29uc3RzW2JjW2lwICsgMV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHMucHVzaChlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBzLnB1c2goaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcy5wdXNoKGVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcHMucHVzaChpcCArIDQgKyBiY1tpcCArIDJdICsgYmNbaXAgKyAzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJGNvbnN0c1tiY1tpcCArIDFdXS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcCArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaXAgKyA0ICsgYmNbaXAgKyAyXSArIGJjW2lwICsgM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gNCArIGJjW2lwICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBiY1tpcCArIDFdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSBiY1tpcCArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwZWckRkFJTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckZmFpbChwZWckY29uc3RzW2JjW2lwICsgMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBiY1tpcCArIDFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gYmMuc2xpY2UoaXAgKyA0LCBpcCArIDQgKyBiY1tpcCArIDNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBwXTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAyXSwgYmNbaXAgKyAyXSwgcGVnJGNvbnN0c1tiY1tpcCArIDFdXS5hcHBseShudWxsLCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwICs9IDQgKyBiY1tpcCArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBlZyRwYXJzZVJ1bGUoYmNbaXAgKyAxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3Bjb2RlOiBcIiArIGJjW2lwXSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gZW5kcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpcCA9IGlwcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9XG4gICAgb3B0aW9ucy5kYXRhID0ge307IC8vIE9iamVjdCB0byB3aGljaCBoZWFkZXIgYXR0cmlidXRlcyB3aWxsIGJlIGFzc2lnbmVkIGR1cmluZyBwYXJzaW5nXG4gICAgZnVuY3Rpb24gbGlzdChoZWFkLCB0YWlsKSB7XG4gICAgICAgIHJldHVybiBbaGVhZF0uY29uY2F0KHRhaWwpO1xuICAgIH1cbiAgICBwZWckcmVzdWx0ID0gcGVnJHBhcnNlUnVsZShwZWckc3RhcnRSdWxlSW5kZXgpO1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcGVnJGZhaWwocGVnJGVuZEV4cGVjdGF0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHBlZyRidWlsZFN0cnVjdHVyZWRFcnJvcihwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwZWckbWF4RmFpbFBvcykgOiBudWxsLCBwZWckbWF4RmFpbFBvcyA8IGlucHV0Lmxlbmd0aFxuICAgICAgICAgICAgPyBwZWckY29tcHV0ZUxvY2F0aW9uKHBlZyRtYXhGYWlsUG9zLCBwZWckbWF4RmFpbFBvcyArIDEpXG4gICAgICAgICAgICA6IHBlZyRjb21wdXRlTG9jYXRpb24ocGVnJG1heEZhaWxQb3MsIHBlZyRtYXhGYWlsUG9zKSk7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZSA9IHBlZyRwYXJzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmV4cG9ydHMuRGlnZXN0QXV0aGVudGljYXRpb24gPSBjb3JlXzEuRGlnZXN0QXV0aGVudGljYXRpb247XG5leHBvcnRzLkdyYW1tYXIgPSBjb3JlXzEuR3JhbW1hcjtcbmV4cG9ydHMuSW5jb21pbmdSZXF1ZXN0ID0gY29yZV8xLkluY29taW5nUmVxdWVzdE1lc3NhZ2U7XG5leHBvcnRzLkluY29taW5nUmVzcG9uc2UgPSBjb3JlXzEuSW5jb21pbmdSZXNwb25zZU1lc3NhZ2U7XG5leHBvcnRzLkxvZ2dlckZhY3RvcnkgPSBjb3JlXzEuTG9nZ2VyRmFjdG9yeTtcbmV4cG9ydHMuTmFtZUFkZHJIZWFkZXIgPSBjb3JlXzEuTmFtZUFkZHJIZWFkZXI7XG5leHBvcnRzLk91dGdvaW5nUmVxdWVzdCA9IGNvcmVfMS5PdXRnb2luZ1JlcXVlc3RNZXNzYWdlO1xuZXhwb3J0cy5QYXJzZXIgPSBjb3JlXzEuUGFyc2VyO1xuZXhwb3J0cy5UaW1lcnMgPSBjb3JlXzEuVGltZXJzO1xuZXhwb3J0cy5VUkkgPSBjb3JlXzEuVVJJO1xudmFyIENsaWVudENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0NsaWVudENvbnRleHRcIik7XG5leHBvcnRzLkNsaWVudENvbnRleHQgPSBDbGllbnRDb250ZXh0XzEuQ2xpZW50Q29udGV4dDtcbnZhciBDb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL0NvbnN0YW50c1wiKTtcbmV4cG9ydHMuQyA9IENvbnN0YW50c18xLkM7XG52YXIgRW51bXNfMSA9IHJlcXVpcmUoXCIuL0VudW1zXCIpO1xuZXhwb3J0cy5EaWFsb2dTdGF0dXMgPSBFbnVtc18xLkRpYWxvZ1N0YXR1cztcbmV4cG9ydHMuU2Vzc2lvblN0YXR1cyA9IEVudW1zXzEuU2Vzc2lvblN0YXR1cztcbmV4cG9ydHMuVHlwZVN0cmluZ3MgPSBFbnVtc18xLlR5cGVTdHJpbmdzO1xuZXhwb3J0cy5VQVN0YXR1cyA9IEVudW1zXzEuVUFTdGF0dXM7XG52YXIgRXhjZXB0aW9uc18xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uc1wiKTtcbmV4cG9ydHMuRXhjZXB0aW9ucyA9IEV4Y2VwdGlvbnNfMS5FeGNlcHRpb25zO1xudmFyIFB1Ymxpc2hDb250ZXh0XzEgPSByZXF1aXJlKFwiLi9QdWJsaXNoQ29udGV4dFwiKTtcbmV4cG9ydHMuUHVibGlzaENvbnRleHQgPSBQdWJsaXNoQ29udGV4dF8xLlB1Ymxpc2hDb250ZXh0O1xudmFyIFJlZmVyQ29udGV4dF8xID0gcmVxdWlyZShcIi4vUmVmZXJDb250ZXh0XCIpO1xuZXhwb3J0cy5SZWZlckNsaWVudENvbnRleHQgPSBSZWZlckNvbnRleHRfMS5SZWZlckNsaWVudENvbnRleHQ7XG5leHBvcnRzLlJlZmVyU2VydmVyQ29udGV4dCA9IFJlZmVyQ29udGV4dF8xLlJlZmVyU2VydmVyQ29udGV4dDtcbnZhciBSZWdpc3RlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1JlZ2lzdGVyQ29udGV4dFwiKTtcbmV4cG9ydHMuUmVnaXN0ZXJDb250ZXh0ID0gUmVnaXN0ZXJDb250ZXh0XzEuUmVnaXN0ZXJDb250ZXh0O1xudmFyIFNlcnZlckNvbnRleHRfMSA9IHJlcXVpcmUoXCIuL1NlcnZlckNvbnRleHRcIik7XG5leHBvcnRzLlNlcnZlckNvbnRleHQgPSBTZXJ2ZXJDb250ZXh0XzEuU2VydmVyQ29udGV4dDtcbnZhciBTZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9TZXNzaW9uXCIpO1xuZXhwb3J0cy5JbnZpdGVDbGllbnRDb250ZXh0ID0gU2Vzc2lvbl8xLkludml0ZUNsaWVudENvbnRleHQ7XG5leHBvcnRzLkludml0ZVNlcnZlckNvbnRleHQgPSBTZXNzaW9uXzEuSW52aXRlU2VydmVyQ29udGV4dDtcbmV4cG9ydHMuU2Vzc2lvbiA9IFNlc3Npb25fMS5TZXNzaW9uO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uXCIpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb247XG52YXIgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9UcmFuc3BvcnRcIik7XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydF8xLlRyYW5zcG9ydDtcbnZhciB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvdHJhbnNhY3Rpb25zXCIpO1xudmFyIFRyYW5zYWN0aW9ucyA9IHtcbiAgICBJbnZpdGVDbGllbnRUcmFuc2FjdGlvbjogdHJhbnNhY3Rpb25zXzEuSW52aXRlQ2xpZW50VHJhbnNhY3Rpb24sXG4gICAgSW52aXRlU2VydmVyVHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uc18xLkludml0ZVNlcnZlclRyYW5zYWN0aW9uLFxuICAgIE5vbkludml0ZUNsaWVudFRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNfMS5Ob25JbnZpdGVDbGllbnRUcmFuc2FjdGlvbixcbiAgICBOb25JbnZpdGVTZXJ2ZXJUcmFuc2FjdGlvbjogdHJhbnNhY3Rpb25zXzEuTm9uSW52aXRlU2VydmVyVHJhbnNhY3Rpb25cbn07XG5leHBvcnRzLlRyYW5zYWN0aW9ucyA9IFRyYW5zYWN0aW9ucztcbnZhciBVQV8xID0gcmVxdWlyZShcIi4vVUFcIik7XG5leHBvcnRzLm1ha2VVc2VyQWdlbnRDb3JlQ29uZmlndXJhdGlvbkZyb21VQSA9IFVBXzEubWFrZVVzZXJBZ2VudENvcmVDb25maWd1cmF0aW9uRnJvbVVBO1xuZXhwb3J0cy5VQSA9IFVBXzEuVUE7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuL1V0aWxzXCIpO1xuZXhwb3J0cy5VdGlscyA9IFV0aWxzXzEuVXRpbHM7XG52YXIgV2ViID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vV2ViL2luZGV4XCIpKTtcbmV4cG9ydHMuV2ViID0gV2ViO1xudmFyIHZlcnNpb24gPSBDb25zdGFudHNfMS5DLnZlcnNpb247XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xudmFyIG5hbWUgPSBcInNpcC5qc1wiO1xuZXhwb3J0cy5uYW1lID0gbmFtZTtcbnZhciBDb3JlID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29yZS9pbmRleFwiKSk7XG5leHBvcnRzLkNvcmUgPSBDb3JlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxJQlJBUllfVkVSU0lPTiA9IFwiMC4xNS4xMVwiO1xuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY3JlYXRlQmluZGluZyhvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xyXG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgIH1cclxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2x2RGV2aWNlIH0gZnJvbSAnLi9saWIvY2x2LWRldmljZSc7XHJcbmV4cG9ydCB7IGNsdkRldmljZSB9O1xyXG4iLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2VzNi1ldmVudC1lbWl0dGVyJztcclxuXHJcbmV4cG9ydCBjbGFzcyBjbHZDYWxsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuXHJcbiAgLyoqXHJcbiAgKiBDcmVhdGUgYSBjbHZDYWxsLiBOb3JtYWxseSBjcmVhdGVkIGJ5IGNsdkRldmljZS5cclxuICAqXHJcbiAgKiBPbmNlIGEgY2FsbCBpcyBjcmVhdGVkLCB5b3UgY2FuIGVpdGhlciBtYWtlIGEgY2FsbCB3aXRoIGBtYWtlQ2FsbCgpYFxyXG4gICogb3Igc2V0IHlvdXJzZWxmIHVwIHRvIHJlY2lldmUgYW4gaW5jb21pbmcgY2FsbCB3aXRoIGBpbmNvbWluZ0NhbGwoKWBcclxuICAqXHJcbiAgKiBAcGFyYW0ge1VBfSBVQSAtIEEgU0lQLmpzIFVzZXIgQWdlbnRcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBpbnZpdGVVcmkgLSBBIFByb3Blcmx5IGZvcm1hdHRlZCBTSVAuanMgaW52aXRlIFVSSSAoY3JlYXRlIHdpdGggU0lQLlVSSSlcclxuICAqXHJcbiAgKiBAZW1pdHMgY2x2Q2FsbCNjb25uZWN0aW5nXHJcbiAgKi9cclxuICBjb25zdHJ1Y3RvcihVQSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX211dGUgPSBmYWxzZTtcclxuICAgIHRoaXMuX3N0YXR1cyA9ICdzdGFydGluZyc7XHJcbiAgICB0aGlzLl9jYWxsVHlwZSA9ICcnO1xyXG4gICAgdGhpcy5VQSA9IFVBO1xyXG4gICAgdGhpcy5fZG9jQm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XHJcbiAgICB0aGlzLmF1ZGlvRWxlbWVudCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuVUEuc3RhcnQoKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIE1ha2UgYSBjYWxsIHRvIGEgcGhvbmUgbnVtYmVyXHJcbiAgKlxyXG4gICogQHBhcmFtIHtVUkl9IGludml0ZVVyaSAtIEEgU0lQLmpzIFVSSSB0aGF0IGluY2x1ZGVzIHRoZSBwaG9uZSBudW1iZXIgdG8gY29ubmVjdCB0b1xyXG4gICovXHJcbiAgbWFrZUNhbGwoaW52aXRlVXJpKSB7XHJcbiAgICB0aGlzLl9jYWxsVHlwZSA9ICdvdXRnb2luZyc7XHJcbiAgICB0aGlzLl9zZXNzaW9uID0gdGhpcy5VQS5pbnZpdGUoaW52aXRlVXJpLCB0aGlzLl9nZXRBdWRpb0VsZW1lbnQoKSk7XHJcbiAgICB0aGlzLl9hdHRhdGNoU2Vzc2lvbkV2ZW50cyh0aGlzLl9zZXNzaW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogU2V0IHVwIHRvIGhhbmRsZSBhbiBpbmNvbWluZyBjYWxsLlxyXG4gICogVGhlIGNhbGxpbmcgZnVuY3Rpb24gd2lsbCB0aGVuIGJlIGFibGUgdG8gYWNjZXB0IG9yIHJlamVjdCB0aGUgY2FsbC5cclxuICAqXHJcbiAgKiBAcGFyYW0ge1Nlc3Npb259IHNlc3Npb24gLSBBIFNJUC5qcyBTZXNzaW9uLCBzcGVjaWZpY2FsbHkgb2YgdGhlIFNJUC5TZXJ2ZXJDb250ZXh0IHR5cGVcclxuICAqL1xyXG4gIGluY29taW5nQ2FsbChzZXNzaW9uKSB7XHJcbiAgICB0aGlzLl9jYWxsVHlwZSA9ICdpbmNvbWluZyc7XHJcbiAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcclxuICAgIHRoaXMuX2F0dGF0Y2hTZXNzaW9uRXZlbnRzKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgX2dldEF1ZGlvRWxlbWVudCgpIHtcclxuICAgIGlmICghdGhpcy5hdWRpb0VsZW1lbnQpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJ0aGlzLmF1ZGlvRWxlbWVudFwiLCB0aGlzLmF1ZGlvRWxlbWVudClcclxuICAgICAgdGhpcy5hdWRpb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xyXG4gICAgICB0aGlzLmF1ZGlvRWxlbWVudC5jbGFzc05hbWUgPSAnY2x2LXNpcGpzLXJlbW90ZS1hdWRpbyc7XHJcbiAgICAgIHRoaXMuX2RvY0JvZHkuYXBwZW5kQ2hpbGQodGhpcy5hdWRpb0VsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYXVkaW9FbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgX2F0dGF0Y2hTZXNzaW9uRXZlbnRzKHNlc3Npb24pIHtcclxuICAgIC8qKlxyXG4gICAgKiBjb25uZWN0aW5nIGV2ZW50OlxyXG4gICAgKlxyXG4gICAgKiBGaXJlZCBhcyB0aGUgc3lzdGVtIHN0YXJ0cyB0byBtYWtlIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgKiBUaGlzIGlzIGFmdGVyIHRoZSB1c2VyTWVkaWEgKG1pY3JvcGhvbmUpIGhhcyBiZWVuIGFxdWlyZWQuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBjbHZDYWxsI2Nvbm5lY3RpbmdcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwiY29ubmVjdGluZ1wiLCAoKSA9PiB7IHRoaXMudHJpZ2dlcihcImNvbm5lY3RpbmdcIik7IHRoaXMuX3N0YXR1cyA9ICdpbml0aWF0aW5nJzsgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIHByb2dyZXNzIGV2ZW50OlxyXG4gICAgKlxyXG4gICAgKiBVc3VhbGx5IGZpcmVkIHR3aWNlIGR1cmluZyBjYWxsIGludGlhbGl6YXRpb24sIG9uY2UgZm9yIFRSWUlORyBhbmQgb25jZSBmb3IgUklOR0lORy5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkNhbGwjcHJvZ3Jlc3NcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IHJlc3BvbnNlIC0gRGV0YWlscyBvZiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwicHJvZ3Jlc3NcIiwgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09IDE4MyAmJiByZXNwb25zZS5ib2R5ICYmIHRoaXMuX3Nlc3Npb24uaGFzT2ZmZXIgJiYgIXRoaXMuX3Nlc3Npb24uZGlhbG9nKSB7XHJcbiAgICAgICAgaWYgKCFyZXNwb25zZS5oYXNIZWFkZXIoJ3JlcXVpcmUnKSB8fCByZXNwb25zZS5nZXRIZWFkZXIoJ3JlcXVpcmUnKS5pbmRleE9mKCcxMDByZWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9zZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuaGFzRGVzY3JpcHRpb24ocmVzcG9uc2UuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSkpIHtcclxuICAgICAgICAgICAgLy8gQGhhY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9vbnNpcC9TSVAuanMvaXNzdWVzLzI0MlxyXG4gICAgICAgICAgICB0aGlzLl9zZXNzaW9uLnN0YXR1cyA9IFNJUC5TZXNzaW9uLkMuU1RBVFVTX0VBUkxZX01FRElBXHJcbiAgICAgICAgICAgIC8vIHRoaXMuX3dhaXRpbmdGb3JBcHBseWluZ0Fuc3dlcihzZXNzaW9uLCByZXNwb25zZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy50cmlnZ2VyKFwicHJvZ3Jlc3NcIiwgcmVzcG9uc2UpXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogYWNjZXB0ZWQgZXZlbnQ6XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIGNhbGwgd2FzIGFjY2VwdGVkIGJ5IHRoZSBjYWxsZWUuIFRoZSBjYWxsIGlzIG5vdyBjb25uZWN0ZWQuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBjbHZDYWxsI2FjY2VwdGVkXHJcbiAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkYXRhIC0gRGV0YWlscyBvZiB0aGUgcmVzcG9uc2VcclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwiYWNjZXB0ZWRcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiYWNjZXB0ZWRcIiwgZGF0YSksIHRoaXMuX3N0YXR1cyA9ICdjb25uZWN0ZWQnOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogZHRtZiBldmVudDpcclxuICAgICpcclxuICAgICogU2VudCB3aGVuIHRoZSB1c2VyIGhhcyBzdWNjZXNzZnVsbHkgc2VudCBhIERUTUYgKGtleXBhZCkgc2lnbmFsLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2Q2FsbCNkdG1mXHJcbiAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByZXF1ZXN0IC0gRGV0YWlscyBvZiB0aGUgcmVxdWVzdFxyXG4gICAgKiBAcHJvcGVydHkge3N0cmluZ30gZHRtZiAtIHRoZSBrZXkocykgdGhhdCB3ZXJlIHN1Ym1pdHRlZFxyXG4gICAgKi9cclxuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJkdG1mXCIsIChyZXF1ZXN0LCBkdG1mKSA9PiB0aGlzLnRyaWdnZXIoXCJkdG1mXCIsIHJlcXVlc3QsIGR0bWYpKTtcclxuXHJcbiAgICAvKipcclxuICAgICogbXV0ZWQgZXZlbnQ6XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHN5c3RlbSBoYXMgc3VjY2Vzc2Z1bGx5IHJlc3BvbmRlZCB0byBhIG11dGUgcmVxdWVzdC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkNhbGwjbXV0ZWRcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGEgLSBEZXRhaWxzIG9mIHRoZSByZXNwb25zZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJtdXRlZFwiLCAoZGF0YSkgPT4gdGhpcy50cmlnZ2VyKFwibXV0ZWRcIiwgZGF0YSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiB1bm11dGVkIGV2ZW50XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIHN5c3RlbSBoYXMgc3VjY2Vzc2Z1bGx5IHJlc3BvbmRlZCB0byBhbiB1bm11dGUgcmVxdWVzdC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkNhbGwjdW5tdXRlZFxyXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YSAtIERldGFpbHMgb2YgdGhlIHJlc3BvbnNlXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcInVubXV0ZWRcIiwgKGRhdGEpID0+IHRoaXMudHJpZ2dlcihcInVubXV0ZWRcIiwgZGF0YSkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBjYW5jZWwgZXZlbnQ6XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIGNhbGwgd2FzIHRlcm1pbmF0ZWQgYmVmb3JlIGVuZCB0byBlbmQgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQsXHJcbiAgICAqIHVzdWFsbHkgYnkgdGhlIHVzZXIncyByZXF1ZXN0LlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2Q2FsbCNjYW5jZWxcclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwiY2FuY2VsXCIsICgpID0+IHsgdGhpcy50cmlnZ2VyKFwiY2FuY2VsXCIpOyB0aGlzLl9zdGF0dXMgPSAnZW5kZWQnIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiByZWZlciBldmVudFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2Q2FsbCNyZWZlclxyXG4gICAgKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2VcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IG5ld1Nlc3Npb25cclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwicmVmZXJcIiwgKGNhbGxiYWNrLCByZXNwb25zZSwgbmV3U2Vzc2lvbikgPT4geyB0aGlzLnRyaWdnZXIoXCJyZWplY3RlZFwiKTsgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIHJlcGxhY2VkIGV2ZW50XHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBjbHZDYWxsI3JlcGxhY2VkXHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBuZXdTZXNzaW9uXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcInJlcGxhY2VkXCIsIChuZXdTZXNzaW9uKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlamVjdGVkXCIsIG5ld1Nlc3Npb24pOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogcmVqZWN0ZWQgZXZlbnRcclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkNhbGwjcmVqZWN0ZWRcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IHJlc3BvbnNlXHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYXVzZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJyZWplY3RlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlamVjdGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IHRoaXMuX3N0YXR1cyA9ICdlbmRlZCcgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGZhaWxlZCBldmVudFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2Q2FsbCNmYWlsZWRcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IHJlc3BvbnNlXHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjYXVzZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3Nlc3Npb24ub24oXCJmYWlsZWRcIiwgKHJlc3BvbnNlLCBjYXVzZSkgPT4geyB0aGlzLnRyaWdnZXIoXCJmYWlsZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTsgdGhpcy5fc3RhdHVzID0gJ2VuZGVkJyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogdGVybWluYXRlZCBldmVudFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2Q2FsbCN0ZXJtaW5hdGVkXHJcbiAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByZXNwb25zZVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gY2F1c2VcclxuICAgICovXHJcbiAgICB0aGlzLl9zZXNzaW9uLm9uKFwidGVybWluYXRlZFwiLCAobWVzc2FnZSwgY2F1c2UpID0+IHsgdGhpcy50cmlnZ2VyKFwidGVybWluYXRlZFwiLCBtZXNzYWdlLCBjYXVzZSk7IHRoaXMuX3N0YXR1cyA9ICdlbmRlZCc7IH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBieWUgZXZlbnRcclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkNhbGwjYnllXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fc2Vzc2lvbi5vbihcImJ5ZVwiLCAoKSA9PiB7IHRoaXMudHJpZ2dlcihcImJ5ZVwiKTsgdGhpcy5fc3RhdHVzID0gJ2VuZGVkJyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogdXNlck1lZGlhUmVxdWVzdCBldmVudDpcclxuICAgICpcclxuICAgICogRmlyZWQgd2hlbiB0aGUgZXZlcnkgdGltZSB0aGUgc3lzdGVtIGNoZWNrcyB0byBzZWUgaWYgaXQgaGFzIG1pY3JvcGhvbmUgcGVybWlzc2lvbiBmcm9tIHRoZSB1c2VyLlxyXG4gICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIGRldGVjdCB3aGVuIHRoZSBicm93c2VyJ3MgXCJBbGxvdyB3ZWJzaXRlIHRvIHVzZSBtaWNyb3Bob25lXCIgZGlhbG9nIGlzIG9wZW4sXHJcbiAgICAqIGJ1dCB5b3Ugd2lsbCBuZWVkIHRvIGJlIHNvbWV3aGF0IGNhcmVmdWwuIFRoaXMgZXZlbnQgd2lsbCBmaXJlIGV2ZW4gaWYgdGhlIHVzZXIgYWxyZWFkeSBoYXNcclxuICAgICogZ2l2ZW4gcGVybWlzc2lvbiwgdGhlbiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEge0BsaW5rIGNsdkNhbGwjdXNlck1lZGlhfSBldmVudC5cclxuICAgICogSWYgeW91IHdpc2ggdG8gaGF2ZSB5b3VyIFVJIGRpc3BsYXkgc29tZSBzb3J0IG9mIFwiYXNraW5nIGZvciBwZXJtaXNzaW9uXCIgZWxlbWVudCwgeW91IG1heSBuZWVkIHRvXHJcbiAgICAqIGRlYm91bmNlIHRoaXMgZXZlbnQ7IGxpc3RlbmluZyBmb3Ige0BsaW5rIGNsdkNhbGwjdXNlck1lZGlhfSB0byBjYW5jZWwgeW91ciBVSSB1cGRhdGUuXHJcbiAgICAqXHJcbiAgICAqIEBldmVudCBjbHZDYWxsI3VzZXJNZWRpYVJlcXVlc3RcclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnN0cmFpbnRzXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fc2Vzc2lvbi5vbigndHJhY2tBZGRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHNlc3Npb24pIHtcclxuICAgICAgICB2YXIgcGMgPSBzZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XHJcbiAgICAgICAgLy8gdmFyIHRoaXMuYXVkaW9FbGVtZW50ID0gdGhpcy5hdWRpb0VsZW1lbnQ7XHJcbiAgICAgICAgLy8gdGhpcy5hdWRpb0VsZW1lbnQuY2xhc3NOYW1lID0gJ2Nsdi1zaXBqcy1yZW1vdGUtYXVkaW8nO1xyXG4gICAgICAgIHZhciByZW1vdGVTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcclxuICAgICAgICBwYy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xyXG4gICAgICAgICAgcmVtb3RlU3RyZWFtLmFkZFRyYWNrKHJlY2VpdmVyLnRyYWNrKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb24ucGFzc2VkT3B0aW9ucy5zcmNPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMuc3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb24ucGFzc2VkT3B0aW9ucy5tb3pTcmNPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMubW96U3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb24ucGFzc2VkT3B0aW9ucy5zcmMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZW1vdGVTdHJlYW0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgYXR0YWNoaW5nIHN0cmVhbSB0byBlbGVtZW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXNzaW9uLnBhc3NlZE9wdGlvbnMucGxheSgpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwidXNlck1lZGlhUmVxdWVzdFwiLCAoY29uc3RyYWludHMpID0+IHt0aGlzLnRyaWdnZXIoXCJ1c2VyTWVkaWFSZXF1ZXN0XCIsIGNvbnN0cmFpbnRzKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogdXNlck1lZGlhIGV2ZW50OlxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBGaXJlZCB3aGVuIHRoZSBzeXN0ZW0gaGFzIGFxdWlyZWQgcGVybWlzc2lvbiB0byB1c2UgdGhlIG1pY3JvcGhvbmUuIFRoaXMgd2lsbCBoYXBwZW4gZWl0aGVyXHJcbiAgICAvLyAqIGltbWVkaWF0ZWx5IGFmdGVyIHtAbGluayBjbHZDYWxsI3VzZXJNZWRpYVJlcXVlc3R9IGlmIHRoZSB1c2VyIGhhcyBwcmV2aW91c2x5IGdpdmVuIHBlcm1pc3Npb25cclxuICAgIC8vICogb3IgYWZ0ZXIgdGhlIHVzZXIgYXBwcm92ZXMgdGhlIHJlcXVlc3QuXHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEBldmVudCBjbHZDYWxsI3VzZXJNZWRpYVxyXG4gICAgLy8gKiBAcHJvcGVydHkge29iamVjdH0gc3RyZWFtXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJ1c2VyTWVkaWFcIiwgKHN0cmVhbSkgPT4ge3RoaXMudHJpZ2dlcihcInVzZXJNZWRpYVwiLCBzdHJlYW0pO30pO1xyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gKiB1c2VyTWVkaWFGYWlsZWQgZXZlbnQ6XHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgcmVmdXNlcyBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgbWljcm9waG9uZS4gVGhlcmUgaXMgbm8gd2F5IGJhY2sgZnJvbSB0aGlzXHJcbiAgICAvLyAqIGV4Y2VwdCBmb3IgdGhlIHVzZXIgdG8gZ28gaW50byBicm93c2VyIHNldHRpbmdzIGFuZCByZW1vdmUgdGhlIGV4Y2VwdGlvbiBmb3IgeW91ciBzaXRlLlxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCN1c2VyTWVkaWFGYWlsZWRcclxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IGVycm9yXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJ1c2VyTWVkaWFGYWlsZWRcIiwgKGVycm9yKSA9PiB7dGhpcy50cmlnZ2VyKFwidXNlck1lZGlhRmFpbGVkXCIsIGVycm9yKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogaWNlR2F0aGVyaW5nIGV2ZW50XHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEBldmVudCBjbHZDYWxsI2ljZUdhdGhlcmluZ1xyXG4gICAgLy8gKi9cclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiaWNlR2F0aGVyaW5nXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VHYXRoZXJpbmdcIik7fSk7XHJcblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAqIGljZUNhbmRpZGF0ZSBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNpY2VDYW5kaWRhdGVcclxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IGNhbmRpZGF0ZVxyXG4gICAgLy8gKi9cclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiaWNlQ2FuZGlkYXRlXCIsIChjYW5kaWRhdGUpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDYW5kaWRhdGVcIiwgY2FuZGlkYXRlKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogaWNlR2F0aGVyaW5nQ29tcGxldGUgZXZlbnRcclxuICAgIC8vICpcclxuICAgIC8vICogQGV2ZW50IGNsdkNhbGwjaWNlR2F0aGVyaW5nQ29tcGxldGVcclxuICAgIC8vICovXHJcbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUdhdGhlcmluZ0NvbXBsZXRlXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VHYXRoZXJpbmdDb21wbGV0ZVwiKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogaWNlQ29ubmVjdGlvbiBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNpY2VDb25uZWN0aW9uXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uXCIpO30pO1xyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ2hlY2tpbmcgZXZlbnRcclxuICAgIC8vICpcclxuICAgIC8vICogQGV2ZW50IGNsdkNhbGwjaWNlQ29ubmVjdGlvbkNoZWNraW5nXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uQ2hlY2tpbmdcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25DaGVja2luZ1wiKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogaWNlQ29ubmVjdGlvbkNvbm5lY3RlZCBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNpY2VDb25uZWN0aW9uQ29ubmVjdGVkXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uQ29ubmVjdGVkXCIpO30pO1xyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ29tcGxldGVkIGV2ZW50XHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEBldmVudCBjbHZDYWxsI2ljZUNvbm5lY3Rpb25Db21wbGV0ZWRcclxuICAgIC8vICovXHJcbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUNvbm5lY3Rpb25Db21wbGV0ZWRcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25Db21wbGV0ZWRcIik7fSk7XHJcblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAqIGljZUNvbm5lY3Rpb25GYWlsZWQgZXZlbnRcclxuICAgIC8vICpcclxuICAgIC8vICogQGV2ZW50IGNsdkNhbGwjaWNlQ29ubmVjdGlvbkZhaWxlZFxyXG4gICAgLy8gKi9cclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiLCAoKSA9PiB7dGhpcy50cmlnZ2VyKFwiaWNlQ29ubmVjdGlvbkZhaWxlZFwiKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCIsICgpID0+IHt0aGlzLnRyaWdnZXIoXCJpY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkXCIpO30pO1xyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gKiBpY2VDb25uZWN0aW9uQ2xvc2VkIGV2ZW50XHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEBldmVudCBjbHZDYWxsI2ljZUNvbm5lY3Rpb25DbG9zZWRcclxuICAgIC8vICovXHJcbiAgICAvLyB0aGlzLl9zZXNzaW9uLm1lZGlhSGFuZGxlci5vbihcImljZUNvbm5lY3Rpb25DbG9zZWRcIiwgKCkgPT4ge3RoaXMudHJpZ2dlcihcImljZUNvbm5lY3Rpb25DbG9zZWRcIik7fSk7XHJcblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAqIGdldERlc2NyaXB0aW9uIGV2ZW50XHJcbiAgICAvLyAqXHJcbiAgICAvLyAqIEBldmVudCBjbHZDYWxsI2dldERlc2NyaXB0aW9uXHJcbiAgICAvLyAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzZHBXcmFwcGVyXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJnZXREZXNjcmlwdGlvblwiLCAoc2RwV3JhcHBlcikgPT4ge3RoaXMudHJpZ2dlcihcImdldERlc2NyaXB0aW9uXCIsIHNkcFdyYXBwZXIpO30pO1xyXG5cclxuICAgIC8vIC8qKlxyXG4gICAgLy8gKiBzZXREZXNjcmlwdGlvbiBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNzZXREZXNjcmlwdGlvblxyXG4gICAgLy8gKiBAcHJvcGVydHkge29iamVjdH0gc2RwV3JhcHBlclxyXG4gICAgLy8gKi9cclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwic2V0RGVzY3JpcHRpb25cIiwgKHNkcFdyYXBwZXIpID0+IHt0aGlzLnRyaWdnZXIoXCJzZXREZXNjcmlwdGlvblwiLCBzZHBXcmFwcGVyKTt9KTtcclxuXHJcbiAgICAvLyAvKipcclxuICAgIC8vICogZGF0YUNoYW5uZWwgZXZlbnRcclxuICAgIC8vICpcclxuICAgIC8vICogQGV2ZW50IGNsdkNhbGwjZGF0YUNoYW5uZWxcclxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IGRhdGFDaGFubmVsXHJcbiAgICAvLyAqL1xyXG4gICAgLy8gdGhpcy5fc2Vzc2lvbi5tZWRpYUhhbmRsZXIub24oXCJkYXRhQ2hhbm5lbFwiLCAoZGF0YUNoYW5uZWwpID0+IHt0aGlzLnRyaWdnZXIoXCJkYXRhQ2hhbm5lbFwiLCBkYXRhQ2hhbm5lbCk7fSk7XHJcblxyXG4gICAgLy8gLyoqXHJcbiAgICAvLyAqIGFkZFN0cmVhbSBldmVudFxyXG4gICAgLy8gKlxyXG4gICAgLy8gKiBAZXZlbnQgY2x2Q2FsbCNhZGRTdHJlYW1cclxuICAgIC8vICogQHByb3BlcnR5IHtvYmplY3R9IHN0cmVhbVxyXG4gICAgLy8gKi9cclxuICAgIC8vIHRoaXMuX3Nlc3Npb24ubWVkaWFIYW5kbGVyLm9uKFwiYWRkU3RyZWFtXCIsIChzdHJlYW0pID0+IHsgdGhpcy50cmlnZ2VyKFwiYWRkU3RyZWFtXCIsIHN0cmVhbSk7IH0pO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjY2VwdCBhbiBpbmNvbWluZyBjYWxsLlxyXG4gICAqIFdoZW4gYSBjYWxsIGlzIHJlY2VpdmVkIGBjbHZEZXZpY2VgIHdpbGwgY3JlYXRlIGEgbmV3IGBjbHZDYWxsYCBmb3IgdGhlIHNlc3Npb25cclxuICAgKiBhbmQgZW1pdCBhIGBpbmNvbWluZ0ludml0ZWAgZXZlbnQuXHJcbiAgICogVGhlIG5ldyBgY2x2Q2FsbGAgaXMgcGFzc2VkIGFsb25nIHdpdGggdGhlIGV2ZW50LiBDYWxsIGBhY2NlcHQoKWAgdG8gYWNjZXB0IHRoZSBjYWxsLlxyXG4gICAqL1xyXG4gIGFuc3dlcigpIHtcclxuICAgIGlmICh0aGlzLl9jYWxsVHlwZSAhPT0gJ2luY29taW5nJykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiYWNjZXB0KCkgbWV0aG9kIGlzIG9ubHkgdmFsaWQgb24gaW5jb21pbmcgY2FsbHNcIik7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9zZXNzaW9uLmFjY2VwdCh7XHJcbiAgICAgIG1lZGlhOiB7XHJcbiAgICAgICAgY29uc3RyYWludHM6IHsgYXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZSB9LFxyXG4gICAgICAgIHJlbmRlcjogeyByZW1vdGU6IHRoaXMuX2dldEF1ZGlvRWxlbWVudCgpIH1cclxuICAgICAgfSxcclxuICAgICAgc2Vzc2lvbkRlc2NyaXB0aW9uSGFuZGxlck9wdGlvbnM6IHtcclxuICAgICAgICBjb25zdHJhaW50czoge1xyXG4gICAgICAgICAgYXVkaW86IHRydWUsXHJcbiAgICAgICAgICB2aWRlbzogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbmRlcjogeyByZW1vdGU6IHRoaXMuX2dldEF1ZGlvRWxlbWVudCgpIH1cclxuICAgICAgfVxyXG5cclxuICAgIH0pO1xyXG4gICAgdGhpcy5fYXR0YXRjaFNlc3Npb25FdmVudHModGhpcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWplY3QgYW4gaW5jb21pbmcgY2FsbC5cclxuICAgKiBXaGVuIGEgY2FsbCBpcyByZWNlaXZlZCBgY2x2RGV2aWNlYCB3aWxsIGNyZWF0ZSBhIG5ldyBgY2x2Q2FsbGAgZm9yIHRoZSBzZXNzaW9uXHJcbiAgICogYW5kIGVtaXQgYSBgaW5jb21pbmdJbnZpdGVgIGV2ZW50LlxyXG4gICAqIFRoZSBuZXcgYGNsdkNhbGxgIGlzIHBhc3NlZCBhbG9uZyB3aXRoIHRoZSBldmVudC4gQ2FsbCBgcmVqZWN0KClgIHRvIHJlamVjdCB0aGUgY2FsbC5cclxuICAgKi9cclxuICByZWplY3QoKSB7XHJcbiAgICBpZiAodGhpcy5fY2FsbFR5cGUgIT09ICdpbmNvbWluZycpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihcInJlamVjdCgpIG1ldGhvZCBpcyBvbmx5IHZhbGlkIG9uIGluY29taW5nIGNhbGxzXCIpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9zZXNzaW9uLnJlamVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHJlcXVlc3Qgb2JqZWN0IGNvbnRhaW5zIG1ldGFkYXRhIGFib3V0IHRoZSBjdXJyZW50IHNlc3Npb24sXHJcbiAgICogaW5jbHVkaW5nIHRoZSB3aG8gdGhlIGNhbGwgaXMgZ29pbmcgYHRvYCBhbmQgaW4gdGhlIGNhc2Ugb2YgaW5jb21pbmcgY2FsbHMsXHJcbiAgICogd2hvIHRoZSBjYWxsIGlzIGNvbWluZyBgZnJvbWAuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtvYmplY3R9IHJlcXVlc3RcclxuICAgKi9cclxuICBnZXQgcmVxdWVzdCgpIHtcclxuICAgIGlmICghdGhpcy5fc2Vzc2lvbikge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX2NhbGxUeXBlID09PSAnaW5jb21pbmcnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uLnRyYW5zYWN0aW9uLnJlcXVlc3Q7XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2NhbGxUeXBlID09PSAnb3V0Z29pbmcnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uLnJlcXVlc3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIElzIHRoZSBjYWxsIHN0aWxsIGluaXRpYXRpbmc/XHJcbiAgKlxyXG4gICogQHJldHVybiB7Qm9vbGVhbn0gaXNJbml0aWF0aW5nXHJcbiAgKi9cclxuICBpc0luaXRpYXRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSAnaW5pdGlhdGluZyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEhhcyB0aGUgY2FsbCBjb25uZWN0ZWQ/XHJcbiAgKlxyXG4gICogQHJldHVybiB7Qm9vbGVhbn0gaXNDb25uZWN0ZWRcclxuICAqL1xyXG4gIGlzQ29ubmVjdGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gJ2Nvbm5lY3RlZCc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIEhhcyB0aGUgY2FsbCBlbmRlZD9cclxuICAqXHJcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBpc0VuZGVkXHJcbiAgKi9cclxuICBpc0VuZGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gJ2VuZGVkJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogSXMgdGhpcyBhbiBpbmNvbWluZyBjYWxsP1xyXG4gICpcclxuICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzSW5jb21pbmdcclxuICAqL1xyXG4gIGlzSW5jb21pbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY2FsbFR5cGUgPT09ICdpbmNvbWluZyc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIElzIHRoaXMgYW4gb3V0Z29pbmcgY2FsbD9cclxuICAqXHJcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBpc091dGdvaW5nXHJcbiAgKi9cclxuICBpc091dGdvaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2NhbGxUeXBlID09PSAnb3V0Z29pbmcnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBFbmQgdGhlIHNlc3Npb25cclxuICAqXHJcbiAgKiBAZW1pdHMgY2x2Q2FsbCN0ZXJtaW5hdGVkXHJcbiAgKi9cclxuICB0ZXJtaW5hdGUoKSB7XHJcbiAgICB0aGlzLl9zZXNzaW9uLnRlcm1pbmF0ZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBTaHV0ZG93biB0aGUgY29ubmVjdGlvbiB0byB0aGUgV2ViUlRDIHNlcnZlcnNcclxuICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY2x2RGV2aWNlLnN0b3BXUyBpbnN0ZWFkLlxyXG4gICovXHJcbiAgc2h1dGRvd24oKSB7XHJcbiAgICB0aGlzLlVBLnN0b3AoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogVG9nZ2xlIG11dGVcclxuICAqXHJcbiAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTXV0ZSAtIGlmIHRydWUgeW91IHdhbnQgbXV0ZSB0byBiZSBPTlxyXG4gICovXHJcbiAgbXV0ZShpc011dGUgLypib29sKi8pIHtcclxuICAgIHRoaXMuX211dGUgPSBpc011dGU7XHJcbiAgICBpZiAodGhpcy5fbXV0ZSkge1xyXG4gICAgICB0aGlzLl9zZXNzaW9uLm11dGUoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3Nlc3Npb24udW5tdXRlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFRvZ2dsZSBob2xkXHJcbiAgKlxyXG4gICogQHBhcmFtIHtib29sZWFufSBpc0hvbGQgLSBpZiB0cnVlIHlvdSB3YW50IG11dGUgdG8gYmUgT05cclxuICAqL1xyXG4gIGhvbGQoaXNIb2xkIC8qYm9vbCovKSB7XHJcbiAgICBpZiAoaXNIb2xkKSB7XHJcbiAgICAgIHRoaXMuX3Nlc3Npb24uaG9sZCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc2Vzc2lvbi51bmhvbGQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogQ3VycmVudCBtdXRlIHN0YXRlXHJcbiAgKlxyXG4gICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBjYWxsIGlzIG9uIG11dGVcclxuICAqL1xyXG4gIGlzTXV0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbXV0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogU2VuZCBwaG9uZSBrZXlwYWQgcHJlc3NlcyAoRFRNRiB0b25lcylcclxuICAqXHJcbiAgKiBVc2VkIGFmdGVyIHRoZSBjYWxsIGlzIGluIHByb2dyZXNzLlxyXG4gICpcclxuICAqIEBwYXJhbSB7c3RyaW5nfSBkaWdpdHMgLSBhIHN0cmluZyBjb250YWluZyBkaWdpdHMgMC05LCAqLCAjXHJcbiAgKiBAZW1pdHMgY2x2Q2FsbCNkdG1mXHJcbiAgKi9cclxuICBzZW5kRGlnaXRzKGRpZ2l0cykge1xyXG4gICAgdGhpcy5fc2Vzc2lvbi5kdG1mKGRpZ2l0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFNlbmQgcGhvbmUga2V5cGFkIHByZXNzZXMgKERUTUYgdG9uZXMpXHJcbiAgKlxyXG4gICogVXNlZCBhZnRlciB0aGUgY2FsbCBpcyBpbiBwcm9ncmVzcy5cclxuICAqXHJcbiAgKiBAcGFyYW0ge3N0cmluZ30gZGlnaXRzIC0gYSBzdHJpbmcgY29udGFpbmcgZGlnaXRzIDAtOSwgKiwgI1xyXG4gICogQGVtaXRzIGNsdkNhbGwjZHRtZlxyXG4gICovXHJcbiAgcmVmZXIoZGlnaXRzKSB7XHJcbiAgICB0aGlzLl9zZXNzaW9uLnJlZmVyKGRpZ2l0cyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFRoZSBcInNpbXBsZVwiIHN0YXR1cy5cclxuICAqXHJcbiAgKiBBbGwgb2YgdGhlIG1hbnkgcGhhc2VzIG9mIHRoZSBjYWxsIGJvaWxlZCBkb3duIGludG8gMyBzdGF0ZXM6IEluaXRpYXRpbmcsIENvbm5lY3RlZCBhbmQgRW5kZWQuXHJcbiAgKlxyXG4gICogQHJldHVybiB7c3RyaW5nfSBvbmUgb2YgaW5pdGlhdGluZywgY29ubmVjdGVkLCBlbmRlZFxyXG4gICovXHJcbiAgc3RhdHVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcclxuICB9XHJcblxyXG4gIF93YWl0aW5nRm9yQXBwbHlpbmdBbnN3ZXIoc2Vzc2lvbiwgcmVzcG9uc2UpIHtcclxuICAgIGxldCBpID0gMSxcclxuICAgICAgY2xlYXJUaW1lclxyXG5cclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gY2hlY2soKSB7XHJcbiAgICAgIGkrK1xyXG4gICAgICBjbGVhclRpbWVyID0gc2V0VGltZW91dChjaGVjaywgMTApXHJcbiAgICAgIGlmIChzZXNzaW9uICYmIHNlc3Npb24uaGFzQW5zd2VyIHx8IGkgPiAxNCkge1xyXG4gICAgICAgIGlmIChzZXNzaW9uLmhhc0Fuc3dlcikge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFyVGltZXIpXHJcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSAxNSkge1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFyVGltZXIpXHJcbiAgICAgICAgICBzZXNzaW9uLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIuc2V0RGVzY3JpcHRpb24ocmVzcG9uc2UuYm9keSkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIHNlc3Npb24ubG9nZ2VyLndhcm4oZXJyb3IpXHJcbiAgICAgICAgICAgIHNlc3Npb24uZmFpbGVkKHJlc3BvbnNlLCBDLmNhdXNlcy5CQURfTUVESUFfREVTQ1JJUFRJT04pXHJcbiAgICAgICAgICAgIHNlc3Npb24udGVybWluYXRlKHsgc3RhdHVzQ29kZTogNDg4LCByZWFzb25fcGhyYXNlOiAnQmFkIE1lZGlhIERlc2NyaXB0aW9uJyB9KVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIDEwKVxyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgVUEsIFJlZmVyQ2xpZW50Q29udGV4dCB9IGZyb20gJ3NpcC5qcyc7XHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXM2LWV2ZW50LWVtaXR0ZXInO1xyXG5pbXBvcnQgeyBjbHZDYWxsIH0gZnJvbSAnLi9jbHYtY2FsbCc7XHJcblxyXG4vKipcclxuKiBSZXByZXNlbnRzIHRoZSBzb2Z0d2FyZSBwaG9uZSBydW5uaW5nIGluIGEgd2ViIGJyb3dzZXIgb3Igb3RoZXIgY29udGV4dC5cclxuKlxyXG4qIEBjbGFzc1xyXG4qL1xyXG5jbGFzcyBjbHZEZXZpY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG5cclxuICAvKipcclxuICAqIENyZWF0ZSBhIG5ldyBjbHZEZXZpY2UuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5ob3N0IFRoZSBob3N0IG5hbWUgb3IgSVAgYWRkcmVzcyBvZiB0aGUgU0lQIHNlcnZlclxyXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5wb3J0IFRoZSBwb3J0IG9mIHRoZSBTSVAgc2VydmVyXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLndzU2VydmVycyBVUkkocykgb2YgdGhlIFdlYlNvY2tldCBTZXJ2ZXJzLiBGb3JtYXQgYHdzczovLzEyMy4wLjAuMDo1MDY2YC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpcyBhbHNvIGFjY2VwdGVkLlxyXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy51c2VybmFtZSBUaGUgdXNlcm5hbWUgZm9yIHRoZSBTSVAgc2VydmVyXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnBhc3N3b3JkIFRoZSBwYXNzd2VvcmQgZm9yIHRoZSBTSVAgc2VydmVyXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRpc3BsYXlOYW1lIFRoZSBodW1hbiByZWFkYWJsZSBuYW1lIHBhc3NlZCBpbiB0aGUgZnJvbSBmaWVsZC4gV2lsbCBiZSB1c2VkIGZvciBDYWxsZXIgSURcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuc3R1blNlcnZlcnMgVVJJKHMpIGZvciBob3cgdG8gY29ubmVjdCB0byB0aGUgU1RVTiBzZXJ2ZXJzLiBGb3JtYXQgYHN0dW46c3R1bi5jbHYuY29tOjgwMDBgLiBBbiBhcnJheSBvZiBzdHJpbmdzIGlzIGFsc28gYWNjZXB0ZWQuXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnLnR1cm5TZXJ2ZXJzIERldGFpbHMgZm9yIGhvdyB0byBjb25uZWN0IHRvIHRoZSBUVVJOIHNlcnZlcnMuIEFuIGFycmF5IG9mIG9iamVjdHMgaXMgYWxzbyBhY2NlcHRlZC5cclxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcudHVyblNlcnZlcnMudXJscyBVUkkocykgZm9yIHRoZSBUVVJOIHNlcnZlcihzKS4gRm9ybWF0IGB0dXJuOnR1cm4uY2x2LmNvbTo4MDAwP3RyYW5zcG9ydD10Y3BgLiBBbiBhcnJheSBvZiBzdHJpbmdzIGlzIGFsc28gYWNjZXB0ZWQuXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnR1cm5TZXJ2ZXJzLnVzZXJuYW1lIFVzZXJuYW1lIHRvIGF1dGhlbnRpY2F0ZSBvbiBUVVJOIHNlcnZlcihzKVxyXG4gICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy50dXJuU2VydmVycy5wYXNzd29yZCBQYXNzd29yZCB0byBhdXRoZW50aWNhdGUgb24gVFVSTiBzZXJ2ZXIocylcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcucmVnaXN0cmFyU2VydmVyIFVSSSBmb3IgdGhlIHJlZ2lzdHJhciBTZXJ2ZXIuIEZvcm1hdCBgc2lwOjEyMy4wLjAuMDo1MDY2YFxyXG4gICogQHBhcmFtIHtCb29sZWFufSBjb25maWcudHJhY2VTaXAgSWYgdHJ1ZSwgU0lQIHRyYWNlcyB3aWxsIGJlIGxvZ2dlZCB0byB0aGUgZGV2IGNvbnNvbGUuXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmxvZ0xldmVsIE9uZSBvZiBcImRlYnVnXCIsIFwibG9nXCIsIFwid2FyblwiLCBcImVycm9yXCIsIFwib2ZmXCIuICBkZWZhdWx0IGlzIFwibG9nXCJcclxuXHJcbiAgKi9cclxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICBpZiAoIWNvbmZpZyB8fCB0eXBlb2YgKGNvbmZpZykgIT09ICdvYmplY3QnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJjbHZEZXZpY2U6IE1pc3NpbmcgY29uZmlnXCIpOyB9XHJcbiAgICBpZiAoIWNvbmZpZy5ob3N0KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJjbHZEZXZpY2U6IE1pc3NpbmcgJ2hvc3QnIHBhcmFtZXRlclwiKTsgfVxyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcblxyXG4gICAgdGhpcy5ob3N0ID0gY29uZmlnLmhvc3Q7XHJcbiAgICB0aGlzLnBvcnQgPSBjb25maWcucG9ydDtcclxuICAgIHRoaXMudXJpID0gYHNpcDoke2NvbmZpZy51c2VybmFtZX1AJHtjb25maWcuaG9zdH1gO1xyXG4gICAgdGhpcy5wYXRoID0gY29uZmlnLnBhdGggfHwgJyc7XHJcbiAgICB0aGlzLndzU2VydmVycyA9IGFycmF5aWZ5KGNvbmZpZy53c1NlcnZlcnMpO1xyXG4gICAgdGhpcy51c2VybmFtZSA9IGNvbmZpZy51c2VybmFtZTtcclxuICAgIHRoaXMucGFzc3dvcmQgPSBjb25maWcucGFzc3dvcmQ7XHJcbiAgICB0aGlzLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lIHx8IGNvbmZpZy51c2VybmFtZTtcclxuICAgIHRoaXMuc3R1blNlcnZlcnMgPSBhcnJheWlmeShjb25maWcuc3R1blNlcnZlcnMpO1xyXG4gICAgdGhpcy50dXJuU2VydmVycyA9IGNvbmZpZy50dXJuU2VydmVycztcclxuICAgIHRoaXMucmVnaXN0cmFyU2VydmVyID0gY29uZmlnLnJlZ2lzdHJhclNlcnZlcjtcclxuXHJcbiAgICB0aGlzLl91c2VyQWdlbnQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX2Vuc3VyZUNvbm5lY3Rpdml0eVdpdGhTaXBTZXJ2ZXIoKTtcclxuXHJcbiAgICAvLyBsZXQgdXJpID0gbmV3IFNJUC5VUkkoXCJzaXBcIiwgdGhpcy51c2VybmFtZSwgdGhpcy5ob3N0LCB0aGlzLnBvcnQpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgbGV0IHNpcFVBQ29uZmlnID0ge1xyXG4gICAgICB1cmk6IGBzaXA6JHt0aGlzLnVzZXJuYW1lfUAke3RoaXMuaG9zdH1gLFxyXG4gICAgICB0cmFuc3BvcnRPcHRpb25zOiB7IHdzU2VydmVyczogW2Ake2NvbmZpZy53c1NlcnZlcnN9YF0gfSxcclxuICAgICAgYXV0aG9yaXphdGlvblVzZXJzaXA6IHRoaXMudXNlcm5hbWUsXHJcbiAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkLFxyXG4gICAgICBkaXNwbGF5TmFtZTogdGhpcy5kaXNwbGF5TmFtZSxcclxuICAgICAgLy8gc3R1blNlcnZlcnM6IHRoaXMuc3R1blNlcnZlcnMsXHJcbiAgICAgIC8vIHR1cm5TZXJ2ZXJzOiB0aGlzLnR1cm5TZXJ2ZXJzLFxyXG4gICAgICAvLyByZWdpc3RyYXJTZXJ2ZXI6IHRoaXMucmVnaXN0cmFyU2VydmVyXHJcbiAgICAgIHNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXJPcHRpb25zOiB7XHJcbiAgICAgICAgY29uc3RyYWludHM6IHtcclxuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxyXG4gICAgICAgICAgdmlkZW86IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChjb25maWcudHJhY2VTaXApIHtcclxuICAgICAgc2lwVUFDb25maWcudHJhY2VTaXAgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGNvbmZpZy5sb2dMZXZlbCkge1xyXG4gICAgICBpZiAoY29uZmlnLmxvZ0xldmVsID09PSBcIm9mZlwiKSB7XHJcbiAgICAgICAgc2lwVUFDb25maWcubG9nID0geyBidWlsdGluRW5hYmxlZDogZmFsc2UgfTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzaXBVQUNvbmZpZy5sb2cgPSB7IGxldmVsOiBjb25maWcubG9nTGV2ZWwgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5fdXNlckFnZW50ID0gbmV3IFVBKHNpcFVBQ29uZmlnKTtcclxuXHJcbiAgICAvKipcclxuICAgICogd3NDb25uZWN0aW5nIGV2ZW50XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gdGhlIGRldmljZSBhdHRlbXB0cyB0byBjb25uZWN0IHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLlxyXG4gICAgKiBJZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgdGhlIGRldmljZSB3aWxsIHRyeSB0byByZWNvbm5lY3QgYW5kIHRoaXMgZXZlbnQgd2lsbCBmaXJlIGFnYWluLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2RGV2aWNlI3dzQ29ubmVjdGluZ1xyXG4gICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgKiBAcHJvcGVydHkge251bWJlcn0gYXR0ZW1wdHMgLSB0aGUgbnVtYmVyIG9mIGNvbm5lY3Rpb24gYXR0ZW1wdHMgdGhhdCBoYXZlIGJlZW4gbWFkZVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImNvbm5lY3RpbmdcIiwgKGFyZ3MpID0+IHsgdGhpcy50cmlnZ2VyKFwid3NDb25uZWN0aW5nXCIsIHsgYXR0ZW1wdHM6IGFyZ3MuYXR0ZW1wdHMgfSk7IH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiB3c0Nvbm5lY3RlZCBldmVudFxyXG4gICAgKlxyXG4gICAgKiBGaXJlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZC5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkRldmljZSN3c0Nvbm5lY3RlZFxyXG4gICAgKi9cclxuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImNvbm5lY3RlZFwiLCAoKSA9PiB7IHRoaXMudHJpZ2dlcihcIndzQ29ubmVjdGVkXCIpOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogd3NEaXNjb25uZWN0ZWQgZXZlbnRcclxuICAgICpcclxuICAgICogRnJpZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscy5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkRldmljZSN3c0Rpc2Nvbm5lY3RlZFxyXG4gICAgKi9cclxuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImRpc2Nvbm5lY3RlZFwiLCAoKSA9PiB7IHRoaXMudHJpZ2dlcihcIndzRGlzY29ubmVjdGVkXCIpOyB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogcmVnaXN0ZXJlZCBldmVudFxyXG4gICAgKlxyXG4gICAgKiBGaXJlZCB3aGVuIGEgdGhlIGRldmljZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgcmVnaXN0ZXJlZCB0byByZWNpZXZlIGNhbGxzLlxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2RGV2aWNlI3JlZ2lzdGVyZWRcclxuICAgICovXHJcbiAgICB0aGlzLl91c2VyQWdlbnQub24oXCJyZWdpc3RlcmVkXCIsICgpID0+IHsgdGhpcy50cmlnZ2VyKFwicmVnaXN0ZXJlZFwiKTsgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIHVucmVnaXN0ZXJlZCBldmVudFxyXG4gICAgKlxyXG4gICAgKiBGaXJlZCBhcyB0aGUgcmVzdWx0IG9mIGEgY2FsbCB0byBgdW5yZWdpc3RlcigpYCBvciBpZiBhIHBlcmlvZGljIHJlLXJlZ2lzdHJhdGlvbiBmYWlscy5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkRldmljZSN1bnJlZ2lzdGVyZWRcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGNhdXNlIC0gbnVsbCBpZiBgdW5yZWdpc3RlcigpYCB3YXMgY2FsbGVkLCBvdGhlcndpc2Ugc2VlIFtTSVBqcyBjYXVzZXNde0BsaW5rIGh0dHA6Ly9zaXBqcy5jb20vYXBpLzAuMTUuMC9jYXVzZXMvfVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2UgLSBUaGUgU0lQIG1lc3NhZ2Ugd2hpY2ggY2F1c2VkIHRoZSBmYWlsdXJlLCBpZiBpdCBleGlzdHMuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdXNlckFnZW50Lm9uKFwidW5yZWdpc3RlcmVkXCIsIChyZXNwb25zZSwgY2F1c2UpID0+IHtcclxuICAgICAgdGhpcy50cmlnZ2VyKFwidW5yZWdpc3RlcmVkXCIsIHsgY2F1c2U6IGNhdXNlLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogcmVnaXN0cmF0aW9uRmFpbGVkIGV2ZW50XHJcbiAgICAqXHJcbiAgICAqIEZpcmVkIHdoZW4gYSByZWdpc3RyYXRpb24gYXR0ZXBtdCBmYWlscy5cclxuICAgICpcclxuICAgICogQGV2ZW50IGNsdkRldmljZSNyZWdpc3RyYXRpb25GYWlsZWRcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IGNhdXNlIC0gc2VlIFtTSVBqcyBjYXVzZXNde0BsaW5rIGh0dHA6Ly9zaXBqcy5jb20vYXBpLzAuMTUuMC9jYXVzZXMvfVxyXG4gICAgKiBAcHJvcGVydHkge29iamVjdH0gcmVzcG9uc2UgLSBUaGUgU0lQIG1lc3NhZ2Ugd2hpY2ggY2F1c2VkIHRoZSBmYWlsdXJlLCBpZiBpdCBleGlzdHMuXHJcbiAgICAqL1xyXG4gICAgdGhpcy5fdXNlckFnZW50Lm9uKFwicmVnaXN0cmF0aW9uRmFpbGVkXCIsIChjYXVzZSwgcmVzcG9uc2UpID0+IHtcclxuICAgICAgdGhpcy50cmlnZ2VyKFwicmVnaXN0cmF0aW9uRmFpbGVkXCIsIHsgY2F1c2U6IGNhdXNlLCByZXNwb25zZTogcmVzcG9uc2UgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogaW5jb21pbmdJbnZpdGUgZXZlbnRcclxuICAgICpcclxuICAgICogRmlyZWQgd2hlbiB0aGUgZGV2aWNlIHJlY2lldmVzIGFuIElOVklURSByZXF1ZXN0XHJcbiAgICAqIEBldmVudCBjbHZEZXZpY2UjaW52aXRlXHJcbiAgICAqIEB0eXBlIHtTZXNzaW9ufVxyXG4gICAgKi9cclxuICAgIHRoaXMuX3VzZXJBZ2VudC5vbihcImludml0ZVwiLCAoc2Vzc2lvbikgPT4ge1xyXG4gICAgICB0aGlzLl9hY3RpdmVDYWxsID0gbmV3IGNsdkNhbGwodGhpcy5fdXNlckFnZW50KTtcclxuICAgICAgdGhpcy5fYWN0aXZlQ2FsbC5pbmNvbWluZ0NhbGwoc2Vzc2lvbik7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihcImludml0ZVwiLCB7XHJcbiAgICAgICAgaWQ6IHNlc3Npb24uaWQsXHJcbiAgICAgICAgcGhvbmVOdW1iZXI6IHNlc3Npb24ucmVtb3RlSWRlbnRpdHkuX2Rpc3BsYXlOYW1lLFxyXG4gICAgICAgIHN0YXR1czogc2Vzc2lvbi5zdGF0dXMsXHJcbiAgICAgICAgdHlwZTogJ2luY29taW5nJyxcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICogbWVzc2FnZSBldmVudFxyXG4gICAgKlxyXG4gICAgKiBAZXZlbnQgY2x2RGV2aWNlI21lc3NhZ2VcclxuICAgICogQHR5cGUge29iamVjdH1cclxuICAgICogQHByb3BlcnR5IHtvYmplY3R9IG1lc3NhZ2UgLSBDb250YWlucyB0aGUgU0lQIG1lc3NhZ2Ugc2VudCBhbmQgc2VydmVyIGNvbnRleHQgbmVjZXNzYXJ5IHRvIHJlY2VpdmUgYW5kIHNlbmQgcmVwbGllcy5cclxuICAgICovXHJcbiAgICB0aGlzLl91c2VyQWdlbnQub24oXCJtZXNzYWdlXCIsIChtZXNzYWdlKSA9PiB7IHRoaXMudHJpZ2dlcihcIm1lc3NhZ2VcIiwgeyBtZXNzYWdlOiBtZXNzYWdlIH0pOyB9KTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFN0YXJ0IHRoZSBjb25uZWN0aW9uIHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLCBhbmQgcmVzdG9yZSB0aGUgcHJldmlvdXMgc3RhdGUgaWYgc3RvcHBlZC5cclxuICAqIFlvdSBuZWVkIHRvIHN0YXJ0IHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBiZWZvcmUgeW91IGNhbiBzZW5kIG9yIHJlY2lldmUgY2FsbHMuIElmIHlvdVxyXG4gICogdHJ5IHRvIGBpbml0aWF0ZUNhbGxgIHdpdGhvdXQgZmlyc3Qgc3RhcnRpbmcgdGhlIGNvbm5lY3Rpb24sIGl0IHdpbGwgYmUgc3RhcnRlZCBmb3IgeW91LFxyXG4gICogYnV0IGl0IHdpbGwgbm90IGJlIHN0b3BwZWQgd2hlbiB0aGUgY2FsbCBpcyB0ZXJtaW5hdGVkLlxyXG4gICovXHJcbiAgc3RhcnRXUygpIHtcclxuICAgIHRoaXMuX3VzZXJBZ2VudC5zdGFydCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgKiBTdG9wIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBXZWJTb2NrZXQgc2VydmVyLCBzYXZpbmcgdGhlIHN0YXRlIHNvIGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlclxyXG4gICogKGJ5IGBzdGFydGApLlxyXG4gICovXHJcbiAgc3RvcFdTKCkge1xyXG4gICAgdGhpcy5fdXNlckFnZW50LnN0b3AoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogU3RhdHVzIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxyXG4gICpcclxuICAqIEByZXR1cm4ge0Jvb2xlYW59IGlzQ29ubmVjdGVkIGB0cnVlYCBpZiB0aGUgZGV2aWNlIGlzIGNvbm5lY3RlZCB0byB0aGUgV2ViU29ja2V0IHNlcnZlciwgYGZhbHNlYCBvdGhlcndpc2VcclxuICAqL1xyXG4gIGlzV1NDb25uZWN0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdXNlckFnZW50LmlzQ29ubmVjdGVkKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAqIFJlZ2lzdGVyIHRoZSBkZXZpY2Ugd2l0aCB0aGUgU0lQIHNlcnZlciBzbyB0aGF0IGl0IGNhbiByZWNlaXZlIGluY29taW5nIGNhbGxzLlxyXG4gICpcclxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvcHRpb25zLmV4dHJhSGVhZGVycyBTSVAgaGVhZGVycyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gZWFjaCBSRUdJU1RFUiByZXF1ZXN0LiBFYWNoIGhlYWRlciBpcyBzdHJpbmcgaW4gdGhlIGZvcm1hdCBgXCJYLUhlYWRlci1OYW1lOiBIZWFkZXItdmFsdWVcImAuXHJcbiAgKiBAZW1pdHMgY2x2RGV2aWNlI3JlZ2lzdGVyZWRcclxuICAqL1xyXG4gIHJlZ2lzdGVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX3VzZXJBZ2VudC5yZWdpc3RlcihvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogVW5yZWdpc3RlciB0aGUgZGV2aWNlIGZyb20gdGhlIFNJUCBzZXJ2ZXI7IGl0IHdpbGwgbm8gbG9uZ2VyIHJlY2lldmUgaW5jb21pbmcgY2FsbHMuXHJcbiAgKlxyXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5hbGwgW09wdGlvbmFsXSAtIGlmIHNldCAmIGB0cnVlYCBpdCB3aWxsIHVucmVnaXN0ZXIgKmFsbCogYmluZGluZ3MgZm9yIHRoZSBTSVAgdXNlci5cclxuICAqIEBwYXJhbSB7U3RyaW5nW119IG9wdGlvbnMuZXh0cmFIZWFkZXJzIFNJUCBoZWFkZXJzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byBlYWNoIFJFR0lTVEVSIHJlcXVlc3QuIEVhY2ggaGVhZGVyIGlzIHN0cmluZyBpbiB0aGUgZm9ybWF0IGBcIlgtSGVhZGVyLU5hbWU6IEhlYWRlci12YWx1ZVwiYC5cclxuICAqIEBlbWl0cyBjbHZEZXZpY2UjdW5yZWdpc3RlcmVkXHJcbiAgKi9cclxuICB1bnJlZ2lzdGVyKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuX3VzZXJBZ2VudC5yZWdpc3RlcihvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogU3RhdHVzIG9mIFNJUCByZWdpc3RyYXRpb25cclxuICAqXHJcbiAgKiBAcmV0dXJuIHtCb29sZWFufSBpc1JlZ2lzdGVyZWQgYHRydWVgIGlmIHRoZSBkZXZpY2UgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBTSVAgU2VydmVyLCBgZmFsc2VgIG90aGVyd2lzZVxyXG4gICovXHJcbiAgaXNSZWdpc3RlcmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3VzZXJBZ2VudC5pc1JlZ2lzdGVyZWQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogTWFrZSBhIHBob25lIGNhbGxcclxuICAqXHJcbiAgKiBAcGFyYW0ge1N0cmluZ30gcGhvbmVOdW1iZXIgVGhlIGRlc2luYXRpb24gcGhvbmUgbnVtYmVyIHRvIGNvbm5lY3QgdG8uIEp1c3QgZGlnaXRzLCBubyBwdW5jdHVhdGlvbi4gRXhhbXBsZSBgXCIxMjA2NTU1MTExMVwiYC5cclxuICAqIEByZXR1cm4ge2NsdkNhbGx9IGFjdGl2ZUNhbGwgS2VlcCBhbiBleWUgb24gdGhlIGNhbGwncyBzdGF0ZSBieSBsaXN0ZW5pbmcgdG8gZXZlbnRzIGVtaXR0ZWQgYnkgYWN0aXZlQ2FsbFxyXG4gICovXHJcbiAgaW5pdGlhdGVDYWxsKHBob25lTnVtYmVyKSB7XHJcbiAgICAvLyBsZXQgdXJpID0gbmV3IFNJUC5VUkkoXCJzaXBcIiwgcGhvbmVOdW1iZXIsIHRoaXMuaG9zdCwgdGhpcy5wb3J0KS50b1N0cmluZygpO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbCA9IG5ldyBjbHZDYWxsKHRoaXMuX3VzZXJBZ2VudCk7XHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLm1ha2VDYWxsKHBob25lTnVtYmVyKVxyXG4gICAgY29uc29sZS5sb2codGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbilcclxuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJjYW5jZWxcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiY2FuY2VsXCIsIGRhdGEpIH0pO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcImJ5ZVwiLCAoZGF0YSkgPT4geyB0aGlzLnRyaWdnZXIoXCJieWVcIiwgZGF0YSkgfSk7XHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwicmVwbGFjZWRcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwicmVwbGFjZWRcIiwgZGF0YSkgfSk7XHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiZmFpbGVkXCIsIChyZXNwb25zZSwgY2F1c2UpID0+IHsgdGhpcy50cmlnZ2VyKFwiZmFpbGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IH0pO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcInJlamVjdGVkXCIsIChyZXNwb25zZSwgY2F1c2UpID0+IHsgdGhpcy50cmlnZ2VyKFwicmVqZWN0ZWRcIiwgcmVzcG9uc2UsIGNhdXNlKTsgfSk7XHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiY29uc3RydWN0ZWRcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiY29uc3RydWN0ZWRcIiwgZGF0YSk7IH0pO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcInRyYWNrIGFkZGVkXCIsIChkYXRhKSA9PiB7IHRoaXMudHJpZ2dlcihcImFjY2VwdCBjYWxsXCIsIGRhdGEpOyB9KTtcclxuICAgIHJldHVybiB0aGlzLl9hY3RpdmVDYWxsO1xyXG4gIH1cclxuICAvKipcclxuICAqIEFuc3dlciBwaG9uZSBjYWxsXHJcbiAgKlxyXG4gICogQHJldHVybiB7Y2x2Q2FsbH0gYWN0aXZlQ2FsbCBLZWVwIGFuIGV5ZSBvbiB0aGUgY2FsbCdzIHN0YXRlIGJ5IGxpc3RlbmluZyB0byBldmVudHMgZW1pdHRlZCBieSBhY3RpdmVDYWxsXHJcbiAgKi9cclxuICBhY2NlcHQoKSB7XHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLmFjY2VwdCgpXHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKCd0cmFja0FkZGVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcGMgPSB0aGlzLnNlc3Npb25EZXNjcmlwdGlvbkhhbmRsZXIucGVlckNvbm5lY3Rpb247XHJcbiAgICAgIC8vIHZhciB0aGlzLmF1ZGlvRWxlbWVudCA9IHRoaXMuYXVkaW9FbGVtZW50O1xyXG4gICAgICB2YXIgcGxheWVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNsdi1zaXBqcy1yZW1vdGUtYXVkaW9cIilbMF07XHJcbiAgICAgIC8vIHRoaXMuYXVkaW9FbGVtZW50LmNsYXNzTmFtZSA9ICdjbHYtc2lwanMtcmVtb3RlLWF1ZGlvJztcclxuICAgICAgdmFyIHJlbW90ZVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xyXG4gICAgICBwYy5nZXRSZWNlaXZlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWNlaXZlcikge1xyXG4gICAgICAgIHJlbW90ZVN0cmVhbS5hZGRUcmFjayhyZWNlaXZlci50cmFjayk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBpZiAodHlwZW9mIHBsYXllci5zcmNPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcGxheWVyLnNyY09iamVjdCA9IHJlbW90ZVN0cmVhbTtcclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGxheWVyLm1velNyY09iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICBwbGF5ZXIubW96U3JjT2JqZWN0ID0gcmVtb3RlU3RyZWFtO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbGF5ZXIuc3JjICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHBsYXllci5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlbW90ZVN0cmVhbSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yIGF0dGFjaGluZyBzdHJlYW0gdG8gZWxlbWVudC4nKTtcclxuICAgICAgfVxyXG4gICAgICBwbGF5ZXIucGxheSgpO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ2FsbDtcclxuICAgIH0pXHJcbiAgICB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLm9uKFwiY2FuY2VsXCIsIChkYXRhKSA9PiB7IHRoaXMudHJpZ2dlcihcImNhbmNlbFwiLCBkYXRhKSB9KTtcclxuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJieWVcIiwgKGRhdGEpID0+IHsgdGhpcy50cmlnZ2VyKFwiYnllXCIsIGRhdGEpIH0pO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcInJlcGxhY2VkXCIsIChkYXRhKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlcGxhY2VkXCIsIGRhdGEpIH0pO1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5vbihcImZhaWxlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcImZhaWxlZFwiLCByZXNwb25zZSwgY2F1c2UpOyB9KTtcclxuICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ub24oXCJyZWplY3RlZFwiLCAocmVzcG9uc2UsIGNhdXNlKSA9PiB7IHRoaXMudHJpZ2dlcihcInJlamVjdGVkXCIsIHJlc3BvbnNlLCBjYXVzZSk7IH0pO1xyXG4gICAgdGhpcy50cmlnZ2VyKFwiYWNjZXB0ZWRcIiwge1xyXG4gICAgICBpZDogdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5pZCxcclxuICAgICAgcGhvbmVOdW1iZXI6IHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24ucmVtb3RlSWRlbnRpdHkuZGlzcGxheU5hbWUsXHJcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5zdGFydFRpbWUgPyB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLnN0YXJ0VGltZSA6IG5ldyBEYXRlKCksXHJcbiAgICAgIHN0YXR1czogdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5zdGF0dXMsXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogR2V0IGEgcmVmZXJlbmNlIHRvIHRoZSBjYWxsIGN1cnJlbnRseSBpbiBwcm9ncmVzc1xyXG4gICpcclxuICAqIEByZXR1cm4ge2NsdkNhbGx9IGFjdGl2ZUNhbGwgS2VlcCBhbiBleWUgb24gdGhlIGNhbGwncyBzdGF0ZSBieSBsaXN0ZW5pbmcgdG8gZXZlbnRzIGVtaXR0ZWQgYnkgYWN0aXZlQ2FsbFxyXG4gICovXHJcbiAgYWN0aXZlQ2FsbCgpIHsgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGw7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVmZXJcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGhvbmVOdW1iZXIgVGhlIHBob25lbnVtYmVyIGNhbiB0byByZWZlclxyXG4gICAqL1xyXG4gIHJlZmVyTnVtYmVyKHBob25lTnVtYmVyKSB7XHJcbiAgICB0aGlzLl9yZWZlciA9IG5ldyBSZWZlckNsaWVudENvbnRleHQodGhpcy5fdXNlckFnZW50LCB0aGlzLl9hY3RpdmVDYWxsLl9zZXNzaW9uLCBwaG9uZU51bWJlcilcclxuICAgIHRoaXMuX3JlZmVyLnJlZmVyKClcclxuICAgIHJldHVybiB0aGlzLl9yZWZlclxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaXNNdXRlZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNNdXRlZCBUaGUgaXNNdXRlZCBjYW4gdG8gcmVmZXJcclxuICAgKi9cclxuICBtdXRlKGlzTXV0ZSkge1xyXG4gICAgdmFyIHBjID0gdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5zZXNzaW9uRGVzY3JpcHRpb25IYW5kbGVyLnBlZXJDb25uZWN0aW9uO1xyXG4gICAgdmFyIGF1ZGlvVHJhY2tzID0gcGMuZ2V0TG9jYWxTdHJlYW1zKClbMF0uZ2V0QXVkaW9UcmFja3MoKTtcclxuXHJcbiAgICAvLyBpZiBNZWRpYVN0cmVhbSBoYXMgcmVmZXJlbmNlIHRvIG1pY3JvcGhvbmVcclxuICAgIGlmIChhdWRpb1RyYWNrc1swXSkge1xyXG4gICAgICBhdWRpb1RyYWNrc1swXS5lbmFibGVkID0gIWlzTXV0ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBwY1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogaXNIb2xkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0hvbGQgVGhlIGlzTXV0ZWQgY2FuIHRvIHJlZmVyXHJcbiAgICovXHJcbiAgaG9sZChpc0hvbGQpIHtcclxuICAgIGlmIChpc0hvbGQpIHtcclxuICAgICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi5ob2xkKClcclxuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb25cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb24udW5ob2xkKClcclxuICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNhbGwuX3Nlc3Npb25cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICogRW5kIHRoZSBzZXNzaW9uXHJcbiAgKlxyXG4gICogQGVtaXRzIFRlbG55eENhbGwjdGVybWluYXRlZFxyXG4gICovXHJcbiAgcmVqZWN0KCkge1xyXG4gICAgdGhpcy5fYWN0aXZlQ2FsbC5fc2Vzc2lvbi50ZXJtaW5hdGUoKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBFbnN1cmUgdGhhdCB3ZSBjYW4gY29ubmVjdCB0byB0aGUgU0lQIHNlcnZlci5cclxuICAvLyBEdWUgdG8gYSBidWcgaW4gY2hyb21lLCB3ZSBuZWVkIHRvIG9wZW4gYW4gaHR0cCBjb25uZWN0aW9uIHRvIHRoZSBTSVAgc2VydmVyXHJcbiAgLy8gYmVmb3JlIHRyeWluZyB0byBjb25uZWN0IHZpYSBXZWIgU29ja2V0LlxyXG4gIC8vXHJcbiAgLy8gIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTMyOTg4NFxyXG4gIF9lbnN1cmVDb25uZWN0aXZpdHlXaXRoU2lwU2VydmVyKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmluZm8oXCJGYWlsZWQgaHR0cCBjb25uZWN0aW9uIHRvIFNJUCBzZXJ2ZXIgaXMgZXhwZWN0ZWQuIEl0IGlzIHJlbGF0ZWQgdG8gYSBjaHJvbWUgYnVnLlwiKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHhoci5vcGVuKFwiR0VUXCIsIGBodHRwczovLyR7dGhpcy5ob3N0fToke3RoaXMucG9ydH1gLCB0cnVlKTtcclxuICAgICAgeGhyLnNlbmQoKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgLy8gZG8gbm90aGluZy4gSWYgYW4gZXJyb3Igb2NjdXJzLCBpdCdzIG5vdCBnb2luZyB0byBtYXR0ZXIgaGVyZS5cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5aWZ5KGl0ZW0pIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xyXG4gICAgcmV0dXJuIGl0ZW0uc2xpY2UoMCk7IC8vIFNoYWxsb3cgQ29weVxyXG4gIH0gZWxzZSB7XHJcbiAgICBsZXQgYXJyID0gW107XHJcbiAgICBhcnIucHVzaChpdGVtKTtcclxuICAgIHJldHVybiBhcnI7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IHsgY2x2RGV2aWNlIH07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=